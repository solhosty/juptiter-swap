import * as web3 from '@solana/web3.js';
import { PublicKey, Connection, Transaction, TokenAmount } from '@solana/web3.js';
import * as beet from '@metaplex-foundation/beet';
import BN from 'bn.js';
import { BinaryReader } from 'borsh';

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */
type ErrorWithCode = Error & {
    code: number;
};
type MaybeErrorWithCode = ErrorWithCode | null | undefined;
/**
 * InvalidMarketParameters: 'Invalid market parameters error'
 *
 * @category Errors
 * @category generated
 */
declare class InvalidMarketParametersError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InvalidMarketAuthority: 'Invalid exchange authority error'
 *
 * @category Errors
 * @category generated
 */
declare class InvalidMarketAuthorityError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * FailedToLoadMarketFromAccount: 'Market deserialization error'
 *
 * @category Errors
 * @category generated
 */
declare class FailedToLoadMarketFromAccountError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * MarketAlreadyInitialized: 'Market already initialized error'
 *
 * @category Errors
 * @category generated
 */
declare class MarketAlreadyInitializedError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * MarketUninitialized: 'Market is not initialized error'
 *
 * @category Errors
 * @category generated
 */
declare class MarketUninitializedError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InvalidStateTransition: 'Invalid state transition error'
 *
 * @category Errors
 * @category generated
 */
declare class InvalidStateTransitionError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InvalidMarketSigner: 'Invalid market signer error'
 *
 * @category Errors
 * @category generated
 */
declare class InvalidMarketSignerError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InvalidLotSize: 'Invalid lot size error'
 *
 * @category Errors
 * @category generated
 */
declare class InvalidLotSizeError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InvalidTickSize: 'Invalid tick size error'
 *
 * @category Errors
 * @category generated
 */
declare class InvalidTickSizeError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InvalidMint: 'Invalid mint error'
 *
 * @category Errors
 * @category generated
 */
declare class InvalidMintError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InvalidBaseVault: 'Invalid base vault error'
 *
 * @category Errors
 * @category generated
 */
declare class InvalidBaseVaultError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InvalidQuoteVault: 'Invalid quote vault error'
 *
 * @category Errors
 * @category generated
 */
declare class InvalidQuoteVaultError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InvalidBaseAccount: 'Invalid base account error'
 *
 * @category Errors
 * @category generated
 */
declare class InvalidBaseAccountError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InvalidQuoteAccount: 'Invalid quote account error'
 *
 * @category Errors
 * @category generated
 */
declare class InvalidQuoteAccountError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * TooManyEvents: 'Too many events error'
 *
 * @category Errors
 * @category generated
 */
declare class TooManyEventsError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * NewOrderError: 'New order error'
 *
 * @category Errors
 * @category generated
 */
declare class NewOrderErrorError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * ReduceOrderError: 'Reduce order error'
 *
 * @category Errors
 * @category generated
 */
declare class ReduceOrderErrorError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * CancelMultipleOrdersError: 'Cancel multiple orders error'
 *
 * @category Errors
 * @category generated
 */
declare class CancelMultipleOrdersErrorError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * WithdrawFundsError: 'Withdraw funds error'
 *
 * @category Errors
 * @category generated
 */
declare class WithdrawFundsErrorError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * RemoveEmptyOrdersError: 'Remove empty orders error'
 *
 * @category Errors
 * @category generated
 */
declare class RemoveEmptyOrdersErrorError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * TraderNotFound: 'Trader not found error'
 *
 * @category Errors
 * @category generated
 */
declare class TraderNotFoundError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InvalidSeatStatus: 'Invalid seat status'
 *
 * @category Errors
 * @category generated
 */
declare class InvalidSeatStatusError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * EvictionError: 'Failed to evict trader'
 *
 * @category Errors
 * @category generated
 */
declare class EvictionErrorError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * Attempts to resolve a custom program error from the provided error code.
 * @category Errors
 * @category generated
 */
declare function errorFromCode(code: number): MaybeErrorWithCode;
/**
 * Attempts to resolve a custom program error from the provided error name, i.e. 'Unauthorized'.
 * @category Errors
 * @category generated
 */
declare function errorFromName(name: string): MaybeErrorWithCode;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type AuditLogHeader = {
    instruction: number;
    sequenceNumber: beet.bignum;
    timestamp: beet.bignum;
    slot: beet.bignum;
    market: web3.PublicKey;
    signer: web3.PublicKey;
    totalEvents: number;
};
/**
 * @category userTypes
 * @category generated
 */
declare const auditLogHeaderBeet: beet.BeetArgsStruct<AuditLogHeader>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category enums
 * @category generated
 */
declare enum Side {
    Bid = 0,
    Ask = 1
}
/**
 * @category userTypes
 * @category generated
 */
declare const sideBeet: beet.FixedSizeBeet<Side, Side>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type CancelOrderParams = {
    side: Side;
    priceInTicks: beet.bignum;
    orderSequenceNumber: beet.bignum;
};
/**
 * @category userTypes
 * @category generated
 */
declare const cancelOrderParamsBeet: beet.BeetArgsStruct<CancelOrderParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type CancelMultipleOrdersByIdParams = {
    orders: CancelOrderParams[];
};
/**
 * @category userTypes
 * @category generated
 */
declare const cancelMultipleOrdersByIdParamsBeet: beet.FixableBeetArgsStruct<CancelMultipleOrdersByIdParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type CancelUpToParams = {
    side: Side;
    tickLimit: beet.COption<beet.bignum>;
    numOrdersToSearch: beet.COption<number>;
    numOrdersToCancel: beet.COption<number>;
};
/**
 * @category userTypes
 * @category generated
 */
declare const cancelUpToParamsBeet: beet.FixableBeetArgsStruct<CancelUpToParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type CondensedOrder = {
    priceInTicks: beet.bignum;
    sizeInBaseLots: beet.bignum;
};
/**
 * @category userTypes
 * @category generated
 */
declare const condensedOrderBeet: beet.BeetArgsStruct<CondensedOrder>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type DepositParams = {
    quoteLotsToDeposit: beet.bignum;
    baseLotsToDeposit: beet.bignum;
};
/**
 * @category userTypes
 * @category generated
 */
declare const depositParamsBeet: beet.BeetArgsStruct<DepositParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type EvictEvent = {
    index: number;
    makerId: web3.PublicKey;
    orderSequenceNumber: beet.bignum;
    priceInTicks: beet.bignum;
    baseLotsEvicted: beet.bignum;
};
/**
 * @category userTypes
 * @category generated
 */
declare const evictEventBeet: beet.BeetArgsStruct<EvictEvent>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type FeeEvent = {
    index: number;
    feesCollectedInQuoteLots: beet.bignum;
};
/**
 * @category userTypes
 * @category generated
 */
declare const feeEventBeet: beet.BeetArgsStruct<FeeEvent>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type FillEvent = {
    index: number;
    makerId: web3.PublicKey;
    orderSequenceNumber: beet.bignum;
    priceInTicks: beet.bignum;
    baseLotsFilled: beet.bignum;
    baseLotsRemaining: beet.bignum;
};
/**
 * @category userTypes
 * @category generated
 */
declare const fillEventBeet: beet.BeetArgsStruct<FillEvent>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type FillSummaryEvent = {
    index: number;
    clientOrderId: beet.bignum;
    totalBaseLotsFilled: beet.bignum;
    totalQuoteLotsFilled: beet.bignum;
    totalFeeInQuoteLots: beet.bignum;
};
/**
 * @category userTypes
 * @category generated
 */
declare const fillSummaryEventBeet: beet.BeetArgsStruct<FillSummaryEvent>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type MarketSizeParams = {
    bidsSize: beet.bignum;
    asksSize: beet.bignum;
    numSeats: beet.bignum;
};
/**
 * @category userTypes
 * @category generated
 */
declare const marketSizeParamsBeet: beet.BeetArgsStruct<MarketSizeParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type TokenParams = {
    decimals: number;
    vaultBump: number;
    mintKey: web3.PublicKey;
    vaultKey: web3.PublicKey;
};
/**
 * @category userTypes
 * @category generated
 */
declare const tokenParamsBeet: beet.BeetArgsStruct<TokenParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type MarketHeader = {
    discriminant: beet.bignum;
    status: beet.bignum;
    marketSizeParams: MarketSizeParams;
    baseParams: TokenParams;
    baseLotSize: beet.bignum;
    quoteParams: TokenParams;
    quoteLotSize: beet.bignum;
    tickSizeInQuoteAtomsPerBaseUnit: beet.bignum;
    authority: web3.PublicKey;
    feeRecipient: web3.PublicKey;
    marketSequenceNumber: beet.bignum;
    successor: web3.PublicKey;
    rawBaseUnitsPerBaseUnit: number;
    padding1: number;
    padding2: beet.bignum[];
};
/**
 * @category userTypes
 * @category generated
 */
declare const marketHeaderBeet: beet.BeetArgsStruct<MarketHeader>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category enums
 * @category generated
 */
declare enum MarketStatus {
    Uninitialized = 0,
    Active = 1,
    PostOnly = 2,
    Paused = 3,
    Closed = 4,
    Tombstoned = 5
}
/**
 * @category userTypes
 * @category generated
 */
declare const marketStatusBeet: beet.FixedSizeBeet<MarketStatus, MarketStatus>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type MultipleOrderPacket = {
    bids: CondensedOrder[];
    asks: CondensedOrder[];
    clientOrderId: beet.COption<beet.bignum>;
    rejectPostOnly: boolean;
};
/**
 * @category userTypes
 * @category generated
 */
declare const multipleOrderPacketBeet: beet.FixableBeetArgsStruct<MultipleOrderPacket>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category enums
 * @category generated
 */
declare enum SelfTradeBehavior {
    Abort = 0,
    CancelProvide = 1,
    DecrementTake = 2
}
/**
 * @category userTypes
 * @category generated
 */
declare const selfTradeBehaviorBeet: beet.FixedSizeBeet<SelfTradeBehavior, SelfTradeBehavior>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * This type is used to derive the {@link OrderPacket} type as well as the de/serializer.
 * However don't refer to it in your code but use the {@link OrderPacket} type instead.
 *
 * @category userTypes
 * @category enums
 * @category generated
 * @private
 */
type OrderPacketRecord = {
    PostOnly: {
        side: Side;
        priceInTicks: beet.bignum;
        numBaseLots: beet.bignum;
        clientOrderId: beet.bignum;
        rejectPostOnly: boolean;
        useOnlyDepositedFunds: boolean;
    };
    Limit: {
        side: Side;
        priceInTicks: beet.bignum;
        numBaseLots: beet.bignum;
        selfTradeBehavior: SelfTradeBehavior;
        matchLimit: beet.COption<beet.bignum>;
        clientOrderId: beet.bignum;
        useOnlyDepositedFunds: boolean;
    };
    ImmediateOrCancel: {
        side: Side;
        priceInTicks: beet.COption<beet.bignum>;
        numBaseLots: beet.bignum;
        numQuoteLots: beet.bignum;
        minBaseLotsToFill: beet.bignum;
        minQuoteLotsToFill: beet.bignum;
        selfTradeBehavior: SelfTradeBehavior;
        matchLimit: beet.COption<beet.bignum>;
        clientOrderId: beet.bignum;
        useOnlyDepositedFunds: boolean;
    };
};
/**
 * Union type respresenting the OrderPacket data enum defined in Rust.
 *
 * NOTE: that it includes a `__kind` property which allows to narrow types in
 * switch/if statements.
 * Additionally `isOrderPacket*` type guards are exposed below to narrow to a specific variant.
 *
 * @category userTypes
 * @category enums
 * @category generated
 */
type OrderPacket = beet.DataEnumKeyAsKind<OrderPacketRecord>;
declare const isOrderPacketPostOnly: (x: OrderPacket) => x is {
    __kind: "PostOnly";
} & Omit<{
    side: Side;
    priceInTicks: beet.bignum;
    numBaseLots: beet.bignum;
    clientOrderId: beet.bignum;
    rejectPostOnly: boolean;
    useOnlyDepositedFunds: boolean;
}, "void"> & {
    __kind: "PostOnly";
};
declare const isOrderPacketLimit: (x: OrderPacket) => x is {
    __kind: "Limit";
} & Omit<{
    side: Side;
    priceInTicks: beet.bignum;
    numBaseLots: beet.bignum;
    selfTradeBehavior: SelfTradeBehavior;
    matchLimit: beet.COption<beet.bignum>;
    clientOrderId: beet.bignum;
    useOnlyDepositedFunds: boolean;
}, "void"> & {
    __kind: "Limit";
};
declare const isOrderPacketImmediateOrCancel: (x: OrderPacket) => x is {
    __kind: "ImmediateOrCancel";
} & Omit<{
    side: Side;
    priceInTicks: beet.COption<beet.bignum>;
    numBaseLots: beet.bignum;
    numQuoteLots: beet.bignum;
    minBaseLotsToFill: beet.bignum;
    minQuoteLotsToFill: beet.bignum;
    selfTradeBehavior: SelfTradeBehavior;
    matchLimit: beet.COption<beet.bignum>;
    clientOrderId: beet.bignum;
    useOnlyDepositedFunds: boolean;
}, "void"> & {
    __kind: "ImmediateOrCancel";
};
/**
 * @category userTypes
 * @category generated
 */
declare const orderPacketBeet: beet.FixableBeet<OrderPacket, Partial<OrderPacket>>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category enums
 * @category generated
 */
declare enum PhoenixMarketEvent {
    Uninitialized = 0,
    Header = 1,
    Fill = 2,
    Place = 3,
    Reduce = 4,
    Evict = 5,
    FillSummary = 6,
    Fee = 7
}
/**
 * @category userTypes
 * @category generated
 */
declare const phoenixMarketEventBeet: beet.FixedSizeBeet<PhoenixMarketEvent, PhoenixMarketEvent>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type PlaceEvent = {
    index: number;
    orderSequenceNumber: beet.bignum;
    clientOrderId: beet.bignum;
    priceInTicks: beet.bignum;
    baseLotsPlaced: beet.bignum;
};
/**
 * @category userTypes
 * @category generated
 */
declare const placeEventBeet: beet.BeetArgsStruct<PlaceEvent>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type ReduceEvent = {
    index: number;
    orderSequenceNumber: beet.bignum;
    priceInTicks: beet.bignum;
    baseLotsRemoved: beet.bignum;
    baseLotsRemaining: beet.bignum;
};
/**
 * @category userTypes
 * @category generated
 */
declare const reduceEventBeet: beet.BeetArgsStruct<ReduceEvent>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type ReduceOrderParams = {
    baseParams: CancelOrderParams;
    size: beet.bignum;
};
/**
 * @category userTypes
 * @category generated
 */
declare const reduceOrderParamsBeet: beet.BeetArgsStruct<ReduceOrderParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type Seat = {
    discriminant: beet.bignum;
    market: web3.PublicKey;
    trader: web3.PublicKey;
    approvalStatus: beet.bignum;
    padding: beet.bignum[];
};
/**
 * @category userTypes
 * @category generated
 */
declare const seatBeet: beet.BeetArgsStruct<Seat>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category enums
 * @category generated
 */
declare enum SeatApprovalStatus {
    NotApproved = 0,
    Approved = 1,
    Retired = 2
}
/**
 * @category userTypes
 * @category generated
 */
declare const seatApprovalStatusBeet: beet.FixedSizeBeet<SeatApprovalStatus, SeatApprovalStatus>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type WithdrawParams = {
    quoteLotsToWithdraw: beet.COption<beet.bignum>;
    baseLotsToWithdraw: beet.COption<beet.bignum>;
};
/**
 * @category userTypes
 * @category generated
 */
declare const withdrawParamsBeet: beet.FixableBeetArgsStruct<WithdrawParams>;

/**
 * Converts a beet.bignum to a number.
 *
 * @param n The number to convert
 */
declare function toNum(n: beet.bignum): number;
/**
 * Converts a number to a BN.
 *
 * @param n The number to convert
 */
declare function toBN(n: number | beet.bignum): BN;
/**
 * Converts a BN sort value to a number.
 *
 * Required because sort function must return a number.
 *
 * @param n The BN to convert
 */
declare function sign(n: BN): 0 | 1 | -1;

declare class Token {
    name: string;
    symbol: string;
    logoUri: string;
    data: TokenParams;
    constructor({ name, symbol, logoUri, data, }: {
        name: string;
        symbol: string;
        logoUri: string;
        data: TokenParams;
    });
}

type OrderId = {
    priceInTicks: beet.bignum;
    orderSequenceNumber: beet.bignum;
};
type RestingOrder = {
    traderIndex: beet.bignum;
    numBaseLots: beet.bignum;
    padding: beet.bignum[];
};
type TraderState = {
    quoteLotsLocked: beet.bignum;
    quoteLotsFree: beet.bignum;
    baseLotsLocked: beet.bignum;
    baseLotsFree: beet.bignum;
    padding: beet.bignum[];
};
type Ladder = {
    bids: Array<[BN, BN]>;
    asks: Array<[BN, BN]>;
};
type UiLadder = {
    bids: Array<[number, number]>;
    asks: Array<[number, number]>;
};
interface MarketData {
    header: MarketHeader;
    baseLotsPerBaseUnit: number;
    quoteLotsPerBaseUnitPerTick: number;
    sequenceNumber: number;
    takerFeeBps: number;
    collectedAdjustedQuoteLotFees: number;
    unclaimedAdjustedQuoteLotFees: number;
    bids: Array<[OrderId, RestingOrder]>;
    asks: Array<[OrderId, RestingOrder]>;
    traders: Map<PublicKey, TraderState>;
}
declare class Market {
    name: string;
    address: PublicKey;
    baseToken: Token;
    quoteToken: Token;
    data: MarketData;
    private constructor();
    /**
     * Returns a `Market` for a given market address and subscribes to updates.
     *
     * @param connection The Solana `Connection` object
     * @param marketAddress The `PublicKey` of the market account
     */
    static load({ connection, address, }: {
        connection: Connection;
        address: PublicKey;
    }): Promise<Market>;
    /**
     * Refreshes the market data
     *
     * @param connection The Solana `Connection` object
     *
     * @returns The refreshed Market
     */
    refresh(connection: Connection): Promise<Market>;
    /**
     * Returns the market's ladder of bids and asks
     */
    getLadder(): Ladder;
    /**
     * Returns the market's ladder of bids and asks  as JS numbers
     */
    getUiLadder(): UiLadder;
    /**
     * Pretty prints the market's current ladder of bids and asks
     */
    printLadder(): void;
    /**
     * Returns a Phoenix swap transaction
     *
     * @param trader The `PublicKey` of the trader
     * @param side The side of the order to place (Bid, Ask)
     * @param inAmount The amount (in whole tokens) of the input token to swap
     * @param slippage The slippage tolerance (optional, default 0.5%)
     * @param clientOrderId The client order ID (optional)
     */
    getSwapTransaction({ trader, side, inAmount, slippage, clientOrderId, }: {
        trader: PublicKey;
        side: Side;
        inAmount: number;
        slippage?: number;
        clientOrderId?: number;
    }): web3.Transaction;
    /**
     * Returns the expected amount out for a given swap order
     *
     * @param side The side of the order (Bid or Ask)
     * @param inAmount The amount of the input token
     */
    getExpectedOutAmount({ side, inAmount, }: {
        side: Side;
        inAmount: number;
    }): number;
    getPriceDecimalPlaces(): number;
}

declare const DEFAULT_LADDER_DEPTH = 10;
declare const DEFAULT_MATCH_LIMIT = 2048;
declare const DEFAULT_SLIPPAGE_PERCENT = 0.005;
/**
 * Deserializes market data from a given buffer and returns a `MarketData` object
 *
 * @param data The data buffer to deserialize
 */
declare function deserializeMarketData(data: Buffer): MarketData;
/**
 * Deserializes a RedBlackTree from a given buffer
 * @description This deserialized the RedBlackTree defined in the sokoban library: https://github.com/Ellipsis-Labs/sokoban/tree/master
 *
 * @param data The data buffer to deserialize
 * @param keyDeserializer The deserializer for the tree key
 * @param valueDeserializer The deserializer for the tree value
 */
declare function deserializeRedBlackTree<Key, Value>(data: Buffer, keyDeserializer: beet.BeetArgsStruct<Key>, valueDeserializer: beet.BeetArgsStruct<Value>): Map<Key, Value>;
/**
 * Returns a ladder of bids and asks for given `MarketData`
 * @description Bids are ordered in descending order by price, and asks are ordered in ascending order by price
 *
 * @param marketData The `MarketData` to get the ladder from
 * @param levels The number of book levels to return, -1 to return the entire book
 */
declare function getMarketLadder(marketData: MarketData, levels?: number): Ladder;
/**
 * Returns the ladder of bids and asks as JS numbers for given `MarketData`
 *
 * @param marketData The `MarketData` to get the ladder from
 * @param levels The number of book levels to return
 */
declare function getMarketUiLadder(marketData: MarketData, levels?: number): UiLadder;
/**
 * Pretty prints the market's ladder as a colored orderbook
 *
 * @param uiLadder The ladder (represented by JS numbers) to print
 */
declare function printUiLadder(uiLadder: UiLadder): void;
/**
 * Returns a Phoenix swap transaction
 *
 * @param marketAddress The address of the market to swap in
 * @param marketData The `MarketData` for the swap market
 * @param trader The `PublicKey` of the trader
 * @param side The side of the order to place (Bid, Ask)
 * @param inAmount The amount (in whole tokens) of the input token to swap
 * @param slippage The slippage tolerance (optional, default 0.5%)
 * @param clientOrderId The client order ID (optional)
 */
declare function getMarketSwapTransaction({ marketAddress, marketData, trader, side, inAmount, slippage, clientOrderId, }: {
    marketAddress: PublicKey;
    marketData: MarketData;
    trader: PublicKey;
    side: Side;
    inAmount: number;
    slippage?: number;
    clientOrderId?: number;
}): Transaction;
/**
 * Returns a Phoenix swap order packet
 *
 * @param marketData The `MarketData` for the swap market
 * @param side The side of the order
 * @param inAmount The amount of the input token
 * @param slippage The slippage tolerance in bps (optional, default 0.5%)
 * @param selfTradeBehavior The self trade behavior (optional, default Abort)
 * @param matchLimit The match limit (optional)
 * @param clientOrderId The client order ID (optional)
 * @param useOnlyDepositedFunds Whether to use only deposited funds (optional)
 */
declare function getMarketSwapOrderPacket({ marketData, side, inAmount, slippage, selfTradeBehavior, matchLimit, clientOrderId, useOnlyDepositedFunds, }: {
    marketData: MarketData;
    side: Side;
    inAmount: number;
    slippage?: number;
    selfTradeBehavior?: SelfTradeBehavior;
    matchLimit?: number;
    clientOrderId?: number;
    useOnlyDepositedFunds?: boolean;
}): Partial<OrderPacket>;
/**
 * Returns the expected amount out for a given swap order
 *
 * @param marketData The `MarketData` for the swap market
 * @param side The side of the order (Bid or Ask)
 * @param inAmount The amount of the input token
 *
 * TODO this should use getMarketLadder and adjust its calculation
 */
declare function getMarketExpectedOutAmount({ marketData, side, inAmount, }: {
    marketData: MarketData;
    side: Side;
    inAmount: number;
}): number;

type Cluster = "mainnet-beta" | "devnet" | "localhost";
declare function getClusterFromEndpoint(endpoint: string): Cluster;

type PhoenixTransaction = {
    instructions: Array<PhoenixEvent>;
};
type PhoenixEvent = {
    header: AuditLogHeader;
    enums: Array<PhoenixMarketEvent>;
    events: Array<FillEvent | PlaceEvent | ReduceEvent | EvictEvent | FillSummaryEvent | FeeEvent>;
};
declare function readPublicKey(reader: BinaryReader): PublicKey;
declare function getEventsFromTransaction(connection: Connection, signature: string): Promise<PhoenixTransaction>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category CancelAllOrders
 * @category generated
 */
declare const CancelAllOrdersStruct: beet.BeetArgsStruct<{
    instructionDiscriminator: number;
}>;
/**
 * Accounts required by the _CancelAllOrders_ instruction
 *
 * @property [] phoenixProgram Phoenix program
 * @property [] logAuthority Phoenix log authority
 * @property [_writable_] market This account holds the market state
 * @property [**signer**] trader
 * @property [_writable_] baseAccount Trader base token account
 * @property [_writable_] quoteAccount Trader quote token account
 * @property [_writable_] baseVault Base vault PDA, seeds are [b'vault', market_address, base_mint_address]
 * @property [_writable_] quoteVault Quote vault PDA, seeds are [b'vault', market_address, quote_mint_address]
 * @category Instructions
 * @category CancelAllOrders
 * @category generated
 */
type CancelAllOrdersInstructionAccounts = {
    phoenixProgram: web3.PublicKey;
    logAuthority: web3.PublicKey;
    market: web3.PublicKey;
    trader: web3.PublicKey;
    baseAccount: web3.PublicKey;
    quoteAccount: web3.PublicKey;
    baseVault: web3.PublicKey;
    quoteVault: web3.PublicKey;
    tokenProgram?: web3.PublicKey;
};
declare const cancelAllOrdersInstructionDiscriminator = 6;
/**
 * Creates a _CancelAllOrders_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category CancelAllOrders
 * @category generated
 */
declare function createCancelAllOrdersInstruction(accounts: CancelAllOrdersInstructionAccounts, programId?: web3.PublicKey): web3.TransactionInstruction;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category CancelAllOrdersWithFreeFunds
 * @category generated
 */
declare const CancelAllOrdersWithFreeFundsStruct: beet.BeetArgsStruct<{
    instructionDiscriminator: number;
}>;
/**
 * Accounts required by the _CancelAllOrdersWithFreeFunds_ instruction
 *
 * @property [] phoenixProgram Phoenix program
 * @property [] logAuthority Phoenix log authority
 * @property [_writable_] market This account holds the market state
 * @property [**signer**] trader
 * @category Instructions
 * @category CancelAllOrdersWithFreeFunds
 * @category generated
 */
type CancelAllOrdersWithFreeFundsInstructionAccounts = {
    phoenixProgram: web3.PublicKey;
    logAuthority: web3.PublicKey;
    market: web3.PublicKey;
    trader: web3.PublicKey;
};
declare const cancelAllOrdersWithFreeFundsInstructionDiscriminator = 7;
/**
 * Creates a _CancelAllOrdersWithFreeFunds_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category CancelAllOrdersWithFreeFunds
 * @category generated
 */
declare function createCancelAllOrdersWithFreeFundsInstruction(accounts: CancelAllOrdersWithFreeFundsInstructionAccounts, programId?: web3.PublicKey): web3.TransactionInstruction;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category CancelMultipleOrdersById
 * @category generated
 */
type CancelMultipleOrdersByIdInstructionArgs = {
    params: CancelMultipleOrdersByIdParams;
};
/**
 * @category Instructions
 * @category CancelMultipleOrdersById
 * @category generated
 */
declare const CancelMultipleOrdersByIdStruct: beet.FixableBeetArgsStruct<CancelMultipleOrdersByIdInstructionArgs & {
    instructionDiscriminator: number;
}>;
/**
 * Accounts required by the _CancelMultipleOrdersById_ instruction
 *
 * @property [] phoenixProgram Phoenix program
 * @property [] logAuthority Phoenix log authority
 * @property [_writable_] market This account holds the market state
 * @property [**signer**] trader
 * @property [_writable_] baseAccount Trader base token account
 * @property [_writable_] quoteAccount Trader quote token account
 * @property [_writable_] baseVault Base vault PDA, seeds are [b'vault', market_address, base_mint_address]
 * @property [_writable_] quoteVault Quote vault PDA, seeds are [b'vault', market_address, quote_mint_address]
 * @category Instructions
 * @category CancelMultipleOrdersById
 * @category generated
 */
type CancelMultipleOrdersByIdInstructionAccounts = {
    phoenixProgram: web3.PublicKey;
    logAuthority: web3.PublicKey;
    market: web3.PublicKey;
    trader: web3.PublicKey;
    baseAccount: web3.PublicKey;
    quoteAccount: web3.PublicKey;
    baseVault: web3.PublicKey;
    quoteVault: web3.PublicKey;
    tokenProgram?: web3.PublicKey;
};
declare const cancelMultipleOrdersByIdInstructionDiscriminator = 10;
/**
 * Creates a _CancelMultipleOrdersById_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category CancelMultipleOrdersById
 * @category generated
 */
declare function createCancelMultipleOrdersByIdInstruction(accounts: CancelMultipleOrdersByIdInstructionAccounts, args: CancelMultipleOrdersByIdInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category CancelMultipleOrdersByIdWithFreeFunds
 * @category generated
 */
type CancelMultipleOrdersByIdWithFreeFundsInstructionArgs = {
    params: CancelMultipleOrdersByIdParams;
};
/**
 * @category Instructions
 * @category CancelMultipleOrdersByIdWithFreeFunds
 * @category generated
 */
declare const CancelMultipleOrdersByIdWithFreeFundsStruct: beet.FixableBeetArgsStruct<CancelMultipleOrdersByIdWithFreeFundsInstructionArgs & {
    instructionDiscriminator: number;
}>;
/**
 * Accounts required by the _CancelMultipleOrdersByIdWithFreeFunds_ instruction
 *
 * @property [] phoenixProgram Phoenix program
 * @property [] logAuthority Phoenix log authority
 * @property [_writable_] market This account holds the market state
 * @property [**signer**] trader
 * @category Instructions
 * @category CancelMultipleOrdersByIdWithFreeFunds
 * @category generated
 */
type CancelMultipleOrdersByIdWithFreeFundsInstructionAccounts = {
    phoenixProgram: web3.PublicKey;
    logAuthority: web3.PublicKey;
    market: web3.PublicKey;
    trader: web3.PublicKey;
};
declare const cancelMultipleOrdersByIdWithFreeFundsInstructionDiscriminator = 11;
/**
 * Creates a _CancelMultipleOrdersByIdWithFreeFunds_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category CancelMultipleOrdersByIdWithFreeFunds
 * @category generated
 */
declare function createCancelMultipleOrdersByIdWithFreeFundsInstruction(accounts: CancelMultipleOrdersByIdWithFreeFundsInstructionAccounts, args: CancelMultipleOrdersByIdWithFreeFundsInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category CancelUpTo
 * @category generated
 */
type CancelUpToInstructionArgs = {
    params: CancelUpToParams;
};
/**
 * @category Instructions
 * @category CancelUpTo
 * @category generated
 */
declare const CancelUpToStruct: beet.FixableBeetArgsStruct<CancelUpToInstructionArgs & {
    instructionDiscriminator: number;
}>;
/**
 * Accounts required by the _CancelUpTo_ instruction
 *
 * @property [] phoenixProgram Phoenix program
 * @property [] logAuthority Phoenix log authority
 * @property [_writable_] market This account holds the market state
 * @property [**signer**] trader
 * @property [_writable_] baseAccount Trader base token account
 * @property [_writable_] quoteAccount Trader quote token account
 * @property [_writable_] baseVault Base vault PDA, seeds are [b'vault', market_address, base_mint_address]
 * @property [_writable_] quoteVault Quote vault PDA, seeds are [b'vault', market_address, quote_mint_address]
 * @category Instructions
 * @category CancelUpTo
 * @category generated
 */
type CancelUpToInstructionAccounts = {
    phoenixProgram: web3.PublicKey;
    logAuthority: web3.PublicKey;
    market: web3.PublicKey;
    trader: web3.PublicKey;
    baseAccount: web3.PublicKey;
    quoteAccount: web3.PublicKey;
    baseVault: web3.PublicKey;
    quoteVault: web3.PublicKey;
    tokenProgram?: web3.PublicKey;
};
declare const cancelUpToInstructionDiscriminator = 8;
/**
 * Creates a _CancelUpTo_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category CancelUpTo
 * @category generated
 */
declare function createCancelUpToInstruction(accounts: CancelUpToInstructionAccounts, args: CancelUpToInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category CancelUpToWithFreeFunds
 * @category generated
 */
type CancelUpToWithFreeFundsInstructionArgs = {
    params: CancelUpToParams;
};
/**
 * @category Instructions
 * @category CancelUpToWithFreeFunds
 * @category generated
 */
declare const CancelUpToWithFreeFundsStruct: beet.FixableBeetArgsStruct<CancelUpToWithFreeFundsInstructionArgs & {
    instructionDiscriminator: number;
}>;
/**
 * Accounts required by the _CancelUpToWithFreeFunds_ instruction
 *
 * @property [] phoenixProgram Phoenix program
 * @property [] logAuthority Phoenix log authority
 * @property [_writable_] market This account holds the market state
 * @property [**signer**] trader
 * @category Instructions
 * @category CancelUpToWithFreeFunds
 * @category generated
 */
type CancelUpToWithFreeFundsInstructionAccounts = {
    phoenixProgram: web3.PublicKey;
    logAuthority: web3.PublicKey;
    market: web3.PublicKey;
    trader: web3.PublicKey;
};
declare const cancelUpToWithFreeFundsInstructionDiscriminator = 9;
/**
 * Creates a _CancelUpToWithFreeFunds_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category CancelUpToWithFreeFunds
 * @category generated
 */
declare function createCancelUpToWithFreeFundsInstruction(accounts: CancelUpToWithFreeFundsInstructionAccounts, args: CancelUpToWithFreeFundsInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category DepositFunds
 * @category generated
 */
type DepositFundsInstructionArgs = {
    depositFundsParams: DepositParams;
};
/**
 * @category Instructions
 * @category DepositFunds
 * @category generated
 */
declare const DepositFundsStruct: beet.BeetArgsStruct<DepositFundsInstructionArgs & {
    instructionDiscriminator: number;
}>;
/**
 * Accounts required by the _DepositFunds_ instruction
 *
 * @property [] phoenixProgram Phoenix program
 * @property [] logAuthority Phoenix log authority
 * @property [_writable_] market This account holds the market state
 * @property [**signer**] trader
 * @property [] seat
 * @property [_writable_] baseAccount Trader base token account
 * @property [_writable_] quoteAccount Trader quote token account
 * @property [_writable_] baseVault Base vault PDA, seeds are [b'vault', market_address, base_mint_address]
 * @property [_writable_] quoteVault Quote vault PDA, seeds are [b'vault', market_address, quote_mint_address]
 * @category Instructions
 * @category DepositFunds
 * @category generated
 */
type DepositFundsInstructionAccounts = {
    phoenixProgram: web3.PublicKey;
    logAuthority: web3.PublicKey;
    market: web3.PublicKey;
    trader: web3.PublicKey;
    seat: web3.PublicKey;
    baseAccount: web3.PublicKey;
    quoteAccount: web3.PublicKey;
    baseVault: web3.PublicKey;
    quoteVault: web3.PublicKey;
    tokenProgram?: web3.PublicKey;
};
declare const depositFundsInstructionDiscriminator = 13;
/**
 * Creates a _DepositFunds_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category DepositFunds
 * @category generated
 */
declare function createDepositFundsInstruction(accounts: DepositFundsInstructionAccounts, args: DepositFundsInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category Log
 * @category generated
 */
declare const LogStruct: beet.BeetArgsStruct<{
    instructionDiscriminator: number;
}>;
/**
 * Accounts required by the _Log_ instruction
 *
 * @property [**signer**] logAuthority Log authority
 * @category Instructions
 * @category Log
 * @category generated
 */
type LogInstructionAccounts = {
    logAuthority: web3.PublicKey;
};
declare const logInstructionDiscriminator = 15;
/**
 * Creates a _Log_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category Log
 * @category generated
 */
declare function createLogInstruction(accounts: LogInstructionAccounts, programId?: web3.PublicKey): web3.TransactionInstruction;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category PlaceLimitOrder
 * @category generated
 */
type PlaceLimitOrderInstructionArgs = {
    orderPacket: OrderPacket;
};
/**
 * @category Instructions
 * @category PlaceLimitOrder
 * @category generated
 */
declare const PlaceLimitOrderStruct: beet.FixableBeetArgsStruct<PlaceLimitOrderInstructionArgs & {
    instructionDiscriminator: number;
}>;
/**
 * Accounts required by the _PlaceLimitOrder_ instruction
 *
 * @property [] phoenixProgram Phoenix program
 * @property [] logAuthority Phoenix log authority
 * @property [_writable_] market This account holds the market state
 * @property [**signer**] trader
 * @property [] seat
 * @property [_writable_] baseAccount Trader base token account
 * @property [_writable_] quoteAccount Trader quote token account
 * @property [_writable_] baseVault Base vault PDA, seeds are [b'vault', market_address, base_mint_address]
 * @property [_writable_] quoteVault Quote vault PDA, seeds are [b'vault', market_address, quote_mint_address]
 * @category Instructions
 * @category PlaceLimitOrder
 * @category generated
 */
type PlaceLimitOrderInstructionAccounts = {
    phoenixProgram: web3.PublicKey;
    logAuthority: web3.PublicKey;
    market: web3.PublicKey;
    trader: web3.PublicKey;
    seat: web3.PublicKey;
    baseAccount: web3.PublicKey;
    quoteAccount: web3.PublicKey;
    baseVault: web3.PublicKey;
    quoteVault: web3.PublicKey;
    tokenProgram?: web3.PublicKey;
};
declare const placeLimitOrderInstructionDiscriminator = 2;
/**
 * Creates a _PlaceLimitOrder_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category PlaceLimitOrder
 * @category generated
 */
declare function createPlaceLimitOrderInstruction(accounts: PlaceLimitOrderInstructionAccounts, args: PlaceLimitOrderInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category PlaceLimitOrderWithFreeFunds
 * @category generated
 */
type PlaceLimitOrderWithFreeFundsInstructionArgs = {
    orderPacket: OrderPacket;
};
/**
 * @category Instructions
 * @category PlaceLimitOrderWithFreeFunds
 * @category generated
 */
declare const PlaceLimitOrderWithFreeFundsStruct: beet.FixableBeetArgsStruct<PlaceLimitOrderWithFreeFundsInstructionArgs & {
    instructionDiscriminator: number;
}>;
/**
 * Accounts required by the _PlaceLimitOrderWithFreeFunds_ instruction
 *
 * @property [] phoenixProgram Phoenix program
 * @property [] logAuthority Phoenix log authority
 * @property [_writable_] market This account holds the market state
 * @property [**signer**] trader
 * @property [] seat
 * @category Instructions
 * @category PlaceLimitOrderWithFreeFunds
 * @category generated
 */
type PlaceLimitOrderWithFreeFundsInstructionAccounts = {
    phoenixProgram: web3.PublicKey;
    logAuthority: web3.PublicKey;
    market: web3.PublicKey;
    trader: web3.PublicKey;
    seat: web3.PublicKey;
};
declare const placeLimitOrderWithFreeFundsInstructionDiscriminator = 3;
/**
 * Creates a _PlaceLimitOrderWithFreeFunds_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category PlaceLimitOrderWithFreeFunds
 * @category generated
 */
declare function createPlaceLimitOrderWithFreeFundsInstruction(accounts: PlaceLimitOrderWithFreeFundsInstructionAccounts, args: PlaceLimitOrderWithFreeFundsInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category PlaceMultiplePostOnlyOrders
 * @category generated
 */
type PlaceMultiplePostOnlyOrdersInstructionArgs = {
    multipleOrderPacket: MultipleOrderPacket;
};
/**
 * @category Instructions
 * @category PlaceMultiplePostOnlyOrders
 * @category generated
 */
declare const PlaceMultiplePostOnlyOrdersStruct: beet.FixableBeetArgsStruct<PlaceMultiplePostOnlyOrdersInstructionArgs & {
    instructionDiscriminator: number;
}>;
/**
 * Accounts required by the _PlaceMultiplePostOnlyOrders_ instruction
 *
 * @property [] phoenixProgram Phoenix program
 * @property [] logAuthority Phoenix log authority
 * @property [_writable_] market This account holds the market state
 * @property [**signer**] trader
 * @property [] seat
 * @property [_writable_] baseAccount Trader base token account
 * @property [_writable_] quoteAccount Trader quote token account
 * @property [_writable_] baseVault Base vault PDA, seeds are [b'vault', market_address, base_mint_address]
 * @property [_writable_] quoteVault Quote vault PDA, seeds are [b'vault', market_address, quote_mint_address]
 * @category Instructions
 * @category PlaceMultiplePostOnlyOrders
 * @category generated
 */
type PlaceMultiplePostOnlyOrdersInstructionAccounts = {
    phoenixProgram: web3.PublicKey;
    logAuthority: web3.PublicKey;
    market: web3.PublicKey;
    trader: web3.PublicKey;
    seat: web3.PublicKey;
    baseAccount: web3.PublicKey;
    quoteAccount: web3.PublicKey;
    baseVault: web3.PublicKey;
    quoteVault: web3.PublicKey;
    tokenProgram?: web3.PublicKey;
};
declare const placeMultiplePostOnlyOrdersInstructionDiscriminator = 16;
/**
 * Creates a _PlaceMultiplePostOnlyOrders_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category PlaceMultiplePostOnlyOrders
 * @category generated
 */
declare function createPlaceMultiplePostOnlyOrdersInstruction(accounts: PlaceMultiplePostOnlyOrdersInstructionAccounts, args: PlaceMultiplePostOnlyOrdersInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category PlaceMultiplePostOnlyOrdersWithFreeFunds
 * @category generated
 */
type PlaceMultiplePostOnlyOrdersWithFreeFundsInstructionArgs = {
    multipleOrderPacket: MultipleOrderPacket;
};
/**
 * @category Instructions
 * @category PlaceMultiplePostOnlyOrdersWithFreeFunds
 * @category generated
 */
declare const PlaceMultiplePostOnlyOrdersWithFreeFundsStruct: beet.FixableBeetArgsStruct<PlaceMultiplePostOnlyOrdersWithFreeFundsInstructionArgs & {
    instructionDiscriminator: number;
}>;
/**
 * Accounts required by the _PlaceMultiplePostOnlyOrdersWithFreeFunds_ instruction
 *
 * @property [] phoenixProgram Phoenix program
 * @property [] logAuthority Phoenix log authority
 * @property [_writable_] market This account holds the market state
 * @property [**signer**] trader
 * @property [] seat
 * @category Instructions
 * @category PlaceMultiplePostOnlyOrdersWithFreeFunds
 * @category generated
 */
type PlaceMultiplePostOnlyOrdersWithFreeFundsInstructionAccounts = {
    phoenixProgram: web3.PublicKey;
    logAuthority: web3.PublicKey;
    market: web3.PublicKey;
    trader: web3.PublicKey;
    seat: web3.PublicKey;
};
declare const placeMultiplePostOnlyOrdersWithFreeFundsInstructionDiscriminator = 17;
/**
 * Creates a _PlaceMultiplePostOnlyOrdersWithFreeFunds_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category PlaceMultiplePostOnlyOrdersWithFreeFunds
 * @category generated
 */
declare function createPlaceMultiplePostOnlyOrdersWithFreeFundsInstruction(accounts: PlaceMultiplePostOnlyOrdersWithFreeFundsInstructionAccounts, args: PlaceMultiplePostOnlyOrdersWithFreeFundsInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category ReduceOrder
 * @category generated
 */
type ReduceOrderInstructionArgs = {
    params: ReduceOrderParams;
};
/**
 * @category Instructions
 * @category ReduceOrder
 * @category generated
 */
declare const ReduceOrderStruct: beet.BeetArgsStruct<ReduceOrderInstructionArgs & {
    instructionDiscriminator: number;
}>;
/**
 * Accounts required by the _ReduceOrder_ instruction
 *
 * @property [] phoenixProgram Phoenix program
 * @property [] logAuthority Phoenix log authority
 * @property [_writable_] market This account holds the market state
 * @property [**signer**] trader
 * @property [_writable_] baseAccount Trader base token account
 * @property [_writable_] quoteAccount Trader quote token account
 * @property [_writable_] baseVault Base vault PDA, seeds are [b'vault', market_address, base_mint_address]
 * @property [_writable_] quoteVault Quote vault PDA, seeds are [b'vault', market_address, quote_mint_address]
 * @category Instructions
 * @category ReduceOrder
 * @category generated
 */
type ReduceOrderInstructionAccounts = {
    phoenixProgram: web3.PublicKey;
    logAuthority: web3.PublicKey;
    market: web3.PublicKey;
    trader: web3.PublicKey;
    baseAccount: web3.PublicKey;
    quoteAccount: web3.PublicKey;
    baseVault: web3.PublicKey;
    quoteVault: web3.PublicKey;
    tokenProgram?: web3.PublicKey;
};
declare const reduceOrderInstructionDiscriminator = 4;
/**
 * Creates a _ReduceOrder_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category ReduceOrder
 * @category generated
 */
declare function createReduceOrderInstruction(accounts: ReduceOrderInstructionAccounts, args: ReduceOrderInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category ReduceOrderWithFreeFunds
 * @category generated
 */
type ReduceOrderWithFreeFundsInstructionArgs = {
    params: ReduceOrderParams;
};
/**
 * @category Instructions
 * @category ReduceOrderWithFreeFunds
 * @category generated
 */
declare const ReduceOrderWithFreeFundsStruct: beet.BeetArgsStruct<ReduceOrderWithFreeFundsInstructionArgs & {
    instructionDiscriminator: number;
}>;
/**
 * Accounts required by the _ReduceOrderWithFreeFunds_ instruction
 *
 * @property [] phoenixProgram Phoenix program
 * @property [] logAuthority Phoenix log authority
 * @property [_writable_] market This account holds the market state
 * @property [_writable_, **signer**] trader
 * @category Instructions
 * @category ReduceOrderWithFreeFunds
 * @category generated
 */
type ReduceOrderWithFreeFundsInstructionAccounts = {
    phoenixProgram: web3.PublicKey;
    logAuthority: web3.PublicKey;
    market: web3.PublicKey;
    trader: web3.PublicKey;
};
declare const reduceOrderWithFreeFundsInstructionDiscriminator = 5;
/**
 * Creates a _ReduceOrderWithFreeFunds_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category ReduceOrderWithFreeFunds
 * @category generated
 */
declare function createReduceOrderWithFreeFundsInstruction(accounts: ReduceOrderWithFreeFundsInstructionAccounts, args: ReduceOrderWithFreeFundsInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category RequestSeat
 * @category generated
 */
declare const RequestSeatStruct: beet.BeetArgsStruct<{
    instructionDiscriminator: number;
}>;
/**
 * Accounts required by the _RequestSeat_ instruction
 *
 * @property [] phoenixProgram Phoenix program
 * @property [] logAuthority Phoenix log authority
 * @property [_writable_] market This account holds the market state
 * @property [_writable_, **signer**] payer
 * @property [_writable_] seat
 * @category Instructions
 * @category RequestSeat
 * @category generated
 */
type RequestSeatInstructionAccounts = {
    phoenixProgram: web3.PublicKey;
    logAuthority: web3.PublicKey;
    market: web3.PublicKey;
    payer: web3.PublicKey;
    seat: web3.PublicKey;
    systemProgram?: web3.PublicKey;
};
declare const requestSeatInstructionDiscriminator = 14;
/**
 * Creates a _RequestSeat_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category RequestSeat
 * @category generated
 */
declare function createRequestSeatInstruction(accounts: RequestSeatInstructionAccounts, programId?: web3.PublicKey): web3.TransactionInstruction;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category Swap
 * @category generated
 */
type SwapInstructionArgs = {
    orderPacket: OrderPacket;
};
/**
 * @category Instructions
 * @category Swap
 * @category generated
 */
declare const SwapStruct: beet.FixableBeetArgsStruct<SwapInstructionArgs & {
    instructionDiscriminator: number;
}>;
/**
 * Accounts required by the _Swap_ instruction
 *
 * @property [] phoenixProgram Phoenix program
 * @property [] logAuthority Phoenix log authority
 * @property [_writable_] market This account holds the market state
 * @property [**signer**] trader
 * @property [_writable_] baseAccount Trader base token account
 * @property [_writable_] quoteAccount Trader quote token account
 * @property [_writable_] baseVault Base vault PDA, seeds are [b'vault', market_address, base_mint_address]
 * @property [_writable_] quoteVault Quote vault PDA, seeds are [b'vault', market_address, quote_mint_address]
 * @category Instructions
 * @category Swap
 * @category generated
 */
type SwapInstructionAccounts = {
    phoenixProgram: web3.PublicKey;
    logAuthority: web3.PublicKey;
    market: web3.PublicKey;
    trader: web3.PublicKey;
    baseAccount: web3.PublicKey;
    quoteAccount: web3.PublicKey;
    baseVault: web3.PublicKey;
    quoteVault: web3.PublicKey;
    tokenProgram?: web3.PublicKey;
};
declare const swapInstructionDiscriminator = 0;
/**
 * Creates a _Swap_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category Swap
 * @category generated
 */
declare function createSwapInstruction(accounts: SwapInstructionAccounts, args: SwapInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category SwapWithFreeFunds
 * @category generated
 */
type SwapWithFreeFundsInstructionArgs = {
    orderPacket: OrderPacket;
};
/**
 * @category Instructions
 * @category SwapWithFreeFunds
 * @category generated
 */
declare const SwapWithFreeFundsStruct: beet.FixableBeetArgsStruct<SwapWithFreeFundsInstructionArgs & {
    instructionDiscriminator: number;
}>;
/**
 * Accounts required by the _SwapWithFreeFunds_ instruction
 *
 * @property [] phoenixProgram Phoenix program
 * @property [] logAuthority Phoenix log authority
 * @property [_writable_] market This account holds the market state
 * @property [**signer**] trader
 * @property [] seat
 * @category Instructions
 * @category SwapWithFreeFunds
 * @category generated
 */
type SwapWithFreeFundsInstructionAccounts = {
    phoenixProgram: web3.PublicKey;
    logAuthority: web3.PublicKey;
    market: web3.PublicKey;
    trader: web3.PublicKey;
    seat: web3.PublicKey;
};
declare const swapWithFreeFundsInstructionDiscriminator = 1;
/**
 * Creates a _SwapWithFreeFunds_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category SwapWithFreeFunds
 * @category generated
 */
declare function createSwapWithFreeFundsInstruction(accounts: SwapWithFreeFundsInstructionAccounts, args: SwapWithFreeFundsInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category WithdrawFunds
 * @category generated
 */
type WithdrawFundsInstructionArgs = {
    withdrawFundsParams: WithdrawParams;
};
/**
 * @category Instructions
 * @category WithdrawFunds
 * @category generated
 */
declare const WithdrawFundsStruct: beet.FixableBeetArgsStruct<WithdrawFundsInstructionArgs & {
    instructionDiscriminator: number;
}>;
/**
 * Accounts required by the _WithdrawFunds_ instruction
 *
 * @property [] phoenixProgram Phoenix program
 * @property [] logAuthority Phoenix log authority
 * @property [_writable_] market This account holds the market state
 * @property [**signer**] trader
 * @property [_writable_] baseAccount Trader base token account
 * @property [_writable_] quoteAccount Trader quote token account
 * @property [_writable_] baseVault Base vault PDA, seeds are [b'vault', market_address, base_mint_address]
 * @property [_writable_] quoteVault Quote vault PDA, seeds are [b'vault', market_address, quote_mint_address]
 * @category Instructions
 * @category WithdrawFunds
 * @category generated
 */
type WithdrawFundsInstructionAccounts = {
    phoenixProgram: web3.PublicKey;
    logAuthority: web3.PublicKey;
    market: web3.PublicKey;
    trader: web3.PublicKey;
    baseAccount: web3.PublicKey;
    quoteAccount: web3.PublicKey;
    baseVault: web3.PublicKey;
    quoteVault: web3.PublicKey;
    tokenProgram?: web3.PublicKey;
};
declare const withdrawFundsInstructionDiscriminator = 12;
/**
 * Creates a _WithdrawFunds_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category WithdrawFunds
 * @category generated
 */
declare function createWithdrawFundsInstruction(accounts: WithdrawFundsInstructionAccounts, args: WithdrawFundsInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;

declare class Trader {
    pubkey: PublicKey;
    tokenBalances: Record<string, TokenAmount>;
    private constructor();
    /**
     * Returns a `Trader` object for a given trader address and subscribes to updates
     *
     * @param connection The Solana `Connection` object
     * @param pubkey The `PublicKey` of the trader
     * @param tokens The list of `Token` objects to load balances for
     */
    static create({ connection, pubkey, tokens, }: {
        connection: Connection;
        pubkey: PublicKey;
        tokens: Array<Token>;
    }): Promise<Trader>;
    /**
     * Refreshes the trader data
     *
     * @param connection The Solana `Connection` object
     *
     * @returns The refreshed Trader
     */
    refresh(connection: Connection): Promise<Trader>;
}

declare class Client {
    connection: Connection;
    trader: Trader;
    tokens: Array<Token>;
    markets: Array<Market>;
    private constructor();
    /**
     * Creates a new `PhoenixClient`
     *
     * @param connection The Solana `Connection` to use for the client
     * @param trader The `PublicKey` of the trader account to use for the client (optional)
     */
    static create(connection: Connection, trader?: PublicKey): Promise<Client>;
}

/**
 * Program address
 *
 * @category constants
 * @category generated
 */
declare const PROGRAM_ADDRESS = "PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY";
/**
 * Program public key
 *
 * @category constants
 * @category generated
 */
declare const PROGRAM_ID: PublicKey;

export { AuditLogHeader, CancelAllOrdersInstructionAccounts, CancelAllOrdersStruct, CancelAllOrdersWithFreeFundsInstructionAccounts, CancelAllOrdersWithFreeFundsStruct, CancelMultipleOrdersByIdInstructionAccounts, CancelMultipleOrdersByIdInstructionArgs, CancelMultipleOrdersByIdParams, CancelMultipleOrdersByIdStruct, CancelMultipleOrdersByIdWithFreeFundsInstructionAccounts, CancelMultipleOrdersByIdWithFreeFundsInstructionArgs, CancelMultipleOrdersByIdWithFreeFundsStruct, CancelMultipleOrdersErrorError, CancelOrderParams, CancelUpToInstructionAccounts, CancelUpToInstructionArgs, CancelUpToParams, CancelUpToStruct, CancelUpToWithFreeFundsInstructionAccounts, CancelUpToWithFreeFundsInstructionArgs, CancelUpToWithFreeFundsStruct, Client, Cluster, CondensedOrder, DEFAULT_LADDER_DEPTH, DEFAULT_MATCH_LIMIT, DEFAULT_SLIPPAGE_PERCENT, DepositFundsInstructionAccounts, DepositFundsInstructionArgs, DepositFundsStruct, DepositParams, EvictEvent, EvictionErrorError, FailedToLoadMarketFromAccountError, FeeEvent, FillEvent, FillSummaryEvent, InvalidBaseAccountError, InvalidBaseVaultError, InvalidLotSizeError, InvalidMarketAuthorityError, InvalidMarketParametersError, InvalidMarketSignerError, InvalidMintError, InvalidQuoteAccountError, InvalidQuoteVaultError, InvalidSeatStatusError, InvalidStateTransitionError, InvalidTickSizeError, Ladder, LogInstructionAccounts, LogStruct, Market, MarketAlreadyInitializedError, MarketData, MarketHeader, MarketSizeParams, MarketStatus, MarketUninitializedError, MultipleOrderPacket, NewOrderErrorError, OrderId, OrderPacket, OrderPacketRecord, PROGRAM_ADDRESS, PROGRAM_ID, PhoenixEvent, PhoenixMarketEvent, PhoenixTransaction, PlaceEvent, PlaceLimitOrderInstructionAccounts, PlaceLimitOrderInstructionArgs, PlaceLimitOrderStruct, PlaceLimitOrderWithFreeFundsInstructionAccounts, PlaceLimitOrderWithFreeFundsInstructionArgs, PlaceLimitOrderWithFreeFundsStruct, PlaceMultiplePostOnlyOrdersInstructionAccounts, PlaceMultiplePostOnlyOrdersInstructionArgs, PlaceMultiplePostOnlyOrdersStruct, PlaceMultiplePostOnlyOrdersWithFreeFundsInstructionAccounts, PlaceMultiplePostOnlyOrdersWithFreeFundsInstructionArgs, PlaceMultiplePostOnlyOrdersWithFreeFundsStruct, ReduceEvent, ReduceOrderErrorError, ReduceOrderInstructionAccounts, ReduceOrderInstructionArgs, ReduceOrderParams, ReduceOrderStruct, ReduceOrderWithFreeFundsInstructionAccounts, ReduceOrderWithFreeFundsInstructionArgs, ReduceOrderWithFreeFundsStruct, RemoveEmptyOrdersErrorError, RequestSeatInstructionAccounts, RequestSeatStruct, RestingOrder, Seat, SeatApprovalStatus, SelfTradeBehavior, Side, SwapInstructionAccounts, SwapInstructionArgs, SwapStruct, SwapWithFreeFundsInstructionAccounts, SwapWithFreeFundsInstructionArgs, SwapWithFreeFundsStruct, Token, TokenParams, TooManyEventsError, Trader, TraderNotFoundError, TraderState, UiLadder, WithdrawFundsErrorError, WithdrawFundsInstructionAccounts, WithdrawFundsInstructionArgs, WithdrawFundsStruct, WithdrawParams, auditLogHeaderBeet, cancelAllOrdersInstructionDiscriminator, cancelAllOrdersWithFreeFundsInstructionDiscriminator, cancelMultipleOrdersByIdInstructionDiscriminator, cancelMultipleOrdersByIdParamsBeet, cancelMultipleOrdersByIdWithFreeFundsInstructionDiscriminator, cancelOrderParamsBeet, cancelUpToInstructionDiscriminator, cancelUpToParamsBeet, cancelUpToWithFreeFundsInstructionDiscriminator, condensedOrderBeet, createCancelAllOrdersInstruction, createCancelAllOrdersWithFreeFundsInstruction, createCancelMultipleOrdersByIdInstruction, createCancelMultipleOrdersByIdWithFreeFundsInstruction, createCancelUpToInstruction, createCancelUpToWithFreeFundsInstruction, createDepositFundsInstruction, createLogInstruction, createPlaceLimitOrderInstruction, createPlaceLimitOrderWithFreeFundsInstruction, createPlaceMultiplePostOnlyOrdersInstruction, createPlaceMultiplePostOnlyOrdersWithFreeFundsInstruction, createReduceOrderInstruction, createReduceOrderWithFreeFundsInstruction, createRequestSeatInstruction, createSwapInstruction, createSwapWithFreeFundsInstruction, createWithdrawFundsInstruction, depositFundsInstructionDiscriminator, depositParamsBeet, deserializeMarketData, deserializeRedBlackTree, errorFromCode, errorFromName, evictEventBeet, feeEventBeet, fillEventBeet, fillSummaryEventBeet, getClusterFromEndpoint, getEventsFromTransaction, getMarketExpectedOutAmount, getMarketLadder, getMarketSwapOrderPacket, getMarketSwapTransaction, getMarketUiLadder, isOrderPacketImmediateOrCancel, isOrderPacketLimit, isOrderPacketPostOnly, logInstructionDiscriminator, marketHeaderBeet, marketSizeParamsBeet, marketStatusBeet, multipleOrderPacketBeet, orderPacketBeet, phoenixMarketEventBeet, placeEventBeet, placeLimitOrderInstructionDiscriminator, placeLimitOrderWithFreeFundsInstructionDiscriminator, placeMultiplePostOnlyOrdersInstructionDiscriminator, placeMultiplePostOnlyOrdersWithFreeFundsInstructionDiscriminator, printUiLadder, readPublicKey, reduceEventBeet, reduceOrderInstructionDiscriminator, reduceOrderParamsBeet, reduceOrderWithFreeFundsInstructionDiscriminator, requestSeatInstructionDiscriminator, seatApprovalStatusBeet, seatBeet, selfTradeBehaviorBeet, sideBeet, sign, swapInstructionDiscriminator, swapWithFreeFundsInstructionDiscriminator, toBN, toNum, tokenParamsBeet, withdrawFundsInstructionDiscriminator, withdrawParamsBeet };
