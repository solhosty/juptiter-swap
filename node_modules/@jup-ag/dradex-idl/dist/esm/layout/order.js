import BN from "bn.js";
import { seq, struct, u32, u8, offset } from "@solana/buffer-layout";
import { publicKeyLayout, setLayoutDecoder, u128, u64 } from "./base";
const OB_HEADER_LAYOUT = struct([u8("flag"), u32("len")], "header");
const ORDER_LAYOUT = struct([
    u128("key"),
    publicKeyLayout("owner"),
    u64("quantity"),
    u64("clientOrderId"),
    u8("feeTier"),
    u64("total"),
]);
export const OB_LAYOUT = struct([
    OB_HEADER_LAYOUT,
    seq(ORDER_LAYOUT, offset(
    // @ts-expect-error
    OB_HEADER_LAYOUT.layoutFor("len"), OB_HEADER_LAYOUT.offsetOf("len") - OB_HEADER_LAYOUT.span), "nodes"),
]);
export class OrderBook {
    constructor(header, nodes) {
        this.header = header;
        this.nodes = nodes || [];
    }
    get isDescending() {
        return this.header.flag == 1 ? true : false;
    }
    static decode(buffer) {
        return OB_LAYOUT.decode(buffer);
    }
    static getPriceFromKey(key) {
        return key.ushrn(64);
    }
    get(searchKey) {
        return this.nodes.find((n) => n.key.eq(searchKey));
    }
    get items() {
        return this.nodes;
    }
    allItems(descending = false) {
        return descending != this.isDescending
            ? this.nodes.slice().reverse()
            : this.nodes;
    }
    find(clientOrderId) {
        if (!(clientOrderId instanceof BN)) {
            clientOrderId = new BN(clientOrderId);
        }
        return this.nodes.find((n) => n.clientOrderId.eq(clientOrderId));
    }
    findMinMax(isMax) {
        return this.allItems(isMax)[0] || null;
    }
}
setLayoutDecoder(OB_LAYOUT, ({ header, nodes }) => new OrderBook(header, nodes));
export const ORDER_SIZE = ORDER_LAYOUT.span;
