import { TransactionError, parseErrorForTransaction, UNKNOWN_ERROR, deserializeAccount } from '@mercurial-finance/optimist';
import { Program } from '@project-serum/anchor';
import { PublicKey, TransactionMessage, VersionedTransaction, Transaction, sendAndConfirmRawTransaction, TransactionInstruction, SystemProgram, SYSVAR_RENT_PUBKEY } from '@solana/web3.js';
import { bs58 } from '@project-serum/anchor/dist/cjs/utils/bytes';
import { TOKEN_PROGRAM_ID, ASSOCIATED_TOKEN_PROGRAM_ID, Token } from '@solana/spl-token';
import JSBI from 'jsbi';

var IDL = {
  version: '0.1.0',
  name: 'jupiter',
  instructions: [{
    name: 'route',
    accounts: [{
      name: 'tokenProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'userTransferAuthority',
      isMut: false,
      isSigner: true
    }, {
      name: 'destinationTokenAccount',
      isMut: false,
      isSigner: false
    }],
    args: [{
      name: 'swapLeg',
      type: {
        defined: 'SwapLeg'
      }
    }, {
      name: 'inAmount',
      type: 'u64'
    }, {
      name: 'quotedOutAmount',
      type: 'u64'
    }, {
      name: 'slippageBps',
      type: 'u16'
    }, {
      name: 'platformFeeBps',
      type: 'u8'
    }]
  }, {
    name: 'whirlpoolSwapExactOutput',
    accounts: [{
      name: 'swapProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'tokenProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'tokenAuthority',
      isMut: false,
      isSigner: true
    }, {
      name: 'whirlpool',
      isMut: true,
      isSigner: false
    }, {
      name: 'tokenOwnerAccountA',
      isMut: true,
      isSigner: false
    }, {
      name: 'tokenVaultA',
      isMut: true,
      isSigner: false
    }, {
      name: 'tokenOwnerAccountB',
      isMut: true,
      isSigner: false
    }, {
      name: 'tokenVaultB',
      isMut: true,
      isSigner: false
    }, {
      name: 'tickArray0',
      isMut: true,
      isSigner: false
    }, {
      name: 'tickArray1',
      isMut: true,
      isSigner: false
    }, {
      name: 'tickArray2',
      isMut: true,
      isSigner: false
    }, {
      name: 'oracle',
      isMut: false,
      isSigner: false
    }],
    args: [{
      name: 'outAmount',
      type: 'u64'
    }, {
      name: 'inAmountWithSlippage',
      type: {
        defined: 'AmountWithSlippage'
      }
    }, {
      name: 'aToB',
      type: 'bool'
    }, {
      name: 'platformFeeBps',
      type: 'u8'
    }]
  }, {
    name: 'raydiumSwapExactOutput',
    accounts: [{
      name: 'swapProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'tokenProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'ammId',
      isMut: true,
      isSigner: false
    }, {
      name: 'ammAuthority',
      isMut: false,
      isSigner: false
    }, {
      name: 'ammOpenOrders',
      isMut: true,
      isSigner: false
    }, {
      name: 'poolCoinTokenAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'poolPcTokenAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'serumProgramId',
      isMut: false,
      isSigner: false
    }, {
      name: 'serumMarket',
      isMut: true,
      isSigner: false
    }, {
      name: 'serumBids',
      isMut: true,
      isSigner: false
    }, {
      name: 'serumAsks',
      isMut: true,
      isSigner: false
    }, {
      name: 'serumEventQueue',
      isMut: true,
      isSigner: false
    }, {
      name: 'serumCoinVaultAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'serumPcVaultAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'serumVaultSigner',
      isMut: false,
      isSigner: false
    }, {
      name: 'userSourceTokenAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'userDestinationTokenAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'userSourceOwner',
      isMut: false,
      isSigner: true
    }],
    args: [{
      name: 'outAmount',
      type: 'u64'
    }, {
      name: 'inAmountWithSlippage',
      type: {
        defined: 'AmountWithSlippage'
      }
    }, {
      name: 'platformFeeBps',
      type: 'u8'
    }]
  }, {
    name: 'raydiumClmmSwapExactOutput',
    accounts: [{
      name: 'swapProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'payer',
      isMut: false,
      isSigner: true
    }, {
      name: 'ammConfig',
      isMut: false,
      isSigner: false
    }, {
      name: 'poolState',
      isMut: true,
      isSigner: false
    }, {
      name: 'inputTokenAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'outputTokenAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'inputVault',
      isMut: true,
      isSigner: false
    }, {
      name: 'outputVault',
      isMut: true,
      isSigner: false
    }, {
      name: 'observationState',
      isMut: true,
      isSigner: false
    }, {
      name: 'tokenProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'tickArray',
      isMut: true,
      isSigner: false
    }],
    args: [{
      name: 'outAmount',
      type: 'u64'
    }, {
      name: 'inAmountWithSlippage',
      type: {
        defined: 'AmountWithSlippage'
      }
    }, {
      name: 'platformFeeBps',
      type: 'u8'
    }]
  }, {
    name: 'createOpenOrders',
    accounts: [{
      name: 'openOrders',
      isMut: true,
      isSigner: false
    }, {
      name: 'payer',
      isMut: true,
      isSigner: true
    }, {
      name: 'dexProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'systemProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'rent',
      isMut: false,
      isSigner: false
    }, {
      name: 'market',
      isMut: false,
      isSigner: false
    }],
    args: []
  }, {
    name: 'mercurialSwap',
    accounts: [{
      name: 'swapProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'swapState',
      isMut: false,
      isSigner: false
    }, {
      name: 'tokenProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'poolAuthority',
      isMut: false,
      isSigner: false
    }, {
      name: 'userTransferAuthority',
      isMut: false,
      isSigner: true
    }, {
      name: 'sourceTokenAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'destinationTokenAccount',
      isMut: true,
      isSigner: false
    }],
    args: []
  }, {
    name: 'cykuraSwap',
    accounts: [{
      name: 'swapProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'signer',
      isMut: false,
      isSigner: true
    }, {
      name: 'factoryState',
      isMut: false,
      isSigner: false
    }, {
      name: 'poolState',
      isMut: true,
      isSigner: false
    }, {
      name: 'inputTokenAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'outputTokenAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'inputVault',
      isMut: true,
      isSigner: false
    }, {
      name: 'outputVault',
      isMut: true,
      isSigner: false
    }, {
      name: 'lastObservationState',
      isMut: true,
      isSigner: false
    }, {
      name: 'coreProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'tokenProgram',
      isMut: false,
      isSigner: false
    }],
    args: []
  }, {
    name: 'serumSwap',
    accounts: [{
      name: 'market',
      accounts: [{
        name: 'market',
        isMut: true,
        isSigner: false
      }, {
        name: 'openOrders',
        isMut: true,
        isSigner: false
      }, {
        name: 'requestQueue',
        isMut: true,
        isSigner: false
      }, {
        name: 'eventQueue',
        isMut: true,
        isSigner: false
      }, {
        name: 'bids',
        isMut: true,
        isSigner: false
      }, {
        name: 'asks',
        isMut: true,
        isSigner: false
      }, {
        name: 'coinVault',
        isMut: true,
        isSigner: false
      }, {
        name: 'pcVault',
        isMut: true,
        isSigner: false
      }, {
        name: 'vaultSigner',
        isMut: false,
        isSigner: false
      }]
    }, {
      name: 'authority',
      isMut: false,
      isSigner: true
    }, {
      name: 'orderPayerTokenAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'coinWallet',
      isMut: true,
      isSigner: false
    }, {
      name: 'pcWallet',
      isMut: true,
      isSigner: false
    }, {
      name: 'dexProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'tokenProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'rent',
      isMut: false,
      isSigner: false
    }],
    args: []
  }, {
    name: 'saberSwap',
    accounts: [{
      name: 'swapProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'tokenProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'swap',
      isMut: false,
      isSigner: false
    }, {
      name: 'swapAuthority',
      isMut: false,
      isSigner: false
    }, {
      name: 'userAuthority',
      isMut: false,
      isSigner: false
    }, {
      name: 'inputUserAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'inputTokenAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'outputUserAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'outputTokenAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'feesTokenAccount',
      isMut: true,
      isSigner: false
    }],
    args: []
  }, {
    name: 'saberAddDecimals',
    accounts: [{
      name: 'addDecimalsProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'wrapper',
      isMut: false,
      isSigner: false
    }, {
      name: 'wrapperMint',
      isMut: true,
      isSigner: false
    }, {
      name: 'wrapperUnderlyingTokens',
      isMut: true,
      isSigner: false
    }, {
      name: 'owner',
      isMut: false,
      isSigner: true
    }, {
      name: 'userUnderlyingTokens',
      isMut: true,
      isSigner: false
    }, {
      name: 'userWrappedTokens',
      isMut: true,
      isSigner: false
    }, {
      name: 'tokenProgram',
      isMut: false,
      isSigner: false
    }],
    args: []
  }, {
    name: 'tokenSwap',
    accounts: [{
      name: 'tokenSwapProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'tokenProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'swap',
      isMut: false,
      isSigner: false
    }, {
      name: 'authority',
      isMut: false,
      isSigner: false
    }, {
      name: 'userTransferAuthority',
      isMut: false,
      isSigner: true
    }, {
      name: 'source',
      isMut: true,
      isSigner: false
    }, {
      name: 'swapSource',
      isMut: true,
      isSigner: false
    }, {
      name: 'swapDestination',
      isMut: true,
      isSigner: false
    }, {
      name: 'destination',
      isMut: true,
      isSigner: false
    }, {
      name: 'poolMint',
      isMut: true,
      isSigner: false
    }, {
      name: 'poolFee',
      isMut: true,
      isSigner: false
    }],
    args: []
  }, {
    name: 'senchaSwap',
    accounts: [{
      name: 'swapProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'tokenProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'swap',
      isMut: true,
      isSigner: false
    }, {
      name: 'userAuthority',
      isMut: false,
      isSigner: false
    }, {
      name: 'inputUserAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'inputTokenAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'inputFeesAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'outputUserAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'outputTokenAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'outputFeesAccount',
      isMut: true,
      isSigner: false
    }],
    args: []
  }, {
    name: 'stepSwap',
    accounts: [{
      name: 'tokenSwapProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'tokenProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'swap',
      isMut: false,
      isSigner: false
    }, {
      name: 'authority',
      isMut: false,
      isSigner: false
    }, {
      name: 'userTransferAuthority',
      isMut: false,
      isSigner: true
    }, {
      name: 'source',
      isMut: true,
      isSigner: false
    }, {
      name: 'swapSource',
      isMut: true,
      isSigner: false
    }, {
      name: 'swapDestination',
      isMut: true,
      isSigner: false
    }, {
      name: 'destination',
      isMut: true,
      isSigner: false
    }, {
      name: 'poolMint',
      isMut: true,
      isSigner: false
    }, {
      name: 'poolFee',
      isMut: true,
      isSigner: false
    }],
    args: []
  }, {
    name: 'cropperSwap',
    accounts: [{
      name: 'tokenSwapProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'tokenProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'swap',
      isMut: false,
      isSigner: false
    }, {
      name: 'swapState',
      isMut: false,
      isSigner: false
    }, {
      name: 'authority',
      isMut: false,
      isSigner: false
    }, {
      name: 'userTransferAuthority',
      isMut: false,
      isSigner: true
    }, {
      name: 'source',
      isMut: true,
      isSigner: false
    }, {
      name: 'swapSource',
      isMut: true,
      isSigner: false
    }, {
      name: 'swapDestination',
      isMut: true,
      isSigner: false
    }, {
      name: 'destination',
      isMut: true,
      isSigner: false
    }, {
      name: 'poolMint',
      isMut: true,
      isSigner: false
    }, {
      name: 'poolFee',
      isMut: true,
      isSigner: false
    }],
    args: []
  }, {
    name: 'raydiumSwap',
    accounts: [{
      name: 'swapProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'tokenProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'ammId',
      isMut: true,
      isSigner: false
    }, {
      name: 'ammAuthority',
      isMut: false,
      isSigner: false
    }, {
      name: 'ammOpenOrders',
      isMut: true,
      isSigner: false
    }, {
      name: 'poolCoinTokenAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'poolPcTokenAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'serumProgramId',
      isMut: false,
      isSigner: false
    }, {
      name: 'serumMarket',
      isMut: true,
      isSigner: false
    }, {
      name: 'serumBids',
      isMut: true,
      isSigner: false
    }, {
      name: 'serumAsks',
      isMut: true,
      isSigner: false
    }, {
      name: 'serumEventQueue',
      isMut: true,
      isSigner: false
    }, {
      name: 'serumCoinVaultAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'serumPcVaultAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'serumVaultSigner',
      isMut: false,
      isSigner: false
    }, {
      name: 'userSourceTokenAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'userDestinationTokenAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'userSourceOwner',
      isMut: false,
      isSigner: true
    }],
    args: []
  }, {
    name: 'cremaSwap',
    accounts: [{
      name: 'swapProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'clmmConfig',
      isMut: false,
      isSigner: false
    }, {
      name: 'clmmpool',
      isMut: true,
      isSigner: false
    }, {
      name: 'tokenA',
      isMut: false,
      isSigner: false
    }, {
      name: 'tokenB',
      isMut: false,
      isSigner: false
    }, {
      name: 'accountA',
      isMut: true,
      isSigner: false
    }, {
      name: 'accountB',
      isMut: true,
      isSigner: false
    }, {
      name: 'tokenAVault',
      isMut: true,
      isSigner: false
    }, {
      name: 'tokenBVault',
      isMut: true,
      isSigner: false
    }, {
      name: 'tickArrayMap',
      isMut: true,
      isSigner: false
    }, {
      name: 'owner',
      isMut: false,
      isSigner: true
    }, {
      name: 'partner',
      isMut: false,
      isSigner: false
    }, {
      name: 'partnerAtaA',
      isMut: true,
      isSigner: false
    }, {
      name: 'partnerAtaB',
      isMut: true,
      isSigner: false
    }, {
      name: 'tokenProgram',
      isMut: false,
      isSigner: false
    }],
    args: []
  }, {
    name: 'lifinitySwap',
    accounts: [{
      name: 'swapProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'authority',
      isMut: false,
      isSigner: false
    }, {
      name: 'amm',
      isMut: false,
      isSigner: false
    }, {
      name: 'userTransferAuthority',
      isMut: false,
      isSigner: true
    }, {
      name: 'sourceInfo',
      isMut: true,
      isSigner: false
    }, {
      name: 'destinationInfo',
      isMut: true,
      isSigner: false
    }, {
      name: 'swapSource',
      isMut: true,
      isSigner: false
    }, {
      name: 'swapDestination',
      isMut: true,
      isSigner: false
    }, {
      name: 'poolMint',
      isMut: true,
      isSigner: false
    }, {
      name: 'feeAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'tokenProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'pythAccount',
      isMut: false,
      isSigner: false
    }, {
      name: 'pythPcAccount',
      isMut: false,
      isSigner: false
    }, {
      name: 'configAccount',
      isMut: true,
      isSigner: false
    }],
    args: []
  }, {
    name: 'marinadeDeposit',
    accounts: [{
      name: 'marinadeFinanceProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'state',
      isMut: true,
      isSigner: false
    }, {
      name: 'msolMint',
      isMut: true,
      isSigner: false
    }, {
      name: 'liqPoolSolLegPda',
      isMut: true,
      isSigner: false
    }, {
      name: 'liqPoolMsolLeg',
      isMut: true,
      isSigner: false
    }, {
      name: 'liqPoolMsolLegAuthority',
      isMut: false,
      isSigner: false
    }, {
      name: 'reservePda',
      isMut: true,
      isSigner: false
    }, {
      name: 'transferFrom',
      isMut: true,
      isSigner: false
    }, {
      name: 'mintTo',
      isMut: true,
      isSigner: false
    }, {
      name: 'msolMintAuthority',
      isMut: false,
      isSigner: false
    }, {
      name: 'systemProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'tokenProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'userWsolTokenAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'tempWsolTokenAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'userTransferAuthority',
      isMut: true,
      isSigner: true
    }, {
      name: 'wsolMint',
      isMut: false,
      isSigner: false
    }, {
      name: 'rent',
      isMut: false,
      isSigner: false
    }],
    args: []
  }, {
    name: 'marinadeUnstake',
    accounts: [{
      name: 'marinadeFinanceProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'state',
      isMut: true,
      isSigner: false
    }, {
      name: 'msolMint',
      isMut: true,
      isSigner: false
    }, {
      name: 'liqPoolSolLegPda',
      isMut: true,
      isSigner: false
    }, {
      name: 'liqPoolMsolLeg',
      isMut: true,
      isSigner: false
    }, {
      name: 'treasuryMsolAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'getMsolFrom',
      isMut: true,
      isSigner: false
    }, {
      name: 'getMsolFromAuthority',
      isMut: false,
      isSigner: true
    }, {
      name: 'transferSolTo',
      isMut: true,
      isSigner: false
    }, {
      name: 'systemProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'tokenProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'userWsolTokenAccount',
      isMut: true,
      isSigner: false
    }],
    args: []
  }, {
    name: 'aldrinSwap',
    accounts: [{
      name: 'swapProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'pool',
      isMut: false,
      isSigner: false
    }, {
      name: 'poolSigner',
      isMut: false,
      isSigner: false
    }, {
      name: 'poolMint',
      isMut: true,
      isSigner: false
    }, {
      name: 'baseTokenVault',
      isMut: true,
      isSigner: false
    }, {
      name: 'quoteTokenVault',
      isMut: true,
      isSigner: false
    }, {
      name: 'feePoolTokenAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'walletAuthority',
      isMut: false,
      isSigner: true
    }, {
      name: 'userBaseTokenAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'userQuoteTokenAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'tokenProgram',
      isMut: false,
      isSigner: false
    }],
    args: []
  }, {
    name: 'aldrinV2Swap',
    accounts: [{
      name: 'swapProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'pool',
      isMut: false,
      isSigner: false
    }, {
      name: 'poolSigner',
      isMut: false,
      isSigner: false
    }, {
      name: 'poolMint',
      isMut: true,
      isSigner: false
    }, {
      name: 'baseTokenVault',
      isMut: true,
      isSigner: false
    }, {
      name: 'quoteTokenVault',
      isMut: true,
      isSigner: false
    }, {
      name: 'feePoolTokenAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'walletAuthority',
      isMut: false,
      isSigner: true
    }, {
      name: 'userBaseTokenAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'userQuoteTokenAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'curve',
      isMut: false,
      isSigner: false
    }, {
      name: 'tokenProgram',
      isMut: false,
      isSigner: false
    }],
    args: []
  }, {
    name: 'whirlpoolSwap',
    accounts: [{
      name: 'swapProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'tokenProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'tokenAuthority',
      isMut: false,
      isSigner: true
    }, {
      name: 'whirlpool',
      isMut: true,
      isSigner: false
    }, {
      name: 'tokenOwnerAccountA',
      isMut: true,
      isSigner: false
    }, {
      name: 'tokenVaultA',
      isMut: true,
      isSigner: false
    }, {
      name: 'tokenOwnerAccountB',
      isMut: true,
      isSigner: false
    }, {
      name: 'tokenVaultB',
      isMut: true,
      isSigner: false
    }, {
      name: 'tickArray0',
      isMut: true,
      isSigner: false
    }, {
      name: 'tickArray1',
      isMut: true,
      isSigner: false
    }, {
      name: 'tickArray2',
      isMut: true,
      isSigner: false
    }, {
      name: 'oracle',
      isMut: false,
      isSigner: false
    }],
    args: []
  }, {
    name: 'invariantSwap',
    accounts: [{
      name: 'swapProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'state',
      isMut: false,
      isSigner: false
    }, {
      name: 'pool',
      isMut: true,
      isSigner: false
    }, {
      name: 'tickmap',
      isMut: true,
      isSigner: false
    }, {
      name: 'accountX',
      isMut: true,
      isSigner: false
    }, {
      name: 'accountY',
      isMut: true,
      isSigner: false
    }, {
      name: 'reserveX',
      isMut: true,
      isSigner: false
    }, {
      name: 'reserveY',
      isMut: true,
      isSigner: false
    }, {
      name: 'owner',
      isMut: false,
      isSigner: true
    }, {
      name: 'programAuthority',
      isMut: false,
      isSigner: false
    }, {
      name: 'tokenProgram',
      isMut: false,
      isSigner: false
    }],
    args: []
  }, {
    name: 'meteoraSwap',
    accounts: [{
      name: 'swapProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'pool',
      isMut: true,
      isSigner: false
    }, {
      name: 'userSourceToken',
      isMut: true,
      isSigner: false
    }, {
      name: 'userDestinationToken',
      isMut: true,
      isSigner: false
    }, {
      name: 'aVault',
      isMut: true,
      isSigner: false
    }, {
      name: 'bVault',
      isMut: true,
      isSigner: false
    }, {
      name: 'aTokenVault',
      isMut: true,
      isSigner: false
    }, {
      name: 'bTokenVault',
      isMut: true,
      isSigner: false
    }, {
      name: 'aVaultLpMint',
      isMut: true,
      isSigner: false
    }, {
      name: 'bVaultLpMint',
      isMut: true,
      isSigner: false
    }, {
      name: 'aVaultLp',
      isMut: true,
      isSigner: false
    }, {
      name: 'bVaultLp',
      isMut: true,
      isSigner: false
    }, {
      name: 'adminTokenFee',
      isMut: true,
      isSigner: false
    }, {
      name: 'user',
      isMut: false,
      isSigner: true
    }, {
      name: 'vaultProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'tokenProgram',
      isMut: false,
      isSigner: false
    }],
    args: []
  }, {
    name: 'goosefxSwap',
    accounts: [{
      name: 'swapProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'controller',
      isMut: false,
      isSigner: false
    }, {
      name: 'pair',
      isMut: true,
      isSigner: false
    }, {
      name: 'sslIn',
      isMut: true,
      isSigner: false
    }, {
      name: 'sslOut',
      isMut: true,
      isSigner: false
    }, {
      name: 'liabilityVaultIn',
      isMut: true,
      isSigner: false
    }, {
      name: 'swappedLiabilityVaultIn',
      isMut: true,
      isSigner: false
    }, {
      name: 'liabilityVaultOut',
      isMut: true,
      isSigner: false
    }, {
      name: 'swappedLiabilityVaultOut',
      isMut: true,
      isSigner: false
    }, {
      name: 'userInAta',
      isMut: true,
      isSigner: false
    }, {
      name: 'userOutAta',
      isMut: true,
      isSigner: false
    }, {
      name: 'feeCollectorAta',
      isMut: true,
      isSigner: false
    }, {
      name: 'userWallet',
      isMut: false,
      isSigner: true
    }, {
      name: 'feeCollector',
      isMut: false,
      isSigner: false
    }, {
      name: 'tokenProgram',
      isMut: false,
      isSigner: false
    }],
    args: []
  }, {
    name: 'deltafiSwap',
    accounts: [{
      name: 'swapProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'marketConfig',
      isMut: false,
      isSigner: false
    }, {
      name: 'swapInfo',
      isMut: true,
      isSigner: false
    }, {
      name: 'userSourceToken',
      isMut: true,
      isSigner: false
    }, {
      name: 'userDestinationToken',
      isMut: true,
      isSigner: false
    }, {
      name: 'swapSourceToken',
      isMut: true,
      isSigner: false
    }, {
      name: 'swapDestinationToken',
      isMut: true,
      isSigner: false
    }, {
      name: 'deltafiUser',
      isMut: true,
      isSigner: false
    }, {
      name: 'adminDestinationToken',
      isMut: true,
      isSigner: false
    }, {
      name: 'pythPriceBase',
      isMut: false,
      isSigner: false
    }, {
      name: 'pythPriceQuote',
      isMut: false,
      isSigner: false
    }, {
      name: 'userAuthority',
      isMut: false,
      isSigner: true
    }, {
      name: 'tokenProgram',
      isMut: false,
      isSigner: false
    }],
    args: []
  }, {
    name: 'balansolSwap',
    accounts: [{
      name: 'swapProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'authority',
      isMut: true,
      isSigner: true
    }, {
      name: 'pool',
      isMut: true,
      isSigner: false
    }, {
      name: 'taxMan',
      isMut: true,
      isSigner: false
    }, {
      name: 'bidMint',
      isMut: false,
      isSigner: false
    }, {
      name: 'treasurer',
      isMut: false,
      isSigner: false
    }, {
      name: 'srcTreasury',
      isMut: true,
      isSigner: false
    }, {
      name: 'srcAssociatedTokenAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'askMint',
      isMut: false,
      isSigner: false
    }, {
      name: 'dstTreasury',
      isMut: true,
      isSigner: false
    }, {
      name: 'dstAssociatedTokenAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'dstTokenAccountTaxman',
      isMut: true,
      isSigner: false
    }, {
      name: 'systemProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'tokenProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'associatedTokenProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'rent',
      isMut: false,
      isSigner: false
    }],
    args: []
  }, {
    name: 'marcoPoloSwap',
    accounts: [{
      name: 'swapProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'state',
      isMut: false,
      isSigner: false
    }, {
      name: 'pool',
      isMut: true,
      isSigner: false
    }, {
      name: 'tokenX',
      isMut: false,
      isSigner: false
    }, {
      name: 'tokenY',
      isMut: false,
      isSigner: false
    }, {
      name: 'poolXAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'poolYAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'swapperXAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'swapperYAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'swapper',
      isMut: true,
      isSigner: true
    }, {
      name: 'referrerXAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'referrerYAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'referrer',
      isMut: true,
      isSigner: false
    }, {
      name: 'programAuthority',
      isMut: false,
      isSigner: false
    }, {
      name: 'systemProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'tokenProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'associatedTokenProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'rent',
      isMut: false,
      isSigner: false
    }],
    args: []
  }, {
    name: 'dradexSwap',
    accounts: [{
      name: 'swapProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'pair',
      isMut: true,
      isSigner: false
    }, {
      name: 'market',
      isMut: true,
      isSigner: false
    }, {
      name: 'eventQueue',
      isMut: true,
      isSigner: false
    }, {
      name: 'dexUser',
      isMut: false,
      isSigner: false
    }, {
      name: 'marketUser',
      isMut: true,
      isSigner: false
    }, {
      name: 'bids',
      isMut: true,
      isSigner: false
    }, {
      name: 'asks',
      isMut: true,
      isSigner: false
    }, {
      name: 't0Vault',
      isMut: true,
      isSigner: false
    }, {
      name: 't1Vault',
      isMut: true,
      isSigner: false
    }, {
      name: 't0User',
      isMut: true,
      isSigner: false
    }, {
      name: 't1User',
      isMut: true,
      isSigner: false
    }, {
      name: 'master',
      isMut: false,
      isSigner: false
    }, {
      name: 'signer',
      isMut: true,
      isSigner: true
    }, {
      name: 'systemProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'tokenProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'logger',
      isMut: false,
      isSigner: false
    }],
    args: []
  }, {
    name: 'lifinityV2Swap',
    accounts: [{
      name: 'swapProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'authority',
      isMut: false,
      isSigner: false
    }, {
      name: 'amm',
      isMut: true,
      isSigner: false
    }, {
      name: 'userTransferAuthority',
      isMut: false,
      isSigner: true
    }, {
      name: 'sourceInfo',
      isMut: true,
      isSigner: false
    }, {
      name: 'destinationInfo',
      isMut: true,
      isSigner: false
    }, {
      name: 'swapSource',
      isMut: true,
      isSigner: false
    }, {
      name: 'swapDestination',
      isMut: true,
      isSigner: false
    }, {
      name: 'poolMint',
      isMut: true,
      isSigner: false
    }, {
      name: 'feeAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'tokenProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'oracleMainAccount',
      isMut: false,
      isSigner: false
    }, {
      name: 'oracleSubAccount',
      isMut: false,
      isSigner: false
    }, {
      name: 'oraclePcAccount',
      isMut: false,
      isSigner: false
    }],
    args: []
  }, {
    name: 'raydiumClmmSwap',
    accounts: [{
      name: 'swapProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'payer',
      isMut: false,
      isSigner: true
    }, {
      name: 'ammConfig',
      isMut: false,
      isSigner: false
    }, {
      name: 'poolState',
      isMut: true,
      isSigner: false
    }, {
      name: 'inputTokenAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'outputTokenAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'inputVault',
      isMut: true,
      isSigner: false
    }, {
      name: 'outputVault',
      isMut: true,
      isSigner: false
    }, {
      name: 'observationState',
      isMut: true,
      isSigner: false
    }, {
      name: 'tokenProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'tickArray',
      isMut: true,
      isSigner: false
    }],
    args: []
  }, {
    name: 'phoenixSwap',
    accounts: [{
      name: 'swapProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'logAuthority',
      isMut: false,
      isSigner: false
    }, {
      name: 'market',
      isMut: true,
      isSigner: false
    }, {
      name: 'trader',
      isMut: false,
      isSigner: true
    }, {
      name: 'baseAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'quoteAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'baseVault',
      isMut: true,
      isSigner: false
    }, {
      name: 'quoteVault',
      isMut: true,
      isSigner: false
    }, {
      name: 'tokenProgram',
      isMut: false,
      isSigner: false
    }],
    args: []
  }, {
    name: 'symmetrySwap',
    accounts: [{
      name: 'swapProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'buyer',
      isMut: false,
      isSigner: true
    }, {
      name: 'fundState',
      isMut: true,
      isSigner: false
    }, {
      name: 'pdaAccount',
      isMut: false,
      isSigner: false
    }, {
      name: 'pdaFromTokenAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'buyerFromTokenAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'pdaToTokenAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'buyerToTokenAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'swapFeeAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'hostFeeAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'managerFeeAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'tokenInfo',
      isMut: false,
      isSigner: false
    }, {
      name: 'prismData',
      isMut: false,
      isSigner: false
    }, {
      name: 'tokenProgram',
      isMut: false,
      isSigner: false
    }],
    args: []
  }],
  types: [{
    name: 'AmountWithSlippage',
    type: {
      kind: 'struct',
      fields: [{
        name: 'amount',
        type: 'u64'
      }, {
        name: 'slippageBps',
        type: 'u16'
      }]
    }
  }, {
    name: 'SplitLegDeeper',
    type: {
      kind: 'struct',
      fields: [{
        name: 'percent',
        type: 'u8'
      }, {
        name: 'swapLeg',
        type: {
          defined: 'SwapLegSwap'
        }
      }]
    }
  }, {
    name: 'SplitLeg',
    type: {
      kind: 'struct',
      fields: [{
        name: 'percent',
        type: 'u8'
      }, {
        name: 'swapLeg',
        type: {
          defined: 'SwapLegDeeper'
        }
      }]
    }
  }, {
    name: 'SwapInstrution',
    type: {
      kind: 'enum',
      variants: [{
        name: 'Swap',
        fields: [{
          defined: 'Swap'
        }]
      }]
    }
  }, {
    name: 'Side',
    type: {
      kind: 'enum',
      variants: [{
        name: 'Bid'
      }, {
        name: 'Ask'
      }]
    }
  }, {
    name: 'SwapLegSwap',
    type: {
      kind: 'enum',
      variants: [{
        name: 'PlaceholderOne'
      }, {
        name: 'PlaceholderTwo'
      }, {
        name: 'Swap',
        fields: [{
          name: 'swap',
          type: {
            defined: 'Swap'
          }
        }]
      }]
    }
  }, {
    name: 'SwapLegDeeper',
    type: {
      kind: 'enum',
      variants: [{
        name: 'Chain',
        fields: [{
          name: 'swap_legs',
          type: {
            vec: {
              defined: 'SwapLegSwap'
            }
          }
        }]
      }, {
        name: 'Split',
        fields: [{
          name: 'split_legs',
          type: {
            vec: {
              defined: 'SplitLegDeeper'
            }
          }
        }]
      }, {
        name: 'Swap',
        fields: [{
          name: 'swap',
          type: {
            defined: 'Swap'
          }
        }]
      }]
    }
  }, {
    name: 'SwapLeg',
    type: {
      kind: 'enum',
      variants: [{
        name: 'Chain',
        fields: [{
          name: 'swap_legs',
          type: {
            vec: {
              defined: 'SwapLegDeeper'
            }
          }
        }]
      }, {
        name: 'Split',
        fields: [{
          name: 'split_legs',
          type: {
            vec: {
              defined: 'SplitLeg'
            }
          }
        }]
      }, {
        name: 'Swap',
        fields: [{
          name: 'swap',
          type: {
            defined: 'Swap'
          }
        }]
      }]
    }
  }, {
    name: 'Swap',
    type: {
      kind: 'enum',
      variants: [{
        name: 'Saber'
      }, {
        name: 'SaberAddDecimalsDeposit'
      }, {
        name: 'SaberAddDecimalsWithdraw'
      }, {
        name: 'TokenSwap'
      }, {
        name: 'Sencha'
      }, {
        name: 'Step'
      }, {
        name: 'Cropper'
      }, {
        name: 'Raydium'
      }, {
        name: 'Crema',
        fields: [{
          name: 'a_to_b',
          type: 'bool'
        }]
      }, {
        name: 'Lifinity'
      }, {
        name: 'Mercurial'
      }, {
        name: 'Cykura'
      }, {
        name: 'Serum',
        fields: [{
          name: 'side',
          type: {
            defined: 'Side'
          }
        }]
      }, {
        name: 'MarinadeDeposit'
      }, {
        name: 'MarinadeUnstake'
      }, {
        name: 'Aldrin',
        fields: [{
          name: 'side',
          type: {
            defined: 'Side'
          }
        }]
      }, {
        name: 'AldrinV2',
        fields: [{
          name: 'side',
          type: {
            defined: 'Side'
          }
        }]
      }, {
        name: 'Whirlpool',
        fields: [{
          name: 'a_to_b',
          type: 'bool'
        }]
      }, {
        name: 'Invariant',
        fields: [{
          name: 'x_to_y',
          type: 'bool'
        }]
      }, {
        name: 'Meteora'
      }, {
        name: 'GooseFX'
      }, {
        name: 'DeltaFi',
        fields: [{
          name: 'stable',
          type: 'bool'
        }]
      }, {
        name: 'Balansol'
      }, {
        name: 'MarcoPolo',
        fields: [{
          name: 'x_to_y',
          type: 'bool'
        }]
      }, {
        name: 'Dradex',
        fields: [{
          name: 'side',
          type: {
            defined: 'Side'
          }
        }]
      }, {
        name: 'LifinityV2'
      }, {
        name: 'RaydiumClmm'
      }, {
        name: 'Openbook',
        fields: [{
          name: 'side',
          type: {
            defined: 'Side'
          }
        }]
      }, {
        name: 'Phoenix',
        fields: [{
          name: 'side',
          type: {
            defined: 'Side'
          }
        }]
      }, {
        name: 'Symmetry',
        fields: [{
          name: 'fromTokenId',
          type: 'u64'
        }, {
          name: 'toTokenId',
          type: 'u64'
        }]
      }]
    }
  }, {
    name: 'SwapAction',
    type: {
      kind: 'enum',
      variants: [{
        name: 'SetupSplit',
        fields: [{
          name: 'percents',
          type: 'bytes'
        }]
      }, {
        name: 'NextSplitLeg'
      }, {
        name: 'MergeSplit'
      }, {
        name: 'Swap',
        fields: [{
          name: 'swap',
          type: {
            defined: 'Swap'
          }
        }]
      }]
    }
  }],
  events: [{
    name: 'Swap',
    fields: [{
      name: 'amm',
      type: 'publicKey',
      index: false
    }, {
      name: 'inputMint',
      type: 'publicKey',
      index: false
    }, {
      name: 'inputAmount',
      type: 'u64',
      index: false
    }, {
      name: 'outputMint',
      type: 'publicKey',
      index: false
    }, {
      name: 'outputAmount',
      type: 'u64',
      index: false
    }]
  }, {
    name: 'Fee',
    fields: [{
      name: 'account',
      type: 'publicKey',
      index: false
    }, {
      name: 'mint',
      type: 'publicKey',
      index: false
    }, {
      name: 'amount',
      type: 'u64',
      index: false
    }]
  }],
  errors: [{
    code: 6000,
    name: 'EmptyRoute',
    msg: 'Empty route'
  }, {
    code: 6001,
    name: 'SlippageToleranceExceeded',
    msg: 'Slippage tolerance exceeded'
  }, {
    code: 6002,
    name: 'InvalidCalculation',
    msg: 'Invalid calculation'
  }, {
    code: 6003,
    name: 'MissingPlatformFeeAccount',
    msg: 'Missing platform fee account'
  }, {
    code: 6004,
    name: 'InvalidSlippage',
    msg: 'Invalid slippage'
  }, {
    code: 6005,
    name: 'NotEnoughPercent',
    msg: 'Not enough percent to 100'
  }, {
    code: 6006,
    name: 'InAmountsStackIsEmpty',
    msg: 'In amounts stack is empty'
  }, {
    code: 6007,
    name: 'OutAmountsStackIsEmpty',
    msg: 'Out amounts stack is empty'
  }, {
    code: 6008,
    name: 'NotEnoughAccountKeys',
    msg: 'Not Enough Account keys'
  }]
};

function _regeneratorRuntime() {
  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */

  _regeneratorRuntime = function () {
    return exports;
  };

  var exports = {},
      Op = Object.prototype,
      hasOwn = Op.hasOwnProperty,
      $Symbol = "function" == typeof Symbol ? Symbol : {},
      iteratorSymbol = $Symbol.iterator || "@@iterator",
      asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
      toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value: value,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), obj[key];
  }

  try {
    define({}, "");
  } catch (err) {
    define = function (obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
        generator = Object.create(protoGenerator.prototype),
        context = new Context(tryLocsList || []);
    return generator._invoke = function (innerFn, self, context) {
      var state = "suspendedStart";
      return function (method, arg) {
        if ("executing" === state) throw new Error("Generator is already running");

        if ("completed" === state) {
          if ("throw" === method) throw arg;
          return doneResult();
        }

        for (context.method = method, context.arg = arg;;) {
          var delegate = context.delegate;

          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);

            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }

          if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
            if ("suspendedStart" === state) throw state = "completed", context.arg;
            context.dispatchException(context.arg);
          } else "return" === context.method && context.abrupt("return", context.arg);
          state = "executing";
          var record = tryCatch(innerFn, self, context);

          if ("normal" === record.type) {
            if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
            return {
              value: record.arg,
              done: context.done
            };
          }

          "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
        }
      };
    }(innerFn, self, context), generator;
  }

  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }

  exports.wrap = wrap;
  var ContinueSentinel = {};

  function Generator() {}

  function GeneratorFunction() {}

  function GeneratorFunctionPrototype() {}

  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });
  var getProto = Object.getPrototypeOf,
      NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);

  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      define(prototype, method, function (arg) {
        return this._invoke(method, arg);
      });
    });
  }

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);

      if ("throw" !== record.type) {
        var result = record.arg,
            value = result.value;
        return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
          invoke("next", value, resolve, reject);
        }, function (err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value).then(function (unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function (error) {
          return invoke("throw", error, resolve, reject);
        });
      }

      reject(record.arg);
    }

    var previousPromise;

    this._invoke = function (method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function (resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    };
  }

  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];

    if (undefined === method) {
      if (context.delegate = null, "throw" === context.method) {
        if (delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel;
        context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }

  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }

  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
  }

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next) return iterable;

      if (!isNaN(iterable.length)) {
        var i = -1,
            next = function next() {
          for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;

          return next.value = undefined, next.done = !0, next;
        };

        return next.next = next;
      }
    }

    return {
      next: doneResult
    };
  }

  function doneResult() {
    return {
      value: undefined,
      done: !0
    };
  }

  return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function (genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function (arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
    return this;
  }), define(Gp, "toString", function () {
    return "[object Generator]";
  }), exports.keys = function (object) {
    var keys = [];

    for (var key in object) keys.push(key);

    return keys.reverse(), function next() {
      for (; keys.length;) {
        var key = keys.pop();
        if (key in object) return next.value = key, next.done = !1, next;
      }

      return next.done = !0, next;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function (skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
    },
    stop: function () {
      this.done = !0;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type) throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function (exception) {
      if (this.done) throw exception;
      var context = this;

      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i],
            record = entry.completion;
        if ("root" === entry.tryLoc) return handle("end");

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"),
              hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
          } else {
            if (!hasFinally) throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function (type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function (record, afterLoc) {
      if ("throw" === record.type) throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function (finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    catch: function (tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;

          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }

          return thrown;
        }
      }

      throw new Error("illegal catch attempt");
    },
    delegateYield: function (iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
    }
  }, exports;
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends.apply(this, arguments);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);

  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }

  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var JUPITER_PROGRAM_ID_DEVNET = /*#__PURE__*/new PublicKey('BHzPYvC5J38kUeqkcUXwfraLWJ68cmGWm43ksF3i8bmk');
var JUPITER_PROGRAM_ID_STAGING = /*#__PURE__*/new PublicKey('JUPSjgjMFjU4453KMgxhqVmzep6W352bQpE4RsNqXAx');
var JUPITER_PROGRAM_ID_PRODUCTION = /*#__PURE__*/new PublicKey('JUP4Fb2cqiRUcaTHdrPC8h2gNsA2ETXiPDD33WcGuJB');
var JUPITER_PROGRAM_ID = JUPITER_PROGRAM_ID_PRODUCTION;
var JUPITER_PROGRAM = /*#__PURE__*/new Program(IDL, JUPITER_PROGRAM_ID, {});
var MAINNET_SERUM_DEX_PROGRAM = /*#__PURE__*/new PublicKey('9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin');
var DEVNET_SERUM_DEX_PROGRAM = /*#__PURE__*/new PublicKey('DESVgJVGajEgKGXhb6XmqDHGz3VjdgP7rEVESBgxmroY');
var RAYDIUM_AMM_V4_PROGRAM_ID = /*#__PURE__*/new PublicKey('675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8');
var ALDRIN_SWAP_PROGRAM_ID = /*#__PURE__*/new PublicKey('AMM55ShdkoGRB5jVYPjWziwk8m5MpwyDgsMWHaMSQWH6'); // https://github.com/aldrin-exchange/aldrin-sdk/blob/f93fe3f2d847d79d8ddff507d8d4f62fd803421b/src/v2.json

var ALDRIN_SWAP_V2_PROGRAM_ID = /*#__PURE__*/new PublicKey('CURVGoZn8zycx6FXwwevgBTB2gVvdbGTEpvMJDbgs2t4');
var SABER_ADD_DECIMALS_PROGRAM_ID = /*#__PURE__*/new PublicKey('DecZY86MU5Gj7kppfUCEmd4LbXXuyZH1yHaP2NTqdiZB');
var CROPPER_PROGRAM_ID = /*#__PURE__*/new PublicKey('CTMAxxk34HjKWxQ3QLZK1HpaLXmBveao3ESePXbiyfzh');
var SENCHA_PROGRAM_ID = /*#__PURE__*/new PublicKey('SCHAtsf8mbjyjiv4LkhLKutTf6JnZAbdJKFkXQNMFHZ');
var LIFINITY_PROGRAM_ID = /*#__PURE__*/new PublicKey('EewxydAPCCVuNEyrVN68PuSYdQ7wKn27V9Gjeoi8dy3S');
var CREMA_PROGRAM_ID = /*#__PURE__*/new PublicKey('CLMM9tUoggJu2wagPkkqs9eFG4BWhVBZWkP1qv3Sp7tR'); // Crema requires a separate partner account controlled by them

var CREMA_PARTNER_ACCOUNT = /*#__PURE__*/new PublicKey('FxYoB1VAx8TfLCwvmworJy16VH89v992qznUvBX5aR8K');
var MERCURIAL_SWAP_PROGRAM_ID = /*#__PURE__*/new PublicKey('MERLuDFBMmsHnsBPZw2sDQZHvXFMwp8EdjudcU2HKky');
var WHIRLPOOL_PROGRAM_ID = /*#__PURE__*/new PublicKey('whirLbMiicVdio4qvUfM5KAg6Ct8VwpYzGff3uctyCc');
var INVARIANT_PROGRAM_ID = /*#__PURE__*/new PublicKey('HyaB3W9q6XdA5xwpU4XnSZV94htfmbmqJXZcEbRaJutt');
var INVARIANT_STATE_ID = /*#__PURE__*/new PublicKey('8NsPwRFYqob3FzYvHYTjFK6WVFJADFN8Hn7yNQKcVNW1');
var INVARIANT_PROGRAM_AUTHORITY_ID = /*#__PURE__*/new PublicKey('J4uBbeoWpZE8fH58PM1Fp9n9K6f1aThyeVCyRdJbaXqt');
var CYKURA_PROGRAM_ID = /*#__PURE__*/new PublicKey('cysPXAjehMpVKUapzbMCCnpFxUFFryEWEaLgnb9NrR8');
var CYKURA_FACTORY_STATE_ADDRESS = /*#__PURE__*/new PublicKey('DBsMwKfeoUHhxMi9x6wd2AsT12UwUCssjNbUzu1aKgqj');
var MARINADE_PROGRAM_ID = /*#__PURE__*/new PublicKey('MarBmsSgKXdrN1egZf5sqe1TMai9K1rChYNDJgjq7aD');
var STEPN_PROGRAM_ID = /*#__PURE__*/new PublicKey('Dooar9JkhdZ7J3LHN3A7YCuoGRUggXhQaG4kijfLGU2j');
var ORCA_V1_PROGRAM_ID = /*#__PURE__*/new PublicKey('DjVE6JNiYqPL2QXyCUUh8rNjHrbz9hXHNYt99MQ59qw1');
var ORCA_V2_PROGRAM_ID = /*#__PURE__*/new PublicKey('9W959DqEETiGZocYWCQPaJ6sBmUzgfxXfqGeTEdp3aQP');
var STEP_TOKEN_SWAP_PROGRAM_ID = /*#__PURE__*/new PublicKey('SSwpMgqNDsyV7mAgN9ady4bDVu5ySjmmXejXvy2vLt1');
var PENGUIN_PROGRAM_ID = /*#__PURE__*/new PublicKey('PSwapMdSai8tjrEXcxFeQth87xC4rRsa4VA5mhGhXkP');
var SAROS_PROGRAM_ID = /*#__PURE__*/new PublicKey('SSwapUtytfBdBn1b9NUGG6foMVPtcWgpRU32HToDUZr');
var METEORA_PROGRAM_ID = /*#__PURE__*/new PublicKey('Eo7WjKq67rjJQSZxS6z3YkapzY3eMj6Xy8X5EQVn5UaB');
var METEORA_VAULT_PROGRAM_ID = /*#__PURE__*/new PublicKey('24Uqj9JCLxUeoC3hGfh5W3s9FM9uCHDS2SG3LYwBpyTi');
var DELTA_FI_PROGRAM_ID = /*#__PURE__*/new PublicKey('GNExJhNUhc9LN2DauuQAUJnXoy6DJ6zey3t9kT9A2PF3');
var DELTA_FI_USER_ID = /*#__PURE__*/new PublicKey('ziSPuDShwunW4xNrCfTnSHTPVT6FZDREtdofpf1BJwe');
var GOOSE_FX_PROGRAM_ID = /*#__PURE__*/new PublicKey('7WduLbRfYhTJktjLw5FDEyrqoEv61aTTCuGAetgLjzN5');
var GOOSE_FX_CONTROLLER_ID = /*#__PURE__*/new PublicKey('8CxKnuJeoeQXFwiG6XiGY2akBjvJA5k3bE52BfnuEmNQ');
var BALANSOL_PROGRAM_ID = /*#__PURE__*/new PublicKey('D3BBjqUdCYuP18fNvvMbPAZ8DpcRi4io2EsYHQawJDag');
var DRADEX_PROGRAM_ID = /*#__PURE__*/new PublicKey('dp2waEWSBy5yKmq65ergoU3G6qRLmqa6K7We4rZSKph');
var DRADEX_LOGGER_PROGRAM_ID = /*#__PURE__*/new PublicKey('1gE3LGQze8DQ3KD2C4ZUCmRX5g4njhY5yLfYmnmcvJR');
var DRADEX_MASTER_ID = /*#__PURE__*/new PublicKey('76ygWLcvJLR6nSzRUpiQqqtX4Pabkq4vpaTxwr3mDcXA');
var LIFINITY_V2_PROGRAM_ID = /*#__PURE__*/new PublicKey('2wT8Yq49kHgDzXuPxZSaeLaH1qbmGXtEyPy64bL7aD3c'); // This is DexUser for Dradex with `BUX7s2ef2htTGb2KKoPHWkmzxPj4nTWMWRgs5CSbQxf9` as owner.

var DRADEX_DEX_USER = /*#__PURE__*/new PublicKey('571oqNkJauZ2tccLwf8CUB56hpLPZkop9X1Px4DE9rnQ');
var RAYDIUM_CLMM_PROGRAM_ID = /*#__PURE__*/new PublicKey('CAMMCzo5YL8w4VFF8KVHrK22GGUsp5VTaW7grrKgrWqK');
var OPENBOOK_PROGRAM_ID = /*#__PURE__*/new PublicKey('srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX');
var MARCO_POLO_PROGRAM_ID = /*#__PURE__*/new PublicKey('9tKE7Mbmj4mxDjWatikzGAtkoWosiiZX9y6J4Hfm2R8H');
var MARCO_POLO_STATE_ID = /*#__PURE__*/new PublicKey('BE5YRQ6N6LCw7UL3JwzVp317EWa4mzJY6JKDaudcXu7A');
var MARCO_POLO_PROGRAM_AUTHORITY = /*#__PURE__*/new PublicKey('JM78XNzeQRmZXDAP4DSq88ZdErbuSXSLE6fkRsVDKSu');
var BONK_SWAP_PROGRAM_ID = /*#__PURE__*/new PublicKey('BSwp6bEBihVLdqJRKGgzjcGLHkcTuzmSo1TQkHepzH8p');
var BONK_SWAP_STATE_ID = /*#__PURE__*/new PublicKey('2QWN6WjrJ3RAk51ecxLxaLPfFCYLAnmWJwJ1oKA92CRD');
var BONK_SWAP_PROGRAM_AUTHORITY = /*#__PURE__*/new PublicKey('8NyaPDJeC2eaBGpkRpZKnD9S448AZGgjSvumFe92DRK2');
var PHOENIX_PROGRAM_ID = /*#__PURE__*/new PublicKey('PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY');
var SYMMETRY_PROGRAM_ID = /*#__PURE__*/new PublicKey('2KehYt3KsEQR53jYcxjbQp2d2kCp4AkuQW68atufRwSr');
var WRAPPED_SOL_MINT = /*#__PURE__*/new PublicKey('So11111111111111111111111111111111111111112');
var MARKETS_URL = {
  devnet: 'https://jupiter-devnet.zhen8558.workers.dev/markets?v=3',
  'mainnet-beta': 'https://cache.jup.ag/markets?v=3',
  testnet: 'https://api.jup.ag/api/markets/cache/devnet'
};
var INDEXED_ROUTE_MAP_URL = 'https://cache.jup.ag/indexed-route-maps-v2';
var TOKEN_LIST_URL = {
  devnet: 'https://api.jup.ag/api/tokens/devnet',
  testnet: 'https://api.jup.ag/api/markets/devnet',
  'mainnet-beta': 'https://cache.jup.ag/tokens'
};
var LAMPORTS_PER_SIGNATURE$1 = 5000; // The default wallet collecting referrer fees

var JUPITER_FEE_OWNER = /*#__PURE__*/new PublicKey('BUX7s2ef2htTGb2KKoPHWkmzxPj4nTWMWRgs5CSbQxf9');
var JUPITER_ERRORS = /*#__PURE__*/Object.freeze( /*#__PURE__*/_extends({
  AlreadyInUse: {
    code: 1,
    name: 'AlreadyInUsed',
    msg: 'Account already In Used'
  },
  InsufficientSOL: {
    code: 1,
    name: 'InsufficientSOL',
    msg: 'Insufficient SOL'
  },
  TransactionNotConfirmed: {
    code: 7000,
    name: 'TransactionNotConfirmed',
    msg: 'Transaction was not confirmed'
  },
  BalancesNotExtractedProperly: {
    code: 7001,
    name: 'BalancesNotExtractedProperly',
    msg: 'Balances cannot be extracted properly'
  }
}, /*#__PURE__*/IDL.errors.reduce(function (accErrors, error) {
  var _extends2;

  return _extends({}, accErrors, (_extends2 = {}, _extends2[error.name] = error, _extends2));
}, {})));

var codeToErrorRecord = /*#__PURE__*/Object.values(JUPITER_ERRORS).reduce(function (record, error) {
  record[error.code] = error;
  return record;
}, {}); // Throws when not found or contains error to satisfy upper control flow

function validateTransactionResponse(_ref) {
  var _transactionResponse$;

  var txid = _ref.txid,
      transactionResponse = _ref.transactionResponse;

  if (!transactionResponse) {
    var errorDetails = JUPITER_ERRORS['TransactionNotConfirmed'];
    return new TransactionError(errorDetails.msg, txid, errorDetails.code, [JUPITER_PROGRAM_ID.toBase58()]);
  }

  if (transactionResponse != null && (_transactionResponse$ = transactionResponse.meta) != null && _transactionResponse$.err) {
    var _parseErrorForTransac = parseErrorForTransaction(transactionResponse),
        message = _parseErrorForTransac.message,
        programIds = _parseErrorForTransac.programIds,
        code = _parseErrorForTransac.code; // only map message if first program is jupiter


    if ((programIds == null ? void 0 : programIds[0]) === JUPITER_PROGRAM_ID.toBase58() && code) {
      var _codeToErrorRecord$co;

      message = (_codeToErrorRecord$co = codeToErrorRecord[code]) == null ? void 0 : _codeToErrorRecord$co.msg;
    }

    if (!message) {
      message = UNKNOWN_ERROR;
    }

    return new TransactionError(message || 'Something went wrong', txid, code, programIds);
  }

  return transactionResponse;
}

var wait = function wait(time) {
  return new Promise(function (resolve) {
    return setTimeout(resolve, time);
  });
};

/** Should this be a method in web3.js? */

function getKeyMap(message, accountKeysFromLookups) {
  return message.getAccountKeys({
    accountKeysFromLookups: accountKeysFromLookups
  }).keySegments().flat().reduce(function (acc, key, index) {
    acc.set(key.toBase58(), index);
    return acc;
  }, new Map());
}

function diffTokenBalance(accountKeyIndex, meta) {
  var _meta$postTokenBalanc, _meta$postTokenBalanc2, _meta$preTokenBalance, _meta$preTokenBalance2;

  var postBalance = (_meta$postTokenBalanc = meta.postTokenBalances) == null ? void 0 : (_meta$postTokenBalanc2 = _meta$postTokenBalanc.find(function (postTokenBalance) {
    return postTokenBalance.accountIndex === accountKeyIndex;
  })) == null ? void 0 : _meta$postTokenBalanc2.uiTokenAmount.amount;
  var preBalance = (_meta$preTokenBalance = meta.preTokenBalances) == null ? void 0 : (_meta$preTokenBalance2 = _meta$preTokenBalance.find(function (preTokenBalance) {
    return preTokenBalance.accountIndex === accountKeyIndex;
  })) == null ? void 0 : _meta$preTokenBalance2.uiTokenAmount.amount; // When token account is created it isn't present in preBalance

  if (!postBalance) return;
  return Math.abs(parseInt(postBalance) - (preBalance !== undefined ? parseInt(preBalance) : 0));
}

function extractTokenBalanceChangeFromTransaction(meta, keyMap, tokenAccountAddress) {
  if (!meta) return;
  var accountKeyIndex = keyMap.get(tokenAccountAddress.toBase58());
  if (accountKeyIndex === undefined) return;
  return diffTokenBalance(accountKeyIndex, meta);
}
/** Assumption: user is the signer so it can never be rolled */

function extractSOLChangeFromTransaction(meta, keyMap, user) {
  var accountKeyIndex = keyMap.get(user.toBase58());

  if (accountKeyIndex !== undefined) {
    return Math.abs(meta.postBalances[accountKeyIndex] - meta.preBalances[accountKeyIndex]);
  }

  return 0;
}
function getTokenBalanceChangesFromTransactionResponse(_x) {
  return _getTokenBalanceChangesFromTransactionResponse.apply(this, arguments);
}

function _getTokenBalanceChangesFromTransactionResponse() {
  _getTokenBalanceChangesFromTransactionResponse = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref) {
    var txid, inputMint, outputMint, user, sourceAddress, destinationAddress, transactionResponse, hasWrappedSOL, sourceTokenBalanceChange, destinationTokenBalanceChange, meta, transaction, keyMap;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            txid = _ref.txid, inputMint = _ref.inputMint, outputMint = _ref.outputMint, user = _ref.user, sourceAddress = _ref.sourceAddress, destinationAddress = _ref.destinationAddress, transactionResponse = _ref.transactionResponse, hasWrappedSOL = _ref.hasWrappedSOL;

            if (transactionResponse) {
              meta = transactionResponse.meta, transaction = transactionResponse.transaction;

              if (meta) {
                keyMap = getKeyMap(transaction.message, meta.loadedAddresses);
                console.log({
                  keyMap: keyMap
                });
                sourceTokenBalanceChange = inputMint.equals(WRAPPED_SOL_MINT) && !hasWrappedSOL ? extractSOLChangeFromTransaction(meta, keyMap, user) : extractTokenBalanceChangeFromTransaction(meta, keyMap, sourceAddress);
                destinationTokenBalanceChange = outputMint.equals(WRAPPED_SOL_MINT) && !hasWrappedSOL ? extractSOLChangeFromTransaction(meta, keyMap, user) : extractTokenBalanceChangeFromTransaction(meta, keyMap, destinationAddress);
              }
            }

            if (sourceTokenBalanceChange && destinationTokenBalanceChange) {
              _context.next = 4;
              break;
            }

            throw new TransactionError('Cannot find source or destination token account balance change', txid, JUPITER_ERRORS['BalancesNotExtractedProperly'].code, [JUPITER_PROGRAM_ID.toBase58()]);

          case 4:
            return _context.abrupt("return", [sourceTokenBalanceChange, destinationTokenBalanceChange]);

          case 5:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _getTokenBalanceChangesFromTransactionResponse.apply(this, arguments);
}

function getUnixTs() {
  return new Date().getTime();
}
var SEND_OPTIONS = {
  skipPreflight: true,
  maxRetries: 2
}; // An empty transaction with a fee payer and blockhash, to check blockhash validity through simulation

function buildCanaryTransaction(_ref2) {
  var feePayer = _ref2.feePayer,
      blockhash = _ref2.blockhash;
  var transactionMessage = new TransactionMessage({
    payerKey: feePayer,
    // Make the canary unique per call just in case
    instructions: [{
      keys: [{
        pubkey: feePayer,
        isSigner: true,
        isWritable: true
      }],
      programId: new PublicKey('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),
      data: Buffer.from(Math.random().toString(), 'utf8')
    }],
    recentBlockhash: blockhash
  });
  var messageV0 = transactionMessage.compileToV0Message([]);
  var tx = new VersionedTransaction(messageV0);
  return tx;
}

function checkIsBlockhashExpired(_x2) {
  return _checkIsBlockhashExpired.apply(this, arguments);
}
/**
 * awaits confirmation while resending the transaction periodically
 *
 * Our RPC node settings
 * solana_send_leader_count: 8
 * solana_send_retry_ms: 15000
 **/


function _checkIsBlockhashExpired() {
  _checkIsBlockhashExpired = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_ref3) {
    var connection, canaryTx, simulationResult, err;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            connection = _ref3.connection, canaryTx = _ref3.canaryTx;
            _context2.next = 3;
            return connection.simulateTransaction(canaryTx, {
              sigVerify: false,
              replaceRecentBlockhash: false,
              commitment: 'processed'
            });

          case 3:
            simulationResult = _context2.sent;
            err = simulationResult.value.err;

            if (!err) {
              _context2.next = 13;
              break;
            }

            if (!(err === 'BlockhashNotFound')) {
              _context2.next = 10;
              break;
            }

            return _context2.abrupt("return", true);

          case 10:
            throw new Error("Unexpected error: " + err);

          case 11:
            _context2.next = 14;
            break;

          case 13:
            return _context2.abrupt("return", false);

          case 14:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _checkIsBlockhashExpired.apply(this, arguments);
}

function transactionSenderAndConfirmationWaiter(_x3) {
  return _transactionSenderAndConfirmationWaiter.apply(this, arguments);
}

function _transactionSenderAndConfirmationWaiter() {
  _transactionSenderAndConfirmationWaiter = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(_ref4) {
    var connection, signedTransaction, _ref4$pollInterval, pollInterval, _ref4$sendInterval, sendInterval, _ref4$sendRetries, sendRetries, rawTransaction, _getTransactionBlockh, feePayer, blockhash, canaryTx, txid, lastSendTimestamp, retries, timestamp, isBlockhashExpired, response;

    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            connection = _ref4.connection, signedTransaction = _ref4.signedTransaction, _ref4$pollInterval = _ref4.pollInterval, pollInterval = _ref4$pollInterval === void 0 ? 500 : _ref4$pollInterval, _ref4$sendInterval = _ref4.sendInterval, sendInterval = _ref4$sendInterval === void 0 ? 2000 : _ref4$sendInterval, _ref4$sendRetries = _ref4.sendRetries, sendRetries = _ref4$sendRetries === void 0 ? 40 : _ref4$sendRetries;
            rawTransaction = signedTransaction.serialize();
            _getTransactionBlockh = getTransactionBlockhashAndFeePayer(signedTransaction), feePayer = _getTransactionBlockh.feePayer, blockhash = _getTransactionBlockh.blockhash;
            canaryTx = buildCanaryTransaction({
              feePayer: feePayer,
              blockhash: blockhash
            });
            _context3.next = 6;
            return connection.sendRawTransaction(rawTransaction, SEND_OPTIONS);

          case 6:
            txid = _context3.sent;
            lastSendTimestamp = getUnixTs();
            retries = 0;

          case 9:

            timestamp = getUnixTs();

            if (!(retries < sendRetries && timestamp - lastSendTimestamp > sendInterval)) {
              _context3.next = 16;
              break;
            }

            lastSendTimestamp = timestamp;
            retries += 1;
            _context3.next = 16;
            return connection.sendRawTransaction(rawTransaction, SEND_OPTIONS);

          case 16:
            _context3.next = 18;
            return checkIsBlockhashExpired({
              connection: connection,
              canaryTx: canaryTx
            });

          case 18:
            isBlockhashExpired = _context3.sent;
            _context3.next = 21;
            return Promise.any([connection.getTransaction(txid, {
              commitment: 'confirmed',
              maxSupportedTransactionVersion: 0
            }), wait(5000)]);

          case 21:
            response = _context3.sent;

            if (!response) {
              _context3.next = 24;
              break;
            }

            return _context3.abrupt("return", {
              txid: txid,
              transactionResponse: response
            });

          case 24:
            if (!isBlockhashExpired) {
              _context3.next = 26;
              break;
            }

            return _context3.abrupt("return", {
              txid: txid,
              transactionResponse: null
            });

          case 26:
            _context3.next = 28;
            return wait(pollInterval);

          case 28:
            _context3.next = 9;
            break;

          case 30:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _transactionSenderAndConfirmationWaiter.apply(this, arguments);
}

function getSignature(transaction) {
  var signature = 'signature' in transaction ? transaction.signature : transaction.signatures[0];

  if (!signature) {
    throw new Error('Transaction has no signature');
  }

  return bs58.encode(signature);
}
function getTransactionBlockhashAndFeePayer(transaction) {
  if ('message' in transaction) {
    return {
      feePayer: transaction.message.staticAccountKeys[0],
      blockhash: transaction.message.recentBlockhash
    };
  } else {
    if (!transaction.feePayer) throw new Error('Missing feePayer');
    if (!transaction.recentBlockhash) throw new Error('Missing blockhash');
    return {
      feePayer: transaction.feePayer,
      blockhash: transaction.recentBlockhash
    };
  }
}
function signTransaction(transaction, signers) {
  if ('message' in transaction) {
    transaction.sign(signers);
  } else {
    transaction.sign.apply(transaction, signers);
  }

  return getSignature(transaction);
}

/** sign, send and await confirmation for an exchange */

var executeTransaction = /*#__PURE__*/function () {
  var _ref2 = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_ref) {
    var connection, wallet, onTransaction, inputMint, outputMint, sourceAddress, destinationAddress, swapTransaction, owner, wrapUnwrapSOL, swapError, swapResult, swapTxid, swapTransactionSender, swapPromise, transactionResponse, _yield$getTokenBalanc, sourceTokenBalanceChange, destinationTokenBalanceChange;

    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            connection = _ref.connection, wallet = _ref.wallet, onTransaction = _ref.onTransaction, inputMint = _ref.inputMint, outputMint = _ref.outputMint, sourceAddress = _ref.sourceAddress, destinationAddress = _ref.destinationAddress, swapTransaction = _ref.swapTransaction, owner = _ref.owner, wrapUnwrapSOL = _ref.wrapUnwrapSOL;
            swapError = undefined;
            swapResult = undefined;
            _context2.prev = 3;

            if (!owner.signer) {
              _context2.next = 8;
              break;
            }

            signTransaction(swapTransaction, [owner.signer]);
            _context2.next = 13;
            break;

          case 8:
            if (wallet) {
              _context2.next = 10;
              break;
            }

            throw new Error('Signer wallet not found');

          case 10:
            _context2.next = 12;
            return wallet.signTransaction(swapTransaction);

          case 12:
            swapTransaction = _context2.sent;

          case 13:
            swapTxid = getSignature(swapTransaction);
            _context2.prev = 14;

            swapTransactionSender = /*#__PURE__*/function () {
              var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
                return _regeneratorRuntime().wrap(function _callee$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        _context.t0 = validateTransactionResponse;
                        _context.next = 3;
                        return transactionSenderAndConfirmationWaiter({
                          connection: connection,
                          signedTransaction: swapTransaction
                        });

                      case 3:
                        _context.t1 = _context.sent;
                        _context.next = 6;
                        return (0, _context.t0)(_context.t1);

                      case 6:
                        return _context.abrupt("return", _context.sent);

                      case 7:
                      case "end":
                        return _context.stop();
                    }
                  }
                }, _callee);
              }));

              return function swapTransactionSender() {
                return _ref3.apply(this, arguments);
              };
            }();

            swapPromise = swapTransactionSender();
            onTransaction == null ? void 0 : onTransaction(swapTxid, swapPromise);
            _context2.next = 20;
            return swapPromise;

          case 20:
            transactionResponse = _context2.sent;

            if (!(transactionResponse instanceof Error)) {
              _context2.next = 23;
              break;
            }

            throw transactionResponse;

          case 23:
            _context2.next = 25;
            return getTokenBalanceChangesFromTransactionResponse({
              txid: swapTxid,
              inputMint: inputMint,
              outputMint: outputMint,
              user: owner.publicKey,
              sourceAddress: sourceAddress,
              destinationAddress: destinationAddress,
              transactionResponse: transactionResponse,
              hasWrappedSOL: !wrapUnwrapSOL
            });

          case 25:
            _yield$getTokenBalanc = _context2.sent;
            sourceTokenBalanceChange = _yield$getTokenBalanc[0];
            destinationTokenBalanceChange = _yield$getTokenBalanc[1];
            swapResult = {
              txid: swapTxid,
              inputAddress: sourceAddress,
              outputAddress: destinationAddress,
              inputAmount: sourceTokenBalanceChange,
              outputAmount: destinationTokenBalanceChange
            };
            _context2.next = 35;
            break;

          case 31:
            _context2.prev = 31;
            _context2.t0 = _context2["catch"](14);
            console.error(_context2.t0);
            swapError = _context2.t0;

          case 35:
            _context2.prev = 35;
            return _context2.finish(35);

          case 37:
            if (!(swapError || !swapResult)) {
              _context2.next = 39;
              break;
            }

            throw swapError || new Error('Swap failed');

          case 39:
            return _context2.abrupt("return", swapResult);

          case 42:
            _context2.prev = 42;
            _context2.t1 = _context2["catch"](3);
            return _context2.abrupt("return", {
              error: _context2.t1
            });

          case 45:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[3, 42], [14, 31, 35, 37]]);
  }));

  return function executeTransaction(_x) {
    return _ref2.apply(this, arguments);
  };
}();

function getPlatformFeeAccounts(_x, _x2) {
  return _getPlatformFeeAccounts.apply(this, arguments);
}

function _getPlatformFeeAccounts() {
  _getPlatformFeeAccounts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(connection, feeAccountOwner) {
    var tokenAccounts, feeAccounts;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return connection.getTokenAccountsByOwner(feeAccountOwner, {
              programId: TOKEN_PROGRAM_ID
            });

          case 2:
            tokenAccounts = _context.sent.value;
            feeAccounts = tokenAccounts.reduce(function (acc, tokenAccount) {
              var deserializedtokenAccount = deserializeAccount(tokenAccount.account.data);

              if (deserializedtokenAccount) {
                acc.set(deserializedtokenAccount.mint.toBase58(), tokenAccount.pubkey);
              }

              return acc;
            }, new Map());
            return _context.abrupt("return", feeAccounts);

          case 5:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _getPlatformFeeAccounts.apply(this, arguments);
}

var Owner = /*#__PURE__*/function () {
  function Owner(owner) {
    this._owner = void 0;
    this._owner = owner;
  }

  Owner.isKeyPair = function isKeyPair(owner) {
    return owner.secretKey !== undefined;
  };

  Owner.isPublicKey = function isPublicKey(owner) {
    return !Owner.isKeyPair(owner);
  };

  _createClass(Owner, [{
    key: "publicKey",
    get: function get() {
      if (Owner.isKeyPair(this._owner)) {
        return this._owner.publicKey;
      }

      return this._owner;
    }
  }, {
    key: "signer",
    get: function get() {
      return Owner.isKeyPair(this._owner) ? this._owner : undefined;
    }
  }, {
    key: "isKeyPair",
    get: function get() {
      return Owner.isKeyPair(this._owner);
    }
  }, {
    key: "isPublicKey",
    get: function get() {
      return Owner.isPublicKey(this._owner);
    }
  }]);

  return Owner;
}();

function getOrAddKeyToIndexMap(pk, mintToIndexMap) {
  var keyIndex = mintToIndexMap.get(pk);

  if (keyIndex === undefined) {
    keyIndex = mintToIndexMap.size;
    mintToIndexMap.set(pk, keyIndex);
  }

  return keyIndex;
}
/** An indexed route map which is light (less data to compress/decompress) and can quickly be inflated into the full route map  */


function routeMapToIndexedRouteMap(routeMap) {
  var _Array$from$reduce = Array.from(routeMap).reduce(function (_ref, _ref2) {
    var mintToIndexMap = _ref.mintToIndexMap,
        indexedRouteMap = _ref.indexedRouteMap;
    var key = _ref2[0],
        item = _ref2[1];
    var keyIndex = getOrAddKeyToIndexMap(key, mintToIndexMap);
    var indexedOutputMintCache = [];

    for (var _iterator = _createForOfIteratorHelperLoose(item), _step; !(_step = _iterator()).done;) {
      var routeOutputKey = _step.value;
      var routeOutputKeyIndex = getOrAddKeyToIndexMap(routeOutputKey, mintToIndexMap);
      indexedOutputMintCache.push(routeOutputKeyIndex);
    }

    indexedRouteMap[keyIndex] = indexedOutputMintCache;
    return {
      mintToIndexMap: mintToIndexMap,
      indexedRouteMap: indexedRouteMap
    };
  }, {
    mintToIndexMap: new Map(),
    indexedRouteMap: {}
  }),
      mintToIndexMap = _Array$from$reduce.mintToIndexMap,
      innerIndexedRouteMap = _Array$from$reduce.indexedRouteMap;

  var indexedRouteMap = {
    mintKeys: Array.from(mintToIndexMap.keys()),
    indexedRouteMap: innerIndexedRouteMap
  };
  return indexedRouteMap;
}
function indexedRouteMapToRouteMap(indexedRouteMap) {
  var getMint = function getMint(index) {
    return indexedRouteMap.mintKeys[index];
  }; // generate route map by replacing indexes with mint addresses


  var generatedRouteMap = new Map();
  Object.keys(indexedRouteMap.indexedRouteMap).forEach(function (key) {
    generatedRouteMap.set(getMint(key), indexedRouteMap['indexedRouteMap'][key].map(function (index) {
      return getMint(index);
    }));
  });
  return generatedRouteMap;
}
function getRemoteRouteMap(_x, _x2) {
  return _getRemoteRouteMap.apply(this, arguments);
}

function _getRemoteRouteMap() {
  _getRemoteRouteMap = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref3, indexedRouteMapUrl) {
    var onlyDirectRoutes, restrictIntermediateTokens, asLegacyTransaction, url, indexedRouteMap;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            onlyDirectRoutes = _ref3.onlyDirectRoutes, restrictIntermediateTokens = _ref3.restrictIntermediateTokens, asLegacyTransaction = _ref3.asLegacyTransaction;
            url = indexedRouteMapUrl || INDEXED_ROUTE_MAP_URL;

            if (onlyDirectRoutes) {
              url = url.concat('?onlyDirectRoutes=true');
            } else if (restrictIntermediateTokens) {
              url = url.concat('?restrictIntermediateTokens=true');
            }

            if (asLegacyTransaction) {
              url = url.concat('?asLegacyTransaction=true');
            }

            _context.next = 6;
            return fetch(url);

          case 6:
            _context.next = 8;
            return _context.sent.json();

          case 8:
            indexedRouteMap = _context.sent;
            return _context.abrupt("return", indexedRouteMapToRouteMap(indexedRouteMap));

          case 10:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _getRemoteRouteMap.apply(this, arguments);
}

var TransactionBuilder = /*#__PURE__*/function () {
  function TransactionBuilder(connection, feePayer, owner) {
    this.connection = void 0;
    this.feePayer = void 0;
    this.instructions = void 0;
    this.owner = void 0;
    this.connection = connection;
    this.feePayer = feePayer;
    this.instructions = [];
    this.owner = owner;
  }

  var _proto = TransactionBuilder.prototype;

  _proto.addInstruction = function addInstruction(instruction) {
    this.instructions.push(instruction);
    return this;
  };

  _proto.build = /*#__PURE__*/function () {
    var _build = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(blockhashWithExpiryBlockHeight, addressLookupTables, asLegacyTransaction) {
      var _this = this;

      var instructions, setupInstructions, cleanupInstructions, signers, transactionInstructions, transaction;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              instructions = [];
              setupInstructions = [];
              cleanupInstructions = [];
              signers = [];
              this.instructions.forEach(function (curr) {
                setupInstructions = setupInstructions.concat(curr.setupInstructions);
                instructions = instructions.concat(curr.instructions);
                cleanupInstructions = cleanupInstructions.concat(curr.cleanupInstructions);
                signers = signers.concat(curr.signers);
              });
              transactionInstructions = setupInstructions.concat(instructions).concat(cleanupInstructions);
              transaction = asLegacyTransaction ? this.buildLegacyTransaction({
                transactionInstructions: transactionInstructions,
                blockhashWithExpiryBlockHeight: blockhashWithExpiryBlockHeight
              }) : this.buildVersionedTransaction({
                transactionInstructions: transactionInstructions,
                blockhashWithExpiryBlockHeight: blockhashWithExpiryBlockHeight,
                addressLookupTables: addressLookupTables
              });
              return _context2.abrupt("return", {
                transaction: transaction,
                signers: signers,
                execute: this.owner.isKeyPair ? function () {
                  var signature = signTransaction(transaction, [_this.owner.signer].concat(signers));
                  var serializedTx = transaction.serialize();
                  return sendAndConfirmRawTransaction(_this.connection, Buffer.from(serializedTx), _extends({
                    signature: signature
                  }, blockhashWithExpiryBlockHeight));
                } : /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
                  return _regeneratorRuntime().wrap(function _callee$(_context) {
                    while (1) {
                      switch (_context.prev = _context.next) {
                        case 0:
                          throw new Error('Please use a Keypair for the owner parameter to enable the execute function');

                        case 1:
                        case "end":
                          return _context.stop();
                      }
                    }
                  }, _callee);
                }))
              });

            case 8:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function build(_x, _x2, _x3) {
      return _build.apply(this, arguments);
    }

    return build;
  }();

  _proto.buildLegacyTransaction = function buildLegacyTransaction(_ref2) {
    var _Transaction;

    var transactionInstructions = _ref2.transactionInstructions,
        blockhashWithExpiryBlockHeight = _ref2.blockhashWithExpiryBlockHeight;
    return (_Transaction = new Transaction(_extends({
      feePayer: this.feePayer
    }, blockhashWithExpiryBlockHeight))).add.apply(_Transaction, transactionInstructions);
  };

  _proto.buildVersionedTransaction = function buildVersionedTransaction(_ref3) {
    var transactionInstructions = _ref3.transactionInstructions,
        blockhashWithExpiryBlockHeight = _ref3.blockhashWithExpiryBlockHeight,
        addressLookupTables = _ref3.addressLookupTables;
    var transactionMessage = new TransactionMessage({
      payerKey: this.feePayer,
      instructions: transactionInstructions,
      recentBlockhash: blockhashWithExpiryBlockHeight.blockhash
    });
    var messageV0 = transactionMessage.compileToV0Message(addressLookupTables);
    return new VersionedTransaction(messageV0);
  };

  return TransactionBuilder;
}();

var getEmptyInstruction = function getEmptyInstruction() {
  return {
    setupInstructions: [],
    instructions: [],
    cleanupInstructions: [],
    signers: []
  };
};

function createAndCloseWSOLAccount(_x) {
  return _createAndCloseWSOLAccount.apply(this, arguments);
}

function _createAndCloseWSOLAccount() {
  _createAndCloseWSOLAccount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref) {
    var connection, amount, publicKey, result, toAccount, info;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            connection = _ref.connection, amount = _ref.amount, publicKey = _ref.owner.publicKey;
            result = getEmptyInstruction();
            toAccount = findAssociatedTokenAddress({
              walletAddress: publicKey,
              tokenMintAddress: WRAPPED_SOL_MINT
            });
            _context.next = 5;
            return connection.getAccountInfo(toAccount);

          case 5:
            info = _context.sent;

            if (info === null) {
              result.setupInstructions.push(createAssociatedTokenAccountInstruction(publicKey, toAccount, publicKey, WRAPPED_SOL_MINT));
            } // Fund account and sync


            result.setupInstructions.push(SystemProgram.transfer({
              fromPubkey: publicKey,
              toPubkey: toAccount,
              lamports: JSBI.toNumber(amount)
            }));
            result.setupInstructions.push( // This is not exposed by the types, but indeed it exists
            Token.createSyncNativeInstruction(TOKEN_PROGRAM_ID, toAccount));
            result.cleanupInstructions = [Token.createCloseAccountInstruction(TOKEN_PROGRAM_ID, toAccount, publicKey, publicKey, [])];
            return _context.abrupt("return", _extends({
              address: toAccount
            }, result));

          case 11:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _createAndCloseWSOLAccount.apply(this, arguments);
}

function findOrCreateAssociatedAccountByMint(_x2) {
  return _findOrCreateAssociatedAccountByMint.apply(this, arguments);
} // 0.1.x @solana/spl-token does not have the version without the rent sysvar
// Source: https://github.com/solana-labs/solana-program-library/blob/dc5684445f0b42ba36a0157f06c561d967a7cb34/associated-token-account/program/src/instruction.rs#L16-L25

function _findOrCreateAssociatedAccountByMint() {
  _findOrCreateAssociatedAccountByMint = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_ref2) {
    var connection, payer, publicKey, mintAddress, unwrapSOL, mint, toAccount, result, info, tokenAccountInfo;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            connection = _ref2.connection, payer = _ref2.payer, publicKey = _ref2.owner.publicKey, mintAddress = _ref2.mintAddress, unwrapSOL = _ref2.unwrapSOL;
            mint = typeof mintAddress === 'string' ? new PublicKey(mintAddress) : mintAddress;
            toAccount = findAssociatedTokenAddress({
              tokenMintAddress: mint,
              walletAddress: publicKey
            });
            result = getEmptyInstruction();
            _context2.next = 6;
            return connection.getAccountInfo(toAccount);

          case 6:
            info = _context2.sent;

            if (!(info === null)) {
              _context2.next = 11;
              break;
            }

            result.setupInstructions.push(createAssociatedTokenAccountInstruction(payer, toAccount, publicKey, mint));
            _context2.next = 14;
            break;

          case 11:
            tokenAccountInfo = deserializeAccount(info.data);

            if (!(tokenAccountInfo && !tokenAccountInfo.owner.equals(publicKey))) {
              _context2.next = 14;
              break;
            }

            throw new Error("/! ATA " + toAccount.toBase58() + " is not owned by " + publicKey.toBase58());

          case 14:
            // We close it when wrapped SOL
            if (mint.equals(WRAPPED_SOL_MINT) && unwrapSOL) {
              result.cleanupInstructions.push(Token.createCloseAccountInstruction(TOKEN_PROGRAM_ID, toAccount, publicKey, publicKey, []));
            }

            return _context2.abrupt("return", _extends({
              address: toAccount
            }, result));

          case 16:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _findOrCreateAssociatedAccountByMint.apply(this, arguments);
}

function createAssociatedTokenAccountInstruction(payer, associatedToken, owner, mint, programId, associatedTokenProgramId) {
  if (programId === void 0) {
    programId = TOKEN_PROGRAM_ID;
  }

  if (associatedTokenProgramId === void 0) {
    associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID;
  }

  var keys = [{
    pubkey: payer,
    isSigner: true,
    isWritable: true
  }, {
    pubkey: associatedToken,
    isSigner: false,
    isWritable: true
  }, {
    pubkey: owner,
    isSigner: false,
    isWritable: false
  }, {
    pubkey: mint,
    isSigner: false,
    isWritable: false
  }, {
    pubkey: SystemProgram.programId,
    isSigner: false,
    isWritable: false
  }, {
    pubkey: programId,
    isSigner: false,
    isWritable: false
  }];
  return new TransactionInstruction({
    keys: keys,
    programId: associatedTokenProgramId,
    data: Buffer.alloc(0)
  });
}
var findAssociatedTokenAddress = function findAssociatedTokenAddress(_ref3) {
  var walletAddress = _ref3.walletAddress,
      tokenMintAddress = _ref3.tokenMintAddress;
  return PublicKey.findProgramAddressSync([walletAddress.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), tokenMintAddress.toBuffer()], ASSOCIATED_TOKEN_PROGRAM_ID)[0];
};

var SwapMode;

(function (SwapMode) {
  SwapMode["ExactIn"] = "ExactIn";
  SwapMode["ExactOut"] = "ExactOut";
})(SwapMode || (SwapMode = {}));

function createOpenOrdersInstruction(serumMarket, serumProgramId, userTransferAuthority) {
  var _PublicKey$findProgra = PublicKey.findProgramAddressSync([Buffer.from('open_orders'), serumMarket.toBuffer(), userTransferAuthority.toBuffer()], JUPITER_PROGRAM_ID),
      openOrders = _PublicKey$findProgra[0];

  var ix = JUPITER_PROGRAM.instruction.createOpenOrders({
    accounts: {
      openOrders: openOrders,
      payer: userTransferAuthority,
      dexProgram: serumProgramId,
      systemProgram: SystemProgram.programId,
      rent: SYSVAR_RENT_PUBKEY,
      market: serumMarket
    }
  });
  return [openOrders, ix];
}
function getOrCreateOpenOrdersAddress(_x, _x2, _x3, _x4) {
  return _getOrCreateOpenOrdersAddress.apply(this, arguments);
}

function _getOrCreateOpenOrdersAddress() {
  _getOrCreateOpenOrdersAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(connection, user, serumMarket, serumProgramId) {
    var result, _createOpenOrdersInst, newOpenOrdersAddress, ix, newOpenOrdersAddressInfo;

    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            result = getEmptyInstruction();
            _createOpenOrdersInst = createOpenOrdersInstruction(serumMarket, serumProgramId, user), newOpenOrdersAddress = _createOpenOrdersInst[0], ix = _createOpenOrdersInst[1];
            _context.next = 4;
            return connection.getAccountInfo(newOpenOrdersAddress);

          case 4:
            newOpenOrdersAddressInfo = _context.sent;

            if (!newOpenOrdersAddressInfo) {
              result.setupInstructions = [ix];
            }

            return _context.abrupt("return", _extends({}, result, {
              address: newOpenOrdersAddress
            }));

          case 7:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _getOrCreateOpenOrdersAddress.apply(this, arguments);
}

function getAtaInstructions(_x5) {
  return _getAtaInstructions.apply(this, arguments);
}

function _getAtaInstructions() {
  _getAtaInstructions = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_ref) {
    var connection, outputMints, owner, unwrapSOL, userTokenAccountResults, _userTokenAccountResu, userDestinationTokenAccountResult;

    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            connection = _ref.connection, outputMints = _ref.outputMints, owner = _ref.owner, unwrapSOL = _ref.unwrapSOL;
            _context2.next = 3;
            return Promise.all(outputMints.map(function (outputMint) {
              return findOrCreateAssociatedAccountByMint({
                connection: connection,
                payer: owner.publicKey,
                owner: owner,
                mintAddress: outputMint,
                unwrapSOL: unwrapSOL
              });
            }));

          case 3:
            userTokenAccountResults = _context2.sent;
            _userTokenAccountResu = userTokenAccountResults.splice(userTokenAccountResults.length - 1, 1), userDestinationTokenAccountResult = _userTokenAccountResu[0];
            return _context2.abrupt("return", {
              userIntermediaryTokenAccountResults: userTokenAccountResults,
              userDestinationTokenAccountResult: userDestinationTokenAccountResult
            });

          case 6:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _getAtaInstructions.apply(this, arguments);
}

var SERUM_OPEN_ACCOUNT_LAMPORTS = 23352760;
var OPEN_TOKEN_ACCOUNT_LAMPORTS = 2039280;
var WALLET_RENT_EXEMPT_MINIMUM = 890880;
var LAMPORTS_PER_SIGNATURE = 5000;

function sum(values) {
  return values.reduce(function (value, acc) {
    acc += value;
    return acc;
  }, 0);
}

var calculateTransactionDepositAndFee = function calculateTransactionDepositAndFee(_ref) {
  var intermediates = _ref.intermediates,
      destination = _ref.destination,
      openOrders = _ref.openOrders,
      hasWrapUnwrapSOL = _ref.hasWrapUnwrapSOL,
      feeCalculator = _ref.feeCalculator;
  var openOrdersDeposits = openOrders.filter(function (ooi) {
    return ooi && ooi.setupInstructions.length > 0;
  }).map(function () {
    return SERUM_OPEN_ACCOUNT_LAMPORTS;
  });
  var ataDeposits = [].concat(intermediates, [destination]).filter(function (item) {
    return (item == null ? void 0 : item.setupInstructions.length) && item.cleanupInstructions.length === 0;
  }).map(function () {
    return OPEN_TOKEN_ACCOUNT_LAMPORTS;
  });
  var signatureFee = feeCalculator.lamportsPerSignature;
  var totalFeeAndDeposits = sum([signatureFee].concat(openOrdersDeposits, ataDeposits)); // We need to account for temporary wrapped SOL token accounts as intermediary or output

  var minimumSOLForTransaction = sum([signatureFee].concat(openOrdersDeposits, ataDeposits, [WALLET_RENT_EXEMPT_MINIMUM, hasWrapUnwrapSOL ? OPEN_TOKEN_ACCOUNT_LAMPORTS : 0]));
  return {
    signatureFee: signatureFee,
    openOrdersDeposits: openOrdersDeposits,
    ataDeposits: ataDeposits,
    totalFeeAndDeposits: totalFeeAndDeposits,
    minimumSOLForTransaction: minimumSOLForTransaction
  };
};
var calculateTransactionDepositAndFeeV2 = function calculateTransactionDepositAndFeeV2(_ref2) {
  var numOfAtasToBeCreated = _ref2.numOfAtasToBeCreated,
      numOfOpenOrdersToBeCreated = _ref2.numOfOpenOrdersToBeCreated;
  var openOrdersDeposits = new Array(numOfOpenOrdersToBeCreated).fill(0).map(function () {
    return SERUM_OPEN_ACCOUNT_LAMPORTS;
  });
  var ataDeposits = new Array(numOfAtasToBeCreated).fill(0).map(function () {
    return OPEN_TOKEN_ACCOUNT_LAMPORTS;
  });
  var signatureFee = LAMPORTS_PER_SIGNATURE;
  var totalFeeAndDeposits = sum([signatureFee].concat(openOrdersDeposits, ataDeposits)); // We need to account for temporary wrapped SOL token accounts as intermediary or output

  var minimumSOLForTransaction = sum([signatureFee].concat(openOrdersDeposits, ataDeposits, [WALLET_RENT_EXEMPT_MINIMUM]));
  return {
    signatureFee: signatureFee,
    openOrdersDeposits: openOrdersDeposits,
    ataDeposits: ataDeposits,
    totalFeeAndDeposits: totalFeeAndDeposits,
    minimumSOLForTransaction: minimumSOLForTransaction
  };
};

export { ALDRIN_SWAP_PROGRAM_ID, ALDRIN_SWAP_V2_PROGRAM_ID, BALANSOL_PROGRAM_ID, BONK_SWAP_PROGRAM_AUTHORITY, BONK_SWAP_PROGRAM_ID, BONK_SWAP_STATE_ID, CREMA_PARTNER_ACCOUNT, CREMA_PROGRAM_ID, CROPPER_PROGRAM_ID, CYKURA_FACTORY_STATE_ADDRESS, CYKURA_PROGRAM_ID, DELTA_FI_PROGRAM_ID, DELTA_FI_USER_ID, DEVNET_SERUM_DEX_PROGRAM, DRADEX_DEX_USER, DRADEX_LOGGER_PROGRAM_ID, DRADEX_MASTER_ID, DRADEX_PROGRAM_ID, GOOSE_FX_CONTROLLER_ID, GOOSE_FX_PROGRAM_ID, IDL, INDEXED_ROUTE_MAP_URL, INVARIANT_PROGRAM_AUTHORITY_ID, INVARIANT_PROGRAM_ID, INVARIANT_STATE_ID, JUPITER_ERRORS, JUPITER_FEE_OWNER, JUPITER_PROGRAM, JUPITER_PROGRAM_ID, JUPITER_PROGRAM_ID_DEVNET, JUPITER_PROGRAM_ID_PRODUCTION, JUPITER_PROGRAM_ID_STAGING, LAMPORTS_PER_SIGNATURE$1 as LAMPORTS_PER_SIGNATURE, LIFINITY_PROGRAM_ID, LIFINITY_V2_PROGRAM_ID, MAINNET_SERUM_DEX_PROGRAM, MARCO_POLO_PROGRAM_AUTHORITY, MARCO_POLO_PROGRAM_ID, MARCO_POLO_STATE_ID, MARINADE_PROGRAM_ID, MARKETS_URL, MERCURIAL_SWAP_PROGRAM_ID, METEORA_PROGRAM_ID, METEORA_VAULT_PROGRAM_ID, OPENBOOK_PROGRAM_ID, ORCA_V1_PROGRAM_ID, ORCA_V2_PROGRAM_ID, Owner, PENGUIN_PROGRAM_ID, PHOENIX_PROGRAM_ID, RAYDIUM_AMM_V4_PROGRAM_ID, RAYDIUM_CLMM_PROGRAM_ID, SABER_ADD_DECIMALS_PROGRAM_ID, SAROS_PROGRAM_ID, SENCHA_PROGRAM_ID, STEPN_PROGRAM_ID, STEP_TOKEN_SWAP_PROGRAM_ID, SYMMETRY_PROGRAM_ID, SwapMode, TOKEN_LIST_URL, TransactionBuilder, WHIRLPOOL_PROGRAM_ID, WRAPPED_SOL_MINT, calculateTransactionDepositAndFee, calculateTransactionDepositAndFeeV2, createAndCloseWSOLAccount, createAssociatedTokenAccountInstruction, createOpenOrdersInstruction, executeTransaction, extractSOLChangeFromTransaction, extractTokenBalanceChangeFromTransaction, findAssociatedTokenAddress, findOrCreateAssociatedAccountByMint, getAtaInstructions, getEmptyInstruction, getOrCreateOpenOrdersAddress, getPlatformFeeAccounts, getRemoteRouteMap, getSignature, getTokenBalanceChangesFromTransactionResponse, getTransactionBlockhashAndFeePayer, getUnixTs, indexedRouteMapToRouteMap, routeMapToIndexedRouteMap, signTransaction, transactionSenderAndConfirmationWaiter, validateTransactionResponse, wait };
//# sourceMappingURL=common.esm.js.map
