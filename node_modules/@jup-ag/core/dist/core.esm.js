import{PublicKey as e,MAX_SEED_LENGTH as t,SystemProgram as n,SYSVAR_RENT_PUBKEY as o,SYSVAR_CLOCK_PUBKEY as i,AddressLookupTableAccount as a,ComputeBudgetProgram as s}from"@solana/web3.js";import r from"lru-cache";import{Market as u,OpenOrders as c,Orderbook as m}from"@project-serum/serum";import{calculateAmpFactor as d,decodeSwap as p,SWAP_PROGRAM_ID as l,StableSwap as h}from"@saberhq/stableswap-sdk";import{TokenSwapStable as g,Fraction as k,TokenSwapConstantProduct as f,toDecimal as S,Stable as A,ZERO_FRACTION as y,ZERO as M,TWO as w,ONE as T}from"@jup-ag/math";import v from"jsbi";import*as P from"fzstd";import{deserializeAccount as b,deserializeMint as I}from"@mercurial-finance/optimist";import{findProgramAddressSync as B,createProgramAddressSync as F}from"@project-serum/anchor/dist/cjs/utils/pubkey";import{u64 as D,TOKEN_PROGRAM_ID as L,NATIVE_MINT as q,ASSOCIATED_TOKEN_PROGRAM_ID as x}from"@solana/spl-token";import O,{BN as E}from"bn.js";import{SYMMETRY_PROGRAM_ID as C,JUPITER_PROGRAM as R,ALDRIN_SWAP_PROGRAM_ID as N,ALDRIN_SWAP_V2_PROGRAM_ID as V,SABER_ADD_DECIMALS_PROGRAM_ID as U,LIFINITY_V2_PROGRAM_ID as K,CYKURA_PROGRAM_ID as z,CYKURA_FACTORY_STATE_ADDRESS as W,WHIRLPOOL_PROGRAM_ID as j,JUPITER_PROGRAM_ID as Q,MARINADE_PROGRAM_ID as X,INVARIANT_PROGRAM_ID as Y,INVARIANT_STATE_ID as _,INVARIANT_PROGRAM_AUTHORITY_ID as $,METEORA_PROGRAM_ID as H,METEORA_VAULT_PROGRAM_ID as Z,GOOSE_FX_PROGRAM_ID as J,GOOSE_FX_CONTROLLER_ID as G,DELTA_FI_PROGRAM_ID as ee,DELTA_FI_USER_ID as te,BALANSOL_PROGRAM_ID as ne,DRADEX_PROGRAM_ID as oe,DRADEX_DEX_USER as ie,DRADEX_MASTER_ID as ae,DRADEX_LOGGER_PROGRAM_ID as se,CREMA_PROGRAM_ID as re,CREMA_PARTNER_ACCOUNT as ue,findAssociatedTokenAddress as ce,RAYDIUM_CLMM_PROGRAM_ID as me,PHOENIX_PROGRAM_ID as de,MERCURIAL_SWAP_PROGRAM_ID as pe,RAYDIUM_AMM_V4_PROGRAM_ID as le,BONK_SWAP_PROGRAM_ID as he,BONK_SWAP_STATE_ID as ge,BONK_SWAP_PROGRAM_AUTHORITY as ke,MARCO_POLO_PROGRAM_ID as fe,MARCO_POLO_STATE_ID as Se,MARCO_POLO_PROGRAM_AUTHORITY as Ae,OPENBOOK_PROGRAM_ID as ye,STEP_TOKEN_SWAP_PROGRAM_ID as Me,JUPITER_FEE_OWNER as we,ORCA_V1_PROGRAM_ID as Te,ORCA_V2_PROGRAM_ID as ve,PENGUIN_PROGRAM_ID as Pe,SAROS_PROGRAM_ID as be,STEPN_PROGRAM_ID as Ie,MAINNET_SERUM_DEX_PROGRAM as Be,DEVNET_SERUM_DEX_PROGRAM as Fe,CROPPER_PROGRAM_ID as De,SENCHA_PROGRAM_ID as Le,LIFINITY_PROGRAM_ID as qe,getEmptyInstruction as xe,getAtaInstructions as Oe,WRAPPED_SOL_MINT as Ee,calculateTransactionDepositAndFee as Ce,Owner as Re,createAndCloseWSOLAccount as Ne,TransactionBuilder as Ve,executeTransaction as Ue,getRemoteRouteMap as Ke,MARKETS_URL as ze}from"@jup-ag/common";export*from"@jup-ag/common";import{Layout as We,blob as je,struct as Qe,u8 as Xe,u32 as Ye,nu64 as _e}from"@solana/buffer-layout";import{sha256 as $e}from"@noble/hashes/sha256";import{AnchorProvider as He,Program as Ze,BorshAccountsCoder as Je,BorshCoder as Ge,BN as et,utils as tt}from"@project-serum/anchor";import nt from"decimal.js";import{PDAUtil as ot,TickUtil as it,TICK_ARRAY_SIZE as at,computeSwap as st,TickMath as rt,IDL as ut}from"@jup-ag/crema-sdk-v2";import{tickPosition as ct,TickMath as mt,generateBitmapWord as dt,TICK_SEED as pt,u32ToSeed as lt,BITMAP_SEED as ht,u16ToSeed as gt,nextInitializedBit as kt,buildTick as ft,Pool as St,OBSERVATION_SEED as At,IDL as yt}from"@jup-ag/cykura-sdk";import{Token as Mt,CurrencyAmount as wt}from"@jup-ag/cykura-sdk-core";import{getSwappedAmountsAndPriceImpactFromRawValue as Tt,getDeltafiDexV2 as vt}from"@jup-ag/deltafi-sdk";import{parsePriceData as Pt}from"@pythnetwork/client";import{BigNumber as bt}from"bignumber.js";import{PAIR_LAYOUT as It,SyncSwap as Bt,SSL as Ft,wasm as Dt,loadWasm as Lt}from"@jup-ag/goosefx-ssl-sdk";import{calculatePriceSqrt as qt,MIN_TICK as xt,MAX_TICK as Ot,toDecimal as Et,simulateSwap as Ct,findClosestTicks as Rt,TICK_CROSSES_PER_IX as Nt,IDL as Vt,DENOMINATOR as Ut}from"@jup-ag/invariant";import{LIFINITY_AMM_LAYOUT as Kt,getParsedData as zt,TradeDirection as Wt,getCurveAmount as jt}from"@jup-ag/lifinity-sdk";import{IDL as Qt,getParsedData as Xt,TradeDirection as Yt,getCurveAmount as _t}from"@jup-ag/lifinity-sdk-v2";import{AmmIdl as $t,PROGRAM_ID as Ht,VaultIdl as Zt,calculateSwapQuote as Jt,CURVE_TYPE_ACCOUNTS as Gt}from"@mercurial-finance/dynamic-amm-sdk";import{SwapUtils as en,swapQuoteWithParams as tn,ParsableWhirlpool as nn,ParsableTickArray as on}from"@jup-ag/whirlpools-sdk";import{dexCoder as an,QuoteCalculator as sn}from"@jup-ag/dradex-sdk";import{OrderBook as rn}from"@jup-ag/dradex-idl";import{IDL as un,Amm as cn}from"@jup-ag/raydium-clmm-sdk";import{deserializeMarketData as mn,getMarketLadder as dn}from"@jup-ag/phoenix-sdk";import pn from"cross-fetch";const ln={Raydium:{Openbook:!0}},hn={Symmetry:!0,Openbook:!0,Cykura:!0,Meteora:{Lifinity:!0,"Lifinity V2":!0,Balansol:!0,Crema:!0,Dradex:!0,Raydium:!0,BonkSwap:!0,Oasis:!0},Crema:{Balansol:!0,Raydium:!0,Lifinity:!0,"Lifinity V2":!0},BonkSwap:{Lifinity:!0,"Lifinity V2":!0,Balansol:!0,Crema:!0,Dradex:!0,Raydium:!0,Oasis:!0},Oasis:{Lifinity:!0,"Lifinity V2":!0,Balansol:!0,Crema:!0,Dradex:!0,Raydium:!0,BonkSwap:!0},Dradex:{Lifinity:!0,"Lifinity V2":!0,Balansol:!0,Crema:!0,Raydium:!0},Balansol:{Raydium:!0},Lifinity:{Raydium:!0},"Lifinity V2":{Raydium:!0}},gn={Symmetry:!0,Raydium:!0,GooseFX:!0,Meteora:!0,Serum:!0,Openbook:!0,Dradex:!0,Crema:!0,Lifinity:!0,"Lifinity V2":!0},kn=(e,t,n)=>{const o=e[t];if(o){if(!0===o||!0===o["*"])return!0;if(n)return!0===o[n]}return!1},fn=(e,t,n)=>kn(e,t,n)||!!n&&kn(e,n,t);function Sn(e,t){return Array.apply(0,new Array(Math.ceil(e.length/t))).map(((n,o)=>e.slice(o*t,(o+1)*t)))}async function An(t,n,o=1e3,i=100){return(await Promise.all(Sn(n,o).map((async n=>{const o=Sn(n,i).map((e=>({methodName:"getMultipleAccounts",args:t._buildArgs([e],t.commitment,"base64+zstd")})));return t._rpcBatchRequest(o).then((t=>t.reduce(((t,n)=>(n.result.value.forEach((n=>{if(n){const o=n;o.data=Buffer.from(P.decompress(Buffer.from(n.data[0],"base64"))),o.owner=new e(n.owner),t.push(o)}else t.push(null)})),t)),[]))).catch((e=>n.map((()=>null))))})))).flat()}var yn;!function(e){e.ExactIn="ExactIn",e.ExactOut="ExactOut"}(yn||(yn={}));const Mn=(e,t)=>t.map((t=>{const n=e.get(t.toString());if(!n)throw new Error(`Account info ${t.toBase58()} missing`);return n})),wn=e=>e.map((e=>{const t=b(e.data);if(!t)throw new Error("Invalid token account");return t})).map((e=>v.BigInt(e.amount))),Tn=async(e,t)=>{const n=e.map((e=>e.getAccountsForUpdate().map((e=>e.toBase58())))).flat(),o=new Map;(await An(t,n)).forEach(((e,t)=>{e&&o.set(n[t],e)}));for(let t of e)t.update(o)};class vn extends We{constructor(e){const t=je(32);super(t.span,e),this.layout=void 0,this.layout=t}getSpan(e,t){return this.layout.getSpan(e,t)}decode(t,n){return new e(this.layout.decode(t,n))}encode(e,t,n){return this.layout.encode(e.toBuffer(),t,n)}}const Pn=e=>new vn(e);class bn extends We{constructor(e=8,t){const n=je(e);super(n.span,t),this.layout=void 0,this.layout=n}getSpan(e,t){return this.layout.getSpan(e,t)}decode(e,t){return new D(this.layout.decode(e,t),10,"le")}encode(e,t,n){return this.layout.encode(e.toArrayLike(Buffer,"le",this.layout.span),t,n)}}const In=e=>new bn(8,e),Bn=e=>new bn(16,e);function Fn(n,o){let i=Buffer.alloc(0);n.forEach((function(e){if(e.length>t)throw new TypeError("Max seed length exceeded");var n;i=Buffer.concat([i,(n=e,Buffer.isBuffer(n)?n:n instanceof Uint8Array?Buffer.from(n.buffer,n.byteOffset,n.byteLength):Buffer.from(n))])})),i=Buffer.concat([i,o.toBuffer(),Buffer.from("ProgramDerivedAddress")]);let a=$e(new Uint8Array(i)),s=new O(a,16).toArray(void 0,32);return new e(s)}const Dn=Qe([Xe("version"),Xe("isInitialized"),Xe("nonce"),Pn("ammId"),Pn("serumProgramId"),Pn("serumMarket"),Pn("tokenProgramId"),Pn("tokenAAccount"),Pn("tokenBAccount"),Pn("poolMint"),Pn("mintA"),Pn("mintB")]),Ln=Qe([Xe("isInitialized"),Pn("stateOwner"),Pn("feeOwner"),In("initialSupply"),In("returnFeeNumerator"),In("fixedFeeNumerator"),In("feeDenominator"),Xe("curveType"),je(32,"curveParameters")]),qn=new e("3hsU1VgsBgBgz5jWiqdw9RfGU6TpWdCmdah1oi4kF3Tq"),xn=(e,t)=>{const n=t.owner,o=Dn.decode(t.data);return{programId:n,authority:Fn([e.toBuffer(),Buffer.from([o.nonce])],n),version:o.version,isInitialized:Boolean(o.isInitialized),nonce:o.nonce,ammId:o.ammId,serumProgramId:o.serumProgramId,tokenProgramId:o.tokenProgramId,tokenAAccount:o.tokenAAccount,tokenBAccount:o.tokenBAccount,serumMarket:o.serumMarket,poolMint:o.poolMint,mintA:o.mintA,mintB:o.mintB}},On={Bid:{bid:{}},Ask:{ask:{}}},En=e=>({serum:{side:e}}),Cn=e=>({crema:{aToB:e}}),Rn=e=>({aldrin:{side:e}}),Nn=e=>({aldrinV2:{side:e}}),Vn=e=>({whirlpool:{aToB:e}}),Un=e=>({invariant:{xToY:e}}),Kn=e=>({dradex:{side:e}}),zn=e=>({marcoPolo:{xToY:e}}),Wn=e=>({openbook:{side:e}}),jn=e=>({phoenix:{side:e}}),Qn=(e,t)=>({symmetry:{fromTokenId:e,toTokenId:t}}),Xn=e=>({chain:{swapLegs:e}}),Yn=e=>({split:{splitLegs:e}}),_n=e=>({swap:{swap:e}}),$n=(e,t)=>({percent:e,swapLeg:t}),Hn=["StepAscQoEioFxxWGnh2sLBDFp9d8rvKz2Yp39iDpyT","DubwWZNWiNGMMeeQHPnMATNj77YZPZSAz2WVR5WjLJqz"],Zn="development"===process.env.NODE_ENV,Jn="test"===process.env.NODE_ENV,Gn="production"===process.env.NODE_ENV,eo=100,to=new He(null,null,{skipPreflight:!1}),no=new Ze({version:"0.1.0",name:"funds",instructions:[{name:"createFund",accounts:[{name:"manager",isMut:!0,isSigner:!0},{name:"tokenInfo",isMut:!1,isSigner:!1},{name:"fundState",isMut:!0,isSigner:!1},{name:"pdaAccount",isMut:!1,isSigner:!1},{name:"fundToken",isMut:!0,isSigner:!0},{name:"createFeeSweeper",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[{name:"messageDigestFive",type:{array:["u8",16]}},{name:"managerFee",type:"u64"},{name:"hostPubkey",type:"publicKey"},{name:"hostFee",type:"u64"},{name:"activelyManaged",type:"u64"},{name:"assetPool",type:{array:["u8",256]}},{name:"refilterInterval",type:"u64"},{name:"reweightInterval",type:"u64"},{name:"rebalanceInterval",type:"u64"},{name:"rebalanceThreshold",type:"u64"},{name:"rebalanceSlippage",type:"u64"},{name:"lpOffsetThreshold",type:"u64"},{name:"fundLpFee",type:"u64"}]},{name:"closeFund",accounts:[{name:"manager",isMut:!0,isSigner:!0},{name:"fundToken",isMut:!0,isSigner:!1},{name:"fundState",isMut:!0,isSigner:!1},{name:"pdaAccount",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[]},{name:"setRules",accounts:[{name:"manager",isMut:!0,isSigner:!0},{name:"fundState",isMut:!0,isSigner:!1}],args:[{name:"numOfRules",type:"u64"},{name:"rulesData",type:{array:["u8",512]}},{name:"ruleWeights",type:{array:["u64",20]}},{name:"ruleExpos",type:{array:["i64",20]}}]},{name:"fundEdit",accounts:[{name:"manager",isMut:!0,isSigner:!0},{name:"tokenInfo",isMut:!1,isSigner:!1},{name:"fundState",isMut:!0,isSigner:!1}],args:[{name:"messageDigestFive",type:{array:["u8",16]}},{name:"managerFee",type:"u64"},{name:"activelyManaged",type:"u64"},{name:"assetPool",type:{array:["u8",256]}},{name:"refilterInterval",type:"u64"},{name:"reweightInterval",type:"u64"},{name:"rebalanceInterval",type:"u64"},{name:"rebalanceThreshold",type:"u64"},{name:"rebalanceSlippage",type:"u64"},{name:"lpOffsetThreshold",type:"u64"},{name:"fundLpFee",type:"u64"}]},{name:"buyFund",accounts:[{name:"buyer",isMut:!0,isSigner:!0},{name:"fundState",isMut:!0,isSigner:!1},{name:"tokenInfo",isMut:!1,isSigner:!1},{name:"pdaAccount",isMut:!1,isSigner:!1},{name:"pdaUsdcAccount",isMut:!0,isSigner:!1},{name:"buyerUsdcAccount",isMut:!0,isSigner:!1},{name:"managerUsdcAccount",isMut:!0,isSigner:!1},{name:"smfFeeAccount",isMut:!0,isSigner:!1},{name:"hostUsdcAccount",isMut:!0,isSigner:!1},{name:"buyerFundTokenAccount",isMut:!0,isSigner:!1},{name:"buyState",isMut:!0,isSigner:!0},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"amount",type:"u64"}]},{name:"mintFund",accounts:[{name:"signer",isMut:!0,isSigner:!0},{name:"buyer",isMut:!0,isSigner:!1},{name:"fundState",isMut:!0,isSigner:!1},{name:"tokenInfo",isMut:!1,isSigner:!1},{name:"buyState",isMut:!0,isSigner:!1},{name:"pdaAccount",isMut:!1,isSigner:!1},{name:"buyerFundTokenAccount",isMut:!0,isSigner:!1},{name:"fundToken",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[]},{name:"swapFundTokens",accounts:[{name:"buyer",isMut:!1,isSigner:!0},{name:"fundState",isMut:!0,isSigner:!1},{name:"pdaAccount",isMut:!1,isSigner:!1},{name:"pdaFromTokenAccount",isMut:!0,isSigner:!1},{name:"buyerFromTokenAccount",isMut:!0,isSigner:!1},{name:"pdaToTokenAccount",isMut:!0,isSigner:!1},{name:"buyerToTokenAccount",isMut:!0,isSigner:!1},{name:"swapFeeAccount",isMut:!0,isSigner:!1},{name:"hostFeeAccount",isMut:!0,isSigner:!1},{name:"managerFeeAccount",isMut:!0,isSigner:!1},{name:"tokenInfo",isMut:!1,isSigner:!1},{name:"curveData",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"fromTokenId",type:"u64"},{name:"toTokenId",type:"u64"},{name:"fromAmount",type:"u64"},{name:"minimumToAmount",type:"u64"}]},{name:"sellFund",accounts:[{name:"seller",isMut:!0,isSigner:!0},{name:"fundState",isMut:!0,isSigner:!1},{name:"pdaAccount",isMut:!1,isSigner:!1},{name:"newFundState",isMut:!0,isSigner:!1},{name:"sellerFundTokenAccount",isMut:!0,isSigner:!1},{name:"fundToken",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[{name:"amount",type:"u64"},{name:"rebalance",type:"u64"}]},{name:"claimToken",accounts:[{name:"manager",isMut:!0,isSigner:!0},{name:"fundState",isMut:!0,isSigner:!1},{name:"tokenInfo",isMut:!1,isSigner:!1},{name:"sellerTokenAccount",isMut:!0,isSigner:!1},{name:"pdaTokenAccount",isMut:!0,isSigner:!1},{name:"pdaAccount",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"tokenId",type:"u64"}]},{name:"claimTokenFromBuyState",accounts:[{name:"signer",isMut:!0,isSigner:!0},{name:"buyer",isMut:!0,isSigner:!1},{name:"fundState",isMut:!0,isSigner:!1},{name:"buyState",isMut:!0,isSigner:!1},{name:"tokenInfo",isMut:!1,isSigner:!1},{name:"buyerTokenAccount",isMut:!0,isSigner:!1},{name:"pdaTokenAccount",isMut:!0,isSigner:!1},{name:"pdaAccount",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"tokenId",type:"u64"}]},{name:"updateCurrentWeights",accounts:[{name:"fundState",isMut:!0,isSigner:!1},{name:"tokenInfo",isMut:!1,isSigner:!1}],args:[]},{name:"buyStateRebalance",accounts:[{name:"fundState",isMut:!0,isSigner:!1},{name:"buyState",isMut:!0,isSigner:!1},{name:"tokenInfo",isMut:!1,isSigner:!1},{name:"pythToken",isMut:!1,isSigner:!1},{name:"pythUsdc",isMut:!1,isSigner:!1},{name:"pdaAccount",isMut:!1,isSigner:!1},{name:"pdaTokenAccount",isMut:!0,isSigner:!1},{name:"pdaUsdcAccount",isMut:!0,isSigner:!1},{name:"rebalanceFeeAccount",isMut:!0,isSigner:!1},{name:"prismProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"tokenId",type:"u8"},{name:"instructionId",type:{array:["u8",8]}},{name:"instructionSize",type:"u8"},{name:"instructionData",type:{array:["u8",28]}}]},{name:"rebalanceToUsdc",accounts:[{name:"signer",isMut:!0,isSigner:!0},{name:"fundState",isMut:!0,isSigner:!1},{name:"tokenInfo",isMut:!1,isSigner:!1},{name:"pythToken",isMut:!1,isSigner:!1},{name:"pythUsdc",isMut:!1,isSigner:!1},{name:"pdaAccount",isMut:!1,isSigner:!1},{name:"pdaTokenAccount",isMut:!0,isSigner:!1},{name:"pdaUsdcAccount",isMut:!0,isSigner:!1},{name:"rebalanceFeeAccount",isMut:!0,isSigner:!1},{name:"prismProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"tokenId",type:"u8"},{name:"maxAmountToSell",type:"u64"},{name:"instructionId",type:{array:["u8",8]}},{name:"instructionSize",type:"u8"},{name:"instructionData",type:{array:["u8",28]}}]},{name:"rebalanceFromUsdc",accounts:[{name:"signer",isMut:!0,isSigner:!0},{name:"fundState",isMut:!0,isSigner:!1},{name:"tokenInfo",isMut:!1,isSigner:!1},{name:"pythToken",isMut:!1,isSigner:!1},{name:"pythUsdc",isMut:!1,isSigner:!1},{name:"pdaAccount",isMut:!1,isSigner:!1},{name:"pdaTokenAccount",isMut:!0,isSigner:!1},{name:"pdaUsdcAccount",isMut:!0,isSigner:!1},{name:"rebalanceFeeAccount",isMut:!0,isSigner:!1},{name:"prismProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"tokenId",type:"u8"},{name:"maxAmountToSpend",type:"u64"},{name:"instructionId",type:{array:["u8",8]}},{name:"instructionSize",type:"u8"},{name:"instructionData",type:{array:["u8",28]}}]},{name:"reweight",accounts:[{name:"signer",isMut:!0,isSigner:!0},{name:"fundState",isMut:!0,isSigner:!1},{name:"tokenStats",isMut:!1,isSigner:!1}],args:[]},{name:"refilter",accounts:[{name:"signer",isMut:!0,isSigner:!0},{name:"fundState",isMut:!0,isSigner:!1},{name:"tokenStats",isMut:!1,isSigner:!1}],args:[]},{name:"addToken",accounts:[{name:"owner",isMut:!0,isSigner:!0},{name:"tokenInfo",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[{name:"tokenMint",type:"publicKey"},{name:"pdaTokenAccount",type:"publicKey"},{name:"coingeckoId",type:{array:["u8",30]}},{name:"pyth",type:"publicKey"},{name:"decimals",type:"u8"},{name:"index",type:"u8"}]},{name:"updateDatabase",accounts:[{name:"owner",isMut:!0,isSigner:!0},{name:"database",isMut:!0,isSigner:!1}],args:[{name:"tokenId",type:"u64"},{name:"price",type:"u64"},{name:"circulatingSupply",type:"u64"},{name:"volume",type:"u64"},{name:"timestamp",type:"u64"}]},{name:"updateTokenStats",accounts:[{name:"owner",isMut:!0,isSigner:!0},{name:"tokenStats",isMut:!0,isSigner:!1},{name:"database",isMut:!1,isSigner:!1}],args:[{name:"startIndex",type:"u8"},{name:"endIndex",type:"u8"}]},{name:"updateCurveData",accounts:[{name:"owner",isMut:!0,isSigner:!0},{name:"curveData",isMut:!0,isSigner:!1}],args:[{name:"startIndex",type:"u8"},{name:"endIndex",type:"u8"},{name:"priceData",type:{array:[{array:[{array:[{array:["u64",2]},10]},2]},3]}}]},{name:"initializeTokenInfo",accounts:[{name:"owner",isMut:!0,isSigner:!0},{name:"tokenInfo",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[]},{name:"initializeDatabase",accounts:[{name:"owner",isMut:!0,isSigner:!0},{name:"database",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[]},{name:"initializeTokenStats",accounts:[{name:"owner",isMut:!0,isSigner:!0},{name:"tokenStats",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[]},{name:"initializeCurveData",accounts:[{name:"owner",isMut:!0,isSigner:!0},{name:"curveData",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[]},{name:"closeDatabase",accounts:[{name:"owner",isMut:!0,isSigner:!0},{name:"database",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[]},{name:"closeTokenStats",accounts:[{name:"owner",isMut:!0,isSigner:!0},{name:"tokenStats",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[]},{name:"closeTokenInfo",accounts:[{name:"owner",isMut:!0,isSigner:!0},{name:"tokenInfo",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[]},{name:"closeToken",accounts:[{name:"owner",isMut:!0,isSigner:!0},{name:"pdaAccount",isMut:!1,isSigner:!1},{name:"tokenAccount",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[]},{name:"closeOpenOrders",accounts:[{name:"owner",isMut:!0,isSigner:!0},{name:"pdaAccount",isMut:!0,isSigner:!1},{name:"openOrders",isMut:!0,isSigner:!1},{name:"market",isMut:!1,isSigner:!1},{name:"serumDex",isMut:!1,isSigner:!1},{name:"serumSwapProgram",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[]}],accounts:[{name:"fundState",type:{kind:"struct",fields:[{name:"version",type:"u64"},{name:"manager",type:"publicKey"},{name:"fundToken",type:"publicKey"},{name:"managerFee",type:"u64"},{name:"supplyOutsanding",type:"u64"},{name:"activelyManaged",type:"u64"},{name:"activeBuyStates",type:"u64"},{name:"sellState",type:"u64"},{name:"rebalanceSellState",type:"u64"},{name:"hostPubkey",type:"publicKey"},{name:"hostFee",type:"u64"},{name:"numOfTokens",type:"u64"},{name:"currentCompToken",type:{array:["u64",20]}},{name:"currentCompAmount",type:{array:["u64",20]}},{name:"lastRebalanceTime",type:{array:["u64",20]}},{name:"targetWeight",type:{array:["u64",20]}},{name:"weightSum",type:"u64"},{name:"currentWeight",type:{array:["u64",20]}},{name:"fundWorth",type:"u64"},{name:"lastUpdateTime",type:"u64"},{name:"refilterInterval",type:"u64"},{name:"reweightInterval",type:"u64"},{name:"rebalanceInterval",type:"u64"},{name:"rebalanceThreshold",type:"u64"},{name:"rebalanceSlippage",type:"u64"},{name:"lpOffsetThreshold",type:"u64"},{name:"lastRefilterTime",type:"u64"},{name:"lastReweightTime",type:"u64"},{name:"rulesReady",type:"u64"},{name:"assetPool",type:{array:["u64",200]}},{name:"numOfRules",type:"u64"},{name:"rules",type:{array:[{defined:"Rule"},20]}},{name:"numRuleTokens",type:"u64"},{name:"ruleTokens",type:{array:["u64",20]}},{name:"ruleTokenWeights",type:{array:["u64",20]}},{name:"messageDigestFive",type:{array:["u8",16]}},{name:"fundLpFee",type:"u64"},{name:"symmetryLpFee",type:"u64"},{name:"extraBytes",type:{array:["u64",96]}}]}},{name:"buyState",type:{kind:"struct",fields:[{name:"fund",type:"publicKey"},{name:"buyer",type:"publicKey"},{name:"fundManager",type:"publicKey"},{name:"hostPlatform",type:"publicKey"},{name:"buyerFundTokenAccount",type:"publicKey"},{name:"usdcContributed",type:"u64"},{name:"usdcLeft",type:"u64"},{name:"token",type:{array:["u64",20]}},{name:"amountToSpend",type:{array:["u64",20]}},{name:"amountBought",type:{array:["u64",20]}},{name:"creationTimestamp",type:"u64"},{name:"contributedValue",type:"u64"}]}},{name:"tokenInfo",type:{kind:"struct",fields:[{name:"numTokens",type:"u64"},{name:"tokenMint",type:{array:["publicKey",200]}},{name:"pdaTokenAccount",type:{array:["publicKey",200]}},{name:"coingeckoIds",type:{array:[{array:["u8",30]},200]}},{name:"pyth",type:{array:["publicKey",200]}},{name:"decimals",type:{array:["u8",200]}}]}},{name:"database",type:{kind:"struct",fields:[{name:"data",type:{array:[{defined:"TokenData"},200]}},{name:"numberOfTokens",type:"u64"}]}},{name:"tokenStats",type:{kind:"struct",fields:[{name:"stats",type:{array:[{array:[{defined:"Stats"},6]},200]}}]}},{name:"prismData",type:{kind:"struct",fields:[{name:"buy",type:{array:[{defined:"TokenPriceData"},200]}},{name:"sell",type:{array:[{defined:"TokenPriceData"},200]}}]}}],types:[{name:"Rule",type:{kind:"struct",fields:[{name:"filterBy",type:"u64"},{name:"filterDays",type:"u64"},{name:"sortBy",type:"u64"},{name:"totalWeight",type:"u64"},{name:"fixedAsset",type:"u64"},{name:"numAssets",type:"u64"},{name:"weightBy",type:"u64"},{name:"weightDays",type:"u64"},{name:"weightExpo",type:"i64"},{name:"excludeNum",type:"u64"},{name:"excludeAssets",type:{array:["u64",10]}},{name:"ruleAssets",type:{array:["u64",20]}}]}},{name:"TokenData",type:{kind:"struct",fields:[{name:"price",type:{array:["u64",460]}},{name:"circulatingSupply",type:{array:["u64",460]}},{name:"volume",type:{array:["u64",460]}},{name:"timestamp",type:{array:["u64",460]}},{name:"index",type:"u64"}]}},{name:"Stats",type:{kind:"struct",fields:[{name:"days",type:"u64"},{name:"performance",type:"u64"},{name:"volume",type:"u64"},{name:"mcap",type:"u64"}]}},{name:"TokenPriceData",type:{kind:"struct",fields:[{name:"amount",type:{array:["u64",10]}},{name:"price",type:{array:["u64",10]}}]}},{name:"PriceStatus",type:{kind:"enum",variants:[{name:"Unknown"},{name:"Trading"},{name:"Halted"},{name:"Auction"}]}},{name:"CorpAction",type:{kind:"enum",variants:[{name:"NoCorpAct"}]}},{name:"PriceType",type:{kind:"enum",variants:[{name:"Unknown"},{name:"Price"},{name:"TWAP"},{name:"Volatility"}]}}],errors:[{code:6e3,name:"AlreadySet",msg:"Rules are already set"},{code:6001,name:"IncorrectPdaUsdcAccount",msg:"Incorrect pda_usdc_account"},{code:6002,name:"IncorrectPythAccount",msg:"Incorrect pyth account provided"},{code:6003,name:"IncorrectSellState",msg:"Fund_state is provided instead of sell_state"},{code:6004,name:"IncorrectPdaTokenAccount",msg:"Incorrect pda_token_account"},{code:6005,name:"UpdateCurrentWeights",msg:"Current weights need to be updated"},{code:6006,name:"TimeHasntPassed",msg:"Enough time hasn't passed yet"},{code:6007,name:"InThreshold",msg:"weight is in rebalance threshold"},{code:6008,name:"MoreThan20Assets",msg:"Number of Assets must be less or equal to 20"},{code:6009,name:"ConstraintError",msg:"Constraint error"},{code:6010,name:"NotActivelyManaged",msg:"Fund isn't actively managed"},{code:6011,name:"IncorrectSmfFeeAccount",msg:"Incorrect smf_fee_account"},{code:6012,name:"ExpoRangeError",msg:"Expo must be in [0;1] range"},{code:6013,name:"NoRefilterAndReweightForSellState",msg:"Refilter or Reweight shouldn't be called for sell_state"},{code:6014,name:"IncorrectRebalanceFeeAccount",msg:"Incorrect rebalance_fee_account"},{code:6015,name:"TokenIsAlreadyBought",msg:"Rebalance function already bought this token"},{code:6016,name:"FundStateMustBeUpdated",msg:"Fund state must be updated"},{code:6017,name:"RuleWeightLimitError",msg:"Rule weight is more than 1000"},{code:6018,name:"IntervalLimitsAreIncorrect",msg:"Refilter, Reweight or Rebalance interval limits are incorrect"},{code:6019,name:"SlippageError",msg:"Swap Exceeded FundState Rebalance Slippage"},{code:6020,name:"TokenIsntPresentInState",msg:"Passed token is not present in buy_state"},{code:6021,name:"LessTokenInFund",msg:"There are less free tokens Tokens in fund_state than buyer wants"},{code:6022,name:"UsdcIsntEnough",msg:"USDC worth is less than token worth"},{code:6023,name:"ExceedsTargetWeight",msg:"Token weight after swap exceeds target weight"},{code:6024,name:"FundWorthDecreasing",msg:"Fund worth fill decrease after swap"},{code:6025,name:"SlippageExceeded",msg:"Swap slippage exceeded"},{code:6026,name:"IncorrectManagerAccount",msg:"manager_usdc_account doesnt belong to manager"},{code:6027,name:"WrongSigner",msg:"Sell state rebalance should be executed by manager"},{code:6028,name:"ClaimTokens",msg:"Only ClaimTokens function is available on this sellState"},{code:6029,name:"FilterOrWeightByError",msg:"filter_by and weight_by should be in [0;3] range"},{code:6030,name:"FilterOrWeightDaysError",msg:"filter_days and weight_days should be in [0;5] range"},{code:6031,name:"SortByError",msg:"sort_by must be 0 or 1"},{code:6032,name:"IncorrectRefferalFeeAccount",msg:"Incorrect refferal USDC account"},{code:6033,name:"IncorrectTokenAccount",msg:"Incorrect Buyer Token account"},{code:6034,name:"TokenStatsShouldBeUpdated",msg:"To call refilter/reweight function token stats must be updated"},{code:6035,name:"SellState",msg:"Fund is a SellState"},{code:6036,name:"ProgramFreezed",msg:"Program is freezed. Contact developer support."},{code:6037,name:"TvlLimitReached",msg:"TVL Limit reached as symmetry funds are in beta mode."},{code:6038,name:"BuyLimit",msg:"Max allowed contribution is limited to 5000 USDC"},{code:6039,name:"PythStatus",msg:"Pyth status should be Trading"},{code:6040,name:"PythConfidence",msg:"Pyth status should be Trading"},{code:6041,name:"PythNegativePrice",msg:"Pyth price can not be negative"},{code:6042,name:"AssetPool",msg:"Asset Pool shouldn't contain repeating tokens and should contain USDC"},{code:6043,name:"InvalidInstructionData",msg:"Invalid instruction data was provided"},{code:6044,name:"NotAssociatedTokenAccount",msg:"Fee account is not associated"},{code:6045,name:"CouldNotSwap",msg:"Could not swap enough amount"},{code:6046,name:"IncorrectTokenId",msg:"Incorrect token Id"},{code:6047,name:"FixedRule",msg:"Fixed rule should contain only 1 asset"},{code:6048,name:"FundIsActive",msg:"Fund is still active"},{code:6049,name:"BuyStateIsBeingClaimed",msg:"Buy state is being claimed"},{code:6050,name:"AssetPoolContainsOfflinePythToken",msg:"Asset pool contains token with offline pyth status"}]},C,to),oo=new e("4Rn7pKKyiSNKZXKCoLqEpRznX1rhveV4dW1DCg6hRoVH"),io=new e("4QMjSHuM3iS7Fdfi8kZJfHRKoEJSDHEtEwqbChsTcUVK"),ao=new e("AWfpfzA6FYbqx4JLz75PDgsjH7jtBnnmJ6MXW5zNY2Ei"),so=new e("BLBYiq48WcLQ5SxiftyKmPtmsZPUBEnDEjqEnKGAR4zx"),ro={pubkey:Q,isSigner:!1,isWritable:!1};function uo(e,t,n,o,i,a,s,r){return R.instruction.route(n,i,a,s,r,{accounts:{tokenProgram:L,userTransferAuthority:e,destinationTokenAccount:t},remainingAccounts:o})}function co(e,t,n,o){return{swapProgram:pe,swapState:e.ammId,tokenProgram:L,poolAuthority:e.authority,userTransferAuthority:o,sourceTokenAccount:t,destinationTokenAccount:n}}const[mo]=B([new Uint8Array(Buffer.from("amm authority".replace(" "," "),"utf-8"))],le);function po(e,t,n,o){if(!e.serumMarketKeys)throw new Error("RaydiumAmm is missing serumMarketKeys");return{swapProgram:le,tokenProgram:L,ammId:e.ammId,ammAuthority:mo,ammOpenOrders:e.ammOpenOrders,poolCoinTokenAccount:e.poolCoinTokenAccount,poolPcTokenAccount:e.poolPcTokenAccount,serumProgramId:e.serumProgramId,serumMarket:e.serumMarket,serumBids:e.serumMarketKeys.serumBids,serumAsks:e.serumMarketKeys.serumAsks,serumEventQueue:e.serumMarketKeys.serumEventQueue,serumCoinVaultAccount:e.serumMarketKeys.serumCoinVaultAccount,serumPcVaultAccount:e.serumMarketKeys.serumPcVaultAccount,serumVaultSigner:e.serumMarketKeys.serumVaultSigner,userSourceTokenAccount:t,userDestinationTokenAccount:n,userSourceOwner:o}}function lo(e,t,n,i,a,s){const r=F([e.address.toBuffer(),e.decoded.vaultSignerNonce.toArrayLike(Buffer,"le",8)],e.programId);return{market:{market:e.address,openOrders:t,requestQueue:e.decoded.requestQueue,eventQueue:e.decoded.eventQueue,bids:e.bidsAddress,asks:e.asksAddress,coinVault:e.decoded.baseVault,pcVault:e.decoded.quoteVault,vaultSigner:r},authority:s,orderPayerTokenAccount:n,coinWallet:i,pcWallet:a,dexProgram:e.programId,tokenProgram:L,rent:o}}function ho(e,t,n,o,i){const a=t.equals(e.state.tokenA.mint)?e.state.tokenB.adminFeeAccount:e.state.tokenA.adminFeeAccount,[s,r]=t.equals(e.state.tokenA.mint)?[e.state.tokenA.reserve,e.state.tokenB.reserve]:[e.state.tokenB.reserve,e.state.tokenA.reserve];return{swapProgram:e.config.swapProgramID,tokenProgram:L,swap:e.config.swapAccount,swapAuthority:e.config.authority,userAuthority:i,inputUserAccount:n,inputTokenAccount:s,outputUserAccount:o,outputTokenAccount:r,feesTokenAccount:a}}function go(e,t){const n=[];return n.push(e?{pubkey:e,isSigner:!1,isWritable:!0}:t?{pubkey:t,isSigner:!1,isWritable:!0}:ro),n}const ko=new D(0);class fo{constructor(e,t){this.numerator=void 0,this.denominator=void 0,this.toString=()=>`${this.numerator.toString()}/${this.denominator.toString()}`,this.numerator=e,this.denominator=t}static fromDecimal(e){return fo.fromFraction(e.toDecimalPlaces(1).mul(10).toNumber(),1e3)}static fromFraction(e,t){const n="number"==typeof e?new D(e.toString()):e,o="number"==typeof t?new D(t.toString()):t;return new fo(n,o)}toDecimal(){return this.denominator.eq(ko)?new nt(0):new nt(this.numerator.toString()).div(new nt(this.denominator.toString()))}add(e){const t=this.denominator.gcd(e.denominator),n=this.denominator.div(t).mul(e.denominator),o=n.div(this.denominator),i=n.div(e.denominator),a=this.numerator.mul(o),s=e.numerator.mul(i),r=a.add(s);return new fo(new D(r.toString()),new D(n.toString()))}}const So=Qe([In("tradeFeeNumerator"),In("tradeFeeDenominator"),In("ownerTradeFeeNumerator"),In("ownerTradeFeeDenominator"),In("ownerWithdrawFeeNumerator"),In("ownerWithdrawFeeDenominator")],"fees"),Ao=[je(8,"padding"),Pn("lpTokenFreezeVault"),Pn("poolMint"),Pn("baseTokenVault"),Pn("baseTokenMint"),Pn("quoteTokenVault"),Pn("quoteTokenMint"),Pn("poolSigner"),Xe("poolSignerNonce"),Pn("authority"),Pn("initializerAccount"),Pn("feeBaseAccount"),Pn("feeQuoteAccount"),Pn("feePoolTokenAccount"),So],yo=Qe(Ao),Mo=Qe([...Ao,Xe("curveType"),Pn("curve")]),wo=Qe([je(8,"padding"),In("amp")]);function To(e,t){const n=!!t.owner.equals(V),o=(n?Mo:yo).decode(t.data),i="curveType"in o?{curveType:o.curveType,curve:o.curve}:{};return{isV2:n,address:e,poolMint:o.poolMint,baseTokenVault:o.baseTokenVault,baseTokenMint:o.baseTokenMint,quoteTokenVault:o.quoteTokenVault,quoteTokenMint:o.quoteTokenMint,poolSigner:o.poolSigner,feeBaseAccount:o.feeBaseAccount,feeQuoteAccount:o.feeQuoteAccount,feePoolTokenAccount:o.feePoolTokenAccount,fees:{traderFee:fo.fromFraction(o.fees.tradeFeeNumerator,o.fees.tradeFeeDenominator),ownerFee:fo.fromFraction(o.fees.ownerTradeFeeNumerator,o.fees.ownerTradeFeeDenominator)},...i}}class vo{constructor(e,t,n){if(this.params=void 0,this.id=void 0,this.label="Aldrin",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.poolState=void 0,this.tokenReserveAmounts=void 0,this.calculator=void 0,this.params=n,this.poolState=To(e,t),this.id=e.toBase58(),1===this.poolState.curveType){const{amp:e}=this.params;if(!e)throw new Error("Amp is required for a stable curve");this.calculator=new g(v.BigInt(e),new k(v.BigInt(this.poolState.fees.traderFee.numerator.toString()),v.BigInt(this.poolState.fees.traderFee.denominator.toString())),new k(v.BigInt(this.poolState.fees.ownerFee.numerator.toString()),v.BigInt(this.poolState.fees.ownerFee.denominator.toString())))}else this.calculator=new f(new k(v.BigInt(this.poolState.fees.traderFee.numerator.toString()),v.BigInt(this.poolState.fees.traderFee.denominator.toString())),new k(v.BigInt(this.poolState.fees.ownerFee.numerator.toString()),v.BigInt(this.poolState.fees.ownerFee.denominator.toString())))}static decodeStableCurveAmp(e){const{amp:t}=wo.decode(e.data);return 2*t.toNumber()}getAccountsForUpdate(){return[this.poolState.quoteTokenVault,this.poolState.baseTokenVault]}update(e){const t=Mn(e,this.getAccountsForUpdate());this.tokenReserveAmounts=wn(t)}getQuote({sourceMint:e,amount:t}){if(!this.tokenReserveAmounts)throw new Error("Missing tokenReserveAmounts");let n=new nt(this.poolState.fees.traderFee.numerator.toString()).div(this.poolState.fees.traderFee.denominator.toString()).add(new nt(this.poolState.fees.ownerFee.numerator.toString()).div(this.poolState.fees.ownerFee.denominator.toString()));const o=this.poolState.baseTokenMint.equals(e)?0:1;let i=this.calculator.exchange(this.tokenReserveAmounts,t,o);return{notEnoughLiquidity:!1,inAmount:t,outAmount:i.expectedOutputAmount,feeAmount:i.fees,feeMint:e.toBase58(),feePct:n.toNumber(),priceImpactPct:i.priceImpact.toNumber()}}getSwapLegAndAccounts(e){if(this.poolState.isV2){if(!this.poolState.curve)throw new Error("Unable to fetch curve account.");return function({poolState:e,sourceMint:t,userSourceTokenAccount:n,userDestinationTokenAccount:o,curve:i,userTransferAuthority:a}){const[s,r,u]=t.equals(e.baseTokenMint)?[On.Ask,n,o]:[On.Bid,o,n];return[_n(Nn(s)),R.instruction.aldrinV2Swap({accounts:{swapProgram:V,pool:e.address,poolSigner:e.poolSigner,poolMint:e.poolMint,baseTokenVault:e.baseTokenVault,quoteTokenVault:e.quoteTokenVault,feePoolTokenAccount:e.feePoolTokenAccount,walletAuthority:a,userBaseTokenAccount:r,userQuoteTokenAccount:u,curve:i,tokenProgram:L}}).keys]}({poolState:this.poolState,curve:this.poolState.curve,...e})}return function({poolState:e,sourceMint:t,userSourceTokenAccount:n,userDestinationTokenAccount:o,userTransferAuthority:i}){const[a,s,r]=t.equals(e.baseTokenMint)?[On.Ask,n,o]:[On.Bid,o,n];return[_n(Rn(a)),R.instruction.aldrinSwap({accounts:{swapProgram:N,pool:e.address,poolSigner:e.poolSigner,poolMint:e.poolMint,baseTokenVault:e.baseTokenVault,quoteTokenVault:e.quoteTokenVault,feePoolTokenAccount:e.feePoolTokenAccount,walletAuthority:i,userBaseTokenAccount:s,userQuoteTokenAccount:r,tokenProgram:L}}).keys]}({poolState:this.poolState,...e})}get reserveTokenMints(){return[this.poolState.quoteTokenMint,this.poolState.baseTokenMint]}}vo.accountInfoToAldrinPoolState=To;const Po={version:"0.1.0",name:"balancer_amm",instructions:[{name:"swap",accounts:[{name:"authority",isMut:!0,isSigner:!0},{name:"pool",isMut:!0,isSigner:!1},{name:"taxMan",isMut:!0,isSigner:!1},{name:"bidMint",isMut:!1,isSigner:!1},{name:"treasurer",isMut:!1,isSigner:!1},{name:"srcTreasury",isMut:!0,isSigner:!1},{name:"srcAssociatedTokenAccount",isMut:!0,isSigner:!1},{name:"askMint",isMut:!1,isSigner:!1},{name:"dstTreasury",isMut:!0,isSigner:!1},{name:"dstAssociatedTokenAccount",isMut:!0,isSigner:!1},{name:"dstTokenAccountTaxman",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"associatedTokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[{name:"bidAmount",type:"u64"},{name:"limit",type:"u64"}],returns:"u64"}],accounts:[{name:"pool",type:{kind:"struct",fields:[{name:"authority",type:"publicKey"},{name:"fee",type:"u64"},{name:"taxFee",type:"u64"},{name:"state",type:{defined:"PoolState"}},{name:"mintLpt",type:"publicKey"},{name:"taxMan",type:"publicKey"},{name:"mints",type:{vec:"publicKey"}},{name:"actions",type:{vec:{defined:"MintActionState"}}},{name:"treasuries",type:{vec:"publicKey"}},{name:"reserves",type:{vec:"u64"}},{name:"weights",type:{vec:"u64"}}]}}],types:[{name:"PoolState",type:{kind:"enum",variants:[{name:"Uninitialized"},{name:"Initialized"},{name:"Frozen"},{name:"Deleted"}]}},{name:"MintActionState",type:{kind:"enum",variants:[{name:"Active"},{name:"BidOnly"},{name:"AskOnly"},{name:"Paused"}]}}],errors:[]},bo=(e,t)=>{const n=e.map((e=>e.toNumber()/1e9));return t.toNumber()/1e9/n.reduce(((e,t)=>e+t),0)},Io=(e,t)=>{const{balanceIn:n,balanceOut:o,weightIn:i,weightOut:a,swapFee:s}=t,r=Number(n.toString()),u=Number(o.toString()),c=i,m=a,d=Number(s.toString())/1e9;return-r*m/(u*(-1+d)*(r/(e+r-e*d))**((c+m)/m)*c)},Bo=new Je(Po);class Fo{constructor(e,t){this.address=void 0,this.label="Balansol",this.id=void 0,this.shouldPrefetch=!0,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.poolData=void 0,this.address=e,this.id=e.toBase58(),this.poolData=Bo.decode("pool",t.data)}getAccountsForUpdate(){return[new e(this.id)]}update(e){let[t]=Mn(e,this.getAccountsForUpdate());const n=Bo.decode("pool",t.data);this.poolData=n}getQuote({sourceMint:e,destinationMint:t,amount:n}){var o,i;if(!this.poolData)throw new Error(`Invalid pool data ${this.address.toBase58()}`);if(!this.poolData.state.initialized)throw new Error(`Pool is not initialized ${this.address.toBase58()}`);const a=this.poolData.mints.map((e=>e.toBase58())),s=a.indexOf(e.toBase58()),r=a.indexOf(t.toBase58());if(null===(o=this.poolData.actions[s])||void 0===o||!o.active)throw new Error(`Invalid bid mint state ${this.address.toBase58()}`);if(null===(i=this.poolData.actions[r])||void 0===i||!i.active)throw new Error(`Invalid ask mint state ${this.address.toBase58()}`);const u=bo(this.poolData.weights,this.poolData.weights[s]),c=bo(this.poolData.weights,this.poolData.weights[r]),m=((e,t,n,o,i,a)=>{const s=Number(t.toString()),r=Number(n.toString());return s*(1-(r/(r+e))**(i/o))*(1-Number(a.toString())/1e9)})(Number(n.toString()),this.poolData.reserves[r],this.poolData.reserves[s],c,u,this.poolData.fee.add(this.poolData.taxFee)),d=((e,t)=>{const n=Io(0,t),o=Io(e,t);return o<n?0:1-n/o})(Number(n.toString()),{balanceIn:this.poolData.reserves[s],balanceOut:this.poolData.reserves[r],weightIn:u,weightOut:c,swapFee:this.poolData.fee.add(this.poolData.taxFee)}),p=this.poolData.fee.add(this.poolData.taxFee).toNumber()/10**9,l=m/(1-p)*p;return{notEnoughLiquidity:!1,inAmount:n,outAmount:v.BigInt(Math.floor(m)),feeAmount:v.BigInt(Math.floor(l)),feeMint:t.toBase58(),feePct:0,priceImpactPct:d}}getSwapLegAndAccounts(t){var i;if(!this.poolData)throw new Error(`Invalid pool data ${this.address.toBase58()}`);const a=this.poolData.mints.findIndex((e=>e.equals(t.sourceMint))),s=this.poolData.mints.findIndex((e=>e.equals(t.destinationMint))),[r]=e.findProgramAddressSync([Buffer.from("treasurer"),this.address.toBuffer()],ne),u=ce({tokenMintAddress:t.destinationMint,walletAddress:this.poolData.taxMan});return function({additionalArgs:e,userSourceTokenAccount:t,userDestinationTokenAccount:i,userTransferAuthority:a,sourceMint:s,destinationMint:r}){return[_n({balansol:{}}),R.instruction.balansolSwap({accounts:{swapProgram:ne,authority:a,pool:e.pool,taxMan:e.taxMan,bidMint:s,treasurer:e.treasurer,srcTreasury:e.srcTreasury,srcAssociatedTokenAccount:t,askMint:r,dstTreasury:e.dstTreasury,dstAssociatedTokenAccount:i,dstTokenAccountTaxman:e.dstTokenAccountTaxman,systemProgram:n.programId,tokenProgram:L,associatedTokenProgram:x,rent:o},remainingAccounts:e.referrer?[{pubkey:e.referrer,isSigner:!1,isWritable:!0}]:[ro]}).keys]}({...t,additionalArgs:{pool:this.address,taxMan:this.poolData.taxMan,dstTokenAccountTaxman:u,treasurer:r,srcTreasury:this.poolData.treasuries[a],dstTreasury:this.poolData.treasuries[s],referrer:null===(i=t.quoteMintToReferrer)||void 0===i?void 0:i.get(t.destinationMint.toBase58())}})}get reserveTokenMints(){return this.poolData.mints}}Fo.getIDL=()=>Po;const Do=new Ge(ut);class Lo{constructor(e,t,n){this.address=void 0,this.id=void 0,this.label="Crema",this.shouldPrefetch=!0,this.exactOutputSupported=!1,this.hasDynamicAccounts=!0,this.clmmpoolData=void 0,this.reserveTokenDecimals=void 0,this.tickArrayMapPubkey=void 0,this.feeRate=void 0,this.tickArrayMap=void 0,this.tickArrayPubkeys=[],this.tickArrays=[],this.arrayStartIndex=void 0,this.swapTicks=void 0,this.address=e,this.id=e.toBase58(),this.clmmpoolData=Do.accounts.decode("clmmpool",t.data),this.feeRate=this.clmmpoolData.feeRate,this.tickArrayMapPubkey=ot.getTickArrayMapPDA(re,e).publicKey,this.reserveTokenDecimals=[n.decimalA,n.decimalB],this.arrayStartIndex=0}getAccountsForUpdate(){return[this.address,this.tickArrayMapPubkey,...this.tickArrayPubkeys]}update(e){const t=e.get(this.address.toBase58());if(!t)throw new Error(`Missing poolData ${this.address.toBase58()}`);this.clmmpoolData=Do.accounts.decode("clmmpool",t.data),this.feeRate=this.clmmpoolData.feeRate;const n=e.get(this.tickArrayMapPubkey.toBase58());if(!n)throw new Error(`Missing tickArrayMap ${this.tickArrayMapPubkey.toBase58()}`);const o=Do.accounts.decode("tickArrayMap",n.data);this.tickArrayPubkeys=this.getTickArrayPubkeys(this.address,o),this.tickArrayMap=o;const i=it.getArrayIndex(this.clmmpoolData.currentTickIndex,this.clmmpoolData.tickSpacing);let a=!1;const s=[];for(let t=0;t<this.tickArrayPubkeys.length;t++){const n=e.get(this.tickArrayPubkeys[t].toBase58());if(n){const e=Do.accounts.decode("tickArray",n.data);!1===a&&e.arrayIndex>=i&&(a=!0,this.arrayStartIndex=t),s.push({address:this.tickArrayPubkeys[t],data:e})}}this.tickArrays=s;const r={aToB:[],bToA:[]};for(let e=this.arrayStartIndex;e>this.arrayStartIndex-3;e--){let t=this.tickArrays[e];t&&r.aToB.push(t)}for(let e=this.arrayStartIndex;e<this.arrayStartIndex+3;e++){let t=this.tickArrays[e];t&&r.bToA.push(t)}this.swapTicks={aToB:[],bToA:[]},[r.aToB,r.bToA].forEach(((e,t)=>{for(let n=0;n<e.length;n++){const o=e[n];if(0===t)for(let e=at-1;e>=0;e--)o.data&&o.data.ticks[e].isInitialized&&this.swapTicks.aToB.push(o.data.ticks[e]);else for(let e=0;e<at;e++)o.data&&o.data.ticks[e].isInitialized&&this.swapTicks.bToA.push(o.data.ticks[e])}}))}getTickArrayPubkeys(e,t){let n=[];for(let e=0;e<868;e++){let o=t.bitmap[e];for(let e=0;e<8;e++)n.push((o>>e&1)>0)}const o=[];for(let t=0;t<n.length;t++)if(n[t]){const n=ot.getTickArrayPDA(re,e,t).publicKey;o.push(n)}return o}getQuote(e){let t,n,o;if(!this.swapTicks)throw new Error("swapTicks is not initialized");"ExactIn"===e.swapMode?(t=e.destinationMint,o=!0):(t=e.sourceMint,o=!1),n=!!e.sourceMint.equals(this.reserveTokenMints[0]);const i=new E(e.amount.toString()),a=st(n,o,i,this.clmmpoolData,this.swapTicks[n?"aToB":"bToA"]),s=rt.sqrtPriceX64ToPrice(this.clmmpoolData.currentSqrtPrice,this.reserveTokenDecimals[0],this.reserveTokenDecimals[1]).toNumber(),r=rt.sqrtPriceX64ToPrice(a.nextSqrtPrice,this.reserveTokenDecimals[0],this.reserveTokenDecimals[1]).toNumber();let u=!1;if(u=o?a.amountIn.lt(i):a.amountOut.lt(i),u)throw new Error("not enough liquidity");return{notEnoughLiquidity:u,inAmount:v.BigInt(a.amountIn),outAmount:v.BigInt(a.amountOut),feeMint:t.toString(),feeAmount:v.multiply(v.BigInt(e.amount),v.BigInt(this.feeRate)),feePct:this.feeRate,priceImpactPct:Math.abs(s-r)/s}}getSwapLegAndAccounts(e){let t,n;if(!this.swapTicks)throw new Error("swapTicks is not initialized");const o=ot.getClmmConfigPDA(re).publicKey;if(t=!!e.sourceMint.equals(this.reserveTokenMints[0]),n="ExactIn"===e.swapMode,!this.tickArrayMap)throw new Error("tickArrayMap is not initialized");const i=new E(e.amount.toString()),a=st(t,n,i,this.clmmpoolData,this.swapTicks[t?"aToB":"bToA"],this.address,this.tickArrayMap);return function({additionalArgs:e,userSourceTokenAccount:t,userDestinationTokenAccount:n,userTransferAuthority:o,sourceMint:i}){const{aToB:a,accountA:s,accountB:r}=i.equals(e.tokenA)?{aToB:!0,accountA:t,accountB:n}:{aToB:!1,accountA:n,accountB:t};let u=[];return e.remainingAccounts.forEach((e=>{u.push({pubkey:e,isSigner:!1,isWritable:!0})})),u.push(ro),[_n(Cn(a)),R.instruction.cremaSwap({accounts:{swapProgram:re,clmmConfig:e.clmmConfig,clmmpool:e.clmmpool,tokenA:e.tokenA,tokenB:e.tokenB,accountA:s,accountB:r,tokenAVault:e.tokenAVault,tokenBVault:e.tokenBVault,tickArrayMap:e.tickArrayMap,owner:o,partner:ue,partnerAtaA:ce({walletAddress:ue,tokenMintAddress:e.tokenA}),partnerAtaB:ce({walletAddress:ue,tokenMintAddress:e.tokenB}),tokenProgram:L},remainingAccounts:u}).keys]}({additionalArgs:{clmmConfig:o,clmmpool:this.address,tokenA:this.clmmpoolData.tokenA,tokenB:this.clmmpoolData.tokenB,tokenAVault:this.clmmpoolData.tokenAVault,tokenBVault:this.clmmpoolData.tokenBVault,tickArrayMap:this.tickArrayMapPubkey,remainingAccounts:a.swapTickArrays},...e})}get reserveTokenMints(){return[this.clmmpoolData.tokenA,this.clmmpoolData.tokenB]}}class qo{static async getStateFromStateAccount(e){const t=await e.getAccountInfo(qn);if(!t)throw new Error("State account not found");return(e=>{const t=Ln.decode(e.data);return{isInitialized:Boolean(t.isInitialized),stateOwner:t.stateOwner,feeOwner:t.feeOwner,initialSupply:t.initialSupply,returnFeeNumerator:t.returnFeeNumerator.toNumber(),fixedFeeNumerator:t.fixedFeeNumerator.toNumber(),feeDenominator:t.feeDenominator.toNumber(),curveType:t.curveType,curveParameters:t.curveParameters}})(t)}constructor(t,n,o){this.id=void 0,this.label="Cropper",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.poolState=void 0,this.tokenReserveAmounts=void 0,this.calculator=void 0,this.feePct=void 0,this.params=void 0,this.id=t.toBase58(),this.poolState=xn(t,n),this.params={...o,tokenAFeeAccount:new e(o.tokenAFeeAccount),tokenBFeeAccount:new e(o.tokenBFeeAccount)},this.feePct=new nt(this.params.fixedFeeNumerator).add(new nt(this.params.returnFeeNumerator)).div(this.params.feeDenominator),this.calculator=new f(new k(v.BigInt(this.params.fixedFeeNumerator),v.BigInt(this.params.feeDenominator)),new k(v.BigInt(this.params.returnFeeNumerator),v.BigInt(this.params.feeDenominator)))}getAccountsForUpdate(){return[this.poolState.tokenAAccount,this.poolState.tokenBAccount]}update(e){const t=Mn(e,this.getAccountsForUpdate());this.tokenReserveAmounts=wn(t)}getQuote({sourceMint:e,amount:t}){if(!this.tokenReserveAmounts)throw new Error("Missing tokenReserveAmounts");const n=this.poolState.mintA.equals(e)?1:0,o=this.calculator.exchange(this.tokenReserveAmounts,t,n);return{notEnoughLiquidity:!1,inAmount:t,outAmount:o.expectedOutputAmount,feeAmount:o.fees,feeMint:e.toBase58(),feePct:this.feePct.toNumber(),priceImpactPct:o.priceImpact.toNumber()}}getSwapLegAndAccounts(e){const t=e.sourceMint.equals(this.poolState.mintA)?this.params.tokenAFeeAccount:this.params.tokenBFeeAccount;return function({poolState:e,feeAccount:t,sourceMint:n,userSourceTokenAccount:o,userDestinationTokenAccount:i,userTransferAuthority:a}){const[s,r]=n.equals(e.mintA)?[e.tokenAAccount,e.tokenBAccount]:[e.tokenBAccount,e.tokenAAccount];return[_n({cropper:{}}),R.instruction.cropperSwap({accounts:{tokenSwapProgram:e.programId,tokenProgram:L,swap:e.ammId,swapState:qn,authority:e.authority,userTransferAuthority:a,source:o,swapSource:s,swapDestination:r,destination:i,poolMint:e.poolMint,poolFee:t}}).keys]}({poolState:this.poolState,feeAccount:t,...e})}get reserveTokenMints(){return[this.poolState.mintA,this.poolState.mintB]}}qo.decodePoolState=xn;class xo{constructor(e,t){this.program=void 0,this.pool=void 0,this.bitmapCache=void 0,this.tickCache=void 0,this.accountsToFetch={bitmaps:[],ticks:[]},this.program=e,this.pool=t,this.bitmapCache=new Map,this.tickCache=new Map}async eagerLoadCache(e,t){const n=v.toNumber(v.divide(v.BigInt(e),v.BigInt(t))),{wordPos:o}=ct(n);try{const e=[],{wordPos:n}=ct(Math.floor(mt.MIN_TICK/t)),{wordPos:a}=ct(Math.floor(mt.MAX_TICK/t)),s=Math.max(o-10,n),r=Math.min(o+10,a);for(let t=s;t<r;t++)e.push(this.getBitmapAddressSync(t));const u=await this.program.account.tickBitmapState.fetchMultiple(e),c=[];for(let n=0;n<r-s;n++){var i;const o=n+s,a=null===(i=u[n])||void 0===i?void 0:i.word,r=a?dt(a):new et(0);if(this.bitmapCache.set(o,{address:e[n],word:r}),r&&!r.eqn(0))for(let e=0;e<256;e++)if(r.shrn(e).and(new et(1)).eqn(1)){const n=this.getTickAddressSync(((o<<8)+e)*t);c.push(n)}}const m=await this.program.account.tickState.fetchMultiple(c);for(const e in c){const t=m[e];if(!t)continue;const{tick:n,liquidityNet:o}=t;this.tickCache.set(n,{address:c[e],liquidityNet:v.BigInt(o)})}}catch(e){}}lazyLoadAccountsToCache(e,t){const n=v.toNumber(v.divide(v.BigInt(e),v.BigInt(t))),{wordPos:o}=ct(n),i=[],a=[],{wordPos:s}=ct(Math.floor(mt.MIN_TICK/t)),{wordPos:r}=ct(Math.floor(mt.MAX_TICK/t)),u=Math.max(o-10,s),c=Math.min(o+10,r);for(let e=u;e<c;e++){i.push(this.getBitmapAddressSync(e));const t=this.bitmapCache.get(e);a.push(t)}const m=[];for(let e=0;e<c-u;e++){var d,p;const n=e+u,o=null!==(d=null===(p=a[e])||void 0===p?void 0:p.word)&&void 0!==d?d:new et(0);if(this.bitmapCache.set(n,{address:i[e],word:o}),o&&!o.eqn(0))for(let e=0;e<256;e++)if(o.shrn(e).and(new et(1)).eqn(1)){const o=this.getTickAddressSync(((n<<8)+e)*t);m.push(o)}}return this.accountsToFetch={bitmaps:i,ticks:m},[...i,...m]}getTick(e){let t=this.tickCache.get(e);if(!t)throw new Error("Tick not cached");return{address:t.address,liquidityNet:t.liquidityNet}}async getTickAddress(e){return this.getTickAddressSync(e)}getTickAddressSync(e){return B([pt,this.pool.token0.toBuffer(),this.pool.token1.toBuffer(),lt(this.pool.fee),lt(e)],this.program.programId)[0]}async getBitmapAddress(e){return this.getBitmapAddressSync(e)}getBitmapAddressSync(e){return B([ht,this.pool.token0.toBuffer(),this.pool.token1.toBuffer(),lt(this.pool.fee),gt(e)],this.program.programId)[0]}getBitmap(e){let t=this.bitmapCache.get(e);if(!t)throw new Error("Bitmap not cached");return t}nextInitializedTickWithinOneWord(e,t,n){let o=v.toNumber(v.divide(v.BigInt(e),v.BigInt(n)));e<0&&e%n!=0&&(o-=1),t||(o+=1);const{wordPos:i,bitPos:a}=ct(o),s=this.getBitmap(i),{next:r,initialized:u}=kt(s.word,a,t);return[ft(i,r,n),u,i,a,s.address]}updateCachedAccountInfos(e){for(const t of this.accountsToFetch.bitmaps){const n=e.get(t.toBase58());if(n){const e=this.program.coder.accounts.decode("tickBitmapState",n.data);this.bitmapCache.set(e.wordPos,{address:t,word:dt(e.word)})}}for(const t of this.accountsToFetch.ticks){const n=e.get(t.toBase58());if(n){const e=this.program.coder.accounts.decode("tickState",n.data);this.tickCache.set(e.tick,{address:t,liquidityNet:v.BigInt(e.liquidityNet)})}}}}const Oo=v.BigInt(1e6),Eo=new Ze(yt,z,to);class Co{constructor(e,t){this.address=void 0,this.label="Cykura",this.id=void 0,this.shouldPrefetch=!0,this.exactOutputSupported=!1,this.hasDynamicAccounts=!0,this.poolState=void 0,this.pool=void 0,this.tickDataProvider=void 0,this.tokens=void 0,this.vaults=void 0,this.feePct=void 0,this.fee=void 0,this.address=e,this.id=e.toBase58(),this.poolState=Eo.coder.accounts.decode("poolState",t.data);const{token0:n,token1:o,fee:i,sqrtPriceX32:a,liquidity:s,tick:r}=this.poolState;this.tickDataProvider=new xo(Eo,{token0:n,token1:o,fee:i}),this.tokens={token0:new Mt(101,n,0,"",""),token1:new Mt(101,o,0,"","")},this.pool=new St(this.tokens.token0,this.tokens.token1,i,v.BigInt(a.toString()),v.BigInt(s.toString()),r,this.tickDataProvider),this.vaults={vault0:B([this.address.toBuffer(),L.toBuffer(),n.toBuffer()],x)[0],vault1:B([this.address.toBuffer(),L.toBuffer(),o.toBuffer()],x)[0]},this.fee=v.BigInt(this.poolState.fee),this.feePct=this.poolState.fee/v.toNumber(Oo)}getAccountsForUpdate(){return[this.address,...this.tickDataProvider.lazyLoadAccountsToCache(this.pool.tickCurrent,this.pool.tickSpacing)]}update(e){const t=e.get(this.address.toBase58());if(!t)throw new Error(`Could not find poolAccountInfo ${this.address.toBase58()}`);this.poolState=Eo.coder.accounts.decode("poolState",t.data);const{fee:n,sqrtPriceX32:o,liquidity:i,tick:a}=this.poolState;this.pool=new St(this.tokens.token0,this.tokens.token1,n,v.BigInt(o.toString()),v.BigInt(i.toString()),a,this.tickDataProvider),this.tickDataProvider.updateCachedAccountInfos(e)}getQuote({sourceMint:e,amount:t}){const n=e.equals(this.poolState.token0)?this.tokens.token0:this.tokens.token1,[o,i,a]=this.pool.getOutputAmount(wt.fromRawAmount(n,t)),s=S(v.subtract(this.pool.sqrtRatioX32,i.sqrtRatioX32)).div(this.pool.sqrtRatioX32.toString());return{notEnoughLiquidity:!1,inAmount:t,outAmount:o.quotient,feeAmount:v.divide(v.multiply(t,this.fee),Oo),feeMint:e.toBase58(),feePct:this.feePct,priceImpactPct:s.toNumber()}}getSwapLegAndAccounts(e){const[t,n]=e.sourceMint.equals(this.poolState.token0)?[this.vaults.vault0,this.vaults.vault1]:[this.vaults.vault1,this.vaults.vault0],o=B([At,this.poolState.token0.toBuffer(),this.poolState.token1.toBuffer(),lt(this.poolState.fee),gt(this.poolState.observationIndex)],z)[0],i=e.sourceMint.equals(this.poolState.token0)?this.tokens.token0:this.tokens.token1,[,,a]=this.pool.getOutputAmount(wt.fromRawAmount(i,e.amount)),s=B([At,this.poolState.token0.toBuffer(),this.poolState.token1.toBuffer(),lt(this.poolState.fee),gt((this.poolState.observationIndex+1)%this.poolState.observationCardinalityNext)],z)[0],r={poolAddress:this.address,inputVault:t,outputVault:n,nextObservationState:s,lastObservationState:o,swapAccountMetas:a};return function({additionalArgs:e,userSourceTokenAccount:t,userDestinationTokenAccount:n,userTransferAuthority:o}){return[_n({cykura:{}}),R.instruction.cykuraSwap({accounts:{swapProgram:z,signer:o,factoryState:W,poolState:e.poolAddress,inputTokenAccount:t,outputTokenAccount:n,inputVault:e.inputVault,outputVault:e.outputVault,lastObservationState:e.lastObservationState,coreProgram:z,tokenProgram:L},remainingAccounts:[...e.swapAccountMetas,{pubkey:e.nextObservationState,isSigner:!1,isWritable:!0},ro]}).keys]}({...e,additionalArgs:r})}get reserveTokenMints(){return[this.poolState.token0,this.poolState.token1]}}const Ro={DkwiQyA2JfD8ARfvMbMqu2DD4XKRkewRZVDE94SZNxSS:{price:1}},No=vt(ee,to);class Vo{constructor(e,t){this.address=void 0,this.id=void 0,this.label="DeltaFi",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.swapInfo=void 0,this.feePct=void 0,this.prices=void 0,this.pythAddresses=void 0,this.address=e,this.id=e.toBase58(),this.swapInfo=No.coder.accounts.decode("SwapInfo",t.data);const{swapConfig:o}=this.swapInfo;this.feePct=o.tradeFeeNumerator/o.tradeFeeDenominator,this.pythAddresses=[this.swapInfo.pythPriceBase,this.swapInfo.pythPriceQuote].filter((e=>!n.programId.equals(e)))}getAccountsForUpdate(){return[this.address,...this.pythAddresses]}getPriceData(e,t){const{id:n}=this,o=e.get(t.toBase58())||Ro[n];if(!o)throw new Error(`Missing pyth account info for ${t.toBase58()}`);return"data"in o?Pt(o.data):o}update(e){const t=e.get(this.address.toBase58());if(!t)throw new Error(`Missing ${this.address.toBase58()}`);this.swapInfo=No.coder.accounts.decode("SwapInfo",t.data);try{const t=this.getPriceData(e,this.swapInfo.pythPriceBase),n=this.getPriceData(e,this.swapInfo.pythPriceQuote);if(t.price&&n.price){const e=new bt(t.price).dividedBy(new bt(n.price)),o=new bt(t.price+t.confidence).dividedBy(new bt(n.price-n.confidence)),i=new bt(t.price-t.confidence).dividedBy(new bt(n.price+n.confidence));this.prices={marketPrice:e,highPrice:o,lowPrice:i}}else this.prices=void 0}catch(e){this.prices=void 0}}getQuote({destinationMint:e,amount:t}){if(!this.prices)throw new Error("Missing price data from pyth");const{swapInfo:n}=this,{amountIn:o,amountOut:i,priceImpact:a}=Tt(n,e.equals(n.mintQuote)?{sellBase:{}}:{sellQuote:{}},new bt(t.toString()),this.prices.marketPrice,this.prices.highPrice,this.prices.lowPrice),s=i.multipliedBy(n.swapConfig.tradeFeeNumerator.toString()).dividedBy(n.swapConfig.tradeFeeDenominator.toString()).decimalPlaces(0),r=i.minus(s);return{notEnoughLiquidity:!1,inAmount:v.BigInt(o),outAmount:v.BigInt(r),feeAmount:v.BigInt(s),feeMint:e.toBase58(),feePct:this.feePct,priceImpactPct:Number(a)}}getSwapLegAndAccounts(e){var t;if(!this.prices)throw new Error("Missing price data from pyth");const{swapSourceToken:n,swapDestinationToken:o,adminDestinationToken:i}=this.swapInfo.mintBase.equals(e.sourceMint)?{swapSourceToken:this.swapInfo.tokenBase,swapDestinationToken:this.swapInfo.tokenQuote,adminDestinationToken:this.swapInfo.adminFeeTokenQuote}:{swapSourceToken:this.swapInfo.tokenQuote,swapDestinationToken:this.swapInfo.tokenBase,adminDestinationToken:this.swapInfo.adminFeeTokenBase};return function({additionalArgs:e,userSourceTokenAccount:t,userDestinationTokenAccount:n,userTransferAuthority:o}){return[_n((i=e.stable,{deltaFi:{stable:i}})),R.instruction.deltafiSwap({accounts:{swapProgram:ee,marketConfig:e.marketConfig,swapInfo:e.swapInfo,userSourceToken:t,userDestinationToken:n,swapSourceToken:e.swapSourceToken,swapDestinationToken:e.swapDestinationToken,deltafiUser:te,adminDestinationToken:e.adminDestinationToken,pythPriceBase:e.pythPriceBase,pythPriceQuote:e.pythPriceQuote,userAuthority:o,tokenProgram:L},remainingAccounts:e.referrer?[{pubkey:e.referrer,isSigner:!1,isWritable:!0}]:[ro]}).keys];var i}({additionalArgs:{stable:!!this.swapInfo.swapType.stableSwap,marketConfig:this.swapInfo.configKey,swapInfo:this.address,swapSourceToken:n,swapDestinationToken:o,adminDestinationToken:i,pythPriceBase:this.swapInfo.pythPriceBase,pythPriceQuote:this.swapInfo.pythPriceQuote,referrer:null===(t=e.quoteMintToReferrer)||void 0===t?void 0:t.get(e.destinationMint.toBase58())},...e})}get reserveTokenMints(){return[this.swapInfo.mintQuote,this.swapInfo.mintBase]}}const Uo=e=>D.fromBuffer(e.data.slice(64,72)),Ko=e=>D.fromBuffer(e.data.slice(36,44));function zo(e){const t=e.readBigUInt64LE();return Number(t)}function Wo(e){const t=e.readBigInt64LE(32);return Number(t)}class jo{constructor(e,t){this.address=void 0,this.id=void 0,this.label="GooseFX",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!0,this.pairLayout=void 0,this.quoter=void 0,this.gooseFxAccounts=void 0,this.fixedAccounts=void 0,this.oracleAccounts=[],this.quoteParams=void 0,this.isQuoteInvalid=!0,this.slot=void 0,this.address=e,this.id=e.toBase58(),this.pairLayout=It.decode(t.data);const[n,o]=this.pairLayout.mints,a=new Bt;this.quoter=a.getSyncQuoter(n,o),this.gooseFxAccounts=this.quoter.getAccounts();const{pairAddress:s,sslIn:r,sslOut:u,liabilityVaultIn:c,liabilityVaultOut:m,swappedLiabilityVaultIn:d,swappedLiabilityVaultOut:p}=this.gooseFxAccounts;this.fixedAccounts=[i,s,r,u,c,m,d,p],this.updateOracles()}updateOracles(){const e=Number(this.pairLayout.nOracle.toString()),t=this.pairLayout.oracles.slice(0,e).reduce(((e,t)=>{const n=Number(t.n);for(const o of t.elements.slice(0,n))e.push(o.address);return e}),[]);this.oracleAccounts=t}getAccountsForUpdate(){return[...this.fixedAccounts,...this.oracleAccounts]}isSuspended(e){if(this.quoteParams){let t=Boolean(this.quoteParams.suspended);if(void 0!==e)for(const n of this.quoteParams.publishedSlots)t||=n+this.quoteParams.maxDelay<=e;return t}return!0}update(e){var t;const[n,o,i,a,s,r,u,c]=Mn(e,this.fixedAccounts);if(!(o&&i&&a&&s&&r&&u&&c))throw new Error("Missing account data");const m=Dt.OracleRegistry;this.pairLayout=It.decode(o.data);const{oracles:d,nOracle:p,maxDelay:l}=this.pairLayout,h=Number(p.toString()),g=new m;this.updateOracles();let k=[];for(const t of d.slice(0,h)){const n=Number(t.n);for(const o of t.elements.slice(0,n)){const t=e.get(o.address.toBase58());if(!t)return void(this.isQuoteInvalid=!0);g.add_oracle(o.address.toBuffer(),t.data),k.push(BigInt(Pt(t.data).aggregate.publishSlot))}}this.slot=BigInt(zo(n.data)),this.isQuoteInvalid&&(this.isQuoteInvalid=!1),null===(t=this.quoteParams)||void 0===t||t.registry.free(),this.quoteParams={liabilityIn:BigInt(Uo(s).toString()),liabilityOut:BigInt(Uo(r).toString()),pairData:o.data,sslInData:i.data,sslOutData:a.data,swappedLiabilityIn:BigInt(Uo(u).toString()),swappedLiabilityOut:BigInt(Uo(c).toString()),registry:g,suspended:new Ft(i).isSuspended()||new Ft(a).isSuspended(),maxDelay:l,publishedSlots:k}}getQuote({sourceMint:e,amount:t}){if(!this.quoteParams||this.isQuoteInvalid)throw new Error("Missing quote data");if(this.isSuspended(this.slot))throw new Error("Quote suspended");const{quoteParams:n}=this,o=Dt.swap;let i;const a=e.equals(this.pairLayout.mints[0]);i=a?o(n.sslInData.slice(),n.sslOutData.slice(),n.pairData.slice(),n.liabilityIn,n.liabilityOut,n.swappedLiabilityIn,n.swappedLiabilityOut,n.registry,BigInt(t.toString())):o(n.sslOutData.slice(),n.sslInData.slice(),n.pairData.slice(),n.liabilityOut,n.liabilityIn,n.swappedLiabilityOut,n.swappedLiabilityIn,n.registry,BigInt(t.toString()));const s=this.pairLayout.feeRates[a?0:1],r={notEnoughLiquidity:!1,inAmount:v.BigInt(i.amount_in.toString()),outAmount:v.BigInt(i.amount_out.toString()),feeAmount:v.BigInt(i.fee_paid.toString()),feeMint:e.toBase58(),feePct:s/1e4,priceImpactPct:i.price_impact};return i.free(),r}getSwapLegAndAccounts(e){var t;if(!this.quoteParams)throw new Error("Missing quote data");const n=e.sourceMint.equals(this.pairLayout.mints[0]),{gooseFxAccounts:o}=this,[i,a,s,r,u,c]=n?[o.sslIn,o.liabilityVaultIn,o.swappedLiabilityVaultIn,o.sslOut,o.liabilityVaultOut,o.swappedLiabilityVaultOut]:[o.sslOut,o.liabilityVaultOut,o.swappedLiabilityVaultOut,o.sslIn,o.liabilityVaultIn,o.swappedLiabilityVaultIn];return function({additionalArgs:e,userSourceTokenAccount:t,userDestinationTokenAccount:n,userTransferAuthority:o}){const i=[];return i.push(e.referrer?{pubkey:e.referrer,isSigner:!1,isWritable:!0}:ro),e.oracles.forEach((e=>{i.push({pubkey:e,isSigner:!1,isWritable:!1})})),i.push(ro),[_n({gooseFx:{}}),R.instruction.goosefxSwap({accounts:{swapProgram:J,controller:G,pair:e.pair,sslIn:e.sslIn,sslOut:e.sslOut,liabilityVaultIn:e.liabilityVaultIn,swappedLiabilityVaultIn:e.swappedLiabilityVaultIn,liabilityVaultOut:e.liabilityVaultOut,swappedLiabilityVaultOut:e.swappedLiabilityVaultOut,userInAta:t,userOutAta:n,feeCollectorAta:e.feeCollectorAta,userWallet:o,feeCollector:e.feeCollector,tokenProgram:L},remainingAccounts:i}).keys]}({additionalArgs:{pair:this.gooseFxAccounts.pairAddress,sslIn:i,sslOut:r,liabilityVaultIn:a,swappedLiabilityVaultIn:s,liabilityVaultOut:u,swappedLiabilityVaultOut:c,feeCollectorAta:ce({walletAddress:this.pairLayout.feeCollector,tokenMintAddress:e.sourceMint}),feeCollector:this.pairLayout.feeCollector,oracles:this.oracleAccounts,referrer:null===(t=e.quoteMintToReferrer)||void 0===t?void 0:t.get(e.sourceMint.toBase58())},...e})}get reserveTokenMints(){return this.pairLayout.mints}}const Qo=new Ze(Vt,Y,to);class Xo{static parsePoolStructure(e){return Qo.coder.accounts.decode("pool",e.data)}static parseTickmap(e){return Qo.coder.accounts.decode("tickmap",e.data)}static parseTick(e){return{...Qo.coder.accounts.decode("tick",e.data)}}static getQuote(e,t,n,o,i,a){const{currentTickIndex:s,fee:r,tickSpacing:u,tokenX:c,liquidity:m,sqrtPrice:d}=e,p={currentTickIndex:s,tickSpacing:u,liquidity:m,fee:r,sqrtPrice:d},l={xToY:o.equals(c),byAmountIn:a===yn.ExactIn,swapAmount:new E(i.toString()),priceLimit:o.equals(c)?qt(xt):qt(Ot),slippage:Et(0),ticks:t,tickmap:n,pool:p};return Ct(l)}static getTickIndexToTickPubkeyHash(e,t,n){if(!n){const{tickAddress:n}=this.getTickAddress(e,t.currentTickIndex),o=new Map;return o.set(t.currentTickIndex,n),o}const o=Rt(n.bitmap,t.currentTickIndex,t.tickSpacing,Nt,Infinity,"down"),i=Rt(n.bitmap,t.currentTickIndex,t.tickSpacing,Nt,Infinity,"up");return o.concat([t.currentTickIndex]).concat(i).reduce(((t,n)=>{const{tickAddress:o}=this.getTickAddress(e,n);return t.set(n,o),t}),new Map)}static getTickAddress(t,n){const o=Buffer.alloc(4);o.writeInt32LE(n);const[i,a]=e.findProgramAddressSync([Buffer.from(tt.bytes.utf8.encode("tickv1")),t.toBuffer(),o],Qo.programId);return{tickAddress:i,tickBump:a}}}class Yo{constructor(e,t){this.address=void 0,this.id=void 0,this.label="Invariant",this.shouldPrefetch=!0,this.exactOutputSupported=!1,this.hasDynamicAccounts=!0,this.poolStructure=void 0,this.tickmap=void 0,this.tickPkToTickIndexHash=void 0,this.ticks=new Map,this.feePct=void 0,this.address=e,this.id=e.toBase58(),this.poolStructure=Xo.parsePoolStructure(t),this.tickPkToTickIndexHash=Xo.getTickIndexToTickPubkeyHash(this.address,this.poolStructure,this.tickmap),this.feePct=new nt(this.poolStructure.fee.v.toString()).div(Ut.toString()).toNumber()}getAccountsForUpdate(){const e=this.tickPkToTickIndexHash.values();return[this.address,this.poolStructure.tickmap,...e]}update(e){const t=e.get(this.address.toBase58());if(!t)throw new Error(`Missing invariant pool data ${this.address.toBase58()}`);this.poolStructure=Xo.parsePoolStructure(t);const n=e.get(this.poolStructure.tickmap.toBase58());n&&(this.tickmap=Xo.parseTickmap(n)),this.tickPkToTickIndexHash=Xo.getTickIndexToTickPubkeyHash(this.address,this.poolStructure,this.tickmap),this.ticks.clear();for(const[t,n]of this.tickPkToTickIndexHash){const o=e.get(n.toBase58());if(!o)continue;const i=Xo.parseTick(o);this.ticks.set(t,i)}}getQuote({sourceMint:e,amount:t,swapMode:n}){if(!this.tickmap)throw new Error("Missing tickmap");const o=Xo.getQuote(this.poolStructure,this.ticks,this.tickmap,e,t,n),i=new nt(o.priceImpact.toString()).div(Ut.toString()).toNumber();if(0!==o.status)throw new Error(`Invariant simulation failed: ${this.address}`);const a=o.accumulatedAmountIn.add(o.accumulatedFee);return{notEnoughLiquidity:!1,inAmount:v.BigInt(a.toString()),outAmount:v.BigInt(o.accumulatedAmountOut.toString()),feeAmount:v.BigInt(o.accumulatedFee.toString()),feeMint:e.toBase58(),feePct:this.feePct,priceImpactPct:i}}getSwapLegAndAccounts(e){var t;if(!this.tickmap)throw new Error("Missing tickmap");const n=Xo.getQuote(this.poolStructure,this.ticks,this.tickmap,e.sourceMint,e.amount,e.swapMode),o={};this.tickPkToTickIndexHash.forEach(((e,t)=>{o[t]=e}));const i=n.crossedTicks.concat(this.poolStructure.currentTickIndex).map((e=>{const t=o[e];if(!t)throw new Error("Missing tick account.");return t})),a=e.sourceMint.equals(this.poolStructure.tokenX);return function({additionalArgs:e,userSourceTokenAccount:t,userDestinationTokenAccount:n,userTransferAuthority:o}){const[i,a]=e.xToY?[t,n]:[n,t],s=e.referrer?[{pubkey:e.referrer,isSigner:!1,isWritable:!0}]:[];return e.crossedTickAddresses.forEach((e=>{s.push({pubkey:e,isSigner:!1,isWritable:!0})})),s.push(ro),[_n(Un(e.xToY)),R.instruction.invariantSwap({accounts:{swapProgram:Y,tokenProgram:L,owner:o,state:_,pool:e.pool,tickmap:e.tickmap,accountX:i,accountY:a,reserveX:e.reserveX,reserveY:e.reserveY,programAuthority:$},remainingAccounts:s}).keys]}({...e,additionalArgs:{xToY:a,pool:this.address,tickmap:this.poolStructure.tickmap,reserveX:this.poolStructure.tokenXReserve,reserveY:this.poolStructure.tokenYReserve,crossedTickAddresses:i,referrer:null===(t=e.quoteMintToReferrer)||void 0===t?void 0:t.get(e.sourceMint.toBase58())}})}get reserveTokenMints(){return[this.poolStructure.tokenX,this.poolStructure.tokenY]}}class _o{constructor(e,t){var n;this.ammAccountInfo=void 0,this.id=void 0,this.label="Lifinity",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.swapState=void 0,this.poolInfo=void 0,this.ammData=void 0,this.slot=void 0,this.ammAccountInfo=t,this.id=e.toBase58(),this.swapState=((e,t)=>{const n=t.owner,o=Kt.decode(t.data),[i]=B([e.toBuffer()],n);return{programId:n,authority:i,amm:e,tokenAMint:o.tokenAMint,tokenBMint:o.tokenBMint,poolMint:o.poolMint,feeAccount:o.poolFeeAccount,pythAccount:o.pythAccount,pythPcAccount:o.pythPcAccount,configAccount:o.configAccount,poolCoinTokenAccount:o.tokenAAccount,poolCoinMint:o.tokenAMint,poolPcTokenAccount:o.tokenBAccount,poolPcMint:o.tokenBMint}})(e,t),this.poolInfo={amm:(n=this.swapState).amm.toBase58(),configAccount:n.configAccount.toBase58(),feeAccount:n.feeAccount.toBase58(),pythAccount:n.pythAccount.toBase58(),pythPcAccount:n.pythPcAccount.toBase58(),poolCoinMint:n.poolCoinMint.toBase58(),poolCoinTokenAccount:n.poolCoinTokenAccount.toBase58(),poolMint:n.poolMint.toBase58(),poolPcTokenAccount:n.poolPcTokenAccount.toBase58(),poolPcMint:n.poolPcMint.toBase58(),poolCoinDecimal:0,poolPcDecimal:0,poolMintDecimal:0,pythBaseDecimal:0}}getAccountsForUpdate(){return[this.swapState.poolCoinTokenAccount,this.swapState.poolPcTokenAccount,this.swapState.configAccount,this.swapState.pythAccount,this.swapState.pythPcAccount,i]}update(e){const t=[];this.getAccountsForUpdate().forEach(((n,o)=>{const i=e.get(n.toBase58());i&&t.push({publicKey:n,account:i})})),this.ammData=zt([{publicKey:this.swapState.amm,account:this.ammAccountInfo},...t],this.poolInfo),this.slot=zo(t[t.length-1].account.data)}getQuote({sourceMint:e,amount:t}){if(!this.ammData||!this.slot)throw new Error("Accounts not loaded, missing ammData");if(this.isTradeFrozen)throw new Error("Trade is frozen");const n=this.swapState.poolCoinMint.equals(e)?Wt.AtoB:Wt.BtoA;if(!this.ammData.pyth.status.equals(1)||this.ammData.pythPc&&!this.ammData.pythPc.status.equals(1))throw new Error("Pyth accounts are outdated");const o=new nt(t.toString()),i=jt(o,this.slot,this.ammData.amm,this.ammData.fees,this.ammData.coinBalance,this.ammData.pcBalance,this.ammData.config,this.ammData.pyth,this.ammData.pythPc,n);return{notEnoughLiquidity:!1,inAmount:t,outAmount:v.BigInt(i.amountSwapped.toString()),feeAmount:v.BigInt(i.fee.ceil().toString()),feeMint:e.toBase58(),feePct:i.feePercent.toNumber(),priceImpactPct:i.priceImpact.toNumber()}}getSwapLegAndAccounts(e){return function({swapState:e,sourceMint:t,userSourceTokenAccount:n,userDestinationTokenAccount:o,userTransferAuthority:i}){const[a,s]=t.equals(e.tokenAMint)?[e.poolCoinTokenAccount,e.poolPcTokenAccount]:[e.poolPcTokenAccount,e.poolCoinTokenAccount];return[_n({lifinity:{}}),R.instruction.lifinitySwap({accounts:{swapProgram:e.programId,authority:e.authority,amm:e.amm,userTransferAuthority:i,sourceInfo:n,destinationInfo:o,swapSource:a,swapDestination:s,poolMint:e.poolMint,feeAccount:e.feeAccount,tokenProgram:L,pythAccount:e.pythAccount,pythPcAccount:e.pythPcAccount,configAccount:e.configAccount}}).keys]}({swapState:this.swapState,...e})}get reserveTokenMints(){return[this.swapState.poolCoinMint,this.swapState.poolPcMint]}get isTradeFrozen(){var e;return 1===(null===(e=this.ammData)||void 0===e?void 0:e.amm.freezeTrade)}}class $o{constructor(e,t){this.address=void 0,this.id=void 0,this.label="Lifinity V2",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.ammState=void 0,this.poolInfo=void 0,this.ammData=void 0,this.slot=void 0,this.address=e;const n=new Je(Qt);var o;this.id=e.toBase58(),this.ammState=n.decode("amm",t.data),this.poolInfo={amm:this.id,poolMint:(o=this.ammState).poolMint.toBase58(),feeAccount:o.feeAccount.toBase58(),oracleMainAccount:o.oracleMainAccount.toBase58(),oracleSubAccount:o.oracleSubAccount.toBase58(),oraclePcAccount:o.oraclePcAccount.toBase58(),poolCoinTokenAccount:o.tokenAAccount.toBase58(),poolCoinMint:o.tokenAMint.toBase58(),poolCoinDecimal:0,poolPcTokenAccount:o.tokenBAccount.toBase58(),poolPcMint:o.tokenBMint.toBase58(),poolPcDecimal:0,poolMintDecimal:0,pythBaseDecimal:o.baseDecimals}}getAccountsForUpdate(){return[this.address,this.ammState.tokenAAccount,this.ammState.tokenBAccount,this.ammState.oracleMainAccount,this.ammState.oracleSubAccount,this.ammState.oraclePcAccount,i]}update(e){const t=this.getAccountsForUpdate().reduce(((t,n)=>{const o=e.get(n.toBase58());return o&&t.push({publicKey:n,account:o}),t}),new Array);this.ammData=Xt(t,this.poolInfo),this.slot=zo(t[t.length-1].account.data)}getQuote({sourceMint:e,amount:t}){if(!this.ammData)throw new Error("Accounts not loaded, missing ammData");if(void 0===this.slot)throw new Error("Slot not fetched");if(this.isTradeFrozen)throw new Error("Trade is frozen");const n=this.ammState.tokenAMint.equals(e)?Yt.AtoB:Yt.BtoA;if(this.ammData.oracleMain&&!this.ammData.oracleMain.status.equals(1)||this.ammData.oracleSub&&!this.ammData.oracleSub.status.equals(1)||this.ammData.oraclePc&&!this.ammData.oraclePc.status.equals(1))throw new Error("Pyth accounts are outdated");const o=new nt(t.toString()),i=_t(o,this.slot,this.ammData.amm,this.ammData.fees,this.ammData.coinBalance,this.ammData.pcBalance,this.ammData.config,this.ammData.oracleMain,this.ammData.oracleSub,this.ammData.oraclePc,n);return{notEnoughLiquidity:!1,inAmount:t,outAmount:v.BigInt(i.amountSwapped.toString()),feeAmount:v.BigInt(i.fee.ceil().toString()),feeMint:e.toBase58(),feePct:i.feePercent.toNumber(),priceImpactPct:i.priceImpact.toNumber()}}getSwapLegAndAccounts(e){return function({ammState:e,amm:t,sourceMint:n,userSourceTokenAccount:o,userDestinationTokenAccount:i,userTransferAuthority:a}){const[s,r]=n.equals(e.tokenAMint)?[e.tokenAAccount,e.tokenBAccount]:[e.tokenBAccount,e.tokenAAccount];return[_n({lifinityV2:{}}),R.instruction.lifinityV2Swap({accounts:{swapProgram:K,authority:B([t.toBuffer()],K)[0],amm:t,userTransferAuthority:a,sourceInfo:o,destinationInfo:i,swapSource:s,swapDestination:r,poolMint:e.poolMint,feeAccount:e.feeAccount,tokenProgram:L,oracleMainAccount:e.oracleMainAccount,oracleSubAccount:e.oracleSubAccount,oraclePcAccount:e.oraclePcAccount}}).keys]}({ammState:this.ammState,amm:this.address,...e})}get reserveTokenMints(){return[this.ammState.tokenAMint,this.ammState.tokenBMint]}get isTradeFrozen(){return 1===this.ammState.freezeTrade}}var Ho="marinade_finance",Zo=[{name:"initialize",accounts:[{name:"creatorAuthority",isMut:!1,isSigner:!0},{name:"state",isMut:!0,isSigner:!1},{name:"reservePda",isMut:!1,isSigner:!1},{name:"stakeList",isMut:!0,isSigner:!1},{name:"validatorList",isMut:!0,isSigner:!1},{name:"msolMint",isMut:!1,isSigner:!1},{name:"operationalSolAccount",isMut:!1,isSigner:!1},{name:"liqPool",accounts:[{name:"lpMint",isMut:!1,isSigner:!1},{name:"solLegPda",isMut:!1,isSigner:!1},{name:"msolLeg",isMut:!1,isSigner:!1}]},{name:"treasuryMsolAccount",isMut:!1,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[{name:"data",type:{defined:"InitializeData"}}]},{name:"changeAuthority",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"adminAuthority",isMut:!1,isSigner:!0}],args:[{name:"data",type:{defined:"ChangeAuthorityData"}}]},{name:"addValidator",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"managerAuthority",isMut:!1,isSigner:!0},{name:"validatorList",isMut:!0,isSigner:!1},{name:"validatorVote",isMut:!1,isSigner:!1},{name:"duplicationFlag",isMut:!0,isSigner:!1},{name:"rentPayer",isMut:!0,isSigner:!0},{name:"clock",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[{name:"score",type:"u32"}]},{name:"removeValidator",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"managerAuthority",isMut:!1,isSigner:!0},{name:"validatorList",isMut:!0,isSigner:!1},{name:"duplicationFlag",isMut:!0,isSigner:!1},{name:"operationalSolAccount",isMut:!0,isSigner:!1}],args:[{name:"index",type:"u32"},{name:"validatorVote",type:"publicKey"}]},{name:"setValidatorScore",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"managerAuthority",isMut:!1,isSigner:!0},{name:"validatorList",isMut:!0,isSigner:!1}],args:[{name:"index",type:"u32"},{name:"validatorVote",type:"publicKey"},{name:"score",type:"u32"}]},{name:"configValidatorSystem",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"managerAuthority",isMut:!1,isSigner:!0}],args:[{name:"extraRuns",type:"u32"}]},{name:"deposit",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"msolMint",isMut:!0,isSigner:!1},{name:"liqPoolSolLegPda",isMut:!0,isSigner:!1},{name:"liqPoolMsolLeg",isMut:!0,isSigner:!1},{name:"liqPoolMsolLegAuthority",isMut:!1,isSigner:!1},{name:"reservePda",isMut:!0,isSigner:!1},{name:"transferFrom",isMut:!0,isSigner:!0},{name:"mintTo",isMut:!0,isSigner:!1},{name:"msolMintAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"lamports",type:"u64"}]},{name:"depositStakeAccount",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"validatorList",isMut:!0,isSigner:!1},{name:"stakeList",isMut:!0,isSigner:!1},{name:"stakeAccount",isMut:!0,isSigner:!1},{name:"stakeAuthority",isMut:!1,isSigner:!0},{name:"duplicationFlag",isMut:!0,isSigner:!1},{name:"rentPayer",isMut:!0,isSigner:!0},{name:"msolMint",isMut:!0,isSigner:!1},{name:"mintTo",isMut:!0,isSigner:!1},{name:"msolMintAuthority",isMut:!1,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"stakeProgram",isMut:!1,isSigner:!1}],args:[{name:"validatorIndex",type:"u32"}]},{name:"liquidUnstake",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"msolMint",isMut:!0,isSigner:!1},{name:"liqPoolSolLegPda",isMut:!0,isSigner:!1},{name:"liqPoolMsolLeg",isMut:!0,isSigner:!1},{name:"treasuryMsolAccount",isMut:!0,isSigner:!1},{name:"getMsolFrom",isMut:!0,isSigner:!1},{name:"getMsolFromAuthority",isMut:!1,isSigner:!0},{name:"transferSolTo",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"msolAmount",type:"u64"}]},{name:"addLiquidity",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"lpMint",isMut:!0,isSigner:!1},{name:"lpMintAuthority",isMut:!1,isSigner:!1},{name:"liqPoolMsolLeg",isMut:!1,isSigner:!1},{name:"liqPoolSolLegPda",isMut:!0,isSigner:!1},{name:"transferFrom",isMut:!0,isSigner:!0},{name:"mintTo",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"lamports",type:"u64"}]},{name:"removeLiquidity",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"lpMint",isMut:!0,isSigner:!1},{name:"burnFrom",isMut:!0,isSigner:!1},{name:"burnFromAuthority",isMut:!1,isSigner:!0},{name:"transferSolTo",isMut:!0,isSigner:!1},{name:"transferMsolTo",isMut:!0,isSigner:!1},{name:"liqPoolSolLegPda",isMut:!0,isSigner:!1},{name:"liqPoolMsolLeg",isMut:!0,isSigner:!1},{name:"liqPoolMsolLegAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"tokens",type:"u64"}]},{name:"setLpParams",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"adminAuthority",isMut:!1,isSigner:!0}],args:[{name:"minFee",type:{defined:"Fee"}},{name:"maxFee",type:{defined:"Fee"}},{name:"liquidityTarget",type:"u64"}]},{name:"configMarinade",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"adminAuthority",isMut:!1,isSigner:!0}],args:[{name:"params",type:{defined:"ConfigMarinadeParams"}}]},{name:"orderUnstake",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"msolMint",isMut:!0,isSigner:!1},{name:"burnMsolFrom",isMut:!0,isSigner:!1},{name:"burnMsolAuthority",isMut:!1,isSigner:!0},{name:"newTicketAccount",isMut:!0,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"msolAmount",type:"u64"}]},{name:"claim",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"reservePda",isMut:!0,isSigner:!1},{name:"ticketAccount",isMut:!0,isSigner:!1},{name:"transferSolTo",isMut:!0,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[]},{name:"stakeReserve",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"validatorList",isMut:!0,isSigner:!1},{name:"stakeList",isMut:!0,isSigner:!1},{name:"validatorVote",isMut:!0,isSigner:!1},{name:"reservePda",isMut:!0,isSigner:!1},{name:"stakeAccount",isMut:!0,isSigner:!1},{name:"stakeDepositAuthority",isMut:!1,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"epochSchedule",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1},{name:"stakeHistory",isMut:!1,isSigner:!1},{name:"stakeConfig",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"stakeProgram",isMut:!1,isSigner:!1}],args:[{name:"validatorIndex",type:"u32"}]},{name:"updateActive",accounts:[{name:"common",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"stakeList",isMut:!0,isSigner:!1},{name:"stakeAccount",isMut:!0,isSigner:!1},{name:"stakeWithdrawAuthority",isMut:!1,isSigner:!1},{name:"reservePda",isMut:!0,isSigner:!1},{name:"msolMint",isMut:!0,isSigner:!1},{name:"msolMintAuthority",isMut:!1,isSigner:!1},{name:"treasuryMsolAccount",isMut:!0,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"stakeHistory",isMut:!1,isSigner:!1},{name:"stakeProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}]},{name:"validatorList",isMut:!0,isSigner:!1}],args:[{name:"stakeIndex",type:"u32"},{name:"validatorIndex",type:"u32"}]},{name:"updateDeactivated",accounts:[{name:"common",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"stakeList",isMut:!0,isSigner:!1},{name:"stakeAccount",isMut:!0,isSigner:!1},{name:"stakeWithdrawAuthority",isMut:!1,isSigner:!1},{name:"reservePda",isMut:!0,isSigner:!1},{name:"msolMint",isMut:!0,isSigner:!1},{name:"msolMintAuthority",isMut:!1,isSigner:!1},{name:"treasuryMsolAccount",isMut:!0,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"stakeHistory",isMut:!1,isSigner:!1},{name:"stakeProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}]},{name:"operationalSolAccount",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[{name:"stakeIndex",type:"u32"}]},{name:"deactivateStake",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"reservePda",isMut:!1,isSigner:!1},{name:"validatorList",isMut:!0,isSigner:!1},{name:"stakeList",isMut:!0,isSigner:!1},{name:"stakeAccount",isMut:!0,isSigner:!1},{name:"stakeDepositAuthority",isMut:!1,isSigner:!1},{name:"splitStakeAccount",isMut:!0,isSigner:!0},{name:"splitStakeRentPayer",isMut:!0,isSigner:!0},{name:"clock",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1},{name:"epochSchedule",isMut:!1,isSigner:!1},{name:"stakeHistory",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"stakeProgram",isMut:!1,isSigner:!1}],args:[{name:"stakeIndex",type:"u32"},{name:"validatorIndex",type:"u32"}]},{name:"emergencyUnstake",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"validatorManagerAuthority",isMut:!1,isSigner:!0},{name:"validatorList",isMut:!0,isSigner:!1},{name:"stakeList",isMut:!0,isSigner:!1},{name:"stakeAccount",isMut:!0,isSigner:!1},{name:"stakeDepositAuthority",isMut:!1,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"stakeProgram",isMut:!1,isSigner:!1}],args:[{name:"stakeIndex",type:"u32"},{name:"validatorIndex",type:"u32"}]},{name:"mergeStakes",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"stakeList",isMut:!0,isSigner:!1},{name:"validatorList",isMut:!0,isSigner:!1},{name:"destinationStake",isMut:!0,isSigner:!1},{name:"sourceStake",isMut:!0,isSigner:!1},{name:"stakeDepositAuthority",isMut:!1,isSigner:!1},{name:"stakeWithdrawAuthority",isMut:!1,isSigner:!1},{name:"operationalSolAccount",isMut:!0,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"stakeHistory",isMut:!1,isSigner:!1},{name:"stakeProgram",isMut:!1,isSigner:!1}],args:[{name:"destinationStakeIndex",type:"u32"},{name:"sourceStakeIndex",type:"u32"},{name:"validatorIndex",type:"u32"}]}],Jo=[{name:"State",type:{kind:"struct",fields:[{name:"msolMint",type:"publicKey"},{name:"adminAuthority",type:"publicKey"},{name:"operationalSolAccount",type:"publicKey"},{name:"treasuryMsolAccount",type:"publicKey"},{name:"reserveBumpSeed",type:"u8"},{name:"msolMintAuthorityBumpSeed",type:"u8"},{name:"rentExemptForTokenAcc",type:"u64"},{name:"rewardFee",type:{defined:"Fee"}},{name:"stakeSystem",type:{defined:"StakeSystem"}},{name:"validatorSystem",type:{defined:"ValidatorSystem"}},{name:"liqPool",type:{defined:"LiqPool"}},{name:"availableReserveBalance",type:"u64"},{name:"msolSupply",type:"u64"},{name:"msolPrice",type:"u64"},{name:"circulatingTicketCount",type:"u64"},{name:"circulatingTicketBalance",type:"u64"},{name:"lentFromReserve",type:"u64"},{name:"minDeposit",type:"u64"},{name:"minWithdraw",type:"u64"},{name:"stakingSolCap",type:"u64"},{name:"emergencyCoolingDown",type:"u64"}]}},{name:"TicketAccountData",type:{kind:"struct",fields:[{name:"stateAddress",type:"publicKey"},{name:"beneficiary",type:"publicKey"},{name:"lamportsAmount",type:"u64"},{name:"createdEpoch",type:"u64"}]}}],Go=[{name:"Fee",type:{kind:"struct",fields:[{name:"basisPoints",type:"u32"}]}},{name:"InitializeData",type:{kind:"struct",fields:[{name:"adminAuthority",type:"publicKey"},{name:"validatorManagerAuthority",type:"publicKey"},{name:"minStake",type:"u64"},{name:"rewardFee",type:{defined:"Fee"}},{name:"liqPool",type:{defined:"LiqPoolInitializeData"}},{name:"additionalStakeRecordSpace",type:"u32"},{name:"additionalValidatorRecordSpace",type:"u32"},{name:"slotsForStakeDelta",type:"u64"}]}},{name:"LiqPoolInitializeData",type:{kind:"struct",fields:[{name:"lpLiquidityTarget",type:"u64"},{name:"lpMaxFee",type:{defined:"Fee"}},{name:"lpMinFee",type:{defined:"Fee"}},{name:"lpTreasuryCut",type:{defined:"Fee"}}]}},{name:"ChangeAuthorityData",type:{kind:"struct",fields:[{name:"admin",type:{option:"publicKey"}},{name:"validatorManager",type:{option:"publicKey"}},{name:"operationalSolAccount",type:{option:"publicKey"}},{name:"treasuryMsolAccount",type:{option:"publicKey"}}]}},{name:"ConfigMarinadeParams",type:{kind:"struct",fields:[{name:"rewardsFee",type:{option:{defined:"Fee"}}},{name:"slotsForStakeDelta",type:{option:"u64"}},{name:"minStake",type:{option:"u64"}},{name:"minDeposit",type:{option:"u64"}},{name:"minWithdraw",type:{option:"u64"}},{name:"stakingSolCap",type:{option:"u64"}},{name:"liquiditySolCap",type:{option:"u64"}},{name:"autoAddValidatorEnabled",type:{option:"bool"}}]}},{name:"LiqPool",type:{kind:"struct",fields:[{name:"lpMint",type:"publicKey"},{name:"lpMintAuthorityBumpSeed",type:"u8"},{name:"solLegBumpSeed",type:"u8"},{name:"msolLegAuthorityBumpSeed",type:"u8"},{name:"msolLeg",type:"publicKey"},{name:"lpLiquidityTarget",type:"u64"},{name:"lpMaxFee",type:{defined:"Fee"}},{name:"lpMinFee",type:{defined:"Fee"}},{name:"treasuryCut",type:{defined:"Fee"}},{name:"lpSupply",type:"u64"},{name:"lentFromSolLeg",type:"u64"},{name:"liquiditySolCap",type:"u64"}]}},{name:"List",type:{kind:"struct",fields:[{name:"account",type:"publicKey"},{name:"itemSize",type:"u32"},{name:"count",type:"u32"},{name:"newAccount",type:"publicKey"},{name:"copiedCount",type:"u32"}]}},{name:"StakeRecord",type:{kind:"struct",fields:[{name:"stakeAccount",type:"publicKey"},{name:"lastUpdateDelegatedLamports",type:"u64"},{name:"lastUpdateEpoch",type:"u64"},{name:"isEmergencyUnstaking",type:"u8"}]}},{name:"StakeSystem",type:{kind:"struct",fields:[{name:"stakeList",type:{defined:"List"}},{name:"delayedUnstakeCoolingDown",type:"u64"},{name:"stakeDepositBumpSeed",type:"u8"},{name:"stakeWithdrawBumpSeed",type:"u8"},{name:"slotsForStakeDelta",type:"u64"},{name:"lastStakeDeltaEpoch",type:"u64"},{name:"minStake",type:"u64"},{name:"extraStakeDeltaRuns",type:"u32"}]}},{name:"ValidatorRecord",type:{kind:"struct",fields:[{name:"validatorAccount",type:"publicKey"},{name:"activeBalance",type:"u64"},{name:"score",type:"u32"},{name:"lastStakeDeltaEpoch",type:"u64"},{name:"duplicationFlagBumpSeed",type:"u8"}]}},{name:"ValidatorSystem",type:{kind:"struct",fields:[{name:"validatorList",type:{defined:"List"}},{name:"managerAuthority",type:"publicKey"},{name:"totalValidatorScore",type:"u32"},{name:"totalActiveBalance",type:"u64"},{name:"autoAddValidatorEnabled",type:"u8"}]}},{name:"CommonError",type:{kind:"enum",variants:[{name:"InvalidProgramId",fields:["publicKey"]},{name:"UnexpectedAccount",fields:["publicKey"]},{name:"CalculationFailure"},{name:"AccountWithLockup"},{name:"NumberTooLow",fields:["u64","u64"]},{name:"NumberTooHigh",fields:["u64","u64"]},{name:"FeeTooHigh",fields:[{defined:"Fee"}]},{name:"FeesWrongWayRound",fields:[{defined:"Fee"},{defined:"Fee"}]},{name:"LiquidityTargetTooLow"},{name:"TicketNotDue",fields:["u64"]},{name:"TicketNotReady"},{name:"WrongBeneficiary"},{name:"InsufficientLiquidity"},{name:"InvalidValidator"}]}},{name:"InitializeError",type:{kind:"enum",variants:[{name:"WrongReserveOwner",fields:["publicKey"]},{name:"NonEmptyReserveData",fields:[{defined:"usize"}]},{name:"InvalidInitialReserveLamports",fields:["u64"]},{name:"ZeroValidatorChunkSize"},{name:"TooBigValidatorChunkSize",fields:["u32"]},{name:"ZeroCreditChunkSize"},{name:"TooBigCreditChunkSize",fields:["u32"]},{name:"TooLowCreditFee",fields:["u64"]},{name:"InvalidMintAuthority",fields:[{name:"expected",type:"publicKey"},{name:"got",type:"publicKey"}]},{name:"MintHasInitialSupply",fields:["u64"]},{name:"InvalidOwnerFeeState",fields:[{defined:"spl_token::state::AccountState"}]}]}}],ei={__proto__:null,version:"0.0.0",name:Ho,instructions:Zo,accounts:Jo,types:Go,default:{version:"0.0.0",name:Ho,instructions:Zo,accounts:Jo,types:Go}};function ti(e,t,n){return n.isZero()?e:e.mul(t).div(n)}class ni{constructor(e,t){this.address=void 0,this.id=void 0,this.label="Marinade",this.shouldPrefetch=!0,this.exactOutputSupported=!1,this.hasDynamicAccounts=!0,this.marinadeFinanceProgram=void 0,this.marinadeStateResponse=void 0,this.liqPoolSolLegPdaAddress=void 0,this.marinadeState=void 0,this.id=e.toBase58(),this.marinadeFinanceProgram=new Ze(ei,X,{}),this.marinadeStateResponse=this.marinadeFinanceProgram.coder.accounts.decode("State",t.data),this.address=e,this.liqPoolSolLegPdaAddress=this.findProgramDerivedAddress("liq_sol")}getAccountsForUpdate(){return[this.address,this.liqPoolSolLegPdaAddress,this.marinadeStateResponse.liqPool.msolLeg]}update(e){const[t,n,o]=Mn(e,this.getAccountsForUpdate());this.marinadeStateResponse=this.marinadeFinanceProgram.coder.accounts.decode("State",t.data);const i=b(o.data);if(!i)throw new Error(`liqPoolMSOLLeg token account cannot be deserialized ${this.marinadeStateResponse.liqPool.msolLeg.toBase58()}`);this.marinadeState=new oi(this.marinadeStateResponse,new O(n.lamports),i.amount)}getQuote({sourceMint:e,amount:t}){if(!this.marinadeState)throw new Error("Update was not run to create a complete marinadeState");const n=new O(t.toString()),o=e.equals(q)?this.marinadeState.depositQuote(n):this.marinadeState.liquidUnstakeQuote(n);return{notEnoughLiquidity:!1,inAmount:t,outAmount:v.BigInt(o.outAmount.toString()),feeAmount:v.BigInt(o.feeAmount.toString()),feeMint:this.marinadeStateResponse.msolMint.toBase58(),feePct:o.feePct,priceImpactPct:0}}getSwapLegAndAccounts(e){return e.sourceMint.equals(q)?function({additionalArgs:e,userSourceTokenAccount:t,userDestinationTokenAccount:i,userTransferAuthority:a}){const s=B([Buffer.from("temp-wsol-token-account"),a.toBuffer()],Q)[0],r=B([Buffer.from("temp-sol-pda"),a.toBuffer()],Q)[0];return[_n({marinadeDeposit:{}}),R.instruction.marinadeDeposit({accounts:{marinadeFinanceProgram:X,state:e.address,msolMint:e.marinadeStateResponse.msolMint,liqPoolSolLegPda:e.liqPoolSolLegPda,liqPoolMsolLeg:e.marinadeStateResponse.liqPool.msolLeg,liqPoolMsolLegAuthority:e.liqPoolMsolLegAuthority,reservePda:e.reservePda,transferFrom:r,mintTo:i,msolMintAuthority:e.msolMintAuthority,systemProgram:n.programId,tokenProgram:L,userWsolTokenAccount:t,tempWsolTokenAccount:s,userTransferAuthority:a,wsolMint:q,rent:o}}).keys]}({additionalArgs:{address:this.address,marinadeStateResponse:this.marinadeStateResponse,liqPoolSolLegPda:this.liqPoolSolLegPdaAddress,liqPoolMsolLegAuthority:this.findProgramDerivedAddress("liq_st_sol_authority"),reservePda:this.findProgramDerivedAddress("reserve"),msolMintAuthority:this.findProgramDerivedAddress("st_mint")},...e}):function({additionalArgs:e,userSourceTokenAccount:t,userDestinationTokenAccount:o,userTransferAuthority:i}){const a=B([Buffer.from("temp-sol-pda"),i.toBuffer()],Q)[0];return[_n({marinadeUnstake:{}}),R.instruction.marinadeUnstake({accounts:{marinadeFinanceProgram:X,state:e.address,msolMint:e.marinadeStateResponse.msolMint,liqPoolSolLegPda:e.liqPoolSolLegPda,liqPoolMsolLeg:e.marinadeStateResponse.liqPool.msolLeg,treasuryMsolAccount:e.marinadeStateResponse.treasuryMsolAccount,getMsolFrom:t,getMsolFromAuthority:i,transferSolTo:a,systemProgram:n.programId,tokenProgram:L,userWsolTokenAccount:o}}).keys]}({additionalArgs:{address:this.address,marinadeStateResponse:this.marinadeStateResponse,liqPoolSolLegPda:this.liqPoolSolLegPdaAddress},...e})}get reserveTokenMints(){return[q,this.marinadeStateResponse.msolMint]}findProgramDerivedAddress(e,t=[]){const n=[this.address.toBuffer(),Buffer.from(e),...t],[o]=B(n,this.marinadeFinanceProgram.programId);return o}}class oi{constructor(e,t,n){this.state=void 0,this.liqPoolSolLegPdaLamports=void 0,this.liqPoolMSOLLegAmount=void 0,this.state=e,this.liqPoolSolLegPdaLamports=t,this.liqPoolMSOLLegAmount=n}depositQuote(e){let t=e;const n=this.calcMSOLFromLamports(t),o=O.min(n,this.liqPoolMSOLLegAmount);let i=new O(0);if(t=(()=>{if(o.gt(new O(0))){const e=n.eq(o)?t:this.calcLamportsFromMSOLAmount(o);return i=i.add(o),ii(t,e)}return t})(),t.gt(new O(0))){this.checkStakingCap(t);const e=this.calcMSOLFromLamports(t);i=i.add(e)}return{outAmount:i,feeAmount:0,feePct:0,priceImpactPct:0}}checkStakingCap(e){if(this.totalLamportsUnderControl().add(e).gt(this.state.stakingSolCap))throw new Error("Staking cap reached")}calcMSOLFromLamports(e){return t=e,n=this.totalVirtualStakedLamports(),(o=this.state.msolSupply).eq(new O(0))?t:ti(t,o,n);var t,n,o}calcLamportsFromMSOLAmount(e){return ti(e,this.totalVirtualStakedLamports(),this.state.msolSupply)}totalVirtualStakedLamports(){return ii(this.totalLamportsUnderControl(),this.state.circulatingTicketBalance)}totalLamportsUnderControl(){return this.state.validatorSystem.totalActiveBalance.add(this.totalCoolingDown()).add(this.state.availableReserveBalance)}totalCoolingDown(){return this.state.stakeSystem.delayedUnstakeCoolingDown.add(this.state.emergencyCoolingDown)}liquidUnstakeQuote(e){const t=ii(this.liqPoolSolLegPdaLamports,this.state.rentExemptForTokenAcc),n=this.calcLamportsFromMSOLAmount(e),o=function(e,t,n,o,i){if(i.gte(o))return t;const a=o.sub(i);return a.gte(n)?e:t-ti(new O(t-e),a,n).toNumber()}(this.state.liqPool.lpMinFee.basisPoints,this.state.liqPool.lpMaxFee.basisPoints,this.state.liqPool.lpLiquidityTarget,t,n),i=e.mul(new O(o)).div(new O(1e4)),a=this.calcLamportsFromMSOLAmount(e.sub(i));if(a.add(this.state.rentExemptForTokenAcc).gt(this.liqPoolSolLegPdaLamports))throw new Error("Insufficient liquidity");return{outAmount:a,feeAmount:i,feePct:o/1e4,priceImpactPct:0}}}function ii(e,t){return e.gt(t)?e.sub(t):new O(0)}const ai=Math.pow(10,10),si=Qe([Xe("version"),Xe("isInitialized"),Xe("nonce"),In("amplificationCoefficient"),In("feeNumerator"),In("adminFeeNumerator"),Ye("tokenAccountsLength"),In("precisionFactor"),In("precisionMultiplierA"),In("precisionMultiplierB"),In("precisionMultiplierC"),In("precisionMultiplierD"),Pn("tokenAccountA"),Pn("tokenAccountB"),Pn("tokenAccountC"),Pn("tokenAccountD")]),ri=(e,t)=>{const n=t.owner,o=si.decode(t.data),i=o.tokenAccountsLength,a=Fn([e.toBuffer(),Buffer.from([o.nonce])],n),s=[o.precisionMultiplierA.toNumber(),o.precisionMultiplierB.toNumber(),o.precisionMultiplierC.toNumber(),o.precisionMultiplierD.toNumber()].slice(0,i),r=[o.tokenAccountA,o.tokenAccountB,o.tokenAccountC,o.tokenAccountD].slice(0,i);return{programId:n,authority:a,isInitialized:Boolean(o.isInitialized),nonce:o.nonce,ammId:e,amplificationCoefficient:o.amplificationCoefficient.toNumber(),feeNumerator:o.feeNumerator.toNumber(),tokenAccountsLength:i,precisionFactor:o.precisionFactor.toNumber(),precisionMultipliers:s,tokenAccounts:r}};class ui{constructor(t,n,o){this.address=void 0,this.params=void 0,this.id=void 0,this.label="Mercurial",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.swapLayout=void 0,this.tokenMints=void 0,this.tokenReserveAmounts=void 0,this.calculator=void 0,this.address=t,this.params=o,this.id=t.toBase58(),this.swapLayout=ri(t,n),this.calculator=ui.calculatorFromSwapState(this.swapLayout),this.tokenMints=o.tokenMints.map((t=>new e(t)))}getAccountsForUpdate(){return[this.address,...this.swapLayout.tokenAccounts]}static calculatorFromSwapState(e){return new A(v.BigInt(e.tokenAccountsLength),v.BigInt(e.amplificationCoefficient),e.precisionMultipliers.map((e=>v.BigInt(e))),new k(v.BigInt(e.feeNumerator),v.BigInt(ai)))}update(e){const[t,...n]=Mn(e,this.getAccountsForUpdate());this.swapLayout=ui.decodeSwapLayout(this.address,t),this.calculator=ui.calculatorFromSwapState(this.swapLayout),this.tokenReserveAmounts=wn(n)}getQuote({sourceMint:e,destinationMint:t,amount:n}){if(!this.tokenReserveAmounts)throw new Error("Missing tokenReserveAmounts");const o=this.tokenReserveAmounts.findIndex(((t,n)=>this.tokenMints[n].equals(e))),i=this.tokenReserveAmounts.findIndex(((e,n)=>this.tokenMints[n].equals(t))),a=this.calculator.exchange(this.tokenReserveAmounts,n,o,i),s=this.swapLayout.feeNumerator/ai;return{notEnoughLiquidity:!1,inAmount:n,outAmount:a.expectedOutputAmount,feeAmount:a.fees,feeMint:t.toBase58(),feePct:s,priceImpactPct:a.priceImpact.toNumber()}}getSwapLegAndAccounts(e){return function({swapLayout:e,userSourceTokenAccount:t,userDestinationTokenAccount:n,userTransferAuthority:o}){const i=[];for(const t of e.tokenAccounts)i.push({pubkey:t,isSigner:!1,isWritable:!0});return[_n({mercurial:{}}),R.instruction.mercurialSwap({accounts:co(e,t,n,o),remainingAccounts:i}).keys]}({swapLayout:this.swapLayout,...e})}get reserveTokenMints(){return this.params.tokenMints.map((t=>new e(t)))}}ui.decodeSwapLayout=ri;const ci=new Ze($t,Ht,to),mi=new Ze(Zt,Ht,to),di=e=>ci.coder.accounts.decode("pool",e.data),pi=e=>mi.coder.accounts.decode("vault",e.data);class li{constructor(t,n,o){var i,a;this.address=void 0,this.id=void 0,this.label="Meteora",this.shouldPrefetch=!0,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.poolState=void 0,this.data=void 0,this.depegAccount=void 0,this.depegAccounts=new Map,this.vaultLpMint=void 0,this.vaultToken=void 0,this.feePct=void 0,this.address=t,this.id=t.toBase58(),this.poolState=di(n),this.vaultLpMint={a:new e(o.vaultLpMint.a),b:new e(o.vaultLpMint.b)},this.vaultToken={a:new e(o.vaultToken.a),b:new e(o.vaultToken.b)};const s=this.poolState.curveType,r=Object.keys((null==s||null===(i=s.stable)||void 0===i||null===(a=i.depeg)||void 0===a?void 0:a.depegType)||{})[0];if(r&&"none"!==r)if("lido"===r||"marinade"===r)this.depegAccount={pubkey:Gt[r]};else{if("splStake"!==r)throw new Error("depegType not supported");this.depegAccount={pubkey:this.poolState.stake}}const{ownerTradeFeeDenominator:u,ownerTradeFeeNumerator:c,tradeFeeDenominator:m,tradeFeeNumerator:d}=this.poolState.fees;this.feePct=new nt(c.toString()).div(u.toString()).add(new nt(d.toString()).div(m.toString())).toNumber()}getAccountsForUpdate(){var e;const t=[this.poolState.aVault,this.poolState.bVault,this.poolState.aVaultLp,this.poolState.bVaultLp,this.poolState.lpMint,this.vaultLpMint.a,this.vaultLpMint.b,this.vaultToken.a,this.vaultToken.b,i];return null!==(e=this.depegAccount)&&void 0!==e&&e.pubkey&&t.push(this.depegAccount.pubkey),t}update(e){const[t,n,o,i,a,s,r,u,c,m,d]=Mn(e,this.getAccountsForUpdate());d&&this.depegAccount&&this.depegAccounts.set(this.depegAccount.pubkey.toBase58(),d),this.data={vaultA:pi(t),vaultB:pi(n),poolAVaultLpAmount:Uo(o),poolBVaultLpAmount:Uo(i),poolLpTotalSupply:Ko(a),vaultALpTotalSupply:Ko(s),vaultBLpTotalSupply:Ko(r),vaultAReserve:Uo(u),vaultBReserve:Uo(c),currentTime:Wo(m.data)}}getQuote({sourceMint:e,destinationMint:t,amount:n}){if(void 0===this.data||this.depegAccount&&0===this.depegAccounts.size)throw new Error("Missing initial fetch");const o=new E(n.toString()),i=Jt(e,o,{currentTime:this.data.currentTime,depegAccounts:this.depegAccounts,poolState:this.poolState,poolVaultALp:this.data.poolAVaultLpAmount,poolVaultBLp:this.data.poolBVaultLpAmount,vaultA:this.data.vaultA,vaultALpSupply:this.data.vaultALpTotalSupply,vaultB:this.data.vaultB,vaultBLpSupply:this.data.vaultBLpTotalSupply,vaultAReserve:this.data.vaultAReserve,vaultBReserve:this.data.vaultBReserve});return{notEnoughLiquidity:!1,inAmount:n,outAmount:v.BigInt(i.amountOut.toString()),feeAmount:v.BigInt(i.fee.toString()),feeMint:t.toBase58(),feePct:this.feePct,priceImpactPct:i.priceImpact.toNumber()}}getSwapLegAndAccounts(e){var t,n;if(void 0===this.data)throw new Error("Unable to fetch accounts.");const o=e.sourceMint.equals(this.poolState.tokenAMint)?this.poolState.adminTokenAFee:this.poolState.adminTokenBFee;return function({additionalArgs:e,userSourceTokenAccount:t,userDestinationTokenAccount:n,userTransferAuthority:o}){const i=[];return i.push(e.referrer?{pubkey:e.referrer,isSigner:!1,isWritable:!0}:ro),i.push(e.depeg?{pubkey:e.depeg,isSigner:!1,isWritable:!1}:ro),[_n({meteora:{}}),R.instruction.meteoraSwap({accounts:{swapProgram:H,pool:e.pool,userSourceToken:t,userDestinationToken:n,aVault:e.aVault,bVault:e.bVault,aTokenVault:e.aTokenVault,bTokenVault:e.bTokenVault,aVaultLpMint:e.aVaultLpMint,bVaultLpMint:e.bVaultLpMint,aVaultLp:e.aVaultLp,bVaultLp:e.bVaultLp,adminTokenFee:e.adminTokenFee,user:o,vaultProgram:Z,tokenProgram:L},remainingAccounts:i}).keys]}({additionalArgs:{pool:this.address,aVault:this.poolState.aVault,bVault:this.poolState.bVault,aTokenVault:this.vaultToken.a,bTokenVault:this.vaultToken.b,aVaultLpMint:this.vaultLpMint.a,bVaultLpMint:this.vaultLpMint.b,aVaultLp:this.poolState.aVaultLp,bVaultLp:this.poolState.bVaultLp,adminTokenFee:o,referrer:null===(t=e.quoteMintToReferrer)||void 0===t?void 0:t.get(e.sourceMint.toBase58()),depeg:null===(n=this.depegAccount)||void 0===n?void 0:n.pubkey},...e})}get reserveTokenMints(){return[this.poolState.tokenAMint,this.poolState.tokenBMint]}}li.accountInfoToMeteoraSwapLayout=di,li.accountInfoToVaultLayout=pi;const hi=Qe([_e("status"),_e("nonce"),_e("orderNum"),_e("depth"),_e("coinDecimals"),_e("pcDecimals"),_e("state"),_e("resetFlag"),_e("minSize"),_e("volMaxCutRatio"),_e("amountWaveRatio"),_e("coinLotSize"),_e("pcLotSize"),_e("minPriceMultiplier"),_e("maxPriceMultiplier"),_e("systemDecimalsValue"),_e("minSeparateNumerator"),_e("minSeparateDenominator"),_e("tradeFeeNumerator"),_e("tradeFeeDenominator"),_e("pnlNumerator"),_e("pnlDenominator"),_e("swapFeeNumerator"),_e("swapFeeDenominator"),_e("needTakePnlCoin"),_e("needTakePnlPc"),_e("totalPnlPc"),_e("totalPnlCoin"),Bn("poolTotalDepositPc"),Bn("poolTotalDepositCoin"),Bn("swapCoinInAmount"),Bn("swapPcOutAmount"),_e("swapCoin2PcFee"),Bn("swapPcInAmount"),Bn("swapCoinOutAmount"),_e("swapPc2CoinFee"),Pn("poolCoinTokenAccount"),Pn("poolPcTokenAccount"),Pn("coinMintAddress"),Pn("pcMintAddress"),Pn("lpMintAddress"),Pn("ammOpenOrders"),Pn("serumMarket"),Pn("serumProgramId"),Pn("ammTargetOrders"),Pn("poolWithdrawQueue"),Pn("poolTempLpTokenAccount"),Pn("ammOwner"),Pn("pnlOwner")]);class gi{constructor(t,n,o){this.ammId=void 0,this.id=void 0,this.label="Raydium",this.shouldPrefetch=!1,this.exactOutputSupported=!0,this.hasDynamicAccounts=!1,this.coinMint=void 0,this.pcMint=void 0,this.status=void 0,this.serumProgramId=void 0,this.serumMarket=void 0,this.ammOpenOrders=void 0,this.ammTargetOrders=void 0,this.poolCoinTokenAccount=void 0,this.poolPcTokenAccount=void 0,this.serumMarketKeys=void 0,this.coinReserve=void 0,this.pcReserve=void 0,this.feePct=void 0,this.calculator=void 0,this.ammId=t,this.id=t.toBase58();const i=hi.decode(n.data);this.status=i.status,this.coinMint=new e(i.coinMintAddress),this.pcMint=new e(i.pcMintAddress),this.poolCoinTokenAccount=new e(i.poolCoinTokenAccount),this.poolPcTokenAccount=new e(i.poolPcTokenAccount),this.serumProgramId=new e(i.serumProgramId),this.serumMarket=new e(i.serumMarket),this.ammOpenOrders=new e(i.ammOpenOrders),this.ammTargetOrders=new e(i.ammTargetOrders),this.serumMarketKeys=Object.keys(o).reduce(((t,n)=>{if(!o[n])throw new Error(`Could not find ${n} in params`);return t[n]=new e(o[n]),t}),{});const a=i.swapFeeNumerator,s=i.swapFeeDenominator;this.feePct=new nt(a.toString()).div(s.toString()),this.calculator=new f(new k(v.BigInt(a),v.BigInt(s)),y)}static decodeSerumMarketKeysString(e,t,n,o){if(!t.equals(ye))return{serumBids:e.toBase58(),serumAsks:e.toBase58(),serumEventQueue:e.toBase58(),serumCoinVaultAccount:e.toBase58(),serumPcVaultAccount:e.toBase58(),serumVaultSigner:e.toBase58()};const i=u.getLayout(t).decode(o.data),a=Fn([n.toBuffer(),i.vaultSignerNonce.toArrayLike(Buffer,"le",8)],t);return{serumBids:i.bids.toBase58(),serumAsks:i.asks.toBase58(),serumEventQueue:i.eventQueue.toBase58(),serumCoinVaultAccount:i.baseVault.toBase58(),serumPcVaultAccount:i.quoteVault.toBase58(),serumVaultSigner:a.toBase58()}}getAccountsForUpdate(){return[this.ammId,this.poolCoinTokenAccount,this.poolPcTokenAccount,this.ammOpenOrders]}update(e){const[t,n,o,i]=Mn(e,this.getAccountsForUpdate()),[a,s]=[Uo(n),Uo(o)],r=c.fromAccountInfo(this.ammOpenOrders,i,i.owner),u=hi.decode(t.data);this.coinReserve=v.BigInt(a.add(r.baseTokenTotal).sub(new D(String(u.needTakePnlCoin)))),this.pcReserve=v.BigInt(s.add(r.quoteTokenTotal).sub(new D(String(u.needTakePnlPc))))}getQuoteInternal({amount:e,sourceMint:t,coinReserve:n,pcReserve:o,swapMode:i}){const a=this.coinMint.equals(t)?1:0;if(i==yn.ExactIn){const t=this.calculator.exchange([n,o],e,a);return{inAmount:e,outAmount:t.expectedOutputAmount,feeAmount:t.fees,priceImpactPct:t.priceImpact.toNumber()}}{const t=this.calculator.exchangeForExactOutput([n,o],e,a);return{inAmount:t.expectedInputAmount,outAmount:e,feeAmount:t.fees,priceImpactPct:t.priceImpact.toNumber()}}}getQuote({sourceMint:e,amount:t,swapMode:n}){const{coinReserve:o,pcReserve:i}=this;if(!this.isTradable)throw new Error("Pool is not tradable");if(!o||!i)throw new Error("Pool token accounts balances not refreshed or empty");return{...this.getQuoteInternal({amount:t,sourceMint:e,coinReserve:o,pcReserve:i,swapMode:n}),notEnoughLiquidity:!1,feeMint:e.toBase58(),feePct:this.feePct.toNumber()}}getSwapLegAndAccounts(e){return function({raydiumAmm:e,userSourceTokenAccount:t,userDestinationTokenAccount:n,userTransferAuthority:o}){return[_n({raydium:{}}),R.instruction.raydiumSwap({accounts:po(e,t,n,o)}).keys]}({raydiumAmm:this,...e})}createExactOutSwapInstruction(e){return function({raydiumAmm:e,userSourceTokenAccount:t,userDestinationTokenAccount:n,userTransferAuthority:o,outAmount:i,inAmount:a,slippageBps:s,platformFee:r,overflowFeeAccount:u}){var c;return R.instruction.raydiumSwapExactOutput(i,{amount:a,slippageBps:s},null!==(c=null==r?void 0:r.feeBps)&&void 0!==c?c:0,{accounts:po(e,t,n,o),remainingAccounts:go(null==r?void 0:r.feeAccount,u)})}({raydiumAmm:this,...e,outAmount:new O(e.amount.toString()),inAmount:new O(e.inAmount.toString())})}get reserveTokenMints(){return[this.coinMint,this.pcMint]}get isTradable(){return 1===this.status||6===this.status}}const ki=new Ze({version:"0.0.1",name:"add_decimals",instructions:[],accounts:[{name:"wrappedToken",type:{kind:"struct",fields:[{name:"decimals",type:"u8"},{name:"multiplier",type:"u64"},{name:"wrappedUnderlyingMint",type:"publicKey"},{name:"wrappedUnderlyingTokens",type:"publicKey"},{name:"wrapperMint",type:"publicKey"},{name:"nonce",type:"u8"}]}}],errors:[]},U,to);class fi{constructor(e,t){this.address=void 0,this.accountInfo=void 0,this.id=void 0,this.label="Saber (Decimals)",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.wrappedToken=void 0,this.multiplierJsbi=void 0,this.address=e,this.accountInfo=t,this.id=e.toBase58(),this.wrappedToken=ki.coder.accounts.decode("wrappedToken",t.data),this.multiplierJsbi=v.BigInt(this.wrappedToken.multiplier)}getAccountsForUpdate(){return new Array}update(e){}toWrappedAmount(e){return v.multiply(this.multiplierJsbi,e)}toUnderlyingAmount(e){return v.divide(e,this.multiplierJsbi)}getAmounts(e,t){if(t)return[e,this.toWrappedAmount(e)];{const t=this.toUnderlyingAmount(e);return[this.toWrappedAmount(t),t]}}getQuote({sourceMint:e,amount:t}){const n=this.wrappedToken.wrappedUnderlyingMint.equals(e),[o,i]=this.getAmounts(t,n);return{notEnoughLiquidity:!1,inAmount:o,outAmount:i,feeAmount:M,feeMint:e.toBase58(),feePct:0,priceImpactPct:0}}getSwapLegAndAccounts(e){return function({wrapper:e,wrappedToken:t,userSourceTokenAccount:n,userDestinationTokenAccount:o,userTransferAuthority:i,deposit:a}){return[_n(a?{saberAddDecimalsDeposit:{}}:{saberAddDecimalsWithdraw:{}}),R.instruction.saberAddDecimals({accounts:{addDecimalsProgram:U,wrapper:e,wrapperMint:t.wrapperMint,wrapperUnderlyingTokens:t.wrappedUnderlyingTokens,owner:i,userUnderlyingTokens:a?n:o,userWrappedTokens:a?o:n,tokenProgram:L}}).keys]}({wrapper:this.address,wrappedToken:this.wrappedToken,...e,deposit:this.wrappedToken.wrappedUnderlyingMint.equals(e.sourceMint)})}get reserveTokenMints(){return[this.wrappedToken.wrappedUnderlyingMint,this.wrappedToken.wrapperMint]}get wrapperMint(){return this.wrappedToken.wrapperMint}}class Si{constructor(e){this.stableSwap=void 0,this.id=void 0,this.label="Saber",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.tokenReserveAmounts=void 0,this.stableSwapState=void 0,this.calculator=void 0,this.stableSwap=e,this.id=e.config.swapAccount.toBase58(),this.stableSwapState=e.state,this.calculator=new A(w,d(this.stableSwap.state),[T,T],new k(this.stableSwap.state.fees.trade.numerator,this.stableSwap.state.fees.trade.denominator))}getAccountsForUpdate(){return[this.stableSwap.config.swapAccount,i,this.stableSwap.state.tokenA.reserve,this.stableSwap.state.tokenB.reserve]}update(e){const[t,n,...o]=Mn(e,this.getAccountsForUpdate());this.stableSwapState=p(t.data);const i=Wo(n.data);this.calculator.setAmp(d(this.stableSwapState,i)),this.calculator.setTraderFee(new k(this.stableSwapState.fees.trade.numerator,this.stableSwapState.fees.trade.denominator)),this.tokenReserveAmounts=wn(o)}getQuote({sourceMint:e,destinationMint:t,amount:n}){if(this.stableSwap.state.isPaused)throw new Error("Saber pool is paused");if(!this.tokenReserveAmounts)throw new Error("Missing tokenReserveAmounts");const[o,i]=this.stableSwap.state.tokenA.mint.equals(e)?[0,1]:[1,0],a=this.calculator.exchange(this.tokenReserveAmounts,n,o,i),s=new nt(this.stableSwap.state.fees.trade.asFraction.toFixed(4));return{notEnoughLiquidity:!1,inAmount:n,outAmount:a.expectedOutputAmount,feeAmount:a.fees,feeMint:t.toBase58(),feePct:s.toNumber(),priceImpactPct:a.priceImpact.toNumber()}}getSwapLegAndAccounts(e){return function({stableSwap:e,sourceMint:t,userSourceTokenAccount:n,userDestinationTokenAccount:o,userTransferAuthority:i}){return[_n({saber:{}}),R.instruction.saberSwap({accounts:ho(e,t,n,o,i)}).keys]}({stableSwap:this.stableSwap,...e})}get reserveTokenMints(){return[this.stableSwap.state.tokenA.mint,this.stableSwap.state.tokenB.mint]}}const Ai=Qe([je(8,"discriminator"),Pn("factory"),Xe("bump"),In("index"),Pn("admin"),Pn("token0Reserves"),Pn("token0Mint"),Pn("token0Fees"),Pn("token1Reserves"),Pn("token1Mint"),Pn("token1Fees"),Xe("isPaused"),Pn("poolMint"),In("tradeFeeKbps"),In("withdrawFeeKbps"),In("adminTradeFeeKbps"),In("adminWithdrawFeeKbps")]);class yi{constructor(e,t){this.id=void 0,this.label="Sencha",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.poolState=void 0,this.calculator=void 0,this.tokenReserveAmounts=void 0,this.id=e.toBase58(),this.poolState=((e,t)=>{const n=t.owner,o=Ai.decode(t.data);return{programId:n,isPaused:Boolean(o.isPaused),bump:o.bump,ammId:e,token0Reserves:o.token0Reserves,token1Reserves:o.token1Reserves,token0Mint:o.token0Mint,token1Mint:o.token1Mint,token0Fees:o.token0Fees,token1Fees:o.token1Fees,poolMint:o.poolMint,tradeFeeKbps:o.tradeFeeKbps.toNumber()}})(e,t),this.calculator=new f(new k(v.BigInt(this.poolState.tradeFeeKbps),v.BigInt(1e7)),new k(M,M),!1)}get isPaused(){return this.poolState.isPaused}getAccountsForUpdate(){return[this.poolState.token0Reserves,this.poolState.token1Reserves]}update(e){const t=Mn(e,this.getAccountsForUpdate());this.tokenReserveAmounts=wn(t)}getQuote({sourceMint:e,amount:t}){if(this.isPaused)throw new Error("Sencha pool is paused");if(!this.tokenReserveAmounts)throw new Error("Missing tokenReserveAmounts");const n=this.poolState.token0Mint.equals(e)?1:0;let o=this.calculator.exchange(this.tokenReserveAmounts,t,n),i=this.poolState.tradeFeeKbps/1e7;return{notEnoughLiquidity:!1,inAmount:t,outAmount:o.expectedOutputAmount,feeAmount:o.fees,feeMint:e.toBase58(),feePct:i,priceImpactPct:o.priceImpact.toNumber()}}getSwapLegAndAccounts(e){return function({poolState:e,sourceMint:t,userSourceTokenAccount:n,userDestinationTokenAccount:o,userTransferAuthority:i}){const[a,s]=t.equals(e.token0Mint)?[e.token0Reserves,e.token1Reserves]:[e.token1Reserves,e.token0Reserves],[r,u]=t.equals(e.token0Mint)?[e.token0Fees,e.token1Fees]:[e.token1Fees,e.token0Fees];return[_n({sencha:{}}),R.instruction.senchaSwap({accounts:{swapProgram:e.programId,tokenProgram:L,swap:e.ammId,userAuthority:i,inputUserAccount:n,inputTokenAccount:a,inputFeesAccount:r,outputUserAccount:o,outputTokenAccount:s,outputFeesAccount:u}}).keys]}({poolState:this.poolState,...e})}get reserveTokenMints(){return[this.poolState.token0Mint,this.poolState.token1Mint]}}const Mi=["77quYg4MGneUdjgXCunt9GgM1usmrxKY31twEy3WHwcS","5cLrMai1DsLRYc1Nio9qMTicsWtvzjzZfJPXyAoF4t1Z","EERNEEnBqdGzBS8dd46wwNY5F2kwnaCQ3vsq2fNKGogZ","8sFf9TW3KzxLiBXcDcjAxqabEsRroo4EiRr3UG1xbJ9m","2iDSTGhjJEiRxNaLF27CY6daMYPs5hgYrP2REHd5YD62"],wi=["B2na8Awyd7cpC59iEU43FagJAPLigr3AP3s38KM982bu"];function*Ti(e){const t=e.isBids;for(const{key:n,quantity:o}of e.slab.items(t)){const e=v.BigInt(n.ushrn(64).toString());yield[e,v.BigInt(o.toString())]}}function vi(e,t){const n=e._decoded.baseLotSize;return n.isZero()?new nt(0):function(e,t){const n=new nt(e.div(t).toString()),o=e.umod(t),i=o.gcd(t);return n.add(new nt(o.div(i).toString()).div(new nt(t.div(i).toString())))}(t.mul(e._decoded.quoteLotSize).mul(e._baseSplTokenMultiplier),n.mul(e._quoteSplTokenMultiplier))}class Pi{constructor(e){this.market=void 0,this.id=void 0,this.label=void 0,this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this._orderbooks=void 0,this.isOpenbook=void 0,this.market=e,this.id=e.address.toBase58(),this.isOpenbook=e.programId.equals(ye),this.label=this.isOpenbook?"Openbook":"Serum"}get orderbooks(){return this._orderbooks}getAccountsForUpdate(){return[this.market.asksAddress,this.market.bidsAddress]}update(e){const[t,n]=Mn(e,this.getAccountsForUpdate()),o=m.decode(this.market,t.data),i=m.decode(this.market,n.data);this._orderbooks={asks:o,bids:i}}getQuote({sourceMint:e,destinationMint:t,amount:n}){if(!this.orderbooks)throw new Error("Failed to find orderbooks");const o=function({market:e,asks:t,bids:n,fromAmount:o,fromMint:i,toMint:a,isOpenbook:s}){const r=s?wi.includes(e.address.toBase58())?1e-4:4e-4:Mi.includes(e.address.toBase58())?1e-4:4e-4;return i.equals(e.quoteMintAddress)&&a.equals(e.baseMintAddress)?function(e,t,n,o){let i=M,a=M,s=M,r=M,u=M;const c=e.quoteSizeLotsToNumber(new O(1));let m=c?v.BigInt(new nt(n.toString()).div(1+o).div(c).floor()):M;const d=v.BigInt(e.baseSizeLotsToNumber(new O(1)).toString());for(let[e,n]of Ti(t)){v.equal(a,M)&&(a=e),s=e;const t=v.multiply(n,d),o=v.multiply(n,e);if(u=v.add(u,t),v.greaterThanOrEqual(o,m)){const t=v.divide(m,e);r=v.add(r,v.multiply(e,t)),i=v.add(i,v.multiply(d,t)),m=M;break}r=v.add(r,v.multiply(e,n)),i=v.add(i,t),m=v.subtract(m,o)}let p=0;if(v.notEqual(a,M)){const e=new nt(a.toString());p=new nt(s.toString()).sub(e).div(e).toNumber()}const l=vi(e,new O(a.toString())),h=vi(e,new O(r.toString())),g=h.mul(d.toString()).ceil(),k=h.mul(d.toString()).mul(o).ceil();return{side:"buy",notEnoughLiquidity:v.lessThanOrEqual(u,i),minimum:{in:v.BigInt(l.mul(d.toString()).mul(1+o).ceil()),out:d},inAmount:v.BigInt(g.add(k)),outAmount:i,feeAmount:v.BigInt(k),priceImpactPct:p,feePct:o}}(e,t,o,r):function(e,t,n,o){let i=v.BigInt(0),a=v.BigInt(0),s=v.BigInt(0),r=v.BigInt(0),u=n,c=v.BigInt(0);const m=v.BigInt(e.baseSizeLotsToNumber(new O(1))),d=v.BigInt(e.quoteSizeLotsToNumber(new O(1)));for(const[e,n]of Ti(t)){v.equal(a,M)&&(a=e),s=e;const t=v.multiply(m,n),o=v.multiply(n,v.multiply(e,d));if(r=v.add(r,t),v.greaterThanOrEqual(t,u)){const t=v.divide(u,m),n=v.multiply(t,e);i=v.add(i,v.multiply(n,d)),u=v.subtract(u,n),c=v.add(c,v.multiply(t,m));break}i=v.add(i,o),u=v.subtract(u,t),c=v.add(c,t)}let p=new nt(i.toString()).mul(1-o).floor(),l=0;const h=vi(e,new O(a.toString()));if(v.notEqual(a,M)){const t=vi(e,new O(s.toString()));l=h.minus(t).div(h).toNumber()}return{side:"sell",notEnoughLiquidity:v.greaterThan(v.BigInt(n),r),minimum:{in:m,out:v.BigInt(h.mul(v.toNumber(m)).mul(1-o).floor().toString())},inAmount:c,outAmount:v.BigInt(p),feeAmount:v.BigInt(new nt(i.toString()).mul(o).round()),priceImpactPct:l,feePct:o}}(e,n,o,r)}({market:this.market,asks:this.orderbooks.asks,bids:this.orderbooks.bids,fromMint:e,toMint:t,fromAmount:n,isOpenbook:this.isOpenbook});return{notEnoughLiquidity:o.notEnoughLiquidity,minInAmount:o.minimum.in,minOutAmount:o.minimum.out,inAmount:o.inAmount,outAmount:o.outAmount,feeAmount:o.feeAmount,feeMint:this.market.quoteMintAddress.toBase58(),feePct:o.feePct,priceImpactPct:o.priceImpactPct}}getSwapLegAndAccounts(e){var t;if(!e.openOrdersAddress)throw new Error("Missing open orders");return function({market:e,sourceMint:t,openOrdersAddress:n,userSourceTokenAccount:o,userDestinationTokenAccount:i,userTransferAuthority:a,referrer:s,isOpenbook:r}){const{side:u,coinWallet:c,pcWallet:m}=t.equals(e.baseMintAddress)?{side:On.Ask,coinWallet:o,pcWallet:i}:{side:On.Bid,coinWallet:i,pcWallet:o};return[_n(r?Wn(u):En(u)),R.instruction.serumSwap({accounts:lo(e,n,o,c,m,a),remainingAccounts:s?[{pubkey:s,isSigner:!1,isWritable:!0}]:[ro]}).keys]}({market:this.market,openOrdersAddress:e.openOrdersAddress,referrer:null==e||null===(t=e.quoteMintToReferrer)||void 0===t?void 0:t.get(this.market.quoteMintAddress.toBase58()),isOpenbook:this.isOpenbook,...e})}get reserveTokenMints(){return[this.market.baseMintAddress,this.market.quoteMintAddress]}}Pi.getL2=Ti;const bi=Qe([Xe("version"),Xe("isInitialized"),Xe("bumpSeed"),Pn("tokenProgramId"),Pn("tokenAccountA"),Pn("tokenAccountB"),Pn("tokenPool"),Pn("mintA"),Pn("mintB"),Pn("feeAccount"),In("tradeFeeNumerator"),In("tradeFeeDenominator"),In("ownerTradeFeeNumerator"),In("ownerTradeFeeDenominator"),In("ownerWithdrawFeeNumerator"),In("ownerWithdrawFeeDenominator"),In("hostFeeNumerator"),In("hostFeeDenominator"),Xe("curveType"),je(32,"curveParameters")]),Ii=Qe([Xe("version"),Xe("isInitialized"),Xe("bumpSeed"),Pn("tokenProgramId"),Pn("tokenAccountA"),Pn("tokenAccountB"),Pn("tokenPool"),Pn("mintA"),Pn("mintB"),Pn("feeAccount"),In("tradeFeeNumerator"),In("tradeFeeDenominator"),In("ownerTradeFeeNumerator"),In("ownerTradeFeeDenominator"),In("ownerWithdrawFeeNumerator"),In("ownerWithdrawFeeDenominator"),Xe("curveType"),je(32,"curveParameters"),Xe("poolNonce")]);var Bi;!function(e){e[e.ConstantProduct=0]="ConstantProduct",e[e.Stable=2]="Stable"}(Bi||(Bi={}));class Fi{constructor(t,n,o){if(this.label=void 0,this.id=void 0,this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.tokenSwapState=void 0,this.curveType=void 0,this.feePct=void 0,this.tokenReserveAmounts=void 0,this.calculator=void 0,this.label=o,this.id=t.toBase58(),this.tokenSwapState=function(t,n){const o=n.owner,i=o.equals(Me)?Ii.decode(n.data):bi.decode(n.data);if(!i.isInitialized)throw new Error("Invalid token swap state");const a=Fn([t.toBuffer(),Buffer.from([i.bumpSeed])],o),s=new e(i.tokenPool),r=new e(i.feeAccount),u=new e(i.tokenAccountA),c=new e(i.tokenAccountB),m=new e(i.mintA),d=new e(i.mintB);return{address:t,programId:o,tokenProgramId:new e(i.tokenProgramId),poolToken:s,feeAccount:r,authority:a,tokenAccountA:u,tokenAccountB:c,mintA:m,mintB:d,tradeFeeNumerator:i.tradeFeeNumerator,tradeFeeDenominator:i.tradeFeeDenominator,ownerTradeFeeNumerator:i.ownerTradeFeeNumerator,ownerTradeFeeDenominator:i.ownerTradeFeeDenominator,ownerWithdrawFeeNumerator:i.ownerWithdrawFeeNumerator,ownerWithdrawFeeDenominator:i.ownerWithdrawFeeDenominator,curveType:i.curveType,curveParameters:i.curveParameters,poolNonce:"poolNonce"in i?i.poolNonce:void 0}}(t,n),this.curveType=this.tokenSwapState.curveType,!(this.curveType in Bi))throw new Error(`curveType ${this.tokenSwapState.curveType} is not supported`);const i=Fi.getFeeFraction(this.tokenSwapState.tradeFeeNumerator,this.tokenSwapState.tradeFeeDenominator),a=Fi.getFeeFraction(this.tokenSwapState.ownerTradeFeeNumerator,this.tokenSwapState.ownerTradeFeeDenominator);this.calculator=this.tokenSwapState.curveType===Bi.ConstantProduct?new f(i,a):new g(v.BigInt(this.tokenSwapState.curveParameters[0]),i,a),this.feePct=Fi.getFeeDecimal(this.tokenSwapState.tradeFeeNumerator,this.tokenSwapState.tradeFeeDenominator).add(Fi.getFeeDecimal(this.tokenSwapState.ownerTradeFeeNumerator,this.tokenSwapState.ownerTradeFeeDenominator)).toNumber()}static getFeeFraction(e,t){return new k(v.BigInt(e.toString()),v.BigInt(t.toString()))}static getFeeDecimal(e,t){return e.eq(new D(0))?new nt(0):new nt(e.toString()).div(t.toString())}getAccountsForUpdate(){return[this.tokenSwapState.tokenAccountA,this.tokenSwapState.tokenAccountB]}update(e){const t=Mn(e,this.getAccountsForUpdate());this.tokenReserveAmounts=wn(t)}getQuote({sourceMint:e,amount:t}){if(!this.tokenReserveAmounts)throw new Error("Missing tokenReserveAmounts");const n=this.reserveTokenMints[0].equals(e)?1:0,o=this.calculator.exchange(this.tokenReserveAmounts,t,n);return{notEnoughLiquidity:!1,inAmount:t,outAmount:o.expectedOutputAmount,feeAmount:o.fees,feeMint:e.toBase58(),feePct:this.feePct,priceImpactPct:o.priceImpact.toNumber()}}getSwapLegAndAccounts(e){return function({tokenSwapState:e,sourceMint:t,userSourceTokenAccount:n,userDestinationTokenAccount:o,userTransferAuthority:i,isStep:a}){const[s,r]=t.equals(e.mintA)?[e.tokenAccountA,e.tokenAccountB]:[e.tokenAccountB,e.tokenAccountA];return[_n(a?{step:{}}:{tokenSwap:{}}),(a?R.instruction.stepSwap:R.instruction.tokenSwap)({accounts:{tokenSwapProgram:e.programId,tokenProgram:L,swap:e.address,authority:e.authority,userTransferAuthority:i,source:n,swapSource:s,swapDestination:r,destination:o,poolMint:e.poolToken,poolFee:e.feeAccount}}).keys]}({tokenSwapState:this.tokenSwapState,...e,isStep:this.tokenSwapState.programId.equals(Me)})}get reserveTokenMints(){return[this.tokenSwapState.mintA,this.tokenSwapState.mintB]}}function Di(e){return e.reduce(((t,n)=>(e.forEach((e=>{n!==e&&t.push([n,e])})),t)),new Array)}const Li=v.BigInt(100);class qi{constructor(e,t,n){this.firstAmm=void 0,this.secondAmm=void 0,this.reserveTokenMints=void 0,this.market=void 0,this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.portion1=0,this.portion2=0,this.firstAmm=e,this.secondAmm=t,this.reserveTokenMints=n,this.market=e instanceof Pi?e.market:t instanceof Pi?t.market:null}static getAmmIdsFromSplitTradeAmmId(e){const t=e.split("-");return t.length>1?t:[]}static create(e,t){if(!function(e,t){return!fn(ln,e.label,t.label)}(e,t))return;const n=Di(e.reserveTokenMints),o=Di(t.reserveTokenMints);for(const i of n)for(const n of o)if(i.every(((e,t)=>e.equals(n[t]))))return new qi(e,t,i)}setPortions(e,t){if(e+t!==100)throw new Error("Split trade portions must sum to 100");this.portion1=e,this.portion2=t}get id(){return`${this.firstAmm.id}-${this.secondAmm.id}`}get label(){return[{label:this.firstAmm.label,portion:this.portion1},{label:this.secondAmm.label,portion:this.portion2}].sort(((e,t)=>t.portion-e.portion)).map((({label:e,portion:t})=>`${e} (${t}%)`)).join(" + ")}getAccountsForUpdate(){return[]}update(e){}getQuote(e){const t=e.sourceMint.toBase58(),n=e.amount;let o={outAmount:M,portion:0,firstQuote:void 0,secondQuote:void 0};for(let t=100;t-=5;t>0){const i=v.divide(v.multiply(n,v.BigInt(t)),Li),a=v.subtract(n,i),s=this.firstAmm.getQuote({...e,amount:i}),r=this.secondAmm.getQuote({...e,amount:a}),u=v.add(s.outAmount,r.outAmount);if(v.lessThan(u,o.outAmount))break;o={outAmount:u,portion:t,firstQuote:s,secondQuote:r}}if(!o.firstQuote||!o.secondQuote)throw new Error("Unreachable: There was no better solution than getting 0 outAmount");const{outAmount:i,portion:a,firstQuote:s,secondQuote:r}=o,u=a,c=100-u;this.portion1=u,this.portion2=c;let m={amount:s.feeAmount,mint:s.feeMint},d={amount:r.feeAmount,mint:r.feeMint};m.mint!==d.mint&&(m.mint!==t&&(m={amount:v.divide(v.divide(v.multiply(m.amount,v.multiply(n,v.BigInt(u))),Li),o.outAmount),mint:t}),d.mint!==t&&(d={amount:v.divide(v.divide(v.multiply(v.multiply(d.amount,n),v.BigInt(c)),Li),o.outAmount),mint:t}));const p=(u*s.feePct+c*r.feePct)/100,l=(u*s.priceImpactPct+c*r.priceImpactPct)/100;return{notEnoughLiquidity:!1,inAmount:e.amount,outAmount:i,feeAmount:v.add(m.amount,d.amount),feeMint:m.mint,feePct:p,priceImpactPct:l}}getSwapLegAndAccounts(e){let[t,n]=this.firstAmm.getSwapLegAndAccounts(e),[o,i]=this.secondAmm.getSwapLegAndAccounts(e),a=[$n(this.portion1,t),$n(this.portion2,o)],s=[...n,...i];return[Yn(a),s]}}function xi(e,t){const n=nn.parse(t);if(!n)throw new Error(`Failed to parse whirlpool ${e.toBase58()}`);return n}function Oi(e,t){const n=on.parse(t);if(!n)throw new Error(`Failed to parse tick array ${e.toBase58()}`);return n}class Ei{constructor(e,t){this.address=void 0,this.id=void 0,this.label="Orca (Whirlpools)",this.shouldPrefetch=!0,this.exactOutputSupported=!0,this.hasDynamicAccounts=!0,this.whirlpoolData=void 0,this.tickArrays={aToB:[],bToA:[]},this.tickPks=void 0,this.oracle=void 0,this.feePct=void 0,this.address=e,this.id=e.toBase58(),this.whirlpoolData=xi(e,t.data),this.oracle=B([Buffer.from("oracle"),e.toBuffer()],j)[0],this.feePct=new nt(this.whirlpoolData.feeRate).div(1e6),this.tickPks=this.getTickArrayPks()}getTickArrayPks(){const e={aToB:[],bToA:[]};return[!0,!1].forEach((t=>{e[t?"aToB":"bToA"].push(...en.getTickArrayPublicKeys(this.whirlpoolData.tickCurrentIndex,this.whirlpoolData.tickSpacing,t,j,this.address))})),e}getAccountsForUpdate(){return[this.address,...this.tickPks.aToB,...this.tickPks.bToA]}update(e){const t=e.get(this.address.toBase58());if(!t)throw new Error(`Missing ${this.address.toBase58()}`);this.whirlpoolData=xi(this.address,t.data),this.tickPks=this.getTickArrayPks();const n={aToB:[],bToA:[]};[!0,!1].forEach((t=>{const o=t?"aToB":"bToA";for(const t of this.tickPks[o]){const i=t.toBase58(),a=e.get(i);if(!a)continue;const s=Oi(t,a.data);n[o].push({address:t,data:s})}})),this.tickArrays=n}getQuote({sourceMint:e,amount:t,swapMode:n}){const o=!!e.equals(this.whirlpoolData.tokenMintA),i=n===yn.ExactIn,a=tn({amountSpecifiedIsInput:i,aToB:o,otherAmountThreshold:en.getDefaultOtherAmountThreshold(i),sqrtPriceLimit:en.getDefaultSqrtPriceLimit(o),tickArrays:this.tickArrays[o?"aToB":"bToA"],tokenAmount:new O(t.toString()),whirlpoolData:this.whirlpoolData}),s=v.BigInt(a.estimatedAmountIn.toString()),r=v.BigInt(a.estimatedAmountOut.toString()),u=v.BigInt(a.estimatedFeeAmount.toString()),c=a.aToB?new nt(a.estimatedAmountOut.toString()).div(a.estimatedAmountIn.toString()):new nt(a.estimatedAmountIn.toString()).div(a.estimatedAmountOut.toString()),m=(d=this.whirlpoolData.sqrtPrice,new nt(d.toString()).mul(nt.pow(2,-64))).pow(2);var d;const p=m.minus(c).div(m).abs().toNumber();return{notEnoughLiquidity:!1,inAmount:s,outAmount:r,feeAmount:u,feeMint:e.toBase58(),feePct:this.feePct.toNumber(),priceImpactPct:Number(p)}}getSwapLegAndAccounts(e){const t=e.sourceMint.equals(this.whirlpoolData.tokenMintA),n=e.swapMode===yn.ExactIn,{tickArray0:o,tickArray1:i,tickArray2:a}=tn({amountSpecifiedIsInput:n,aToB:t,otherAmountThreshold:en.getDefaultOtherAmountThreshold(n),sqrtPriceLimit:en.getDefaultSqrtPriceLimit(t),tickArrays:this.tickArrays[t?"aToB":"bToA"],tokenAmount:new O(e.amount.toString()),whirlpoolData:this.whirlpoolData});return function({additionalArgs:e,userSourceTokenAccount:t,userDestinationTokenAccount:n,userTransferAuthority:o}){const[i,a]=e.aToB?[t,n]:[n,t];return[_n(Vn(e.aToB)),R.instruction.whirlpoolSwap({accounts:{swapProgram:j,tokenProgram:L,tokenAuthority:o,whirlpool:e.whirlpool,tokenOwnerAccountA:i,tokenVaultA:e.tokenVaultA,tokenOwnerAccountB:a,tokenVaultB:e.tokenVaultB,tickArray0:e.tickArray0,tickArray1:e.tickArray1,tickArray2:e.tickArray2,oracle:e.oracle}}).keys]}({additionalArgs:{aToB:t,whirlpool:this.address,tickArray0:o,tickArray1:i,tickArray2:a,oracle:this.oracle,...this.whirlpoolData},...e})}createExactOutSwapInstruction(e){const t=e.sourceMint.equals(this.whirlpoolData.tokenMintA),n=e.swapMode===yn.ExactIn,{tickArray0:o,tickArray1:i,tickArray2:a}=tn({amountSpecifiedIsInput:n,aToB:t,otherAmountThreshold:en.getDefaultOtherAmountThreshold(n),sqrtPriceLimit:en.getDefaultSqrtPriceLimit(t),tickArrays:this.tickArrays[t?"aToB":"bToA"],tokenAmount:new O(e.amount.toString()),whirlpoolData:this.whirlpoolData});return function({additionalArgs:e,userSourceTokenAccount:t,userDestinationTokenAccount:n,userTransferAuthority:o,outAmount:i,inAmount:a,slippageBps:s,platformFee:r,overflowFeeAccount:u}){var c;const[m,d]=e.aToB?[t,n]:[n,t];return R.instruction.whirlpoolSwapExactOutput(i,{amount:a,slippageBps:s},e.aToB,null!==(c=null==r?void 0:r.feeBps)&&void 0!==c?c:0,{accounts:{swapProgram:j,tokenProgram:L,tokenAuthority:o,whirlpool:e.whirlpool,tokenOwnerAccountA:m,tokenVaultA:e.tokenVaultA,tokenOwnerAccountB:d,tokenVaultB:e.tokenVaultB,tickArray0:e.tickArray0,tickArray1:e.tickArray1,tickArray2:e.tickArray2,oracle:e.oracle},remainingAccounts:go(null==r?void 0:r.feeAccount,u)})}({additionalArgs:{aToB:t,whirlpool:this.address,tickArray0:o,tickArray1:i,tickArray2:a,oracle:this.oracle,...this.whirlpoolData},...e,outAmount:new O(e.amount.toString()),inAmount:new O(e.inAmount.toString())})}get reserveTokenMints(){return[this.whirlpoolData.tokenMintA,this.whirlpoolData.tokenMintB]}}class Ci{constructor(t,n,o){this.address=void 0,this.id=void 0,this.label="Dradex",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.state=void 0,this.orderBookState=void 0,this.quoteCalculator=void 0,this.marketUser=void 0,this.address=t,this.id=t.toBase58(),this.state=an.accounts.decode("market",n.data),this.marketUser=new e(o.marketUser)}getAccountsForUpdate(){return[this.address,...this.reserveTokenMints,this.state.orderBook.bids,this.state.orderBook.asks]}update(e){const t=e.get(this.id),n=e.get(this.state.orderBook.bids.toString()),o=e.get(this.state.orderBook.asks.toString()),i=this.reserveTokenMints.map((t=>e.get(t.toString())));if(!t||!n||!o||i.find((e=>!e)))throw new Error(`One of the required accounts is missing: ${this.address.toBase58()}`);if(i.length!==this.reserveTokenMints.length)throw new Error(`Missing mint info: ${this.address.toBase58()}`);this.state=an.accounts.decode("market",t.data);const a=this.reserveTokenMints.map(((e,t)=>I(i[t].data,e)));this.orderBookState={bids:rn.decode(n.data).items,asks:rn.decode(o.data).items},this.quoteCalculator=new sn(this.state,this.orderBookState,a)}getQuote(e){if(!this.quoteCalculator)throw new Error(`Quote calculator is not initialized: ${this.address.toBase58()}`);const t=this.quoteCalculator.getQuote(e);return{...t,priceImpactPct:t.priceImpactPct/100}}getSwapLegAndAccounts(e){var t;return function({additionalArgs:e,userSourceTokenAccount:t,userDestinationTokenAccount:o,userTransferAuthority:i,sourceMint:a}){const{side:s,t0User:r,t1User:u}=a.equals(e.t0)?{side:On.Ask,t0User:t,t1User:o}:{side:On.Bid,t0User:o,t1User:t};return[_n(Kn(s)),R.instruction.dradexSwap({accounts:{swapProgram:oe,pair:e.pair,market:e.market,eventQueue:e.eventQueue,dexUser:ie,marketUser:e.marketUser,bids:e.bids,asks:e.asks,t0Vault:e.t0Vault,t1Vault:e.t1Vault,t0User:r,t1User:u,master:ae,signer:i,systemProgram:n.programId,tokenProgram:L,logger:se},remainingAccounts:e.referrer?[{pubkey:e.referrer,isSigner:!1,isWritable:!0}]:[ro]}).keys]}({additionalArgs:{pair:this.state.pair,market:this.address,eventQueue:this.state.eventQueue,marketUser:this.marketUser,bids:this.state.orderBook.bids,asks:this.state.orderBook.asks,t0:this.state.t0,t1:this.state.t1,t0Vault:this.state.t0Vault,t1Vault:this.state.t1Vault,referrer:null===(t=e.quoteMintToReferrer)||void 0===t?void 0:t.get(e.destinationMint.toBase58())},...e})}get reserveTokenMints(){return[this.state.t0,this.state.t1]}}class Ri{constructor(e,t){this.address=void 0,this.label="Raydium CLMM",this.id=void 0,this.reserveTokenMints=void 0,this.hasDynamicAccounts=!0,this.shouldPrefetch=!0,this.exactOutputSupported=!0,this.programId=void 0,this.poolState=void 0,this.coder=void 0,this.tickArrayPks=void 0,this.tickArrayCache={},this.ammV3PoolInfo=void 0,this.address=e,this.id=e.toBase58(),this.address=e,this.coder=new Je(un),this.poolState=this.coder.decode("poolState",t.data),this.reserveTokenMints=[this.poolState.tokenMint0,this.poolState.tokenMint1],this.programId=me,this.tickArrayPks=cn.getTickArrayPks(this.address,this.poolState,this.programId)}getAccountsForUpdate(){return[this.address,this.poolState.ammConfig,...this.tickArrayPks]}update(e){const t=e.get(this.id);if(!t)throw new Error("Missing poolStateAccountInfo");const n=e.get(this.poolState.ammConfig.toBase58());if(!n)throw new Error("Missing ammConfigAccoutnInfo");this.poolState=this.coder.decode("poolState",t.data);const o=this.coder.decode("ammConfig",n.data);this.tickArrayPks=cn.getTickArrayPks(this.address,this.poolState,this.programId);const i={};for(const t of this.tickArrayPks){const n=e.get(t.toBase58());if(!n)continue;const o=this.coder.decode("tickArrayState",n.data);i[o.startTickIndex]={...o,address:t}}this.tickArrayCache=i,this.ammV3PoolInfo=cn.formatPoolInfo({address:this.address,poolState:this.poolState,ammConfig:o,programId:this.programId})}getQuote(e){if(0!==this.poolState.status)throw new Error("Pool is not swapable");if(!this.ammV3PoolInfo)throw new Error("Missing ammV3PoolInfo");if(e.swapMode===yn.ExactIn){const{amountOut:t,fee:n,priceImpact:o}=cn.computeAmountOut({poolInfo:this.ammV3PoolInfo,tickArrayCache:this.tickArrayCache,baseMint:e.sourceMint,amountIn:new O(e.amount.toString()),slippage:0});return{notEnoughLiquidity:!1,inAmount:e.amount,outAmount:v.BigInt(t.toString()),feeAmount:v.BigInt(n.toString()),feeMint:e.sourceMint.toString(),feePct:this.ammV3PoolInfo.ammConfig.tradeFeeRate/10**6,priceImpactPct:o}}{const{amountIn:t,fee:n,priceImpact:o}=cn.computeAmountIn({poolInfo:this.ammV3PoolInfo,tickArrayCache:this.tickArrayCache,baseMint:e.destinationMint,amountOut:new O(e.amount.toString()),slippage:0});return{notEnoughLiquidity:!1,inAmount:v.BigInt(t.toString()),outAmount:e.amount,feeAmount:v.BigInt(n.toString()),feeMint:e.sourceMint.toString(),feePct:this.ammV3PoolInfo.ammConfig.tradeFeeRate/10**6,priceImpactPct:o}}}getSwapLegAndAccounts(e){if(!this.ammV3PoolInfo)throw new Error("Missing ammV3PoolInfo");const{remainingAccounts:t}=cn.computeAmountOut({poolInfo:this.ammV3PoolInfo,tickArrayCache:this.tickArrayCache,baseMint:e.sourceMint,amountIn:new O(e.amount.toString()),slippage:0}),[n,o]=e.sourceMint.equals(this.poolState.tokenMint0)?[this.poolState.tokenVault0,this.poolState.tokenVault1]:[this.poolState.tokenVault1,this.poolState.tokenVault0],i=t.shift();if(!i)throw new Error("Missing at least one tick array");return function({additionalArgs:e,userSourceTokenAccount:t,userDestinationTokenAccount:n,userTransferAuthority:o}){const i=e.remainingAccounts.map((e=>({pubkey:e,isWritable:!0,isSigner:!1})));return i.push(ro),[_n({raydiumClmm:{}}),R.instruction.raydiumClmmSwap({accounts:{swapProgram:me,payer:o,ammConfig:e.ammConfig,poolState:e.poolState,inputTokenAccount:t,outputTokenAccount:n,inputVault:e.inputVault,outputVault:e.outputVault,observationState:e.observationState,tokenProgram:L,tickArray:e.tickArray},remainingAccounts:i}).keys]}({additionalArgs:{poolState:this.address,inputVault:n,outputVault:o,observationState:this.poolState.observationKey,tickArray:i,remainingAccounts:t,...this.poolState},...e})}createExactOutSwapInstruction(e){if(!this.ammV3PoolInfo)throw new Error("Missing ammV3PoolInfo");const{remainingAccounts:t}=cn.computeAmountIn({poolInfo:this.ammV3PoolInfo,tickArrayCache:this.tickArrayCache,baseMint:e.sourceMint,amountOut:new O(e.amount.toString()),slippage:0}),[n,o]=e.sourceMint.equals(this.poolState.tokenMint0)?[this.poolState.tokenVault0,this.poolState.tokenVault1]:[this.poolState.tokenVault1,this.poolState.tokenVault0],i=t.shift();if(!i)throw new Error("Missing at least one tick array");return function({additionalArgs:e,userSourceTokenAccount:t,userDestinationTokenAccount:n,userTransferAuthority:o,outAmount:i,inAmount:a,slippageBps:s,platformFee:r,overflowFeeAccount:u}){var c;const m=e.remainingAccounts.map((e=>({pubkey:e,isWritable:!0,isSigner:!1})));return m.push(ro),m.push(...go(null==r?void 0:r.feeAccount,u)),R.instruction.raydiumClmmSwapExactOutput(i,{amount:a,slippageBps:s},null!==(c=null==r?void 0:r.feeBps)&&void 0!==c?c:0,{accounts:{swapProgram:me,payer:o,ammConfig:e.ammConfig,poolState:e.poolState,inputTokenAccount:t,outputTokenAccount:n,inputVault:e.inputVault,outputVault:e.outputVault,observationState:e.observationState,tokenProgram:L,tickArray:e.tickArray},remainingAccounts:m})}({additionalArgs:{poolState:this.address,inputVault:n,outputVault:o,observationState:this.poolState.observationKey,tickArray:i,remainingAccounts:t,...this.poolState},...e,outAmount:new O(e.amount.toString()),inAmount:new O(e.inAmount.toString())})}}const Ni=new Ze({version:"0.1.1",name:"marcopolo",instructions:[{name:"createPool",accounts:[{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"poolXAccount",isMut:!0,isSigner:!0},{name:"poolYAccount",isMut:!0,isSigner:!0},{name:"adminXAccount",isMut:!0,isSigner:!1},{name:"adminYAccount",isMut:!0,isSigner:!1},{name:"admin",isMut:!0,isSigner:!0},{name:"projectOwner",isMut:!1,isSigner:!1},{name:"programAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[{name:"lpFee",type:{defined:"FixedPoint"}},{name:"buybackFee",type:{defined:"FixedPoint"}},{name:"projectFee",type:{defined:"FixedPoint"}},{name:"mercantiFee",type:{defined:"FixedPoint"}},{name:"initialTokenX",type:{defined:"Token"}},{name:"initialTokenY",type:{defined:"Token"}},{name:"bump",type:"u8"}]},{name:"createProvider",accounts:[{name:"pool",isMut:!0,isSigner:!1},{name:"farm",isMut:!0,isSigner:!1},{name:"provider",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"poolXAccount",isMut:!0,isSigner:!1},{name:"poolYAccount",isMut:!0,isSigner:!1},{name:"ownerXAccount",isMut:!0,isSigner:!1},{name:"ownerYAccount",isMut:!0,isSigner:!1},{name:"owner",isMut:!0,isSigner:!0},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[{name:"tokenXAmount",type:{defined:"Token"}},{name:"tokenYAmount",type:{defined:"Token"}},{name:"bump",type:"u8"}]},{name:"createState",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"admin",isMut:!0,isSigner:!0},{name:"programAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[{name:"nonce",type:"u8"}]},{name:"addTokens",accounts:[{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!0,isSigner:!1},{name:"farm",isMut:!0,isSigner:!1},{name:"provider",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"tokenMarco",isMut:!0,isSigner:!1},{name:"tokenProjectFirst",isMut:!0,isSigner:!1},{name:"tokenProjectSecond",isMut:!0,isSigner:!1},{name:"ownerXAccount",isMut:!0,isSigner:!1},{name:"ownerYAccount",isMut:!0,isSigner:!1},{name:"poolXAccount",isMut:!0,isSigner:!1},{name:"poolYAccount",isMut:!0,isSigner:!1},{name:"ownerMarcoAccount",isMut:!0,isSigner:!1},{name:"ownerProjectFirstAccount",isMut:!0,isSigner:!1},{name:"ownerProjectSecondAccount",isMut:!0,isSigner:!1},{name:"tokenMarcoAccount",isMut:!0,isSigner:!1},{name:"tokenProjectFirstAccount",isMut:!0,isSigner:!1},{name:"tokenProjectSecondAccount",isMut:!0,isSigner:!1},{name:"owner",isMut:!0,isSigner:!0},{name:"programAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"associatedTokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[{name:"deltaX",type:{defined:"Token"}},{name:"deltaY",type:{defined:"Token"}}]},{name:"withdrawBuyback",accounts:[{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"buybackXAccount",isMut:!0,isSigner:!1},{name:"buybackYAccount",isMut:!0,isSigner:!1},{name:"poolXAccount",isMut:!0,isSigner:!1},{name:"poolYAccount",isMut:!0,isSigner:!1},{name:"admin",isMut:!0,isSigner:!0},{name:"programAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"associatedTokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[]},{name:"swap",accounts:[{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"poolXAccount",isMut:!0,isSigner:!1},{name:"poolYAccount",isMut:!0,isSigner:!1},{name:"swapperXAccount",isMut:!0,isSigner:!1},{name:"swapperYAccount",isMut:!0,isSigner:!1},{name:"swapper",isMut:!0,isSigner:!0},{name:"referrerXAccount",isMut:!0,isSigner:!1},{name:"referrerYAccount",isMut:!0,isSigner:!1},{name:"referrer",isMut:!0,isSigner:!1},{name:"programAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"associatedTokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[{name:"deltaIn",type:{defined:"Token"}},{name:"priceLimit",type:{defined:"FixedPoint"}},{name:"xToY",type:"bool"}]},{name:"withdrawShares",accounts:[{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!0,isSigner:!1},{name:"farm",isMut:!0,isSigner:!1},{name:"provider",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"tokenMarco",isMut:!0,isSigner:!1},{name:"tokenProjectFirst",isMut:!0,isSigner:!1},{name:"tokenProjectSecond",isMut:!0,isSigner:!1},{name:"poolXAccount",isMut:!0,isSigner:!1},{name:"poolYAccount",isMut:!0,isSigner:!1},{name:"tokenMarcoAccount",isMut:!0,isSigner:!1},{name:"tokenProjectFirstAccount",isMut:!0,isSigner:!1},{name:"tokenProjectSecondAccount",isMut:!0,isSigner:!1},{name:"ownerXAccount",isMut:!0,isSigner:!1},{name:"ownerYAccount",isMut:!0,isSigner:!1},{name:"ownerMarcoAccount",isMut:!0,isSigner:!1},{name:"ownerProjectFirstAccount",isMut:!0,isSigner:!1},{name:"ownerProjectSecondAccount",isMut:!0,isSigner:!1},{name:"owner",isMut:!0,isSigner:!0},{name:"programAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"associatedTokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[{name:"shares",type:{defined:"Token"}}]},{name:"withdrawLpFee",accounts:[{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!1,isSigner:!1},{name:"provider",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"ownerXAccount",isMut:!0,isSigner:!1},{name:"ownerYAccount",isMut:!0,isSigner:!1},{name:"poolXAccount",isMut:!0,isSigner:!1},{name:"poolYAccount",isMut:!0,isSigner:!1},{name:"owner",isMut:!0,isSigner:!0},{name:"programAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"associatedTokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[]},{name:"withdrawProjectFee",accounts:[{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"projectOwnerXAccount",isMut:!0,isSigner:!1},{name:"projectOwnerYAccount",isMut:!0,isSigner:!1},{name:"poolXAccount",isMut:!0,isSigner:!1},{name:"poolYAccount",isMut:!0,isSigner:!1},{name:"projectOwner",isMut:!0,isSigner:!0},{name:"programAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"associatedTokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[]},{name:"createFarm",accounts:[{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!1,isSigner:!1},{name:"farm",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"tokenMarco",isMut:!1,isSigner:!1},{name:"tokenMarcoAccount",isMut:!0,isSigner:!0},{name:"adminMarcoAccount",isMut:!0,isSigner:!1},{name:"admin",isMut:!0,isSigner:!0},{name:"programAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[{name:"supply",type:{defined:"Token"}},{name:"duration",type:"u64"},{name:"bump",type:"u8"}]},{name:"createDualFarm",accounts:[{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!1,isSigner:!1},{name:"farm",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"tokenMarco",isMut:!1,isSigner:!1},{name:"tokenProjectFirst",isMut:!1,isSigner:!1},{name:"tokenMarcoAccount",isMut:!0,isSigner:!0},{name:"tokenProjectFirstAccount",isMut:!0,isSigner:!0},{name:"adminMarcoAccount",isMut:!0,isSigner:!1},{name:"adminProjectFirstAccount",isMut:!0,isSigner:!1},{name:"admin",isMut:!0,isSigner:!0},{name:"programAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[{name:"supplyMarco",type:{defined:"Token"}},{name:"supplyProjectFirst",type:{defined:"Token"}},{name:"duration",type:"u64"},{name:"bump",type:"u8"}]},{name:"createTripleFarm",accounts:[{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!1,isSigner:!1},{name:"farm",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"tokenMarco",isMut:!1,isSigner:!1},{name:"tokenProjectFirst",isMut:!1,isSigner:!1},{name:"tokenProjectSecond",isMut:!1,isSigner:!1},{name:"tokenMarcoAccount",isMut:!0,isSigner:!0},{name:"tokenProjectFirstAccount",isMut:!0,isSigner:!0},{name:"tokenProjectSecondAccount",isMut:!0,isSigner:!0},{name:"adminMarcoAccount",isMut:!0,isSigner:!1},{name:"adminProjectFirstAccount",isMut:!0,isSigner:!1},{name:"adminProjectSecondAccount",isMut:!0,isSigner:!1},{name:"admin",isMut:!0,isSigner:!0},{name:"programAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[{name:"supplyMarco",type:{defined:"Token"}},{name:"supplyProjectFirst",type:{defined:"Token"}},{name:"supplyProjectSecond",type:{defined:"Token"}},{name:"duration",type:"u64"},{name:"bump",type:"u8"}]},{name:"withdrawRewards",accounts:[{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!1,isSigner:!1},{name:"farm",isMut:!0,isSigner:!1},{name:"provider",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"tokenMarco",isMut:!0,isSigner:!1},{name:"tokenProjectFirst",isMut:!0,isSigner:!1},{name:"tokenProjectSecond",isMut:!0,isSigner:!1},{name:"tokenMarcoAccount",isMut:!0,isSigner:!1},{name:"tokenProjectFirstAccount",isMut:!0,isSigner:!1},{name:"tokenProjectSecondAccount",isMut:!0,isSigner:!1},{name:"ownerMarcoAccount",isMut:!0,isSigner:!1},{name:"ownerProjectFirstAccount",isMut:!0,isSigner:!1},{name:"ownerProjectSecondAccount",isMut:!0,isSigner:!1},{name:"owner",isMut:!0,isSigner:!0},{name:"programAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"associatedTokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[]},{name:"closePool",accounts:[{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!0,isSigner:!1},{name:"farm",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"tokenMarcoAccount",isMut:!0,isSigner:!1},{name:"tokenProjectFirstAccount",isMut:!0,isSigner:!1},{name:"tokenProjectSecondAccount",isMut:!0,isSigner:!1},{name:"poolXAccount",isMut:!0,isSigner:!1},{name:"poolYAccount",isMut:!0,isSigner:!1},{name:"buybackXAccount",isMut:!0,isSigner:!1},{name:"buybackYAccount",isMut:!0,isSigner:!1},{name:"admin",isMut:!0,isSigner:!0},{name:"programAuthority",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[]},{name:"withdrawMercantiFee",accounts:[{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"mercantiXAccount",isMut:!0,isSigner:!1},{name:"mercantiYAccount",isMut:!0,isSigner:!1},{name:"poolXAccount",isMut:!0,isSigner:!1},{name:"poolYAccount",isMut:!0,isSigner:!1},{name:"admin",isMut:!0,isSigner:!0},{name:"programAuthority",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[]},{name:"addSupply",accounts:[{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!0,isSigner:!1},{name:"farm",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"tokenMarcoAccount",isMut:!0,isSigner:!1},{name:"tokenProjectFirstAccount",isMut:!0,isSigner:!1},{name:"tokenProjectSecondAccount",isMut:!0,isSigner:!1},{name:"adminMarcoAccount",isMut:!0,isSigner:!1},{name:"adminProjectFirstAccount",isMut:!0,isSigner:!1},{name:"adminProjectSecondAccount",isMut:!0,isSigner:!1},{name:"admin",isMut:!1,isSigner:!0},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"supplyMarco",type:{defined:"Token"}},{name:"supplyProjectFirst",type:{defined:"Token"}},{name:"supplyProjectSecond",type:{defined:"Token"}},{name:"duration",type:"u64"}]},{name:"updateFees",accounts:[{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"admin",isMut:!0,isSigner:!0},{name:"programAuthority",isMut:!1,isSigner:!1}],args:[{name:"newBuybackFee",type:{defined:"FixedPoint"}},{name:"newProjectFee",type:{defined:"FixedPoint"}},{name:"newProviderFee",type:{defined:"FixedPoint"}},{name:"newMercantiFee",type:{defined:"FixedPoint"}}]},{name:"resetFarm",accounts:[{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!1,isSigner:!1},{name:"farm",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"tokenMarco",isMut:!1,isSigner:!1},{name:"tokenMarcoAccount",isMut:!0,isSigner:!1},{name:"tokenProjectFirstAccount",isMut:!0,isSigner:!1},{name:"tokenProjectSecondAccount",isMut:!0,isSigner:!1},{name:"adminMarcoAccount",isMut:!0,isSigner:!1},{name:"adminProjectFirstAccount",isMut:!0,isSigner:!1},{name:"adminProjectSecondAccount",isMut:!0,isSigner:!1},{name:"admin",isMut:!0,isSigner:!0},{name:"programAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[]}],accounts:[{name:"farm",type:{kind:"struct",fields:[{name:"pool",type:"publicKey"},{name:"tokens",type:{array:["publicKey",3]}},{name:"tokenAccounts",type:{array:["publicKey",3]}},{name:"supply",type:{array:[{defined:"Token"},3]}},{name:"supplyLeft",type:{array:[{defined:"Token"},3]}},{name:"accumulatedSecondsPerShare",type:{defined:"FixedPoint"}},{name:"offsetSecondsPerShare",type:{defined:"FixedPoint"}},{name:"startTime",type:"u64"},{name:"endTime",type:"u64"},{name:"lastUpdate",type:"u64"},{name:"bump",type:"u8"},{name:"farmType",type:{defined:"FarmType"}}]}},{name:"pool",type:{kind:"struct",fields:[{name:"tokenX",type:"publicKey"},{name:"tokenY",type:"publicKey"},{name:"poolXAccount",type:"publicKey"},{name:"poolYAccount",type:"publicKey"},{name:"admin",type:"publicKey"},{name:"projectOwner",type:"publicKey"},{name:"tokenXReserve",type:{defined:"Token"}},{name:"tokenYReserve",type:{defined:"Token"}},{name:"selfShares",type:{defined:"Token"}},{name:"allShares",type:{defined:"Token"}},{name:"buybackAmountX",type:{defined:"Token"}},{name:"buybackAmountY",type:{defined:"Token"}},{name:"projectAmountX",type:{defined:"Token"}},{name:"projectAmountY",type:{defined:"Token"}},{name:"mercantiAmountX",type:{defined:"Token"}},{name:"mercantiAmountY",type:{defined:"Token"}},{name:"lpAccumulatorX",type:{defined:"FixedPoint"}},{name:"lpAccumulatorY",type:{defined:"FixedPoint"}},{name:"constK",type:{defined:"Product"}},{name:"price",type:{defined:"FixedPoint"}},{name:"lpFee",type:{defined:"FixedPoint"}},{name:"buybackFee",type:{defined:"FixedPoint"}},{name:"projectFee",type:{defined:"FixedPoint"}},{name:"mercantiFee",type:{defined:"FixedPoint"}},{name:"farmCount",type:"u64"},{name:"bump",type:"u8"}]}},{name:"provider",type:{kind:"struct",fields:[{name:"tokenX",type:"publicKey"},{name:"tokenY",type:"publicKey"},{name:"owner",type:"publicKey"},{name:"shares",type:{defined:"Token"}},{name:"lastFeeAccumulatorX",type:{defined:"FixedPoint"}},{name:"lastFeeAccumulatorY",type:{defined:"FixedPoint"}},{name:"lastSecondsPerShare",type:{defined:"FixedPoint"}},{name:"lastWithdrawTime",type:"u64"},{name:"tokensOwedX",type:{defined:"Token"}},{name:"tokensOwedY",type:{defined:"Token"}},{name:"currentFarmCount",type:"u64"},{name:"bump",type:"u8"}]}},{name:"state",type:{kind:"struct",fields:[{name:"admin",type:"publicKey"},{name:"programAuthority",type:"publicKey"},{name:"bump",type:"u8"},{name:"nonce",type:"u8"}]}}],types:[{name:"FixedPoint",type:{kind:"struct",fields:[{name:"v",type:"u128"}]}},{name:"Token",type:{kind:"struct",fields:[{name:"v",type:"u64"}]}},{name:"Product",type:{kind:"struct",fields:[{name:"v",type:"u128"}]}},{name:"FarmType",type:{kind:"enum",variants:[{name:"Single"},{name:"Dual"},{name:"Triple"}]}}],errors:[{code:6e3,name:"DeltaTooBig",msg:"Delta greater than provider's tokens"},{code:6001,name:"TokenUnderflow",msg:"Token amount underflow"},{code:6002,name:"WrongRatio",msg:"Wrong tokens ratio"},{code:6003,name:"TooMuchShares",msg:"Too much shares provided"},{code:6004,name:"SwapToBig",msg:"Swap too big"},{code:6005,name:"FeeExceeded",msg:"Fee exceeded 100%"},{code:6007,name:"ScalesNotEqual",msg:"Scales have to be equal"},{code:6008,name:"FeeExceededDeltaOut",msg:"Fees exceeded delta_out"},{code:6009,name:"PriceLimitExceeded",msg:"Price limit exceeded"},{code:6010,name:"MintMismatch",msg:"Mint mismatch"},{code:6011,name:"TokensAreTheSame",msg:"Tokens are the same"},{code:6012,name:"WrongFarm",msg:"Cannot add supply to wrong farm"},{code:6013,name:"RewardsExceedingSupply",msg:"Cannot withdraw rewards exceeding supply left"},{code:6014,name:"FarmNotEnded",msg:"Farm has not ended, cannot add additional rewards"},{code:6015,name:"ZeroAmount",msg:"Must provide a nonzero amount"},{code:6016,name:"InvariantChanged",msg:"Invariant has changed"}],metadata:{address:"9tKE7Mbmj4mxDjWatikzGAtkoWosiiZX9y6J4Hfm2R8H"}},fe,to),Vi=new nt(10).pow(12);class Ui{constructor(e,t){this.address=void 0,this.id=void 0,this.label=void 0,this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.isBonkSwap=void 0,this.pool=void 0,this.calculator=void 0,this.feePct=void 0,this.tokenReserveAmounts=void 0,this.address=e,this.id=e.toBase58(),this.pool=this.decodePoolState(t),this.isBonkSwap=t.owner.equals(he),this.label=this.isBonkSwap?"BonkSwap":"Oasis";const n=this.pool.lpFee.v.add(this.pool.buybackFee.v).add(this.pool.mercantiFee.v).add(this.pool.projectFee.v);this.feePct=new nt(n.toString()).div(Vi),this.calculator=new f(new k(v.BigInt(n),v.BigInt(Vi)),y,!1)}decodePoolState(e){return Ni.coder.accounts.decode("pool",e.data)}getAccountsForUpdate(){return[this.address]}update(e){const t=e.get(this.id);if(!t)throw new Error(`Pool account info is not found: ${this.id}`);const n=this.decodePoolState(t);this.pool=n,this.tokenReserveAmounts=[v.BigInt(n.tokenXReserve.v),v.BigInt(n.tokenYReserve.v)]}getQuote({destinationMint:e,amount:t}){const{tokenX:n}=this.pool;if(!this.tokenReserveAmounts)throw new Error("Missing tokenReserveAmounts");const o=e.equals(n)?0:1,i=this.calculator.exchange(this.tokenReserveAmounts,t,o);return{notEnoughLiquidity:!1,inAmount:t,outAmount:i.expectedOutputAmount,feeAmount:i.fees,feeMint:e.toBase58(),feePct:this.feePct.toNumber(),priceImpactPct:i.priceImpact.toNumber()}}getSwapLegAndAccounts(e){const t=we;return function({additionalArgs:e,userSourceTokenAccount:t,userDestinationTokenAccount:i,userTransferAuthority:a,sourceMint:s}){const r=s.equals(e.tokenX),{swapperXAccount:u,swapperYAccount:c}=r?{swapperXAccount:t,swapperYAccount:i}:{swapperXAccount:i,swapperYAccount:t};let[m,d,p]=e.isBonkSwap?[he,ge,ke]:[fe,Se,Ae];return[_n(zn(r)),R.instruction.marcoPoloSwap({accounts:{swapProgram:m,state:d,pool:e.pool,tokenX:e.tokenX,tokenY:e.tokenY,poolXAccount:e.poolXAccount,poolYAccount:e.poolYAccount,swapperXAccount:u,swapperYAccount:c,swapper:a,referrerXAccount:e.referrerXAccount,referrerYAccount:e.referrerYAccount,referrer:e.referrer,programAuthority:p,systemProgram:n.programId,tokenProgram:L,associatedTokenProgram:x,rent:o}}).keys]}({additionalArgs:{pool:this.address,tokenX:this.pool.tokenX,tokenY:this.pool.tokenY,poolXAccount:this.pool.poolXAccount,poolYAccount:this.pool.poolYAccount,referrer:t,referrerXAccount:ce({walletAddress:t,tokenMintAddress:this.pool.tokenX}),referrerYAccount:ce({walletAddress:t,tokenMintAddress:this.pool.tokenY}),isBonkSwap:this.isBonkSwap},...e})}get reserveTokenMints(){return[this.pool.tokenX,this.pool.tokenY]}}Ui.getProgram=()=>Ni;const Ki=v.BigInt(1e4);class zi{constructor(e,t){this.address=void 0,this.id=void 0,this.label="Phoenix",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.marketData=void 0,this.ladder=void 0,this.outAmountWithoutFeesMultiplier=void 0,this.baseLotsPerBaseUnit=void 0,this.baseLotSize=void 0,this.quoteLotSize=void 0,this.tickSizeInQuoteLotsPerBaseUnitPerTick=void 0,this.address=e,this.id=e.toBase58(),this.marketData=mn(t.data),this.ladder=dn(this.marketData,-1),this.outAmountWithoutFeesMultiplier=v.BigInt(1e4-this.marketData.takerFeeBps),this.baseLotsPerBaseUnit=v.BigInt(this.marketData.baseLotsPerBaseUnit);const n=this.marketData.header;this.baseLotSize=v.BigInt(n.baseLotSize.toString()),this.quoteLotSize=v.BigInt(n.quoteLotSize.toString()),this.tickSizeInQuoteLotsPerBaseUnitPerTick=v.divide(v.BigInt(n.tickSizeInQuoteAtomsPerBaseUnit.toString()),this.quoteLotSize)}getAccountsForUpdate(){return[this.address]}update(e){const t=e.get(this.address.toBase58());if(!t)throw new Error(`Missing market accountInfo ${this.address.toBase58()}`);this.marketData=mn(t.data),this.ladder=dn(this.marketData,-1)}JSBImin(e,t){return v.lessThan(e,t)?e:t}computeQuote({sourceMint:e,amount:t}){let n,o=v.BigInt(0),i=M,a=!1;if(e.equals(this.marketData.header.baseParams.mintKey)){let e=v.divide(t,this.baseLotSize);const s=v.BigInt(e);for(const[t,i]of this.ladder.bids){if(v.lessThanOrEqual(e,M))break;const a=v.BigInt(t.toString()),s=v.BigInt(i.toString()),r=this.JSBImin(s,e),u=v.divide(v.multiply(v.multiply(v.multiply(a,r),this.tickSizeInQuoteLotsPerBaseUnitPerTick),this.quoteLotSize),this.baseLotsPerBaseUnit);if(!n){const e=v.multiply(r,this.baseLotSize);n=new nt(u.toString()).div(e.toString())}o=v.add(o,u),e=v.subtract(e,r)}i=v.multiply(v.subtract(s,e),this.baseLotSize),v.greaterThan(e,M)&&(a=!0)}else{let e=v.divide(t,this.quoteLotSize);const s=v.BigInt(e);for(const[t,i]of this.ladder.asks){if(v.lessThanOrEqual(e,M))break;const a=v.BigInt(t.toString()),s=v.BigInt(i.toString()),r=v.divide(v.divide(v.multiply(e,this.baseLotsPerBaseUnit),this.tickSizeInQuoteLotsPerBaseUnitPerTick),a);let u,c;v.greaterThan(s,r)?(u=r,c=e):(u=s,c=v.divide(v.multiply(v.multiply(a,u),this.tickSizeInQuoteLotsPerBaseUnitPerTick),this.baseLotsPerBaseUnit));const m=v.multiply(u,this.baseLotSize);if(!n){const e=v.multiply(c,this.quoteLotSize);n=new nt(m.toString()).div(e.toString())}o=v.add(o,m),e=v.subtract(e,c)}i=v.multiply(v.subtract(s,e),this.quoteLotSize),v.greaterThan(e,M)&&(a=!0)}const s=this.computAmountAfterFees(o),r=v.subtract(o,s),u=new nt(o.toString()).div(t.toString());if(!n)throw new Error("No best price");return{notEnoughLiquidity:a,inAmount:i,outAmount:s,feeAmount:r,priceImpactPct:n.sub(u).div(n).toNumber()}}computAmountAfterFees(e){return v.divide(v.multiply(e,this.outAmountWithoutFeesMultiplier),Ki)}getQuote({sourceMint:e,amount:t}){const{notEnoughLiquidity:n,inAmount:o,outAmount:i,feeAmount:a,priceImpactPct:s}=this.computeQuote({sourceMint:e,amount:t});return{notEnoughLiquidity:n,inAmount:o,outAmount:i,feeAmount:a,feeMint:e.toBase58(),feePct:this.marketData.takerFeeBps/1e4,priceImpactPct:s}}getSwapLegAndAccounts(t){return function({additionalArgs:e,sourceMint:t,userSourceTokenAccount:n,userDestinationTokenAccount:o,userTransferAuthority:i}){const{side:a,baseAccount:s,quoteAccount:r}=t.equals(e.baseMint)?{side:On.Ask,baseAccount:n,quoteAccount:o}:{side:On.Bid,baseAccount:o,quoteAccount:n};return[_n(jn(a)),R.instruction.phoenixSwap({accounts:{swapProgram:de,logAuthority:e.logAuthority,market:e.market,trader:i,baseAccount:s,quoteAccount:r,baseVault:e.baseVault,quoteVault:e.quoteVault,tokenProgram:L}}).keys]}({...t,additionalArgs:{logAuthority:e.findProgramAddressSync([Buffer.from("log")],de)[0],market:this.address,baseVault:this.marketData.header.baseParams.vaultKey,quoteVault:this.marketData.header.quoteParams.vaultKey,baseMint:this.marketData.header.baseParams.mintKey}})}get reserveTokenMints(){return[this.marketData.header.baseParams.mintKey,this.marketData.header.quoteParams.mintKey]}}function Wi(e,t,n){return Math.floor(e*t/n)}function ji(e,t){let n=e.coder.accounts.decode("tokenInfo",t),o=n.numTokens.toNumber(),i=[];for(let e=0;e<o;e++)i.push({id:e,mint:n.tokenMint[e].toBase58(),pdaAccount:n.pdaTokenAccount[e].toBase58(),pyth:n.pyth[e].toBase58(),decimals:n.decimals[e]});return i}class Qi{constructor(e,t,n){this.address=void 0,this.id=void 0,this.label="Symmetry",this.shouldPrefetch=!0,this.exactOutputSupported=!1,this.hasDynamicAccounts=!0,this.fundState=void 0,this.tokenInfos=void 0,this.curveData=void 0,this.pythPrices=[],this.address=e,this.id=e.toBase58(),this.fundState=no.coder.accounts.decode("fundState",t.data),this.tokenInfos=ji(no,Buffer.from(n.tokenInfoData,"base64"));for(let e=0;e<this.tokenInfos.length;e++)this.pythPrices.push({aggregate:{price:0}})}getAccountsForUpdate(){let t=[this.address,oo,io];for(let n=0;n<this.fundState.numOfTokens.toNumber();n++)t.push(new e(this.tokenInfos[this.fundState.currentCompToken[n].toNumber()].pyth));return t}update(t){const[n,o,i]=Mn(t,this.getAccountsForUpdate());this.fundState=no.coder.accounts.decode("fundState",n.data),this.tokenInfos=ji(no,o.data),this.curveData=no.coder.accounts.decode("prismData",i.data);let a=this.pythPrices;for(let n=0;n<this.fundState.currentCompToken.length;n++){const o=this.fundState.currentCompToken[n].toNumber(),i=this.tokenInfos[o].pyth;if(i!==e.default.toBase58()){const e=t.get(i);if(!e)throw new Error(`Account info ${i} missing`);let n=Pt(e.data);a[o]=n}}this.pythPrices=a}getQuote({sourceMint:e,destinationMint:t,amount:n}){if(!this.curveData)throw new Error("Can't calculate quote without curve data");const o=function(e,t,n,o,i,a,s){let r=s,u=0,c=n.numOfTokens.toNumber(),m=e.findIndex((e=>e.mint===i.toBase58())),d=e.findIndex((e=>e.mint===a.toBase58())),p=-1,l=-1;for(let t=0;t<c;t++){let i=n.currentCompToken[t].toNumber(),a=n.currentCompAmount[t].toNumber();u+=o[i].aggregate.price*(a/10**e[i].decimals),i==m&&(p=t),i==d&&(l=t)}if(-1==p||-1==l||0==u)return;let h=n.weightSum.toNumber(),g=10**e[m].decimals,k=o[m].aggregate.price,f=.99999*k-o[m].confidence/2,S=10**e[d].decimals,A=o[d].aggregate.price,y=1.00001*A+o[d].confidence/2,M=s*f/g,w=n.targetWeight[p].toNumber()*u/n.weightSum.toNumber()*g/k,T=n.targetWeight[l].toNumber()*u/n.weightSum.toNumber()*S/A,v=M;0!=m&&(v=function(e,t,n,o,i,a){let s=0;s=e>t?t:e;let r=0,u=o,c=10**a,m=n,d=m,p=0;for(let t=0;t<10;t++){let n=Math.floor((9*i.price[t].toNumber()+m)/10);if(n<d&&(d=n),p+=i.amount[t].toNumber(),p<=e-s)continue;let o=Math.min(p-(e-s),i.amount[t].toNumber()),a=Wi(o,d,c);if(o>u)return Wi(u,d,c)+r;r+=a,u-=o}return r+=Wi(u,d,c),r}(n.currentCompAmount[p].toNumber(),Math.floor(w),Math.floor(1e6*f),s,t.sell[m],e[m].decimals)/1e6);let P=v*S/y;0!=d&&(P=function(e,t,n,o,i,a){let s=0;s=e<t?t:e;let r=o,u=0,c=10**a,m=n,d=m,p=0;for(let t=0;t<10;t++){let n=Math.floor((9*i.price[t].toNumber()+m)/10);if(n>d&&(d=n),p+=i.amount[t].toNumber(),p<=s-e)continue;let o=Math.min(p-(s-e),i.amount[t].toNumber()),a=Wi(o,d,c);if(a>r)return Wi(r,c,d)+u;u+=o,r-=a}return u+=Wi(r,c,d),u}(n.currentCompAmount[l].toNumber(),Math.floor(T),Math.floor(1e6*y),Math.floor(1e6*v),t.buy[d],e[d].decimals));let b=M*S/y,I=0;b>n.currentCompAmount[l].toNumber()&&(I=b-n.currentCompAmount[l].toNumber(),b=n.currentCompAmount[l].toNumber()),P>b&&(P=b);let B=b-P,F=B-Math.floor(5*B/100)-Math.floor(20*B/100)-Math.floor(20*B/100);u=u+M-(b-F)*A/S;let D=n.targetWeight[p].toNumber()/h,L=n.currentCompAmount[p].toNumber(),q=n.targetWeight[l].toNumber()/h,x=(n.currentCompAmount[l].toNumber()-(b-F))/S,O=n.rebalanceThreshold.toNumber()/1e4*(n.lpOffsetThreshold.toNumber()/1e4);if(x*A/u<q*(1-O)&&q*(1-O)>0)return;let E=(L+s)/g,C=n.rebalanceThreshold.toNumber()/1e4*(n.lpOffsetThreshold.toNumber()/1e4);if(E*k/u>D*(1+C)&&0!=m&&D*(1+C)<1)return;let R=B+I,N=b-F+R;return{inAmount:r,outAmount:Math.floor(P),feeMint:a,feeAmount:Math.ceil(R),priceImpact:R/N,feePct:R/N}}(this.tokenInfos,this.curveData,this.fundState,this.pythPrices,e,t,v.toNumber(n));if(!o)throw new Error("Can't calculate quote");return{notEnoughLiquidity:!1,inAmount:v.BigInt(o.inAmount),outAmount:v.BigInt(o.outAmount),feeAmount:v.BigInt(o.feeAmount),feeMint:o.feeMint.toBase58(),feePct:o.feePct,priceImpactPct:o.priceImpact}}getSwapLegAndAccounts(t){return function({additionalArgs:t,sourceMint:n,destinationMint:o,userSourceTokenAccount:i,userDestinationTokenAccount:a,userTransferAuthority:s}){let r=t.tokenInfos.findIndex((e=>e.mint===n.toBase58())),u=t.tokenInfos.findIndex((e=>e.mint===o.toBase58())),c=ce({walletAddress:ao,tokenMintAddress:o}),m=ce({walletAddress:t.fundState.hostPubkey,tokenMintAddress:o}),d=ce({walletAddress:t.fundState.manager,tokenMintAddress:o}),p=[];for(let n=0;n<t.fundState.numOfTokens.toNumber();n++){let o=t.fundState.currentCompToken[n].toNumber();p.push({pubkey:new e(t.tokenInfos[o].pyth),isWritable:!1,isSigner:!1})}return[_n(Qn(new O(r),new O(u))),R.instruction.symmetrySwap({accounts:{swapProgram:C,buyer:s,fundState:t.fundAddress,pdaAccount:so,pdaFromTokenAccount:t.tokenInfos[r].pdaAccount,buyerFromTokenAccount:i,pdaToTokenAccount:t.tokenInfos[u].pdaAccount,buyerToTokenAccount:a,swapFeeAccount:c,hostFeeAccount:m,managerFeeAccount:d,tokenInfo:oo,prismData:io,tokenProgram:L},remainingAccounts:[...p,ro]}).keys]}({additionalArgs:{fundAddress:this.address,tokenInfos:this.tokenInfos,fundState:this.fundState},...t})}get reserveTokenMints(){let t=[];for(let n=0;n<this.fundState.numOfTokens.toNumber();n++){let o=this.tokenInfos[this.fundState.currentCompToken[n].toNumber()].mint;t.push(new e(o))}return t}}const Xi=({amms:e,asLegacyTransaction:t,isSplit:n})=>{if(t){if(e.length>2)return!1;const[t,o]=e;return n?!fn(hn,t.label,o.label):!fn(gn,t.label,o.label)}return!0},Yi=new Map([[Te.toString(),"Orca"],[ve.toString(),"Orca"],[Me.toString(),"Step"],[Pe.toString(),"Penguin"],[be.toString(),"Saros"],[Ie.toString(),"Stepn"]]);function _i(t,n,o){const i=new e(n.owner);if(i.equals(Be)||i.equals(Fe)||i.equals(ye)){const e=u.getLayout(i).decode(n.data);if(!e.accountFlags.initialized||!e.accountFlags.market)throw new Error("Invalid market");const t=new u(e,0,0,{},i);return new Pi(t)}if(i.equals(le))return new gi(t,n,o);if(i.equals(pe))return new ui(t,n,o);if(i.equals(l)){const e=n.data.slice(2,3),o=h.loadWithData(t,n.data,Fn([t.toBuffer(),e],l));if(!o.state.isInitialized)return;return new Si(o)}if(i.equals(U))return new fi(t,n);if(i.equals(re))return new Lo(t,n,o);if(i.equals(N)||i.equals(V))return new vo(t,n,o);if([...Yi.keys()].includes(i.toBase58())){var a;const e=null!==(a=Yi.get(n.owner.toBase58()))&&void 0!==a?a:"Unknown";return new Fi(t,n,e)}return i.equals(De)?new qo(t,n,o):i.equals(Le)?new yi(t,n):i.equals(qe)?new _o(t,n):i.equals(K)?new $o(t,n):i.equals(j)?new Ei(t,n):i.equals(z)?new Co(t,n):i.equals(X)?new ni(t,n):i.equals(H)?new li(t,n,o):i.equals(J)?new jo(t,n):i.equals(Y)?new Yo(t,n):i.equals(oe)?new Ci(t,n,o):i.equals(ne)?new Fo(t,n):i.equals(me)?new Ri(t,n):i.equals(fe)?new Ui(t,n):i.equals(de)?new zi(t,n):i.equals(C)?new Qi(t,n,o):void 0}class $i{constructor(e,t){this.connection=void 0,this.ammIdToAddressLookupTable=void 0,this.ammIdToAddressLookupTableAccount=new Map,this.connection=e,this.ammIdToAddressLookupTable=t}async getAdressLookupTableAccounts(t){const n=new Map,o=[...t.reduce(((e,t)=>{const o=this.ammIdToAddressLookupTableAccount.get(t);if(o){const e=o.key.toBase58();n.has(e)||n.set(e,t)}else{const o=this.ammIdToAddressLookupTable.get(t);o&&(e.add(o),n.set(t,o))}return e}),new Set)];return(await An(this.connection,o)).reduce(((t,i,s)=>{const r=o[s];if(i){const o=new a({key:new e(r),state:a.deserialize(i.data)});t.push(o);const s=n.get(r);s&&this.ammIdToAddressLookupTableAccount.set(s,o)}return t}),new Array)}}class Hi{constructor(e){this.ammIdToAddressLookupTableAccount=void 0,this.ammIdToAddressLookupTableAccount=e}static async load(t,n){const o=[...n.entries()],i=await An(t,o.map((([e,t])=>t))),s=new Map;for(const[t,n]of i.entries()){const[i,r]=o[t];n&&s.set(i,new a({key:new e(r),state:a.deserialize(n.data)}))}return new Hi(s)}getAdressLookupTableAccounts(e){const t=new Set,n=e.reduce(((e,n)=>{const o=this.ammIdToAddressLookupTableAccount.get(n);if(o){const n=o.key.toBase58();t.has(n)||(e.push(o),t.add(n))}return e}),new Array);return Promise.resolve(n)}}async function Zi(e,t,n){const o=t.reduce(((e,t)=>{var n;const o=null==t||null===(n=t.params)||void 0===n?void 0:n.addressLookupTableAddress;return o&&e.set(t.pubkey,o),e}),new Map);return n?await Hi.load(e,o):new $i(e,o)}const Ji={};function Gi(e){const t=e._bn.toString(),n=Ji[t];if(n)return n;{const n=e.toBase58();return Ji[t]=n,n}}function ea(e){const t=new Map;return e.forEach((e=>{Di(e.reserveTokenMints).forEach((([n,o])=>{!function(e,t,n,o){let i=o.get(e);i||(i=new Map([[t,[]]]),o.set(e,i));let a=i.get(t);a||(a=[],i.set(t,a)),a.push(n)}(Gi(n),Gi(o),e,t)}))})),t}function ta(e,t,n){return Boolean(e&&t>100&&!e.has(n))}function na(e){return e.marketInfos.map((e=>`${e.amm.id}-${e.inputMint}`)).join("-")}async function oa(e,t,i,a){const s=xe(),r=i.address.toString();if(a){let t=a.get(r);if(t){let n=null;if(n=await e.getAccountInfo(t,"confirmed"),n)return{...s,address:t}}}const[u,c]=function(e,t,i){const[a]=B([Buffer.from("open_orders"),e.toBuffer(),i.toBuffer()],Q);return[a,R.instruction.createOpenOrders({accounts:{openOrders:a,payer:i,dexProgram:t,systemProgram:n.programId,rent:o,market:e}})]}(i.address,i.programId,t);return await e.getAccountInfo(u)||(s.setupInstructions=[c]),null==a||a.set(i.address.toString(),u),{...s,address:u}}const ia={feeBps:0,feeAccounts:new Map};async function aa(e,t){return(await e.getTokenAccountsByOwner(t,{programId:L})).value.reduce(((e,t)=>{const n=b(t.account.data);return n&&e.set(n.mint.toBase58(),t.pubkey),e}),new Map)}const sa=function(e){if(!Array.isArray(e))throw new TypeError(`Argument must be an array: ${e}`)},ra=function(e,t){return e*t.length},ua={},ca=function(e,t){return String(t)};function ma(e){return null!=e}const da=v.BigInt(1e4);function pa({inputMint:e,outputMint:t}){return`${e}-${t}`}function la({ammId:e,amount:t}){return`${e}-${t.toString()}`}function ha(e,t,n){return{ExactIn:v.greaterThanOrEqual(t.outAmount,e.outAmount)?1:-1,ExactOut:v.lessThanOrEqual(t.inAmount,e.inAmount)?1:-1}[n]}async function ga({inputRouteSegment:t,inputMint:n,outputMint:o,amount:i,getDepositAndFeeForRoute:a,platformFeeBps:s,slippageBps:r,filterTopNResult:u=1,onlyDirectRoutes:c,swapMode:m,asLegacyTransaction:d}){const p=n.toBase58(),l=o.toBase58();if(!t.get(p))throw new Error("No routes found for the input and output mints");const h=c||m===yn.ExactOut?1:d?2:3,g=new Map,k=[],f=new Map;return function i({startMint:a,amount:s,level:r=1,walked:p=[a]}){const S=t.get(a);S&&S.forEach(((A,y)=>{const w=pa({inputMint:a,outputMint:y}),T=function({amms:t,inputMint:n,outputMint:o,amount:i,swapMode:a}){return t.map((t=>{try{return{quote:t.getQuote({amount:i,sourceMint:new e(n),destinationMint:new e(o),swapMode:a}),amm:t}}catch(e){return}})).filter(ma).sort(((e,t)=>ha(e.quote,t.quote,a)))}({amms:A,inputMint:a,outputMint:y,amount:s,swapMode:m}),{filteredAmms:P,quoteMap:b}=T.reduce(((e,t)=>(e.filteredAmms.length<u&&e.filteredAmms.push(t.amm),e.quoteMap.set(la({ammId:t.amm.id,amount:s}),t.quote),e)),{filteredAmms:[],quoteMap:new Map});if(1===r&&y===l&&!c&&m===yn.ExactIn){let e=!1;!function(e,t){for(let n=0;n<e.length;n++)for(let o=n+1;o<e.length;o++)e[n].label!==e[o].label&&t(e[n],e[o])}(T.slice(0,Math.max(d?3:2,u)).map((({amm:e})=>e)),((t,i)=>{if(Gn&&e)return;const a=(()=>{if(Xi({amms:[t,i],asLegacyTransaction:d,isSplit:!0}))return qi.create(t,i)})();a&&(e=!0,k.push({amms:[a],mints:[n,o]}))}))}if(S.set(y,P),g.set(w,b),y!==l&&b.size&&!p.includes(y)&&r<h){var I;const e=b.values().next().value.outAmount,t=null!==(I=f.get(y))&&void 0!==I?I:M;(Jn||v.greaterThan(e,t))&&(f.set(y,e),i({startMint:y,amount:e,level:r+1,walked:p.concat(y)}))}else if(y===l){1===r&&S.set(y,A);const n=p.concat(y),o=n.map((t=>new e(t))),i=n.reduce(((e,o,i)=>{var a;return i<n.length-1&&e.push(null===(a=t.get(n[i]))||void 0===a?void 0:a.get(n[i+1])),e}),[]),a=function(e){if(function(e){if(!Array.isArray(e))throw new TypeError("Argument must be an array of arrays");e.forEach(sa),function({length:e}){if(e>=100)throw new TypeError(`Too many arrays (${e}): please use the 'big-cartesian' library instead of 'fast-cartesian'`)}(e),function(e){const t=e.reduce(ra,1);if(t>=4294967296){const e=Number.isFinite(t)?` (${t.toExponential(0)})`:"";throw new TypeError(`Too many combinations${e}: please use the 'big-cartesian' library instead of 'fast-cartesian'`)}}(e)}(e),0===e.length)return[];const t=[];return function(e){const t=ua[e];if(void 0!==t)return t;const n=function(e){const t=Array.from({length:e},ca),n=t.map((e=>`for (const value${e} of arrays[${e}]) {`)).join("\n"),o=t.map((e=>`value${e}`)).join(", "),i="}\n".repeat(e);return new Function("arrays","result",`${n}\nresult.push([${o}])\n${i}`)}(e);return ua[e]=n,n}(e.length)(e,t),t}(i);for(let e of a)(1===e.length||Xi({amms:e,asLegacyTransaction:d}))&&k.push({amms:e,mints:o})}}))}({startMint:p,amount:i}),k.map((e=>{const{amms:t,mints:n}=e;let o=[],u=i,c=M;const d=n,p=t.length;for(const[e,n]of t.entries())try{var l;const t=d[e],a=d[e+1],h=pa({inputMint:t.toBase58(),outputMint:a.toBase58()}),k=null===(l=g.get(h))||void 0===l?void 0:l.get(la({ammId:n.id,amount:u}));if(v.equal(u,M))return;const f=k||n.getQuote({sourceMint:t,destinationMint:a,amount:u,swapMode:m}),S=ka({quote:f,sourceMint:t,destinationMint:a,swapMode:m,legIndex:e,isLastLeg:p-1===e,platformFeeBps:s}),A=m===yn.ExactIn?f.outAmount:f.inAmount;let y=m===yn.ExactIn?v.subtract(A,S.amount):v.add(A,S.amount);v.lessThan(y,M)&&(y=M);const w=v.BigInt(m===yn.ExactIn?new nt(y.toString()).mul(1-r/v.toNumber(da)).ceil():new nt(y.toString()).mul(1+r/v.toNumber(da)).floor()),[T,P]=m===yn.ExactIn?[f.inAmount,y]:[y,u];o.push({amm:n,inputMint:t,outputMint:a,notEnoughLiquidity:f.notEnoughLiquidity,minInAmount:f.minInAmount,minOutAmount:f.minOutAmount,inAmount:T,outAmount:P,priceImpactPct:f.priceImpactPct,lpFee:{amount:f.feeAmount,mint:f.feeMint,pct:f.feePct},platformFee:S}),u=m===yn.ExactIn?y:i,c=w}catch(e){return}return{marketInfos:o,getDepositAndFee:()=>a({marketInfos:o}),inAmount:o[0].inAmount,outAmount:u,amount:i,otherAmountThreshold:c,swapMode:m,slippageBps:r,priceImpactPct:1-o.reduce(((e,t)=>e*(1-t.priceImpactPct)),1)}})).filter(ma).sort(((e,t)=>ha(e,t,m)))}function ka({quote:e,sourceMint:t,destinationMint:n,swapMode:o,legIndex:i,isLastLeg:a,platformFeeBps:s}){return a&&o===yn.ExactIn?{amount:v.divide(v.multiply(e.outAmount,v.BigInt(s)),da),mint:n.toBase58(),pct:s/100}:0===i&&o===yn.ExactOut?{amount:v.divide(v.multiply(e.inAmount,v.BigInt(s)),da),mint:t.toBase58(),pct:s/100}:{amount:M,mint:n.toBase58(),pct:0}}class fa{constructor(e,t,n,o,i,a,u=0,c=!0,m,d,p){this.connection=void 0,this.cluster=void 0,this.tokenRouteSegments=void 0,this.feeCalculator=void 0,this.platformFeeAndAccounts=void 0,this.quoteMintToReferrer=void 0,this.routeCacheDuration=void 0,this.wrapUnwrapSOL=void 0,this.intermediateTokens=void 0,this.shouldLoadSerumOpenOrders=void 0,this.addressLookupTableProvider=void 0,this.serumOpenOrdersPromise=void 0,this.user=void 0,this.routeCache=new Map,this.routeSegmentCache=new r({max:500}),this.getDepositAndFees=async({marketInfos:e,userPublicKey:t,serumOpenOrdersPromise:n=Promise.resolve(new Map)})=>(async({connection:e,owner:t,inputMint:n,marketInfos:o,feeCalculator:i,serumOpenOrdersPromise:a,wrapUnwrapSOL:s})=>{const r=await Promise.all(o.map((async n=>{const o=n.amm;if(o instanceof Pi||o instanceof qi){if(!o.market)return;return await oa(e,t.publicKey,o.market,await a)}}))),{userIntermediaryTokenAccountResults:u,userDestinationTokenAccountResult:c}=await Oe({connection:e,outputMints:o.map((e=>e.outputMint)),owner:t,unwrapSOL:s}),m=!!s&&[n,...o.map((e=>e.outputMint))].some((e=>e.equals(Ee)));return Ce({intermediates:u,destination:c,openOrders:r,hasWrapUnwrapSOL:m,feeCalculator:i})})({connection:this.connection,feeCalculator:this.feeCalculator,inputMint:e[0].inputMint,marketInfos:e,serumOpenOrdersPromise:n,owner:new Re(t),wrapUnwrapSOL:this.wrapUnwrapSOL}),this.getDepositAndFeesForUser=({marketInfos:e})=>{if(this.user&&this.serumOpenOrdersPromise){const t=new Re(this.user);return this.getDepositAndFees({marketInfos:e,userPublicKey:t.publicKey,serumOpenOrdersPromise:this.serumOpenOrdersPromise})}return Promise.resolve(void 0)},this.exchange=async({routeInfo:e,userPublicKey:t,feeAccount:n,wrapUnwrapSOL:o,blockhashWithExpiryBlockHeight:i,asLegacyTransaction:a,computeUnitPriceMicroLamports:r})=>{var u;const{connection:c,serumOpenOrdersPromise:m}=this,d=t||this.user;if(!d)throw new Error("user not found");const p=new Re(d),l=e.marketInfos.length-1,h=e.marketInfos[0].inputMint,g=e.marketInfos[l].outputMint,k=null!=o?o:this.wrapUnwrapSOL,[f,S,A]=await Promise.all([h.equals(Ee)&&k?Ne({connection:c,owner:p,amount:e.swapMode===yn.ExactIn?e.amount:e.otherAmountThreshold}):{...xe(),address:ce({tokenMintAddress:h,walletAddress:p.publicKey})},Oe({connection:c,outputMints:e.marketInfos.map((e=>e.outputMint)),owner:p,unwrapSOL:k}),Promise.all(e.marketInfos.map((async({amm:e})=>{if(e instanceof Pi||e instanceof qi){if(!e.market)return;return await oa(c,p.publicKey,e.market,await m)}})))]),y={intermediates:S.userIntermediaryTokenAccountResults,destination:S.userDestinationTokenAccountResult,openOrders:A},M=y.openOrders.filter(Boolean).length>0,w=(n=null!==(u=n)&&void 0!==u?u:this.platformFeeAndAccounts.feeAccounts.get(e.swapMode===yn.ExactIn?g.toBase58():h.toBase58()))?{feeBps:this.platformFeeAndAccounts.feeBps||Math.floor(100*e.marketInfos[l].platformFee.pct),feeAccount:n}:void 0,{instruction:T}=await async function({user:e,openOrdersAddresses:t,userSourceTokenAccountAddress:n,userIntermediateTokenAccountAddresses:o,userDestinationTokenAccountAddress:i,routeInfo:a,platformFee:r,computeUnitPriceMicroLamports:u,quoteMintToReferrer:c}){if(a.marketInfos.length-1!==o.length)throw new Error("Missing intermediary token account address");const m=[n,...o,i],d=!!r&&r.feeBps>0,p=e.publicKey,l=[s.setComputeUnitLimit({units:14e5})];u&&u>0&&l.push(s.setComputeUnitPrice({microLamports:u}));const h=[];if(a.swapMode===yn.ExactIn){const e=function(e,t,n,o,i,a,s,r){const u=[],c=[];for(const[t,o]of e.marketInfos.entries()){const r=o.amm,[m,d]=i.slice(t),[p,l]=r.getSwapLegAndAccounts({sourceMint:o.inputMint,destinationMint:o.outputMint,userSourceTokenAccount:m,userDestinationTokenAccount:d,userTransferAuthority:n,openOrdersAddress:a[t],quoteMintToReferrer:s,swapMode:e.swapMode,amount:o.inAmount});u.push(p),c.push(...l)}return t&&r&&c.push({pubkey:r.feeAccount,isWritable:!0,isSigner:!1}),{swapInstruction:uo(n,o,Xn(u),c,new E(e.amount.toString()),new E(e.outAmount.toString()),e.slippageBps,t&&r?r.feeBps:0)}}(a,d,p,i,m,t,c,r),{swapInstruction:n}=e;h.push(n)}else if(a.swapMode===yn.ExactOut){const{swapInstruction:e}=function(e,t,n,o,i,a){const s=e.marketInfos[0],r=s.amm;if(r.createExactOutSwapInstruction)return{swapInstruction:r.createExactOutSwapInstruction({sourceMint:s.inputMint,destinationMint:s.outputMint,userSourceTokenAccount:n,userDestinationTokenAccount:o,userTransferAuthority:t,quoteMintToReferrer:i,swapMode:e.swapMode,amount:e.amount,slippageBps:e.slippageBps,inAmount:e.inAmount,platformFee:a,overflowFeeAccount:null==i?void 0:i.get(s.inputMint.toBase58())})};throw new Error(`ExactOutInstruction missing for ${r.label}.`)}(a,p,n,i,c,r);h.push(e)}const{signers:g,cleanupInstructions:k}=xe();return e.isKeyPair&&e.signer&&g.push(e.signer),{instruction:{setupInstructions:l,signers:g,cleanupInstructions:k,instructions:h}}}({user:p,openOrdersAddresses:y.openOrders.map((e=>null==e?void 0:e.address)),userSourceTokenAccountAddress:f.address,userIntermediateTokenAccountAddresses:y.intermediates.map((({address:e})=>e)),userDestinationTokenAccountAddress:y.destination.address,routeInfo:e,platformFee:w,computeUnitPriceMicroLamports:r,quoteMintToReferrer:this.quoteMintToReferrer,asLegacyTransaction:a}),v=new Ve(c,p.publicKey,p),P=[...y.intermediates,f,!y.destination.address.equals(f.address)&&y.destination];v.addInstruction(T),M&&y.openOrders.forEach((e=>{e&&v.addInstruction(e)})),P.forEach((e=>{e&&v.addInstruction(e)})),i=i||await this.connection.getLatestBlockhash("confirmed");const b=await this.addressLookupTableProvider.getAdressLookupTableAccounts(e.marketInfos.map((({amm:e})=>e instanceof qi?[e.firstAmm.id,e.secondAmm.id]:e.id)).flat()),{transaction:I}=await v.build(i,b,a),B=y;return{swapTransaction:I,addressLookupTableAccounts:b,execute:({wallet:e,onTransaction:t}={})=>Ue({connection:this.connection,wallet:e,onTransaction:t,inputMint:h,outputMint:g,sourceAddress:f.address,destinationAddress:B.destination.address,swapTransaction:I,wrapUnwrapSOL:k,owner:p}).finally((()=>{this.routeCache.clear()}))}},this.connection=e,this.cluster=t,this.tokenRouteSegments=n,this.feeCalculator=o,this.platformFeeAndAccounts=i,this.quoteMintToReferrer=a,this.routeCacheDuration=u,this.wrapUnwrapSOL=c,this.intermediateTokens=m,this.shouldLoadSerumOpenOrders=d,this.addressLookupTableProvider=p}static async load({connection:t,cluster:n,user:o,platformFeeAndAccounts:i=ia,quoteMintToReferrer:a,routeCacheDuration:s=0,wrapUnwrapSOL:r=!0,marketsCache:u,restrictIntermediateTokens:c=!1,shouldLoadSerumOpenOrders:m=!1,ammsToExclude:d={GooseFX:!0,Serum:!0},usePreloadedAddressLookupTableCache:p=!1}){const[{tokenRouteSegments:l,addressLookupTableProvider:h,saberWrapperMints:g},{value:{feeCalculator:k}},f]=await Promise.all([fa.loadCoreData({connection:t,cluster:n,marketsCache:u,ammsToExclude:d,usePreloadedAddressLookupTableCache:p}),t.getRecentBlockhashAndContext("processed"),null!=a?a:aa(t,new e(we))]),S=!0===c?await fa.getIntermediateTokens(g):c?c.intermediateTokens:void 0,A=new fa(t,n,l,k,i,f,s,r,S?new Set(S):void 0,m,h);return o&&A.setUserPublicKey(o),A}static async loadCoreData({connection:e,cluster:t,marketsCache:n,ammsToExclude:o,usePreloadedAddressLookupTableCache:i}){let a;a=!n||"url"in n?await(async e=>await(await pn(e)).json())((null==n?void 0:n.url)||ze[t]):n;const{amms:s,saberWrapperMints:r,addressLookupTableProvider:u}=await fa.fetchAmms(e,a,o,i);return{tokenRouteSegments:ea(s),addressLookupTableProvider:u,saberWrapperMints:r}}getAccountToAmmIdsMap(){const e=new Map;return this.tokenRouteSegments.forEach((t=>{Array.from(t.values()).forEach((t=>{t.forEach((t=>{t.getAccountsForUpdate().forEach((n=>{const o=e.get(n.toBase58())||new Set;o.add(t.id),e.set(n.toBase58(),o)}))}))}))})),e}getAmmIdToAmmMap(){const e=new Map;return this.tokenRouteSegments.forEach((t=>{Array.from(t.values()).forEach((t=>{t.forEach((t=>{e.set(t.id,t)}))}))})),e}async computeRoutes({inputMint:e,outputMint:t,amount:n,slippageBps:o,feeBps:i=0,forceFetch:a,onlyDirectRoutes:s,swapMode:r=yn.ExactIn,filterTopNResult:u,asLegacyTransaction:c}){const m=e.toBase58(),d=t.toBase58(),p=i||(this.platformFeeAndAccounts.feeAccounts.get(d)?this.platformFeeAndAccounts.feeBps:0),l=(new Date).getTime(),h=[m,d].sort(((e,t)=>e.localeCompare(t))).join()+s+r+c,g=this.routeCache.get(h);let k=this.routeSegmentCache.get(h);k||(k=function({inputMint:e,outputMint:t,tokenRouteSegments:n,swapMode:o,intermediateTokens:i,onlyDirectRoutes:a,asLegacyTransaction:s}){const r=new Map,u=n.get(e),c=n.get(t);if(u&&c){const m=Math.min(u.size,c.size),d=new Map,p=new Map,[l,h,g,k]=[u,c,e,t];for(let[e,t]of l.entries()){if(t=o===yn.ExactIn?t.slice():t.filter((e=>e.exactOutputSupported)),e===k){const e=t;d.set(k,e),p.set(g,e);continue}if(a||o===yn.ExactOut||ta(i,m,e))continue;let u=n.get(e)||new Map;for(let[n,o]of u){if(o=o.slice(),n===k){const n=o,i=r.get(e)||new Map;if(i.set(g,t),i.set(k,n),r.set(e,i),d.set(e,t),p.set(e,n),s)break}if(!s){if(ta(i,m,n))continue;const a=h.get(n);if(a){d.set(e,t);const i=r.get(e)||new Map;i.set(n,o),r.set(e,i);const s=r.get(n)||new Map;s.set(e,o),r.set(n,s);const u=r.get(n)||new Map;u.set(k,a),r.set(n,u),p.set(n,a)}}}}r.set(g,d),r.set(k,p)}return r}({inputMint:m,outputMint:d,tokenRouteSegments:this.tokenRouteSegments,intermediateTokens:this.intermediateTokens,onlyDirectRoutes:s,swapMode:r,asLegacyTransaction:c}),this.routeSegmentCache.set(h,k));let f=!1;if(-1===this.routeCacheDuration)f=!1;else if(0===this.routeCacheDuration)f=!0;else if(g){const{fetchTimestamp:e}=g;l-e>this.routeCacheDuration&&(f=!0)}else f=!0;(a||f)&&(await async function(e,t){const n=new Map,o=new Set,i=new Map;t.forEach((e=>{e.forEach((e=>{e.forEach((e=>{i.set(e.id,e),e.getAccountsForUpdate().forEach((e=>{o.add(e.toBase58())}))}))}))}));const a=Array.from(o);a.length>0&&((await An(e,a)).forEach(((e,t)=>{e&&n.set(a[t],e)})),i.forEach((e=>{e.update(n)})))}(this.connection,k),this.routeCache.set(h,{fetchTimestamp:(new Date).getTime()}));try{return{routesInfos:await ga({inputRouteSegment:k,inputMint:e,outputMint:t,amount:n,getDepositAndFeeForRoute:this.getDepositAndFeesForUser,onlyDirectRoutes:s,slippageBps:o,platformFeeBps:p,filterTopNResult:u,swapMode:r,asLegacyTransaction:c}),cached:!(a||f)}}catch(e){throw e}finally{this.routeCache.forEach((({fetchTimestamp:e},t)=>{e-l>this.routeCacheDuration&&this.routeCache.delete(t)}))}}setUserPublicKey(e){this.user=e;const t=new Re(this.user);this.serumOpenOrdersPromise=this.shouldLoadSerumOpenOrders?fa.findSerumOpenOrdersForOwner({connection:this.connection,cluster:this.cluster,userPublicKey:t.publicKey}):Promise.resolve(new Map)}static async fetchAmms(t,n,o,i=!1){return async function({connection:t,marketsCache:n,usePreloadedAddressLookupTableCache:o,ammsToExclude:i={}}){const a=(t=>t.map((t=>{const{data:[n,o],pubkey:i,...a}=t;return{...a,pubkey:new e(i),data:Buffer.from(n,o),owner:new e(a.owner)}})))(n);if(Zn){const e=[];if(e.length){const n=await async function(e,t){return await Promise.all((await An(e,t.map((e=>e.toBase58())))).map((async(e,n)=>{const o=t[n];if(!e)throw new Error(`Failed to fetch pool ${o.toBase58()}`);return{pubkey:o,...e}})))}(t,e);a.push(...n)}}const s=[],r=[],u=a.reduce(((e,t)=>{try{const n=_i(t.pubkey,t,t.params);if(n){if(fn(i,n.label))return e;e.push(n),n.shouldPrefetch&&s.push(n),n instanceof fi&&r.push(n.wrapperMint.toBase58())}}catch(e){}return e}),new Array),[c,m,d]=await Promise.all([Tn(s,t),Lt(),await Zi(t,n,o)]);return{amms:u,saberWrapperMints:r,addressLookupTableProvider:d}}({connection:t,marketsCache:n,ammsToExclude:o,usePreloadedAddressLookupTableCache:i})}getRouteMap(e,t){return function(e,t,n,o){const i=new Map,a=new Set(e.keys());a.forEach((e=>{i.set(e,new Set)}));for(const[k,f]of e){const S=new Set(a);for(let e of f.keys()){var s,r;null===(s=i.get(k))||void 0===s||s.add(e),null===(r=i.get(e))||void 0===r||r.add(k),S.delete(e)}if(!n)for(let a of S){var u;let s=null===(u=i.get(k))||void 0===u?void 0:u.has(a);if(s)continue;const r=e.get(k),f=e.get(a);if(r&&f){const u=Math.min(r.size,f.size);let[S,A,y,M]=[r,f,k,a];for(let[r,f]of S.entries()){if(n||ta(t,u,r))continue;let S=e.get(r)||new Map;for(let[e,n]of S){if(e===M){if(!o){var c,m;null===(c=i.get(k))||void 0===c||c.add(a),null===(m=i.get(a))||void 0===m||m.add(k),s=!0;break}for(let e of f){for(let t of n)if(Xi({amms:[e,t],asLegacyTransaction:o})){var d,p;null===(d=i.get(k))||void 0===d||d.add(a),null===(p=i.get(a))||void 0===p||p.add(k),s=!0;break}if(s)break}}if(!o){var l;if(ta(t,u,e))continue;if(null===(l=A.get(e))||void 0===l?void 0:l.slice()){var h,g;null===(h=i.get(k))||void 0===h||h.add(a),null===(g=i.get(a))||void 0===g||g.add(k),s=!0;break}}}if(s)break}}}}return Array.from(i.entries()).reduce(((e,[t,n])=>(e.set(t,[...n]),e)),new Map)}(this.tokenRouteSegments,this.intermediateTokens,e,t)}static async getIntermediateTokens(e){const t=await async function(){const e=await(await pn("https://cache.jup.ag/top-tokens")).json();return new Set(e.filter(((e,t)=>t<60)))}();for(const e of Hn)t.add(e);return e.forEach((e=>t.add(e))),Array.from(t)}}fa.getRemoteRouteMap=Ke,fa.findSerumOpenOrdersForOwner=async({userPublicKey:e,cluster:t,connection:n})=>{const o=new Map;if(e){const i="mainnet-beta"===t?Be:Fe;(await c.findForOwner(n,e,i)).forEach((e=>{o.set(e.market.toString(),e.address)}))}return o};export{vo as AldrinAmm,Fo as BalansolAmm,Lo as CremaAmm,qo as CropperAmm,Co as CykuraAmm,Vo as DeltaFiAmm,Ci as DradexAmm,to as FAKE_PROVIDER,jo as GooseFXAmm,Zn as IS_DEV,Gn as IS_PROD,Jn as IS_TEST,Yo as InvariantAmm,fa as Jupiter,_o as LifinityAmm,$o as LifinityV2Amm,eo as MIN_SEGMENT_SIZE_FOR_INTERMEDIATE_MINTS,Ui as MarcoPoloAmm,ni as MarinadeAmm,ui as MercurialAmm,li as MeteoraAmm,zi as PhoenixAmm,gi as RaydiumAmm,Ri as RaydiumClmm,Hn as SWAP_PROTOCOL_TOKENS,fi as SaberAddDecimalsAmm,Si as SaberAmm,yi as SenchaAmm,Pi as SerumAmm,Fi as SplTokenSwapAmm,qi as SplitTradeAmm,yn as SwapMode,Qi as SymmetryAmm,Ei as WhirlpoolAmm,_i as ammFactory,aa as getPlatformFeeAccounts,na as getRouteInfoUniqueId};
//# sourceMappingURL=core.esm.min.js.map
