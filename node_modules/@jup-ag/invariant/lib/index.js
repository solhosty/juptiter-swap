"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _nullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } }// src/market.ts
var _anchor = require('@project-serum/anchor');
var _spltoken = require('@solana/spl-token');






var _web3js = require('@solana/web3.js');

// src/math.ts

var _invariant = require('invariant'); var _invariant2 = _interopRequireDefault(_invariant);

// src/utils.ts







// src/tick.ts

var getTickFromPrice = (currentTick, tickSpacing, price, xToY) => {
  _invariant2.default.call(void 0, currentTick % tickSpacing === 0, "tick not on tick spacing");
  if (xToY) {
    return priceToTickInRange(
      price,
      Math.max(-TICK_LIMIT, currentTick - TICK_SEARCH_RANGE),
      currentTick,
      tickSpacing
    );
  } else {
    return priceToTickInRange(
      price,
      currentTick,
      Math.min(TICK_LIMIT, currentTick + TICK_SEARCH_RANGE),
      tickSpacing
    );
  }
};
var priceToTickInRange = (price, low, high, step) => {
  _invariant2.default.call(void 0, step !== 0, "step must be non-zero");
  low = Math.floor(low / step);
  high = Math.floor(high / step);
  const targetValue = price;
  while (high - low > 1) {
    const mid = Math.floor((high - low) / 2) + low;
    const val = calculatePriceSqrt(mid * step);
    if (val.v.eq(targetValue.v)) {
      return mid * step;
    }
    if (val.v.lt(targetValue.v)) {
      low = mid;
    }
    if (val.v.gt(targetValue.v)) {
      high = mid;
    }
  }
  return low * step;
};

// src/tickmap.ts

var getSearchLimit = (currentTickIndex, tickSpacing, up) => {
  const index = currentTickIndex.div(tickSpacing);
  let limit = new (0, _anchor.BN)(0);
  if (up) {
    const arrayLimit = new (0, _anchor.BN)(TICK_LIMIT).subn(1);
    const rangeLimit = index.add(new (0, _anchor.BN)(TICK_SEARCH_RANGE));
    const priceLimit = new (0, _anchor.BN)(MAX_TICK).div(tickSpacing);
    limit = _anchor.BN.min(_anchor.BN.min(arrayLimit, rangeLimit), priceLimit);
  } else {
    const arrayLimit = new (0, _anchor.BN)(-TICK_LIMIT).addn(1);
    const rangeLimit = index.sub(new (0, _anchor.BN)(TICK_SEARCH_RANGE));
    const priceLimit = new (0, _anchor.BN)(-MAX_TICK).div(tickSpacing);
    limit = _anchor.BN.max(_anchor.BN.max(arrayLimit, rangeLimit), priceLimit);
  }
  return limit.mul(tickSpacing);
};
var getPreviousTick = (tickmap, currentTickIndex, tickSpacing) => {
  const limit = getSearchLimit(new (0, _anchor.BN)(currentTickIndex), new (0, _anchor.BN)(tickSpacing), false);
  let { byte, bit } = tickToPosition(new (0, _anchor.BN)(currentTickIndex), new (0, _anchor.BN)(tickSpacing));
  const { byte: limitingByte, bit: limitingBit } = tickToPosition(limit, new (0, _anchor.BN)(tickSpacing));
  while (byte > limitingByte || byte === limitingByte && bit >= limitingBit) {
    let mask = 1 << bit;
    const value = tickmap.bitmap[byte];
    if (value % (mask << 1) > 0) {
      while ((value & mask) === 0) {
        mask >>= 1;
        bit -= 1;
      }
      if (byte > limitingByte || byte === limitingByte && bit >= limitingBit) {
        const index = byte * 8 + bit;
        return (index - TICK_LIMIT) * tickSpacing;
      } else {
        return null;
      }
    }
    byte -= 1;
    bit = 7;
  }
  return null;
};
var getNextTick = (tickmap, currentTickIndex, tickSpacing) => {
  const limit = getSearchLimit(new (0, _anchor.BN)(currentTickIndex), new (0, _anchor.BN)(tickSpacing), true);
  let { byte, bit } = tickToPosition(new (0, _anchor.BN)(currentTickIndex + tickSpacing), new (0, _anchor.BN)(tickSpacing));
  const { byte: limitingByte, bit: limitingBit } = tickToPosition(
    new (0, _anchor.BN)(limit),
    new (0, _anchor.BN)(tickSpacing)
  );
  while (byte < limitingByte || byte === limitingByte && bit <= limitingBit) {
    let shifted = tickmap.bitmap[byte] >> bit;
    if (shifted !== 0) {
      while (shifted % 2 === 0) {
        shifted >>= 1;
        bit += 1;
      }
      if (byte < limitingByte || byte === limitingByte && bit <= limitingBit) {
        const index = byte * 8 + bit;
        return (index - TICK_LIMIT) * tickSpacing;
      } else {
        return null;
      }
    }
    byte += 1;
    bit = 0;
  }
  return null;
};
var tickToPosition = (tick, tickSpacing) => {
  if (!tick.mod(tickSpacing).eqn(0)) {
    throw new Error("Tick not divisible by spacing");
  }
  const bitmapIndex = tick.div(tickSpacing).addn(TICK_LIMIT);
  const byte = bitmapIndex.divn(8).toNumber();
  const bit = Math.abs(bitmapIndex.modn(8));
  return { byte, bit };
};
var findTickmapChanges = (currentTickmap, nextTickmap, tickSpacing = 1, offset = -TICK_LIMIT) => {
  if (currentTickmap.length !== nextTickmap.length) {
    throw new Error("bitmap length mismatch");
  }
  let tickmapChanges = {};
  for (let i = 0; i < currentTickmap.length; i++) {
    if (currentTickmap[i] !== nextTickmap[i]) {
      const xor = currentTickmap[i] ^ nextTickmap[i];
      for (let bit = 0; bit < 8; bit++) {
        if ((xor & 1 << bit) !== 0) {
          const added = (nextTickmap[i] & 1 << bit) !== 0;
          tickmapChanges = {
            ...tickmapChanges,
            [(i * 8 + bit + offset) * tickSpacing]: added ? "added" : "removed"
          };
        }
      }
    }
  }
  return tickmapChanges;
};

// src/utils.ts
var _bufferlayout = require('@solana/buffer-layout');

var _spltokenregistry = require('@solana/spl-token-registry');
var SEED = "Invariant";
var DECIMAL = 12;
var LIQUIDITY_SCALE = 6;
var GROWTH_SCALE = 24;
var PRICE_SCALE = 24;
var FEE_DECIMAL = 5;
var DENOMINATOR = new (0, _anchor.BN)(10).pow(new (0, _anchor.BN)(DECIMAL));
var LIQUIDITY_DENOMINATOR = new (0, _anchor.BN)(10).pow(new (0, _anchor.BN)(LIQUIDITY_SCALE));
var PRICE_DENOMINATOR = new (0, _anchor.BN)(10).pow(new (0, _anchor.BN)(PRICE_SCALE));
var GROWTH_DENOMINATOR = new (0, _anchor.BN)(10).pow(new (0, _anchor.BN)(GROWTH_SCALE));
var FEE_OFFSET = new (0, _anchor.BN)(10).pow(new (0, _anchor.BN)(DECIMAL - FEE_DECIMAL));
var FEE_DENOMINATOR = 10 ** FEE_DECIMAL;
var U128MAX = new (0, _anchor.BN)("340282366920938463463374607431768211455");
var INVARIANT_ERRORS = /* @__PURE__ */ ((INVARIANT_ERRORS2) => {
  INVARIANT_ERRORS2["ZERO_AMOUNT"] = "0x1770";
  INVARIANT_ERRORS2["ZERO_OUTPUT"] = "0x1771";
  INVARIANT_ERRORS2["WRONG_TICK"] = "0x1772";
  INVARIANT_ERRORS2["WRONG_LIMIT"] = "0x1773";
  INVARIANT_ERRORS2["INVALID_TICK_INDEX"] = "0x1774";
  INVARIANT_ERRORS2["INVALID_TICK_INTERVAL"] = "0x1775";
  INVARIANT_ERRORS2["NO_MORE_TICKS"] = "0x1776";
  INVARIANT_ERRORS2["TICK_NOT_FOUND"] = "0x1777";
  INVARIANT_ERRORS2["PRICE_LIMIT_REACHED"] = "0x1778";
  INVARIANT_ERRORS2["INVALID_TICK_LIQUIDITY"] = "0x1779";
  INVARIANT_ERRORS2["EMPTY_POSITION_POKES"] = "0x177a";
  INVARIANT_ERRORS2["INVALID_POSITION_LIQUIDITY"] = "0x177b";
  INVARIANT_ERRORS2["INVALID_POOL_LIQUIDITY"] = "0x177c";
  INVARIANT_ERRORS2["INVALID_POSITION_INDEX"] = "0x177d";
  INVARIANT_ERRORS2["POSITION_WITHOUT_LIQUIDITY"] = "0x177e";
  INVARIANT_ERRORS2["INVALID_POOL_TOKEN_ADDRESSES"] = "0x1780";
  INVARIANT_ERRORS2["NO_GAIN_SWAP"] = "0x1785";
  INVARIANT_ERRORS2["INVALID_TOKEN_ACCOUNT"] = "0x1786";
  INVARIANT_ERRORS2["INVALID_ADMIN"] = "0x1787";
  INVARIANT_ERRORS2["INVALID_AUTHORITY"] = "0x1788";
  INVARIANT_ERRORS2["INVALID_OWNER"] = "0x1789";
  INVARIANT_ERRORS2["INVALID_MINT"] = "0x178a";
  INVARIANT_ERRORS2["INVALID_TICKMAP"] = "0x178b";
  INVARIANT_ERRORS2["INVALID_TICKMAP_OWNER"] = "0x178c";
  INVARIANT_ERRORS2["INVALID_LIST_OWNER"] = "0x178d";
  INVARIANT_ERRORS2["INVALID_TICK_SPACING"] = "0x178e";
  return INVARIANT_ERRORS2;
})(INVARIANT_ERRORS || {});
var computeUnitsInstruction = (units, wallet) => {
  const program = new (0, _web3js.PublicKey)("ComputeBudget111111111111111111111111111111");
  const params = { instruction: 0, units, additional_fee: 0 };
  const layout = _bufferlayout.struct.call(void 0, [_bufferlayout.u8.call(void 0, "instruction"), _bufferlayout.u32.call(void 0, "units"), _bufferlayout.u32.call(void 0, "additional_fee")]);
  const data = Buffer.alloc(layout.span);
  layout.encode(params, data);
  const keys = [{ pubkey: wallet, isSigner: false, isWritable: false }];
  const unitsIx = new (0, _web3js.TransactionInstruction)({
    keys,
    programId: program,
    data
  });
  return unitsIx;
};
var signAndSend = async (tx, signers, connection, opts) => {
  tx.setSigners(...signers.map((s) => s.publicKey));
  const blockhash = await connection.getRecentBlockhash(
    _nullishCoalesce((opts == null ? void 0 : opts.commitment), () => ( _anchor.AnchorProvider.defaultOptions().commitment))
  );
  tx.recentBlockhash = blockhash.blockhash;
  tx.partialSign(...signers);
  const rawTx = tx.serialize();
  return await _web3js.sendAndConfirmRawTransaction.call(void 0, 
    connection,
    rawTx,
    _nullishCoalesce(opts, () => ( _anchor.AnchorProvider.defaultOptions()))
  );
};
var sleep = async (ms) => {
  return await new Promise((resolve) => setTimeout(resolve, ms));
};
var fromFee = (fee) => {
  return fee.mul(FEE_OFFSET);
};
var feeToTickSpacing = (fee) => {
  if (fee.lte(fromFee(new (0, _anchor.BN)(10)))) {
    return 1;
  }
  const FEE_TO_SPACING_OFFSET = new (0, _anchor.BN)(10).pow(new (0, _anchor.BN)(DECIMAL - 4));
  return fee.div(FEE_TO_SPACING_OFFSET).toNumber();
};
var FEE_TIERS = [
  { fee: fromFee(new (0, _anchor.BN)(1)) },
  { fee: fromFee(new (0, _anchor.BN)(10)) },
  { fee: fromFee(new (0, _anchor.BN)(50)) },
  { fee: fromFee(new (0, _anchor.BN)(100)) },
  { fee: fromFee(new (0, _anchor.BN)(300)) },
  { fee: fromFee(new (0, _anchor.BN)(1e3)) }
];
var getFeeTierAddress = async ({ fee, tickSpacing }, programId) => {
  const ts = _nullishCoalesce(tickSpacing, () => ( feeToTickSpacing(fee)));
  const [address, bump] = await _web3js.PublicKey.findProgramAddress(
    [
      Buffer.from(_anchor.utils.bytes.utf8.encode(FEE_TIER)),
      programId.toBuffer(),
      bigNumberToBuffer(fee, 128),
      bigNumberToBuffer(new (0, _anchor.BN)(ts), 16)
    ],
    programId
  );
  return {
    address,
    bump
  };
};
var toDecimal = (x, decimals = 0) => {
  return { v: DENOMINATOR.muln(x).div(new (0, _anchor.BN)(10).pow(new (0, _anchor.BN)(decimals))) };
};
var getCloserLimit = (closerLimit) => {
  const { sqrtPriceLimit, xToY, currentTick, tickSpacing, tickmap } = closerLimit;
  let index = xToY ? getPreviousTick(tickmap, currentTick, tickSpacing) : getNextTick(tickmap, currentTick, tickSpacing);
  let sqrtPrice;
  let init;
  if (index !== null) {
    sqrtPrice = calculatePriceSqrt(index);
    init = true;
  } else {
    index = getSearchLimit(new (0, _anchor.BN)(currentTick), new (0, _anchor.BN)(tickSpacing), !xToY).toNumber();
    sqrtPrice = calculatePriceSqrt(index);
    init = false;
  }
  if (xToY && sqrtPrice.v.gt(sqrtPriceLimit.v) && index !== null) {
    return { swapLimit: sqrtPrice, limitingTick: { index, initialized: init } };
  } else if (!xToY && sqrtPrice.v.lt(sqrtPriceLimit.v) && index !== null) {
    return { swapLimit: sqrtPrice, limitingTick: { index, initialized: init } };
  } else {
    return { swapLimit: sqrtPriceLimit, limitingTick: null };
  }
};
var simulateSwap = (swapParameters) => {
  const { xToY, byAmountIn, swapAmount, slippage, ticks, tickmap, priceLimit, pool } = swapParameters;
  let { currentTickIndex, tickSpacing, liquidity, sqrtPrice, fee } = pool;
  const startingSqrtPrice = sqrtPrice.v;
  let previousTickIndex = MAX_TICK + 1;
  const amountPerTick = [];
  const crossedTicks = [];
  let accumulatedAmount = new (0, _anchor.BN)(0);
  let accumulatedAmountOut = new (0, _anchor.BN)(0);
  let accumulatedAmountIn = new (0, _anchor.BN)(0);
  let accumulatedFee = new (0, _anchor.BN)(0);
  const priceLimitAfterSlippage = calculatePriceAfterSlippage(priceLimit, slippage, !xToY);
  if (xToY) {
    if (sqrtPrice.v.lt(priceLimitAfterSlippage.v)) {
      throw new Error("Price limit is on the wrong side of price" /* WrongLimit */);
    }
  } else {
    if (sqrtPrice.v.gt(priceLimitAfterSlippage.v)) {
      throw new Error("Price limit is on the wrong side of price" /* WrongLimit */);
    }
  }
  let remainingAmount = swapAmount;
  let status = 0 /* Ok */;
  while (!remainingAmount.lte(new (0, _anchor.BN)(0))) {
    const closerLimit = {
      sqrtPriceLimit: priceLimitAfterSlippage,
      xToY,
      currentTick: currentTickIndex,
      tickSpacing,
      tickmap
    };
    const { swapLimit, limitingTick } = getCloserLimit(closerLimit);
    const result = calculateSwapStep(
      sqrtPrice,
      swapLimit,
      liquidity,
      remainingAmount,
      byAmountIn,
      fee
    );
    accumulatedAmountIn = accumulatedAmountIn.add(result.amountIn);
    accumulatedAmountOut = accumulatedAmountOut.add(result.amountOut);
    accumulatedFee = accumulatedFee.add(result.feeAmount);
    let amountDiff;
    if (byAmountIn) {
      amountDiff = result.amountIn.add(result.feeAmount);
    } else {
      amountDiff = result.amountOut;
    }
    remainingAmount = remainingAmount.sub(amountDiff);
    sqrtPrice = result.nextPrice;
    if (sqrtPrice.v.eq(priceLimitAfterSlippage.v) && remainingAmount.gt(new (0, _anchor.BN)(0))) {
      status = "Price would cross swap limit" /* PriceLimitReached */;
      break;
    }
    if (result.nextPrice.v.eq(swapLimit.v) && limitingTick != null) {
      const tickIndex = limitingTick.index;
      const initialized = limitingTick.initialized;
      const isEnoughAmountToCross = isEnoughAmountToPushPrice(
        remainingAmount,
        result.nextPrice,
        pool.liquidity,
        pool.fee,
        byAmountIn,
        xToY
      );
      if (initialized) {
        if (!ticks.has(tickIndex)) {
          throw new Error("tick crossed but not passed to simulation" /* TickNotFound */);
        }
        const tick = ticks.get(tickIndex);
        if (!xToY || isEnoughAmountToCross) {
          if (currentTickIndex >= tick.index !== tick.sign) {
            liquidity = { v: liquidity.v.add(tick.liquidityChange.v) };
          } else {
            liquidity = { v: liquidity.v.sub(tick.liquidityChange.v) };
          }
          crossedTicks.push(tickIndex);
        } else if (!remainingAmount.eqn(0)) {
          if (byAmountIn) {
            accumulatedAmountIn = accumulatedAmountIn.add(remainingAmount);
          }
          remainingAmount = new (0, _anchor.BN)(0);
        }
      }
      if (xToY && isEnoughAmountToCross) {
        currentTickIndex = tickIndex - tickSpacing;
      } else {
        currentTickIndex = tickIndex;
      }
    } else {
      currentTickIndex = getTickFromPrice(currentTickIndex, tickSpacing, result.nextPrice, xToY);
    }
    accumulatedAmount = accumulatedAmount.add(amountDiff);
    const isTickInitialized = limitingTick !== null && limitingTick.initialized;
    if (isTickInitialized || remainingAmount.eqn(0)) {
      amountPerTick.push(accumulatedAmount);
      accumulatedAmount = new (0, _anchor.BN)(0);
    }
    if (!isTickInitialized && liquidity.v.eqn(0)) {
      status = "Too large liquidity gap" /* TooLargeGap */;
      break;
    }
    if (currentTickIndex === previousTickIndex && !remainingAmount.eqn(0)) {
      status = "At the end of price range" /* LimitReached */;
      break;
    } else {
      previousTickIndex = currentTickIndex;
    }
  }
  if (accumulatedAmountOut.isZero() && status === 0 /* Ok */) {
    status = "Amount out is zero" /* NoGainSwap */;
  }
  const priceAfterSwap = sqrtPrice.v;
  const priceImpact = calculatePriceImpact(startingSqrtPrice, priceAfterSwap);
  let minReceived;
  if (byAmountIn) {
    const endingPriceAfterSlippage = calculatePriceAfterSlippage(
      { v: priceAfterSwap },
      slippage,
      !xToY
    ).v;
    minReceived = calculateMinReceivedTokensByAmountIn(
      endingPriceAfterSlippage,
      xToY,
      accumulatedAmountIn,
      pool.fee.v
    );
  } else {
    minReceived = accumulatedAmountOut;
  }
  return {
    status,
    amountPerTick,
    crossedTicks,
    accumulatedAmountIn,
    accumulatedAmountOut,
    accumulatedFee,
    priceAfterSwap,
    priceImpact,
    minReceived
  };
};
var parseLiquidityOnTicks = (ticks) => {
  let currentLiquidity = new (0, _anchor.BN)(0);
  return ticks.map((tick) => {
    currentLiquidity = currentLiquidity.add(tick.liquidityChange.v.muln(tick.sign ? 1 : -1));
    return {
      liquidity: currentLiquidity,
      index: tick.index
    };
  });
};
var calculateFeeGrowthInside = ({
  tickLower,
  tickUpper,
  tickCurrent,
  feeGrowthGlobalX,
  feeGrowthGlobalY
}) => {
  const currentAboveLower = tickCurrent >= tickLower.index;
  const currentBelowUpper = tickCurrent < tickUpper.index;
  let feeGrowthBelowX;
  let feeGrowthBelowY;
  let feeGrowthAboveX;
  let feeGrowthAboveY;
  if (currentAboveLower) {
    feeGrowthBelowX = tickLower.feeGrowthOutsideX.v;
    feeGrowthBelowY = tickLower.feeGrowthOutsideY.v;
  } else {
    feeGrowthBelowX = feeGrowthGlobalX.v.sub(tickLower.feeGrowthOutsideX.v);
    feeGrowthBelowY = feeGrowthGlobalY.v.sub(tickLower.feeGrowthOutsideY.v);
  }
  if (currentBelowUpper) {
    feeGrowthAboveX = tickUpper.feeGrowthOutsideX.v;
    feeGrowthAboveY = tickUpper.feeGrowthOutsideY.v;
  } else {
    feeGrowthAboveX = feeGrowthGlobalX.v.sub(tickUpper.feeGrowthOutsideX.v);
    feeGrowthAboveY = feeGrowthGlobalY.v.sub(tickUpper.feeGrowthOutsideY.v);
  }
  let feeGrowthInsideX = feeGrowthGlobalX.v.sub(feeGrowthBelowX).sub(feeGrowthAboveX);
  let feeGrowthInsideY = feeGrowthGlobalY.v.sub(feeGrowthBelowY).sub(feeGrowthAboveY);
  if (feeGrowthInsideX.lt(new (0, _anchor.BN)(0))) {
    feeGrowthInsideX = U128MAX.sub(feeGrowthInsideX.abs()).addn(1);
  }
  if (feeGrowthInsideY.lt(new (0, _anchor.BN)(0))) {
    feeGrowthInsideY = U128MAX.sub(feeGrowthInsideY.abs()).addn(1);
  }
  return [feeGrowthInsideX, feeGrowthInsideY];
};
var calculateTokensOwed = ({
  position,
  feeGrowthInsideX,
  feeGrowthInsideY
}) => {
  let tokensOwedX;
  let tokensOwedY;
  if (feeGrowthInsideX.lt(position.feeGrowthInsideX.v)) {
    tokensOwedX = position.liquidity.v.mul(feeGrowthInsideX.add(U128MAX.sub(position.feeGrowthInsideX.v))).div(new (0, _anchor.BN)(10).pow(new (0, _anchor.BN)(DECIMAL + LIQUIDITY_SCALE)));
  } else {
    tokensOwedX = position.liquidity.v.mul(feeGrowthInsideX.sub(position.feeGrowthInsideX.v)).div(new (0, _anchor.BN)(10).pow(new (0, _anchor.BN)(DECIMAL + LIQUIDITY_SCALE)));
  }
  if (feeGrowthInsideY.lt(position.feeGrowthInsideY.v)) {
    tokensOwedY = position.liquidity.v.mul(feeGrowthInsideY.add(U128MAX.sub(position.feeGrowthInsideY.v))).div(new (0, _anchor.BN)(10).pow(new (0, _anchor.BN)(DECIMAL + LIQUIDITY_SCALE)));
  } else {
    tokensOwedY = position.liquidity.v.mul(feeGrowthInsideY.sub(position.feeGrowthInsideY.v)).div(new (0, _anchor.BN)(10).pow(new (0, _anchor.BN)(DECIMAL + LIQUIDITY_SCALE)));
  }
  const tokensOwedXTotal = position.tokensOwedX.v.add(tokensOwedX).div(DENOMINATOR);
  const tokensOwedYTotal = position.tokensOwedY.v.add(tokensOwedY).div(DENOMINATOR);
  return [tokensOwedXTotal, tokensOwedYTotal];
};
var calculateClaimAmount = ({
  position,
  tickLower,
  tickUpper,
  tickCurrent,
  feeGrowthGlobalX,
  feeGrowthGlobalY
}) => {
  const feeGrowthParams = {
    tickLower,
    tickUpper,
    tickCurrent,
    feeGrowthGlobalX,
    feeGrowthGlobalY
  };
  const [feeGrowthInsideX, feeGrowthInsideY] = calculateFeeGrowthInside(feeGrowthParams);
  const tokensOwedParams = {
    position,
    feeGrowthInsideX,
    feeGrowthInsideY
  };
  const [tokensOwedXTotal, tokensOwedYTotal] = calculateTokensOwed(tokensOwedParams);
  return [tokensOwedXTotal, tokensOwedYTotal];
};
var bigNumberToBuffer = (n, size) => {
  const chunk = new (0, _anchor.BN)(2).pow(new (0, _anchor.BN)(16));
  const buffer = Buffer.alloc(size / 8);
  let offset = 0;
  while (n.gt(new (0, _anchor.BN)(0))) {
    buffer.writeUInt16LE(n.mod(chunk).toNumber(), offset);
    n = n.div(chunk);
    offset += 2;
  }
  return buffer;
};
var getMaxTick = (tickSpacing) => {
  const limitedByPrice = MAX_TICK - MAX_TICK % tickSpacing;
  const limitedByTickmap = TICK_LIMIT * tickSpacing - tickSpacing;
  return Math.min(limitedByPrice, limitedByTickmap);
};
var getMinTick = (tickSpacing) => {
  const limitedByPrice = -MAX_TICK + MAX_TICK % tickSpacing;
  const limitedByTickmap = -TICK_LIMIT * tickSpacing;
  return Math.max(limitedByPrice, limitedByTickmap);
};
var getTokens = (liquidity, lowerTickIndex, upperTickIndex) => {
  const lowerSqrtPrice = calculatePriceSqrt(lowerTickIndex);
  const upperSqrtPrice = calculatePriceSqrt(upperTickIndex);
  return getXfromLiquidity(liquidity, upperSqrtPrice.v, lowerSqrtPrice.v);
};
var isActive = (lowerIndex, upperIndex, currentIndex) => {
  return lowerIndex <= currentIndex && upperIndex > currentIndex;
};
var coingeckoIdOverwrites = {
  "9vMJfxuKxXBoEa7rM12mYLMwTacLMLDJqHozw96WQL8i": "terrausd",
  "7dHbWXmci3dT8UFYWYZweBLXgycu7Y3iL6trKn1Y7ARj": "lido-staked-sol",
  NRVwhjBQiUPYtfDT5zRBVJajzFQHaBUNtC7SNVvqRFa: "nirvana-nirv"
};
var getTokensData = async () => {
  const tokens = await new (0, _spltokenregistry.TokenListProvider)().resolve();
  const tokenList = tokens.filterByClusterSlug("mainnet-beta").getList().filter((token) => token.chainId === 101);
  const tokensObj = {};
  tokenList.forEach((token) => {
    var _a;
    tokensObj[token.address.toString()] = {
      id: _nullishCoalesce((coingeckoIdOverwrites == null ? void 0 : coingeckoIdOverwrites[token.address.toString()]), () => ( ((_a = token.extensions) == null ? void 0 : _a.coingeckoId))),
      decimals: token.decimals,
      ticker: token.symbol
    };
  });
  return tokensObj;
};
var getPrice = (sqrtPrice, decimalDiff) => {
  const price = sqrtPrice.v.pow(new (0, _anchor.BN)(2));
  const priceWithCorrectPrecision = price.div(new (0, _anchor.BN)(10).pow(new (0, _anchor.BN)(40)));
  if (decimalDiff > 0) {
    return { v: priceWithCorrectPrecision.mul(new (0, _anchor.BN)(10).pow(new (0, _anchor.BN)(decimalDiff))) };
  }
  if (decimalDiff < 0) {
    return { v: priceWithCorrectPrecision.div(new (0, _anchor.BN)(10).pow(new (0, _anchor.BN)(Math.abs(decimalDiff)))) };
  }
  return { v: priceWithCorrectPrecision };
};

// src/math.ts
var TICK_LIMIT = 44364;
var MAX_TICK = 221818;
var MIN_TICK = -MAX_TICK;
var TICK_SEARCH_RANGE = 256;
var U64_MAX = new (0, _anchor.BN)("18446744073709551615");
var isInitialized = (tickmap, index, tickSpacing) => {
  if (index % tickSpacing !== 0) {
    throw Error("invalid arguments can't check tick");
  }
  const toIndex = Math.floor(index / tickSpacing) + TICK_LIMIT;
  const byte = Math.floor(toIndex / 8);
  const bit = Math.floor(toIndex % 8);
  const value = tickmap.bitmap[byte] & 1 << bit;
  return value !== 0;
};
var fromInteger = (integer) => {
  return { v: new (0, _anchor.BN)(integer).mul(DENOMINATOR) };
};
var calculatePriceSqrt = (tickIndex) => {
  const tick = Math.abs(tickIndex);
  if (tick > MAX_TICK) {
    throw Error("tick over bounds");
  }
  let price = new (0, _anchor.BN)(DENOMINATOR);
  if ((tick & 1) !== 0)
    price = price.mul(new (0, _anchor.BN)("1000049998750")).div(DENOMINATOR);
  if ((tick & 2) !== 0)
    price = price.mul(new (0, _anchor.BN)("1000100000000")).div(DENOMINATOR);
  if ((tick & 4) !== 0)
    price = price.mul(new (0, _anchor.BN)("1000200010000")).div(DENOMINATOR);
  if ((tick & 8) !== 0)
    price = price.mul(new (0, _anchor.BN)("1000400060004")).div(DENOMINATOR);
  if ((tick & 16) !== 0)
    price = price.mul(new (0, _anchor.BN)("1000800280056")).div(DENOMINATOR);
  if ((tick & 32) !== 0)
    price = price.mul(new (0, _anchor.BN)("1001601200560")).div(DENOMINATOR);
  if ((tick & 64) !== 0)
    price = price.mul(new (0, _anchor.BN)("1003204964963")).div(DENOMINATOR);
  if ((tick & 128) !== 0)
    price = price.mul(new (0, _anchor.BN)("1006420201726")).div(DENOMINATOR);
  if ((tick & 256) !== 0)
    price = price.mul(new (0, _anchor.BN)("1012881622442")).div(DENOMINATOR);
  if ((tick & 512) !== 0)
    price = price.mul(new (0, _anchor.BN)("1025929181080")).div(DENOMINATOR);
  if ((tick & 1024) !== 0)
    price = price.mul(new (0, _anchor.BN)("1052530684591")).div(DENOMINATOR);
  if ((tick & 2048) !== 0)
    price = price.mul(new (0, _anchor.BN)("1107820842005")).div(DENOMINATOR);
  if ((tick & 4096) !== 0)
    price = price.mul(new (0, _anchor.BN)("1227267017980")).div(DENOMINATOR);
  if ((tick & 8192) !== 0)
    price = price.mul(new (0, _anchor.BN)("1506184333421")).div(DENOMINATOR);
  if ((tick & 16384) !== 0)
    price = price.mul(new (0, _anchor.BN)("2268591246242")).div(DENOMINATOR);
  if ((tick & 32768) !== 0)
    price = price.mul(new (0, _anchor.BN)("5146506242525")).div(DENOMINATOR);
  if ((tick & 65536) !== 0)
    price = price.mul(new (0, _anchor.BN)("26486526504348")).div(DENOMINATOR);
  if ((tick & 131072) !== 0)
    price = price.mul(new (0, _anchor.BN)("701536086265529")).div(DENOMINATOR);
  if (tickIndex < 0) {
    return {
      v: DENOMINATOR.mul(DENOMINATOR).div(price).mul(new (0, _anchor.BN)(10).pow(new (0, _anchor.BN)(PRICE_SCALE - DECIMAL)))
    };
  }
  return { v: price.mul(new (0, _anchor.BN)(10).pow(new (0, _anchor.BN)(PRICE_SCALE - DECIMAL))) };
};
var sqrt = (num) => {
  if (num.lt(new (0, _anchor.BN)(0))) {
    throw new Error("Sqrt only works on non-negative inputs");
  }
  if (num.lt(new (0, _anchor.BN)(2))) {
    return num;
  }
  const smallCand = sqrt(num.shrn(2)).shln(1);
  const largeCand = smallCand.add(new (0, _anchor.BN)(1));
  if (largeCand.mul(largeCand).gt(num)) {
    return smallCand;
  } else {
    return largeCand;
  }
};
var calculatePriceAfterSlippage = (priceSqrt, slippage, up) => {
  const multiplier = up ? slippage.v.add(DENOMINATOR) : DENOMINATOR.sub(slippage.v);
  const slippageSqrt = sqrt(multiplier.mul(DENOMINATOR));
  return { v: priceSqrt.v.mul(slippageSqrt).div(DENOMINATOR) };
};
var calculateSwapStep = (currentPrice, targetPrice, liquidity, amount, byAmountIn, fee) => {
  if (liquidity.v.eqn(0)) {
    return {
      nextPrice: targetPrice,
      amountIn: new (0, _anchor.BN)(0),
      amountOut: new (0, _anchor.BN)(0),
      feeAmount: new (0, _anchor.BN)(0)
    };
  }
  const aToB = currentPrice.v.gte(targetPrice.v);
  let nextPrice = { v: new (0, _anchor.BN)(0) };
  let amountIn = new (0, _anchor.BN)(0);
  let amountOut = new (0, _anchor.BN)(0);
  let feeAmount = new (0, _anchor.BN)(0);
  if (byAmountIn) {
    const amountAfterFee = fromInteger(1).v.sub(fee.v).mul(amount).div(DENOMINATOR);
    if (aToB) {
      amountIn = _nullishCoalesce(getDeltaX(targetPrice, currentPrice, liquidity, true), () => ( U64_MAX));
    } else {
      amountIn = _nullishCoalesce(getDeltaY(targetPrice, currentPrice, liquidity, true), () => ( U64_MAX));
    }
    if (amountAfterFee.gte(amountIn)) {
      nextPrice = targetPrice;
    } else {
      nextPrice = getNextPriceFromInput(currentPrice, liquidity, amountAfterFee, aToB);
    }
  } else {
    if (aToB) {
      amountOut = _nullishCoalesce(getDeltaY(targetPrice, currentPrice, liquidity, false), () => ( U64_MAX));
    } else {
      amountOut = _nullishCoalesce(getDeltaX(currentPrice, targetPrice, liquidity, false), () => ( U64_MAX));
    }
    if (amount.gte(amountOut)) {
      nextPrice = targetPrice;
    } else {
      nextPrice = getNextPriceFromOutput(currentPrice, liquidity, amount, aToB);
    }
  }
  const max = targetPrice.v.eq(nextPrice.v);
  if (aToB) {
    if (!(max && byAmountIn)) {
      amountIn = getDeltaX(nextPrice, currentPrice, liquidity, true);
    }
    if (!(max && !byAmountIn)) {
      amountOut = getDeltaY(nextPrice, currentPrice, liquidity, false);
    }
  } else {
    if (!(max && byAmountIn)) {
      amountIn = getDeltaY(currentPrice, nextPrice, liquidity, true);
    }
    if (!(max && !byAmountIn)) {
      amountOut = getDeltaX(currentPrice, nextPrice, liquidity, false);
    }
  }
  if (amountIn === null || amountOut === null)
    throw new Error("Amount would be greater than u64");
  if (!byAmountIn && amountOut.gt(amount)) {
    amountOut = amount;
  }
  if (byAmountIn && !nextPrice.v.eq(targetPrice.v)) {
    feeAmount = amount.sub(amountIn);
  } else {
    feeAmount = amountIn.mul(fee.v).add(DENOMINATOR.subn(1)).div(DENOMINATOR);
  }
  return {
    nextPrice,
    amountIn,
    amountOut,
    feeAmount
  };
};
var getDeltaX = (priceA, priceB, liquidity, up) => {
  let deltaPrice;
  if (priceA.v.gt(priceB.v)) {
    deltaPrice = { v: priceA.v.sub(priceB.v) };
  } else {
    deltaPrice = { v: priceB.v.sub(priceA.v) };
  }
  const nominator = liquidity.v.mul(deltaPrice.v).div(LIQUIDITY_DENOMINATOR);
  if (up) {
    const denominatorUp = priceA.v.mul(priceB.v).div(PRICE_DENOMINATOR);
    const result = nominator.mul(PRICE_DENOMINATOR).add(denominatorUp.subn(1)).div(denominatorUp).add(PRICE_DENOMINATOR.subn(1)).div(PRICE_DENOMINATOR);
    return result.lte(U64_MAX) ? result : null;
  } else {
    const denominatorDown = priceA.v.mul(priceB.v).add(PRICE_DENOMINATOR.subn(1)).div(PRICE_DENOMINATOR);
    const result = nominator.mul(PRICE_DENOMINATOR).div(denominatorDown).div(PRICE_DENOMINATOR);
    return result.lte(U64_MAX) ? result : null;
  }
};
var getDeltaY = (priceA, priceB, liquidity, up) => {
  let deltaPrice;
  if (priceA.v.gt(priceB.v)) {
    deltaPrice = { v: priceA.v.sub(priceB.v) };
  } else {
    deltaPrice = { v: priceB.v.sub(priceA.v) };
  }
  if (up) {
    const result = deltaPrice.v.mul(liquidity.v).add(LIQUIDITY_DENOMINATOR.subn(1)).div(LIQUIDITY_DENOMINATOR).add(PRICE_DENOMINATOR.subn(1)).div(PRICE_DENOMINATOR);
    return result.lte(U64_MAX) ? result : null;
  } else {
    const result = deltaPrice.v.mul(liquidity.v).div(LIQUIDITY_DENOMINATOR).div(PRICE_DENOMINATOR);
    return result.lte(U64_MAX) ? result : null;
  }
};
var getNextPriceFromInput = (price, liquidity, amount, aToB) => {
  _invariant2.default.call(void 0, price.v.gt(new (0, _anchor.BN)(0)), "prive should be gt 0");
  _invariant2.default.call(void 0, liquidity.v.gt(new (0, _anchor.BN)(0)), "liquidity should be gt 0");
  if (aToB) {
    return getNextPriceXUp(price, liquidity, amount, true);
  } else {
    return getNextPriceYDown(price, liquidity, amount, true);
  }
};
var getNextPriceFromOutput = (price, liquidity, amount, aToB) => {
  _invariant2.default.call(void 0, price.v.gt(new (0, _anchor.BN)(0)), "prive should be gt 0");
  _invariant2.default.call(void 0, liquidity.v.gt(new (0, _anchor.BN)(0)), "liquidity should be gt 0");
  if (aToB) {
    return getNextPriceYDown(price, liquidity, amount, false);
  } else {
    return getNextPriceXUp(price, liquidity, amount, false);
  }
};
var getNextPriceXUp = (price, liquidity, amount, add) => {
  if (amount.eqn(0)) {
    return price;
  }
  const bigLiquidity = liquidity.v.mul(new (0, _anchor.BN)(10).pow(new (0, _anchor.BN)(PRICE_SCALE - LIQUIDITY_SCALE)));
  const priceMulAmount = price.v.mul(amount);
  let denominator;
  if (add) {
    denominator = bigLiquidity.add(priceMulAmount);
  } else {
    denominator = bigLiquidity.sub(priceMulAmount);
  }
  const nominator = price.v.mul(liquidity.v).add(LIQUIDITY_DENOMINATOR.subn(1)).div(LIQUIDITY_DENOMINATOR);
  return {
    v: nominator.mul(PRICE_DENOMINATOR).add(denominator.subn(1)).div(denominator)
  };
};
var getNextPriceYDown = (price, liquidity, amount, add) => {
  let quotient;
  if (add) {
    quotient = amount.mul(PRICE_DENOMINATOR).mul(PRICE_DENOMINATOR).div(liquidity.v.mul(new (0, _anchor.BN)(10).pow(new (0, _anchor.BN)(PRICE_SCALE - LIQUIDITY_SCALE))));
    return {
      v: price.v.add(quotient)
    };
  } else {
    quotient = amount.mul(PRICE_DENOMINATOR).mul(PRICE_DENOMINATOR).add(liquidity.v.mul(new (0, _anchor.BN)(10).pow(new (0, _anchor.BN)(PRICE_SCALE - LIQUIDITY_SCALE))).subn(1)).div(liquidity.v.mul(new (0, _anchor.BN)(10).pow(new (0, _anchor.BN)(PRICE_SCALE - LIQUIDITY_SCALE))));
    return { v: price.v.sub(quotient) };
  }
};
var findClosestTicks = (ticks, current, tickSpacing, limit, maxRange = Infinity, oneWay = void 0) => {
  if (current % tickSpacing !== 0) {
    throw Error("invalid arguments can't find initialized ticks");
  }
  const currentIndex = Math.floor(current / tickSpacing) + TICK_LIMIT;
  let above = currentIndex + 1;
  let below = currentIndex;
  const found = [];
  let reachedTop = oneWay === "down";
  let reachedBottom = oneWay === "up";
  while (found.length < limit && above - below < maxRange * 2) {
    if (!reachedTop) {
      const valueAbove = ticks[Math.floor(above / 8)] & 1 << above % 8;
      if (valueAbove)
        found.push(above);
      reachedTop = above >= 2 * TICK_LIMIT;
      above++;
    }
    if (!reachedBottom) {
      const valueBelow = ticks[Math.floor(below / 8)] & 1 << below % 8;
      if (valueBelow)
        found.unshift(below);
      reachedBottom = below < 0;
      below--;
    }
    if (reachedTop && reachedBottom) {
      break;
    }
  }
  if (found.length > limit)
    found.pop();
  return found.map((i) => (i - TICK_LIMIT) * tickSpacing);
};
var getX = (liquidity, upperSqrtPrice, currentSqrtPrice, lowerSqrtPrice) => {
  if (upperSqrtPrice.lte(new (0, _anchor.BN)(0)) || currentSqrtPrice.lte(new (0, _anchor.BN)(0)) || lowerSqrtPrice.lte(new (0, _anchor.BN)(0))) {
    throw new Error("Price cannot be lower or equal 0");
  }
  let denominator;
  let nominator;
  if (currentSqrtPrice.gte(upperSqrtPrice)) {
    return new (0, _anchor.BN)(0);
  } else if (currentSqrtPrice.lt(lowerSqrtPrice)) {
    denominator = lowerSqrtPrice.mul(upperSqrtPrice).div(PRICE_DENOMINATOR);
    nominator = upperSqrtPrice.sub(lowerSqrtPrice);
  } else {
    denominator = upperSqrtPrice.mul(currentSqrtPrice).div(PRICE_DENOMINATOR);
    nominator = upperSqrtPrice.sub(currentSqrtPrice);
  }
  return liquidity.mul(nominator).div(denominator).div(LIQUIDITY_DENOMINATOR);
};
var getXfromLiquidity = (liquidity, upperSqrtPrice, lowerSqrtPrice) => {
  if (upperSqrtPrice.lte(new (0, _anchor.BN)(0)) || lowerSqrtPrice.lte(new (0, _anchor.BN)(0))) {
    throw new Error("Price cannot be lower or equal 0");
  }
  const denominator = lowerSqrtPrice.mul(upperSqrtPrice).div(PRICE_DENOMINATOR);
  const nominator = upperSqrtPrice.sub(lowerSqrtPrice);
  return liquidity.mul(nominator).div(denominator).div(LIQUIDITY_DENOMINATOR);
};
var getY = (liquidity, upperSqrtPrice, currentSqrtPrice, lowerSqrtPrice) => {
  if (lowerSqrtPrice.lte(new (0, _anchor.BN)(0)) || currentSqrtPrice.lte(new (0, _anchor.BN)(0)) || upperSqrtPrice.lte(new (0, _anchor.BN)(0))) {
    throw new Error("Price cannot be 0");
  }
  let difference;
  if (currentSqrtPrice.lt(lowerSqrtPrice)) {
    return new (0, _anchor.BN)(0);
  } else if (currentSqrtPrice.gte(upperSqrtPrice)) {
    difference = upperSqrtPrice.sub(lowerSqrtPrice);
  } else {
    difference = currentSqrtPrice.sub(lowerSqrtPrice);
  }
  return liquidity.mul(difference).div(PRICE_DENOMINATOR).div(LIQUIDITY_DENOMINATOR);
};
var isEnoughAmountToPushPrice = (amount, currentPriceSqrt, liquidity, fee, byAmountIn, aToB) => {
  if (liquidity.v.eqn(0)) {
    return true;
  }
  let nextSqrtPrice;
  if (byAmountIn) {
    const amountAfterFee = fromInteger(1).v.sub(fee.v).mul(amount).div(DENOMINATOR);
    nextSqrtPrice = getNextPriceFromInput(currentPriceSqrt, liquidity, amountAfterFee, aToB);
  } else {
    nextSqrtPrice = getNextPriceFromOutput(currentPriceSqrt, liquidity, amount, aToB);
  }
  return !currentPriceSqrt.v.eq(nextSqrtPrice.v);
};
var calculatePriceImpact = (startingSqrtPrice, endingSqrtPrice) => {
  const startingPrice = startingSqrtPrice.mul(startingSqrtPrice);
  const endingPrice = endingSqrtPrice.mul(endingSqrtPrice);
  let priceQuotient;
  if (endingPrice.gte(startingPrice)) {
    priceQuotient = DENOMINATOR.mul(startingPrice).div(endingPrice);
  } else {
    priceQuotient = DENOMINATOR.mul(endingPrice).div(startingPrice);
  }
  return DENOMINATOR.sub(priceQuotient);
};
var calculateMinReceivedTokensByAmountIn = (targetSqrtPrice, xToY, amountIn, fee) => {
  const targetPrice = targetSqrtPrice.mul(targetSqrtPrice);
  let amountOut;
  if (xToY) {
    amountOut = amountIn.mul(targetPrice).div(PRICE_DENOMINATOR).div(PRICE_DENOMINATOR);
  } else {
    amountOut = amountIn.mul(PRICE_DENOMINATOR).mul(PRICE_DENOMINATOR).div(targetPrice);
  }
  return DENOMINATOR.sub(fee).mul(amountOut).div(DENOMINATOR);
};

// src/idl/invariant.ts
var IDL = {
  "version": "0.1.0",
  "name": "invariant",
  "instructions": [
    {
      "name": "createState",
      "accounts": [
        {
          "name": "state",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "admin",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "programAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "rent",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "nonce",
          "type": "u8"
        }
      ]
    },
    {
      "name": "createFeeTier",
      "accounts": [
        {
          "name": "feeTier",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "state",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "admin",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "rent",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "fee",
          "type": "u128"
        },
        {
          "name": "tickSpacing",
          "type": "u16"
        }
      ]
    },
    {
      "name": "createPool",
      "accounts": [
        {
          "name": "state",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "pool",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "feeTier",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tickmap",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "tokenX",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenY",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenXReserve",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "tokenYReserve",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "payer",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "authority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "rent",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "initTick",
          "type": "i32"
        }
      ]
    },
    {
      "name": "swap",
      "accounts": [
        {
          "name": "state",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "pool",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "tickmap",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "accountX",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "accountY",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "reserveX",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "reserveY",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "owner",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "programAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "xToY",
          "type": "bool"
        },
        {
          "name": "amount",
          "type": "u64"
        },
        {
          "name": "byAmountIn",
          "type": "bool"
        },
        {
          "name": "sqrtPriceLimit",
          "type": "u128"
        }
      ]
    },
    {
      "name": "initializeOracle",
      "accounts": [
        {
          "name": "pool",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "oracle",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "tokenX",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenY",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "payer",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "rent",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": []
    },
    {
      "name": "createTick",
      "accounts": [
        {
          "name": "tick",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "pool",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tickmap",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "payer",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "tokenX",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenY",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "rent",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "index",
          "type": "i32"
        }
      ]
    },
    {
      "name": "createPositionList",
      "accounts": [
        {
          "name": "positionList",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "owner",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "signer",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "rent",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": []
    },
    {
      "name": "createPosition",
      "accounts": [
        {
          "name": "state",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "position",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "pool",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "positionList",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "payer",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "owner",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "lowerTick",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "upperTick",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "tickmap",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "tokenX",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenY",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "accountX",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "accountY",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "reserveX",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "reserveY",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "programAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "rent",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "lowerTickIndex",
          "type": "i32"
        },
        {
          "name": "upperTickIndex",
          "type": "i32"
        },
        {
          "name": "liquidityDelta",
          "type": {
            "defined": "Liquidity"
          }
        },
        {
          "name": "slippageLimitLower",
          "type": {
            "defined": "Price"
          }
        },
        {
          "name": "slippageLimitUpper",
          "type": {
            "defined": "Price"
          }
        }
      ]
    },
    {
      "name": "removePosition",
      "accounts": [
        {
          "name": "state",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "removedPosition",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "positionList",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "lastPosition",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "pool",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "tickmap",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "lowerTick",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "upperTick",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "owner",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "tokenX",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenY",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "accountX",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "accountY",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "reserveX",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "reserveY",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "programAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "index",
          "type": "u32"
        },
        {
          "name": "lowerTickIndex",
          "type": "i32"
        },
        {
          "name": "upperTickIndex",
          "type": "i32"
        }
      ]
    },
    {
      "name": "transferPositionOwnership",
      "accounts": [
        {
          "name": "ownerList",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "recipientList",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "newPosition",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "removedPosition",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "lastPosition",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "owner",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "recipient",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "rent",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "index",
          "type": "u32"
        }
      ]
    },
    {
      "name": "claimFee",
      "accounts": [
        {
          "name": "state",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "pool",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "position",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "lowerTick",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "upperTick",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "owner",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "tokenX",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenY",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "accountX",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "accountY",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "reserveX",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "reserveY",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "programAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "index",
          "type": "u32"
        },
        {
          "name": "lowerTickIndex",
          "type": "i32"
        },
        {
          "name": "upperTickIndex",
          "type": "i32"
        }
      ]
    },
    {
      "name": "updateSecondsPerLiquidity",
      "accounts": [
        {
          "name": "pool",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "lowerTick",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "upperTick",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "position",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "tokenX",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenY",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "owner",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "signer",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "rent",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "lowerTickIndex",
          "type": "i32"
        },
        {
          "name": "upperTickIndex",
          "type": "i32"
        },
        {
          "name": "index",
          "type": "i32"
        }
      ]
    },
    {
      "name": "withdrawProtocolFee",
      "accounts": [
        {
          "name": "state",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "pool",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "tokenX",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenY",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "accountX",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "accountY",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "reserveX",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "reserveY",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "authority",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "programAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": []
    },
    {
      "name": "changeProtocolFee",
      "accounts": [
        {
          "name": "state",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "pool",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "tokenX",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenY",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "admin",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "programAuthority",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "protocolFee",
          "type": {
            "defined": "FixedPoint"
          }
        }
      ]
    },
    {
      "name": "changeFeeReceiver",
      "accounts": [
        {
          "name": "state",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "pool",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "tokenX",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenY",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "admin",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "feeReceiver",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": []
    }
  ],
  "accounts": [
    {
      "name": "feeTier",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "fee",
            "type": {
              "defined": "FixedPoint"
            }
          },
          {
            "name": "tickSpacing",
            "type": "u16"
          },
          {
            "name": "bump",
            "type": "u8"
          }
        ]
      }
    },
    {
      "name": "oracle",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "data",
            "type": {
              "array": [
                {
                  "defined": "Record"
                },
                256
              ]
            }
          },
          {
            "name": "head",
            "type": "u16"
          },
          {
            "name": "amount",
            "type": "u16"
          },
          {
            "name": "size",
            "type": "u16"
          }
        ]
      }
    },
    {
      "name": "pool",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "tokenX",
            "type": "publicKey"
          },
          {
            "name": "tokenY",
            "type": "publicKey"
          },
          {
            "name": "tokenXReserve",
            "type": "publicKey"
          },
          {
            "name": "tokenYReserve",
            "type": "publicKey"
          },
          {
            "name": "positionIterator",
            "type": "u128"
          },
          {
            "name": "tickSpacing",
            "type": "u16"
          },
          {
            "name": "fee",
            "type": {
              "defined": "FixedPoint"
            }
          },
          {
            "name": "protocolFee",
            "type": {
              "defined": "FixedPoint"
            }
          },
          {
            "name": "liquidity",
            "type": {
              "defined": "Liquidity"
            }
          },
          {
            "name": "sqrtPrice",
            "type": {
              "defined": "Price"
            }
          },
          {
            "name": "currentTickIndex",
            "type": "i32"
          },
          {
            "name": "tickmap",
            "type": "publicKey"
          },
          {
            "name": "feeGrowthGlobalX",
            "type": {
              "defined": "FeeGrowth"
            }
          },
          {
            "name": "feeGrowthGlobalY",
            "type": {
              "defined": "FeeGrowth"
            }
          },
          {
            "name": "feeProtocolTokenX",
            "type": "u64"
          },
          {
            "name": "feeProtocolTokenY",
            "type": "u64"
          },
          {
            "name": "secondsPerLiquidityGlobal",
            "type": {
              "defined": "FixedPoint"
            }
          },
          {
            "name": "startTimestamp",
            "type": "u64"
          },
          {
            "name": "lastTimestamp",
            "type": "u64"
          },
          {
            "name": "feeReceiver",
            "type": "publicKey"
          },
          {
            "name": "oracleAddress",
            "type": "publicKey"
          },
          {
            "name": "oracleInitialized",
            "type": "bool"
          },
          {
            "name": "bump",
            "type": "u8"
          }
        ]
      }
    },
    {
      "name": "position",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "owner",
            "type": "publicKey"
          },
          {
            "name": "pool",
            "type": "publicKey"
          },
          {
            "name": "id",
            "type": "u128"
          },
          {
            "name": "liquidity",
            "type": {
              "defined": "Liquidity"
            }
          },
          {
            "name": "lowerTickIndex",
            "type": "i32"
          },
          {
            "name": "upperTickIndex",
            "type": "i32"
          },
          {
            "name": "feeGrowthInsideX",
            "type": {
              "defined": "FeeGrowth"
            }
          },
          {
            "name": "feeGrowthInsideY",
            "type": {
              "defined": "FeeGrowth"
            }
          },
          {
            "name": "secondsPerLiquidityInside",
            "type": {
              "defined": "FixedPoint"
            }
          },
          {
            "name": "lastSlot",
            "type": "u64"
          },
          {
            "name": "tokensOwedX",
            "type": {
              "defined": "FixedPoint"
            }
          },
          {
            "name": "tokensOwedY",
            "type": {
              "defined": "FixedPoint"
            }
          },
          {
            "name": "bump",
            "type": "u8"
          }
        ]
      }
    },
    {
      "name": "positionList",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "head",
            "type": "u32"
          },
          {
            "name": "bump",
            "type": "u8"
          }
        ]
      }
    },
    {
      "name": "state",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "admin",
            "type": "publicKey"
          },
          {
            "name": "nonce",
            "type": "u8"
          },
          {
            "name": "authority",
            "type": "publicKey"
          },
          {
            "name": "bump",
            "type": "u8"
          }
        ]
      }
    },
    {
      "name": "tick",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "pool",
            "type": "publicKey"
          },
          {
            "name": "index",
            "type": "i32"
          },
          {
            "name": "sign",
            "type": "bool"
          },
          {
            "name": "liquidityChange",
            "type": {
              "defined": "Liquidity"
            }
          },
          {
            "name": "liquidityGross",
            "type": {
              "defined": "Liquidity"
            }
          },
          {
            "name": "sqrtPrice",
            "type": {
              "defined": "Price"
            }
          },
          {
            "name": "feeGrowthOutsideX",
            "type": {
              "defined": "FeeGrowth"
            }
          },
          {
            "name": "feeGrowthOutsideY",
            "type": {
              "defined": "FeeGrowth"
            }
          },
          {
            "name": "secondsPerLiquidityOutside",
            "type": {
              "defined": "FixedPoint"
            }
          },
          {
            "name": "secondsOutside",
            "type": "u64"
          },
          {
            "name": "bump",
            "type": "u8"
          }
        ]
      }
    },
    {
      "name": "tickmap",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "bitmap",
            "type": {
              "array": [
                "u8",
                11091
              ]
            }
          }
        ]
      }
    }
  ],
  "types": [
    {
      "name": "Price",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "v",
            "type": "u128"
          }
        ]
      }
    },
    {
      "name": "Liquidity",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "v",
            "type": "u128"
          }
        ]
      }
    },
    {
      "name": "FeeGrowth",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "v",
            "type": "u128"
          }
        ]
      }
    },
    {
      "name": "FixedPoint",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "v",
            "type": "u128"
          }
        ]
      }
    },
    {
      "name": "Record",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "timestamp",
            "type": "u64"
          },
          {
            "name": "price",
            "type": {
              "defined": "Price"
            }
          }
        ]
      }
    }
  ],
  "errors": [
    {
      "code": 6e3,
      "name": "ZeroAmount",
      "msg": "Amount is zero"
    },
    {
      "code": 6001,
      "name": "ZeroOutput",
      "msg": "Output would be zero"
    },
    {
      "code": 6002,
      "name": "WrongTick",
      "msg": "Not the expected tick"
    },
    {
      "code": 6003,
      "name": "WrongLimit",
      "msg": "Price limit is on the wrong side of price"
    },
    {
      "code": 6004,
      "name": "InvalidTickIndex",
      "msg": "Tick index not divisible by spacing or over limit"
    },
    {
      "code": 6005,
      "name": "InvalidTickInterval",
      "msg": "Invalid tick_lower or tick_upper"
    },
    {
      "code": 6006,
      "name": "NoMoreTicks",
      "msg": "There is no more tick in that direction"
    },
    {
      "code": 6007,
      "name": "TickNotFound",
      "msg": "Correct tick not found in context"
    },
    {
      "code": 6008,
      "name": "PriceLimitReached",
      "msg": "Price would cross swap limit"
    },
    {
      "code": 6009,
      "name": "InvalidTickLiquidity",
      "msg": "Invalid tick liquidity"
    },
    {
      "code": 6010,
      "name": "EmptyPositionPokes",
      "msg": "Disable empty position pokes"
    },
    {
      "code": 6011,
      "name": "InvalidPositionLiquidity",
      "msg": "Invalid tick liquidity"
    },
    {
      "code": 6012,
      "name": "InvalidPoolLiquidity",
      "msg": "Invalid pool liquidity"
    },
    {
      "code": 6013,
      "name": "InvalidPositionIndex",
      "msg": "Invalid position index"
    },
    {
      "code": 6014,
      "name": "PositionWithoutLiquidity",
      "msg": "Position liquidity would be zero"
    },
    {
      "code": 6015,
      "name": "Unauthorized",
      "msg": "You are not admin"
    },
    {
      "code": 6016,
      "name": "InvalidPoolTokenAddresses",
      "msg": "Invalid pool token addresses"
    },
    {
      "code": 6017,
      "name": "NegativeTime",
      "msg": "Time cannot be negative"
    },
    {
      "code": 6018,
      "name": "OracleAlreadyInitialized",
      "msg": "Oracle is already initialized"
    },
    {
      "code": 6019,
      "name": "LimitReached",
      "msg": "Absolute price limit was reached"
    },
    {
      "code": 6020,
      "name": "InvalidProtocolFee",
      "msg": "Invalid protocol fee"
    },
    {
      "code": 6021,
      "name": "NoGainSwap",
      "msg": "Swap amount out is 0"
    },
    {
      "code": 6022,
      "name": "InvalidTokenAccount",
      "msg": "Provided token account is different than expected"
    },
    {
      "code": 6023,
      "name": "InvalidAdmin",
      "msg": "Admin address is different than expected"
    },
    {
      "code": 6024,
      "name": "InvalidAuthority",
      "msg": "Provided authority is different than expected"
    },
    {
      "code": 6025,
      "name": "InvalidOwner",
      "msg": "Provided token owner is different than expected"
    },
    {
      "code": 6026,
      "name": "InvalidMint",
      "msg": "Provided token account mint is different than expected mint token"
    },
    {
      "code": 6027,
      "name": "InvalidTickmap",
      "msg": "Provided tickmap is different than expected"
    },
    {
      "code": 6028,
      "name": "InvalidTickmapOwner",
      "msg": "Provided tickmap owner is different than program ID"
    },
    {
      "code": 6029,
      "name": "InvalidListOwner",
      "msg": "Recipient list address and owner list address should be different"
    },
    {
      "code": 6030,
      "name": "InvalidTickSpacing",
      "msg": "Invalid tick spacing"
    }
  ]
};

// src/network.ts
var Network = /* @__PURE__ */ ((Network3) => {
  Network3[Network3["LOCAL"] = 0] = "LOCAL";
  Network3[Network3["DEV"] = 1] = "DEV";
  Network3[Network3["MAIN"] = 2] = "MAIN";
  return Network3;
})(Network || {});
var getMarketAddress = (network) => {
  switch (network) {
    case 0 /* LOCAL */:
      return "HyaB3W9q6XdA5xwpU4XnSZV94htfmbmqJXZcEbRaJutt";
    case 1 /* DEV */:
      return "9aiirQKPZ2peE9QrXYmsbTtR7wSDJi2HkQdHuaMpTpei";
    case 2 /* MAIN */:
      return "HyaB3W9q6XdA5xwpU4XnSZV94htfmbmqJXZcEbRaJutt";
    default:
      throw new Error("Unknown network");
  }
};
var MOCK_TOKENS = {
  USDC: "5ihkgQGjKvWvmMtywTgLdwokZ6hqFv5AgxSyYoCNufQW",
  USDT: "4cZv7KgYNgmr3NZSDhT5bhXGGttXKTndqyXeeC1cB6Xm",
  SOL: "BJVjNqQzM1fywLWzzKbQEZ2Jsx9AVyhSLWzko3yF68PH",
  MSOL: "4r8WDEvBntEr3dT69p7ua1rsaWcpTSHnKpY5JugDkcPQ",
  WSOL: "So11111111111111111111111111111111111111112",
  BTC: "4gGKgUYvGkCT62Cu1zfPspuR7VPNPYrigXFmF9KTPji8",
  REN_DOGE: "ArjgPxuQgaGXU16XSdBPDsCit7nxjAKR5Gvtvb2oFZUZ",
  USDH: "41dDByBv1Z6mCHCp4FJeZNP8MPiviUpFz2AdzJYRszzv",
  HBB: "EBuKgNDiUonDYML2CZXCRQKnE982hnt6AhaxXVZZoCyo"
};

// src/market.ts
var _bytes = require('@project-serum/anchor/dist/cjs/utils/bytes');
var POSITION_SEED = "positionv1";
var TICK_SEED = "tickv1";
var POSITION_LIST_SEED = "positionlistv1";
var STATE_SEED = "statev1";
var TICK_CROSSES_PER_IX = 19;
var FEE_TIER = "feetierv1";
var DEFAULT_PUBLIC_KEY = new (0, _web3js.PublicKey)(0);
var Market2 = class {
  constructor(network, wallet, connection, programId) {
    this.stateAddress = _web3js.PublicKey.default;
    this.programAuthority = _web3js.PublicKey.default;
    this.connection = connection;
    this.wallet = wallet;
    const programAddress = new (0, _web3js.PublicKey)(getMarketAddress(network));
    const provider = new (0, _anchor.AnchorProvider)(connection, wallet, _anchor.AnchorProvider.defaultOptions());
    this.network = network;
    this.program = new (0, _anchor.Program)(IDL, programAddress, provider);
  }
  static async build(network, wallet, connection, programId) {
    const instance = new Market2(network, wallet, connection, programId);
    instance.stateAddress = (await instance.getStateAddress()).address;
    instance.programAuthority = (await instance.getProgramAuthority()).programAuthority;
    return instance;
  }
  async createPool(createPool) {
    const { transaction, signers } = await this.createPoolTx(createPool);
    await signAndSend(transaction, [createPool.payer, ...signers], this.connection);
  }
  async createPoolTx({ pair, payer, initTick }) {
    const payerPubkey = _nullishCoalesce((payer == null ? void 0 : payer.publicKey), () => ( this.wallet.publicKey));
    const bitmapKeypair = _web3js.Keypair.generate();
    const tokenXReserve = _web3js.Keypair.generate();
    const tokenYReserve = _web3js.Keypair.generate();
    const tick = _nullishCoalesce(initTick, () => ( 0));
    const { address: stateAddress } = await this.getStateAddress();
    const [poolAddress] = await pair.getAddressAndBump(this.program.programId);
    const { address: feeTierAddress } = await this.getFeeTierAddress(pair.feeTier);
    const createIx = this.program.instruction.createPool(tick, {
      accounts: {
        state: stateAddress,
        pool: poolAddress,
        feeTier: feeTierAddress,
        tickmap: bitmapKeypair.publicKey,
        tokenX: pair.tokenX,
        tokenY: pair.tokenY,
        tokenXReserve: tokenXReserve.publicKey,
        tokenYReserve: tokenYReserve.publicKey,
        authority: this.programAuthority,
        tokenProgram: _spltoken.TOKEN_PROGRAM_ID,
        payer: payerPubkey,
        rent: _web3js.SYSVAR_RENT_PUBKEY,
        systemProgram: _web3js.SystemProgram.programId
      }
    });
    const transaction = new (0, _web3js.Transaction)({
      feePayer: payerPubkey
    }).add(
      _web3js.SystemProgram.createAccount({
        fromPubkey: payerPubkey,
        newAccountPubkey: bitmapKeypair.publicKey,
        space: this.program.account.tickmap.size,
        lamports: await this.connection.getMinimumBalanceForRentExemption(
          this.program.account.tickmap.size
        ),
        programId: this.program.programId
      })
    ).add(createIx);
    return {
      transaction,
      signers: [bitmapKeypair, tokenXReserve, tokenYReserve]
    };
  }
  async getProgramAuthority() {
    const [programAuthority, nonce] = await _web3js.PublicKey.findProgramAddress(
      [Buffer.from(SEED)],
      this.program.programId
    );
    return {
      programAuthority,
      nonce
    };
  }
  async getFeeTier(feeTier) {
    const { address } = await this.getFeeTierAddress(feeTier);
    return await this.program.account.feeTier.fetch(address);
  }
  async getPool(pair) {
    const address = await pair.getAddress(this.program.programId);
    return await this.program.account.pool.fetch(address);
  }
  async getPoolByAddress(address) {
    return await this.program.account.pool.fetch(address);
  }
  async onPoolChange(tokenX, tokenY, feeTier, fn) {
    const poolAddress = await new Pair(tokenX, tokenY, feeTier).getAddress(this.program.programId);
    this.program.account.pool.subscribe(poolAddress, "singleGossip").on("change", (poolStructure) => {
      fn(poolStructure);
    });
  }
  async onTickChange(pair, index, fn) {
    const { tickAddress } = await this.getTickAddress(pair, index);
    this.program.account.tick.subscribe(tickAddress, "singleGossip").on("change", (poolStructure) => {
      fn(poolStructure);
    });
  }
  async unsubscribeTick(pair, index) {
    const { tickAddress } = await this.getTickAddress(pair, index);
    return await this.program.account.tick.unsubscribe(tickAddress);
  }
  async onTickmapChange(tickmap, fn) {
    this.program.account.tickmap.subscribe(tickmap, "singleGossip").on("change", (tickmapStructure) => {
      fn(tickmapStructure);
    });
  }
  async getFeeTierAddress(feeTier) {
    return await getFeeTierAddress(feeTier, this.program.programId);
  }
  async getTickmap(pair) {
    const state = await this.getPool(pair);
    const tickmap = await this.program.account.tickmap.fetch(state.tickmap);
    return tickmap;
  }
  async isInitialized(pair, index) {
    const state = await this.getPool(pair);
    const tickmap = await this.getTickmap(pair);
    return isInitialized(tickmap, index, state.tickSpacing);
  }
  async getTick(pair, index) {
    const { tickAddress } = await this.getTickAddress(pair, index);
    return await this.program.account.tick.fetch(tickAddress);
  }
  async getTickByPool(poolAddress, index) {
    const { tickAddress } = await this.getTickAddressByPool(poolAddress, index);
    return await this.program.account.tick.fetch(tickAddress);
  }
  async getClosestTicks(pair, limit, maxRange, oneWay) {
    const state = await this.getPool(pair);
    const tickmap = await this.getTickmap(pair);
    const indexes = findClosestTicks(
      tickmap.bitmap,
      state.currentTickIndex,
      state.tickSpacing,
      limit,
      maxRange,
      oneWay
    );
    const ticksArray = (await Promise.all(indexes.map((index) => this.getTickAddress(pair, index)))).map((a) => a.tickAddress);
    return await this.program.account.tick.fetchMultiple(ticksArray);
  }
  async getAllTicks(pair) {
    const poolPublicKey = await pair.getAddress(this.program.programId);
    return (await this.program.account.tick.all([
      {
        memcmp: { bytes: _bytes.bs58.encode(poolPublicKey.toBuffer()), offset: 8 }
      }
    ])).map((a) => a.account);
  }
  async getAllPoolLiquidityInTokens(poolAddress) {
    return (await this.program.account.position.all()).map(({ account }) => account).filter((account) => account.pool.equals(poolAddress)).reduce(
      (tokens, { liquidity, lowerTickIndex, upperTickIndex }) => tokens.add(getTokens(liquidity.v, lowerTickIndex, upperTickIndex)),
      new (0, _anchor.BN)(0)
    );
  }
  async getActiveLiquidityInTokens(poolAddress, currentTickIndex) {
    return (await this.program.account.position.all()).map(({ account }) => account).filter((account) => account.pool.equals(poolAddress)).filter((account) => isActive(account.lowerTickIndex, account.upperTickIndex, currentTickIndex)).reduce(
      (tokens, { liquidity, lowerTickIndex, upperTickIndex }) => tokens.add(getTokens(liquidity.v, lowerTickIndex, upperTickIndex)),
      new (0, _anchor.BN)(0)
    );
  }
  async getAllPositions(owner) {
    return (await this.program.account.position.all()).map(({ account }) => account);
  }
  async getAllUserPositions(owner) {
    const positionStructs = [];
    const positions = (await this.program.account.position.all([
      {
        memcmp: { bytes: _bytes.bs58.encode(owner.toBuffer()), offset: 8 }
      }
    ])).map(({ account }) => account);
    for (const position of positions) {
      const {
        pool: poolAddress,
        lowerTickIndex,
        upperTickIndex,
        tokensOwedX,
        tokensOwedY,
        liquidity,
        feeGrowthInsideX,
        feeGrowthInsideY
      } = position;
      const {
        fee,
        tickSpacing,
        tokenX,
        tokenY,
        currentTickIndex,
        feeGrowthGlobalX,
        feeGrowthGlobalY
      } = await this.getPoolByAddress(poolAddress);
      const tokenData = await getTokensData();
      const dataTokenX = tokenData[tokenX.toString()];
      const dataTokenY = tokenData[tokenY.toString()];
      const decimalDiff = dataTokenX.decimals - dataTokenY.decimals;
      const currentSqrtPrice = calculatePriceSqrt(currentTickIndex);
      const lowerSqrtPrice = calculatePriceSqrt(lowerTickIndex);
      const upperSqrtPrice = calculatePriceSqrt(upperTickIndex);
      const lowerPrice = getPrice(lowerSqrtPrice, decimalDiff);
      const upperPrice = getPrice(upperSqrtPrice, decimalDiff);
      const feeTier = { fee: fee.v, tickSpacing };
      const amountTokenX = getX(
        liquidity.v,
        upperSqrtPrice.v,
        currentSqrtPrice.v,
        lowerSqrtPrice.v
      );
      const amountTokenY = getY(
        liquidity.v,
        upperSqrtPrice.v,
        currentSqrtPrice.v,
        lowerSqrtPrice.v
      );
      const positionData = {
        liquidity,
        feeGrowthInsideX,
        feeGrowthInsideY,
        tokensOwedX,
        tokensOwedY
      };
      const claim = {
        position: positionData,
        tickLower: await this.getTickByPool(poolAddress, lowerTickIndex),
        tickUpper: await this.getTickByPool(poolAddress, upperTickIndex),
        tickCurrent: currentTickIndex,
        feeGrowthGlobalX,
        feeGrowthGlobalY
      };
      const [unclaimedFeesX, unclaimedFeesY] = calculateClaimAmount(claim);
      const positionStruct = {
        tokenX,
        tokenY,
        feeTier,
        amountTokenX,
        amountTokenY,
        lowerPrice,
        upperPrice,
        unclaimedFeesX,
        unclaimedFeesY
      };
      positionStructs.push(positionStruct);
    }
    return positionStructs;
  }
  async getLiquidityOnTicks(pair) {
    const ticks = await this.getClosestTicks(pair, Infinity);
    return parseLiquidityOnTicks(ticks);
  }
  async getPositionList(owner) {
    const { positionListAddress } = await this.getPositionListAddress(owner);
    return await this.program.account.positionList.fetch(positionListAddress);
  }
  async getPosition(owner, index) {
    const { positionAddress } = await this.getPositionAddress(owner, index);
    return await this.program.account.position.fetch(positionAddress);
  }
  async getPositionsFromIndexes(owner, indexes) {
    const positionPromises = indexes.map(async (i) => {
      return await this.getPosition(owner, i);
    });
    return await Promise.all(positionPromises);
  }
  async getPositionsFromRange(owner, lowerIndex, upperIndex) {
    try {
      await this.getPositionList(owner);
      return await this.getPositionsFromIndexes(
        owner,
        Array.from({ length: upperIndex - lowerIndex + 1 }, (_, i) => i + lowerIndex)
      );
    } catch (e) {
      return [];
    }
  }
  async getTickAddress(pair, index) {
    const poolAddress = await pair.getAddress(this.program.programId);
    const indexBuffer = Buffer.alloc(4);
    indexBuffer.writeInt32LE(index);
    const [tickAddress, tickBump] = await _web3js.PublicKey.findProgramAddress(
      [Buffer.from(_anchor.utils.bytes.utf8.encode(TICK_SEED)), poolAddress.toBuffer(), indexBuffer],
      this.program.programId
    );
    return {
      tickAddress,
      tickBump
    };
  }
  async getTickAddressByPool(poolAddress, index) {
    const indexBuffer = Buffer.alloc(4);
    indexBuffer.writeInt32LE(index);
    const [tickAddress, tickBump] = await _web3js.PublicKey.findProgramAddress(
      [Buffer.from(_anchor.utils.bytes.utf8.encode(TICK_SEED)), poolAddress.toBuffer(), indexBuffer],
      this.program.programId
    );
    return {
      tickAddress,
      tickBump
    };
  }
  async getPositionListAddress(owner) {
    const [positionListAddress, positionListBump] = await _web3js.PublicKey.findProgramAddress(
      [Buffer.from(_anchor.utils.bytes.utf8.encode(POSITION_LIST_SEED)), owner.toBuffer()],
      this.program.programId
    );
    return {
      positionListAddress,
      positionListBump
    };
  }
  async getPositionAddress(owner, index) {
    const indexBuffer = Buffer.alloc(4);
    indexBuffer.writeInt32LE(index);
    const [positionAddress, positionBump] = await _web3js.PublicKey.findProgramAddress(
      [Buffer.from(_anchor.utils.bytes.utf8.encode(POSITION_SEED)), owner.toBuffer(), indexBuffer],
      this.program.programId
    );
    return {
      positionAddress,
      positionBump
    };
  }
  async getNewPositionAddress(owner) {
    const positionList = await this.getPositionList(owner);
    return await this.getPositionAddress(owner, positionList.head);
  }
  async getPositionsForPool(pool) {
    return (await this.program.account.position.all([
      {
        memcmp: { bytes: _bytes.bs58.encode(pool.toBuffer()), offset: 40 }
      }
    ])).map(({ account, publicKey }) => ({
      ...account,
      address: publicKey
    }));
  }
  async createFeeTierInstruction({ feeTier, admin }) {
    admin = _nullishCoalesce(admin, () => ( this.wallet.publicKey));
    const { fee, tickSpacing } = feeTier;
    const { address } = await this.getFeeTierAddress(feeTier);
    const ts = _nullishCoalesce(tickSpacing, () => ( feeToTickSpacing(fee)));
    return this.program.instruction.createFeeTier(fee, ts, {
      accounts: {
        state: this.stateAddress,
        feeTier: address,
        admin,
        rent: _web3js.SYSVAR_RENT_PUBKEY,
        systemProgram: _web3js.SystemProgram.programId
      }
    });
  }
  async createFeeTierTransaction(createFeeTier) {
    const ix = await this.createFeeTierInstruction(createFeeTier);
    return new (0, _web3js.Transaction)().add(ix);
  }
  async createFeeTier(createFeeTier, signer) {
    const tx = await this.createFeeTierTransaction(createFeeTier);
    await signAndSend(tx, [signer], this.connection);
  }
  async createStateInstruction(admin) {
    admin = _nullishCoalesce(admin, () => ( this.wallet.publicKey));
    const { programAuthority, nonce } = await this.getProgramAuthority();
    const { address } = await this.getStateAddress();
    return this.program.instruction.createState(nonce, {
      accounts: {
        state: address,
        admin,
        programAuthority,
        rent: _web3js.SYSVAR_RENT_PUBKEY,
        systemProgram: _web3js.SystemProgram.programId
      }
    });
  }
  async createStateTransaction(admin) {
    const ix = await this.createStateInstruction(admin);
    return new (0, _web3js.Transaction)().add(ix);
  }
  async createState(admin, signer) {
    const tx = await this.createStateTransaction(admin);
    await signAndSend(tx, [signer], this.connection);
  }
  async getStateAddress() {
    const [address, bump] = await _web3js.PublicKey.findProgramAddress(
      [Buffer.from(_anchor.utils.bytes.utf8.encode(STATE_SEED))],
      this.program.programId
    );
    return {
      address,
      bump
    };
  }
  async getState() {
    const address = (await this.getStateAddress()).address;
    return await this.program.account.state.fetch(address);
  }
  async createTickInstruction({ pair, index, payer }) {
    payer = _nullishCoalesce(payer, () => ( this.wallet.publicKey));
    const state = await this.getPool(pair);
    const { tickAddress } = await this.getTickAddress(pair, index);
    return this.program.instruction.createTick(index, {
      accounts: {
        tick: tickAddress,
        pool: await pair.getAddress(this.program.programId),
        tickmap: state.tickmap,
        payer,
        tokenX: state.tokenX,
        tokenY: state.tokenY,
        rent: _web3js.SYSVAR_RENT_PUBKEY,
        systemProgram: _web3js.SystemProgram.programId
      }
    });
  }
  async createTickTransaction(createTick) {
    const ix = await this.createTickInstruction(createTick);
    return new (0, _web3js.Transaction)().add(ix);
  }
  async createTick(createTick, signer) {
    const tx = await this.createTickTransaction(createTick);
    await signAndSend(tx, [signer], this.connection);
  }
  async createPositionListInstruction(owner) {
    owner = _nullishCoalesce(owner, () => ( this.wallet.publicKey));
    const { positionListAddress } = await this.getPositionListAddress(owner);
    return this.program.instruction.createPositionList({
      accounts: {
        positionList: positionListAddress,
        owner,
        signer: owner,
        rent: _web3js.SYSVAR_RENT_PUBKEY,
        systemProgram: _web3js.SystemProgram.programId
      }
    });
  }
  async createPositionListTransaction(owner) {
    const ix = await this.createPositionListInstruction(owner);
    return new (0, _web3js.Transaction)().add(ix);
  }
  async createPositionList(owner, signer) {
    const tx = await this.createPositionListTransaction(owner);
    await signAndSend(tx, [signer], this.connection);
  }
  async initPositionInstruction({
    pair,
    owner,
    userTokenX,
    userTokenY,
    lowerTick,
    upperTick,
    liquidityDelta,
    knownPrice,
    slippage
  }, assumeFirstPosition = false) {
    const state = await this.getPool(pair);
    owner = _nullishCoalesce(owner, () => ( this.wallet.publicKey));
    const slippageLimitLower = calculatePriceAfterSlippage(knownPrice, slippage, false);
    const slippageLimitUpper = calculatePriceAfterSlippage(knownPrice, slippage, true);
    const upperTickIndex = upperTick !== Infinity ? upperTick : getMaxTick(pair.tickSpacing);
    const lowerTickIndex = lowerTick !== -Infinity ? lowerTick : getMinTick(pair.tickSpacing);
    const { tickAddress: lowerTickAddress } = await this.getTickAddress(pair, lowerTickIndex);
    const { tickAddress: upperTickAddress } = await this.getTickAddress(pair, upperTickIndex);
    const { positionAddress } = await this.getPositionAddress(
      owner,
      assumeFirstPosition ? 0 : (await this.getPositionList(owner)).head
    );
    const { positionListAddress } = await this.getPositionListAddress(owner);
    const poolAddress = await pair.getAddress(this.program.programId);
    return this.program.instruction.createPosition(
      lowerTickIndex,
      upperTickIndex,
      liquidityDelta,
      slippageLimitLower,
      slippageLimitUpper,
      {
        accounts: {
          state: this.stateAddress,
          pool: poolAddress,
          positionList: positionListAddress,
          position: positionAddress,
          tickmap: state.tickmap,
          owner,
          payer: owner,
          lowerTick: lowerTickAddress,
          upperTick: upperTickAddress,
          tokenX: pair.tokenX,
          tokenY: pair.tokenY,
          accountX: userTokenX,
          accountY: userTokenY,
          reserveX: state.tokenXReserve,
          reserveY: state.tokenYReserve,
          programAuthority: this.programAuthority,
          tokenProgram: _spltoken.TOKEN_PROGRAM_ID,
          rent: _web3js.SYSVAR_RENT_PUBKEY,
          systemProgram: _web3js.SystemProgram.programId
        }
      }
    );
  }
  async initPositionTx(initPosition) {
    const { pair, lowerTick: lowerIndex, upperTick: upperIndex } = initPosition;
    const payer = _nullishCoalesce(initPosition.owner, () => ( this.wallet.publicKey));
    const lowerTick = lowerIndex === -Infinity ? getMinTick(pair.tickSpacing) : lowerIndex;
    const upperTick = upperIndex === Infinity ? getMaxTick(pair.tickSpacing) : upperIndex;
    let lowerInstruction;
    let upperInstruction;
    let listInstruction;
    let positionInstruction;
    const tx = new (0, _web3js.Transaction)();
    let lowerExists = true;
    try {
      await this.getTick(pair, lowerTick);
    } catch (e) {
      lowerExists = false;
      lowerInstruction = await this.createTickInstruction({ pair, index: lowerTick, payer });
    }
    let upperExists = true;
    try {
      await this.getTick(pair, upperTick);
    } catch (e) {
      upperExists = false;
      upperInstruction = await this.createTickInstruction({ pair, index: upperTick, payer });
    }
    const { positionListAddress } = await this.getPositionListAddress(payer);
    const account = await this.connection.getAccountInfo(positionListAddress);
    let listExists = true;
    if (account === null) {
      listExists = false;
      listInstruction = await this.createPositionListInstruction(payer);
      positionInstruction = await this.initPositionInstruction(initPosition, true);
    } else {
      positionInstruction = await this.initPositionInstruction(initPosition, false);
    }
    if (!lowerExists && lowerInstruction) {
      tx.add(lowerInstruction);
    }
    if (!upperExists && upperInstruction) {
      tx.add(upperInstruction);
    }
    if (!listExists && listInstruction) {
      tx.add(listInstruction);
    }
    return tx.add(positionInstruction);
  }
  async initPosition(initPosition, signer) {
    const tx = await this.initPositionTx(initPosition);
    await signAndSend(tx, [signer], this.connection);
  }
  async initPoolAndPositionTx({
    pair,
    owner,
    userTokenX,
    userTokenY,
    lowerTick,
    upperTick,
    liquidityDelta,
    initTick,
    knownPrice,
    slippage
  }, payer) {
    const payerPubkey = _nullishCoalesce((payer == null ? void 0 : payer.publicKey), () => ( this.wallet.publicKey));
    const bitmapKeypair = _web3js.Keypair.generate();
    const tokenXReserve = _web3js.Keypair.generate();
    const tokenYReserve = _web3js.Keypair.generate();
    const tick = _nullishCoalesce(initTick, () => ( 0));
    const setCuIx = computeUnitsInstruction(14e5, payerPubkey);
    const { address: stateAddress } = await this.getStateAddress();
    const [poolAddress] = await pair.getAddressAndBump(this.program.programId);
    const { address: feeTierAddress } = await this.getFeeTierAddress(pair.feeTier);
    const { positionListAddress } = await this.getPositionListAddress(payerPubkey);
    const { tickAddress } = await this.getTickAddress(pair, lowerTick);
    const { tickAddress: tickAddressUpper } = await this.getTickAddress(pair, upperTick);
    const listExists = await this.connection.getAccountInfo(positionListAddress) !== null;
    const head = listExists ? (await this.getPositionList(payerPubkey)).head : 0;
    const { positionAddress } = await this.getPositionAddress(payerPubkey, head);
    const transaction = new (0, _web3js.Transaction)({
      feePayer: payerPubkey
    });
    transaction.add(setCuIx).add(
      _web3js.SystemProgram.createAccount({
        fromPubkey: payerPubkey,
        newAccountPubkey: bitmapKeypair.publicKey,
        space: this.program.account.tickmap.size,
        lamports: await this.connection.getMinimumBalanceForRentExemption(
          this.program.account.tickmap.size
        ),
        programId: this.program.programId
      })
    ).add(
      this.program.instruction.createPool(tick, {
        accounts: {
          state: stateAddress,
          pool: poolAddress,
          feeTier: feeTierAddress,
          tickmap: bitmapKeypair.publicKey,
          tokenX: pair.tokenX,
          tokenY: pair.tokenY,
          tokenXReserve: tokenXReserve.publicKey,
          tokenYReserve: tokenYReserve.publicKey,
          authority: this.programAuthority,
          tokenProgram: _spltoken.TOKEN_PROGRAM_ID,
          payer: payerPubkey,
          rent: _web3js.SYSVAR_RENT_PUBKEY,
          systemProgram: _web3js.SystemProgram.programId
        }
      })
    ).add(
      this.program.instruction.createTick(lowerTick, {
        accounts: {
          tick: tickAddress,
          pool: poolAddress,
          tickmap: bitmapKeypair.publicKey,
          payer: payerPubkey,
          tokenX: pair.tokenX,
          tokenY: pair.tokenY,
          rent: _web3js.SYSVAR_RENT_PUBKEY,
          systemProgram: _web3js.SystemProgram.programId
        }
      })
    ).add(
      this.program.instruction.createTick(upperTick, {
        accounts: {
          tick: tickAddressUpper,
          pool: poolAddress,
          tickmap: bitmapKeypair.publicKey,
          payer: payerPubkey,
          tokenX: pair.tokenX,
          tokenY: pair.tokenY,
          rent: _web3js.SYSVAR_RENT_PUBKEY,
          systemProgram: _web3js.SystemProgram.programId
        }
      })
    );
    if (!listExists)
      transaction.add(await this.createPositionListInstruction(payerPubkey));
    const slippageLimitLower = calculatePriceAfterSlippage(knownPrice, slippage, false);
    const slippageLimitUpper = calculatePriceAfterSlippage(knownPrice, slippage, true);
    transaction.add(
      this.program.instruction.createPosition(
        lowerTick,
        upperTick,
        liquidityDelta,
        slippageLimitLower,
        slippageLimitUpper,
        {
          accounts: {
            state: this.stateAddress,
            pool: poolAddress,
            positionList: positionListAddress,
            position: positionAddress,
            tickmap: bitmapKeypair.publicKey,
            owner: payerPubkey,
            payer: payerPubkey,
            lowerTick: tickAddress,
            upperTick: tickAddressUpper,
            tokenX: pair.tokenX,
            tokenY: pair.tokenY,
            accountX: userTokenX,
            accountY: userTokenY,
            reserveX: tokenXReserve.publicKey,
            reserveY: tokenYReserve.publicKey,
            programAuthority: this.programAuthority,
            tokenProgram: _spltoken.TOKEN_PROGRAM_ID,
            rent: _web3js.SYSVAR_RENT_PUBKEY,
            systemProgram: _web3js.SystemProgram.programId
          }
        }
      )
    );
    return {
      transaction,
      signers: [bitmapKeypair, tokenXReserve, tokenYReserve]
    };
  }
  async initPoolAndPosition(createPool, signer) {
    const { transaction, signers } = await this.initPoolAndPositionTx(createPool, signer);
    await signAndSend(transaction, [signer, ...signers], this.connection);
  }
  async swapInstruction(swap) {
    const {
      pair,
      xToY,
      amount,
      estimatedPriceAfterSwap,
      slippage,
      accountX,
      accountY,
      byAmountIn,
      referralAccount
    } = swap;
    const owner = _nullishCoalesce(swap.owner, () => ( this.wallet.publicKey));
    const [pool, tickmap, poolAddress] = await Promise.all([
      this.getPool(pair),
      this.getTickmap(pair),
      pair.getAddress(this.program.programId)
    ]);
    const priceLimit = calculatePriceAfterSlippage(estimatedPriceAfterSwap, slippage, !xToY).v;
    const indexesInDirection = findClosestTicks(
      tickmap.bitmap,
      pool.currentTickIndex,
      pool.tickSpacing,
      referralAccount ? TICK_CROSSES_PER_IX - 1 : TICK_CROSSES_PER_IX,
      Infinity,
      xToY ? "down" : "up"
    );
    const indexesInReverse = findClosestTicks(
      tickmap.bitmap,
      pool.currentTickIndex,
      pool.tickSpacing,
      1,
      Infinity,
      xToY ? "up" : "down"
    );
    const remainingAccounts = await Promise.all(
      indexesInDirection.concat(indexesInReverse).map(async (index) => {
        const { tickAddress } = await this.getTickAddress(pair, index);
        return tickAddress;
      })
    );
    if (referralAccount) {
      remainingAccounts.unshift(referralAccount);
    }
    const ra = remainingAccounts.map((pubkey) => {
      return { pubkey, isWritable: true, isSigner: false };
    });
    const tx = new (0, _web3js.Transaction)();
    const swapIx = this.program.instruction.swap(xToY, amount, byAmountIn, priceLimit, {
      remainingAccounts: ra,
      accounts: {
        state: this.stateAddress,
        pool: poolAddress,
        tickmap: pool.tickmap,
        reserveX: pool.tokenXReserve,
        reserveY: pool.tokenYReserve,
        owner,
        accountX,
        accountY,
        programAuthority: this.programAuthority,
        tokenProgram: _spltoken.TOKEN_PROGRAM_ID
      }
    });
    tx.add(swapIx);
    return tx;
  }
  async swapTransaction(swap) {
    const setCuIx = computeUnitsInstruction(14e5, _nullishCoalesce(swap.owner, () => ( this.wallet.publicKey)));
    const swapIx = await this.swapInstruction(swap);
    return new (0, _web3js.Transaction)().add(setCuIx).add(swapIx);
  }
  async swap(swap, signer) {
    const tx = await this.swapTransaction(swap);
    return await signAndSend(tx, [signer], this.connection);
  }
  async getReserveBalances(pair, tokenX, tokenY) {
    const state = await this.getPool(pair);
    const accounts = await Promise.all([
      tokenX.getAccountInfo(state.tokenXReserve),
      tokenY.getAccountInfo(state.tokenYReserve)
    ]);
    return { x: accounts[0].amount, y: accounts[1].amount };
  }
  async claimFeeInstruction(claimFee) {
    const { pair, userTokenX, userTokenY, index } = claimFee;
    const owner = _nullishCoalesce(claimFee.owner, () => ( this.wallet.publicKey));
    const state = await this.getPool(pair);
    const { positionAddress } = await this.getPositionAddress(owner, index);
    const position = await this.getPosition(owner, index);
    const { tickAddress: lowerTickAddress } = await this.getTickAddress(
      pair,
      position.lowerTickIndex
    );
    const { tickAddress: upperTickAddress } = await this.getTickAddress(
      pair,
      position.upperTickIndex
    );
    return this.program.instruction.claimFee(
      index,
      position.lowerTickIndex,
      position.upperTickIndex,
      {
        accounts: {
          state: this.stateAddress,
          pool: await pair.getAddress(this.program.programId),
          position: positionAddress,
          lowerTick: lowerTickAddress,
          upperTick: upperTickAddress,
          owner,
          tokenX: pair.tokenX,
          tokenY: pair.tokenY,
          accountX: userTokenX,
          accountY: userTokenY,
          reserveX: state.tokenXReserve,
          reserveY: state.tokenYReserve,
          programAuthority: this.programAuthority,
          tokenProgram: _spltoken.TOKEN_PROGRAM_ID
        }
      }
    );
  }
  async claimFeeTransaction(claimFee) {
    const ix = await this.claimFeeInstruction(claimFee);
    return new (0, _web3js.Transaction)().add(ix);
  }
  async claimFee(claimFee, signer) {
    const tx = await this.claimFeeTransaction(claimFee);
    await signAndSend(tx, [signer], this.connection);
  }
  async withdrawProtocolFeeInstruction(withdrawProtocolFee) {
    const { pair, accountX, accountY } = withdrawProtocolFee;
    const admin = _nullishCoalesce(withdrawProtocolFee.admin, () => ( this.wallet.publicKey));
    const pool = await this.getPool(pair);
    return this.program.instruction.withdrawProtocolFee({
      accounts: {
        state: this.stateAddress,
        pool: await pair.getAddress(this.program.programId),
        tokenX: pool.tokenX,
        tokenY: pool.tokenY,
        reserveX: pool.tokenXReserve,
        reserveY: pool.tokenYReserve,
        accountX,
        accountY,
        authority: admin,
        programAuthority: this.programAuthority,
        tokenProgram: _spltoken.TOKEN_PROGRAM_ID
      }
    });
  }
  async withdrawProtocolFeeTransaction(withdrawProtocolFee) {
    const ix = await this.withdrawProtocolFeeInstruction(withdrawProtocolFee);
    return new (0, _web3js.Transaction)().add(ix);
  }
  async withdrawProtocolFee(withdrawProtocolFee, signer) {
    const tx = await this.withdrawProtocolFeeTransaction(withdrawProtocolFee);
    await signAndSend(tx, [signer], this.connection);
  }
  async removePositionInstruction(removePosition) {
    const { pair, index, userTokenX, userTokenY } = removePosition;
    const owner = _nullishCoalesce(removePosition.owner, () => ( this.wallet.publicKey));
    const positionList = await this.getPositionList(owner);
    const { positionListAddress } = await this.getPositionListAddress(owner);
    const { positionAddress: removedPositionAddress } = await this.getPositionAddress(owner, index);
    const { positionAddress: lastPositionAddress } = await this.getPositionAddress(
      owner,
      positionList.head - 1
    );
    const state = await this.getPool(pair);
    const position = await this.getPosition(owner, index);
    const { tickAddress: lowerTickAddress } = await this.getTickAddress(
      pair,
      position.lowerTickIndex
    );
    const { tickAddress: upperTickAddress } = await this.getTickAddress(
      pair,
      position.upperTickIndex
    );
    return this.program.instruction.removePosition(
      index,
      position.lowerTickIndex,
      position.upperTickIndex,
      {
        accounts: {
          state: this.stateAddress,
          owner,
          removedPosition: removedPositionAddress,
          positionList: positionListAddress,
          lastPosition: lastPositionAddress,
          pool: await pair.getAddress(this.program.programId),
          tickmap: state.tickmap,
          lowerTick: lowerTickAddress,
          upperTick: upperTickAddress,
          tokenX: pair.tokenX,
          tokenY: pair.tokenY,
          accountX: userTokenX,
          accountY: userTokenY,
          reserveX: state.tokenXReserve,
          reserveY: state.tokenYReserve,
          programAuthority: this.programAuthority,
          tokenProgram: _spltoken.TOKEN_PROGRAM_ID
        }
      }
    );
  }
  async removePositionTransaction(removePosition) {
    const ix = await this.removePositionInstruction(removePosition);
    return new (0, _web3js.Transaction)().add(ix);
  }
  async removePosition(removePosition, signer) {
    const tx = await this.removePositionTransaction(removePosition);
    await signAndSend(tx, [signer], this.connection);
  }
  async transferPositionOwnershipInstruction(transferPositionOwnership) {
    const { index } = transferPositionOwnership;
    const owner = _nullishCoalesce(transferPositionOwnership.owner, () => ( this.wallet.publicKey));
    const recipient = _nullishCoalesce(transferPositionOwnership.recipient, () => ( this.wallet.publicKey));
    const { positionListAddress: ownerList } = await this.getPositionListAddress(owner);
    const { positionListAddress: recipientList } = await this.getPositionListAddress(recipient);
    const ownerPositionList = await this.getPositionList(owner);
    const { positionAddress: removedPosition } = await this.getPositionAddress(owner, index);
    const { positionAddress: lastPosition } = await this.getPositionAddress(
      owner,
      ownerPositionList.head - 1
    );
    const { positionAddress: newPosition } = await this.getNewPositionAddress(recipient);
    return this.program.instruction.transferPositionOwnership(index, {
      accounts: {
        owner,
        recipient,
        ownerList,
        recipientList,
        lastPosition,
        removedPosition,
        newPosition,
        rent: _web3js.SYSVAR_RENT_PUBKEY,
        systemProgram: _web3js.SystemProgram.programId
      }
    });
  }
  async transferPositionOwnershipTransaction(transferPositionOwnership) {
    const ix = await this.transferPositionOwnershipInstruction(transferPositionOwnership);
    return new (0, _web3js.Transaction)().add(ix);
  }
  async transferPositionOwnership(transferPositionOwnership, signer) {
    const tx = await this.transferPositionOwnershipTransaction(transferPositionOwnership);
    await signAndSend(tx, [signer], this.connection);
  }
  async updateSecondsPerLiquidityInstruction(updateSecondsPerLiquidity) {
    const { pair, signer, lowerTickIndex, upperTickIndex, index } = updateSecondsPerLiquidity;
    const owner = _nullishCoalesce(updateSecondsPerLiquidity.owner, () => ( this.wallet.publicKey));
    const { tickAddress: lowerTickAddress } = await this.getTickAddress(pair, lowerTickIndex);
    const { tickAddress: upperTickAddress } = await this.getTickAddress(pair, upperTickIndex);
    const poolAddress = await pair.getAddress(this.program.programId);
    const { positionAddress } = await this.getPositionAddress(owner, index);
    return this.program.instruction.updateSecondsPerLiquidity(
      lowerTickIndex,
      upperTickIndex,
      index,
      {
        accounts: {
          pool: poolAddress,
          lowerTick: lowerTickAddress,
          upperTick: upperTickAddress,
          position: positionAddress,
          tokenX: pair.tokenX,
          tokenY: pair.tokenY,
          owner,
          signer: _nullishCoalesce(signer, () => ( owner)),
          rent: _web3js.SYSVAR_RENT_PUBKEY,
          systemProgram: _web3js.SystemProgram.programId
        }
      }
    );
  }
  async updateSecondsPerLiquidityTransaction(updateSecondsPerLiquidity) {
    const ix = await this.updateSecondsPerLiquidityInstruction(updateSecondsPerLiquidity);
    return new (0, _web3js.Transaction)().add(ix);
  }
  async updateSecondsPerLiquidity(updateSecondsPerLiquidity, signer) {
    const tx = await this.updateSecondsPerLiquidityTransaction(updateSecondsPerLiquidity);
    await signAndSend(tx, [signer], this.connection);
  }
  async initializeOracle({ pair, payer }) {
    const oracleKeypair = _web3js.Keypair.generate();
    const poolAddress = await pair.getAddress(this.program.programId);
    return await this.program.rpc.initializeOracle({
      accounts: {
        pool: poolAddress,
        oracle: oracleKeypair.publicKey,
        tokenX: pair.tokenX,
        tokenY: pair.tokenY,
        payer: payer.publicKey,
        rent: _web3js.SYSVAR_RENT_PUBKEY,
        systemProgram: _web3js.SystemProgram.programId
      },
      signers: [payer, oracleKeypair],
      instructions: [await this.program.account.oracle.createInstruction(oracleKeypair)]
    });
  }
  async getOracle(pair) {
    const pool = await this.getPool(pair);
    return await this.program.account.oracle.fetch(pool.oracleAddress);
  }
  async changeProtocolFeeInstruction(changeProtocolFee) {
    let { pair, admin, protocolFee } = changeProtocolFee;
    admin = _nullishCoalesce(admin, () => ( this.wallet.publicKey));
    const { address: stateAddress } = await this.getStateAddress();
    const poolAddress = await pair.getAddress(this.program.programId);
    return this.program.instruction.changeProtocolFee(protocolFee, {
      accounts: {
        state: stateAddress,
        pool: poolAddress,
        tokenX: pair.tokenX,
        tokenY: pair.tokenY,
        admin,
        programAuthority: this.programAuthority
      }
    });
  }
  async changeProtocolFeeTransaction(changeProtocolFee) {
    const ix = await this.changeProtocolFeeInstruction(changeProtocolFee);
    return new (0, _web3js.Transaction)().add(ix);
  }
  async changeProtocolFee(changeProtocolFee, signer) {
    const tx = await this.changeProtocolFeeTransaction(changeProtocolFee);
    await signAndSend(tx, [signer], this.connection);
  }
  async changeFeeReceiverInstruction(changeFeeReceiver) {
    const { pair, feeReceiver } = changeFeeReceiver;
    const adminPubkey = _nullishCoalesce(changeFeeReceiver.admin, () => ( this.wallet.publicKey));
    const { address: stateAddress } = await this.getStateAddress();
    const poolAddress = await pair.getAddress(this.program.programId);
    return this.program.instruction.changeFeeReceiver({
      accounts: {
        state: stateAddress,
        pool: poolAddress,
        tokenX: pair.tokenX,
        tokenY: pair.tokenY,
        admin: adminPubkey,
        feeReceiver
      }
    });
  }
  async changeFeeReceiverTransaction(changeFeeReceiver) {
    const ix = await this.changeFeeReceiverInstruction(changeFeeReceiver);
    return new (0, _web3js.Transaction)().add(ix);
  }
  async changeFeeReceiver(changeFeeReceiver, signer) {
    const tx = await this.changeFeeReceiverTransaction(changeFeeReceiver);
    await signAndSend(tx, [signer], this.connection);
  }
  async getWholeLiquidity(pair) {
    const poolPublicKey = await pair.getAddress(this.program.programId);
    const positions = (await this.program.account.position.all([
      {
        memcmp: { bytes: _bytes.bs58.encode(poolPublicKey.toBuffer()), offset: 40 }
      }
    ])).map((a) => a.account);
    let liquidity = new (0, _anchor.BN)(0);
    for (const position of positions) {
      liquidity = liquidity.add(position.liquidity.v);
    }
    return liquidity;
  }
  async getGlobalFee(pair) {
    const pool = await this.getPool(pair);
    const { feeProtocolTokenX, feeProtocolTokenY, protocolFee } = pool;
    const feeX = feeProtocolTokenX.mul(DENOMINATOR).div(protocolFee.v);
    const feeY = feeProtocolTokenY.mul(DENOMINATOR).div(protocolFee.v);
    return { feeX, feeY };
  }
  async getVolume(pair) {
    const pool = await this.getPool(pair);
    const { feeProtocolTokenX, feeProtocolTokenY, protocolFee, fee } = pool;
    const feeDenominator = protocolFee.v.mul(fee.v).div(DENOMINATOR);
    const volumeX = feeProtocolTokenX.mul(DENOMINATOR).div(feeDenominator);
    const volumeY = feeProtocolTokenY.mul(DENOMINATOR).div(feeDenominator);
    return { volumeX, volumeY };
  }
  async getAllPools() {
    return (await this.program.account.pool.all([])).map(
      ({ account }) => account
    );
  }
  async getPairLiquidityValues(pair) {
    const pool = await this.getPool(pair);
    const poolPublicKey = await pair.getAddress(this.program.programId);
    const positions = (await this.program.account.position.all([
      {
        memcmp: { bytes: _bytes.bs58.encode(poolPublicKey.toBuffer()), offset: 40 }
      }
    ])).map(({ account }) => account);
    let liquidityX = new (0, _anchor.BN)(0);
    let liquidityY = new (0, _anchor.BN)(0);
    for (const position of positions) {
      let xVal, yVal;
      try {
        xVal = getX(
          position.liquidity.v,
          calculatePriceSqrt(position.upperTickIndex).v,
          pool.sqrtPrice.v,
          calculatePriceSqrt(position.lowerTickIndex).v
        );
      } catch (error) {
        xVal = new (0, _anchor.BN)(0);
      }
      try {
        yVal = getY(
          position.liquidity.v,
          calculatePriceSqrt(position.upperTickIndex).v,
          pool.sqrtPrice.v,
          calculatePriceSqrt(position.lowerTickIndex).v
        );
      } catch (error) {
        yVal = new (0, _anchor.BN)(0);
      }
      liquidityX = liquidityX.add(xVal);
      liquidityY = liquidityY.add(yVal);
    }
    return { liquidityX, liquidityY };
  }
};

// src/pair.ts


var POOL_SEED = "poolv1";
var Pair = class {
  constructor(first, second, feeTier) {
    if (first.equals(second)) {
      throw new Error("Pair must contain two unique public keys");
    }
    if (first.toString() < second.toString()) {
      this.tokenX = first;
      this.tokenY = second;
    } else {
      this.tokenX = second;
      this.tokenY = first;
    }
    this.tickSpacing = _nullishCoalesce(feeTier.tickSpacing, () => ( feeToTickSpacing(feeTier.fee)));
    this.feeTier = {
      fee: feeTier.fee,
      tickSpacing: this.tickSpacing
    };
    this.feeTierAddress = null;
    if (this.feeTier.tickSpacing == null) {
      this.feeTier.tickSpacing = feeToTickSpacing(this.feeTier.fee);
    }
  }
  async getAddressAndBump(programId) {
    return await _web3js.PublicKey.findProgramAddress(
      [
        Buffer.from(_anchor.utils.bytes.utf8.encode(POOL_SEED)),
        this.tokenX.toBuffer(),
        this.tokenY.toBuffer(),
        bigNumberToBuffer(this.feeTier.fee, 128),
        bigNumberToBuffer(new (0, _anchor.BN)(this.feeTier.tickSpacing), 16)
      ],
      programId
    );
  }
  async getAddress(programId) {
    return await this.getAddressAndBump(programId).then(([address, _]) => address);
  }
  async getFeeTierAddress(programId) {
    if (this.feeTierAddress == null) {
      const { address: feeTierAddress } = await getFeeTierAddress(this.feeTier, programId);
      this.feeTierAddress = feeTierAddress;
    }
    return this.feeTierAddress;
  }
};



























exports.DENOMINATOR = DENOMINATOR; exports.FEE_TIER = FEE_TIER; exports.IDL = IDL; exports.INVARIANT_ERRORS = INVARIANT_ERRORS; exports.LIQUIDITY_DENOMINATOR = LIQUIDITY_DENOMINATOR; exports.MAX_TICK = MAX_TICK; exports.MIN_TICK = MIN_TICK; exports.MOCK_TOKENS = MOCK_TOKENS; exports.Market = Market2; exports.Network = Network; exports.PRICE_DENOMINATOR = PRICE_DENOMINATOR; exports.Pair = Pair; exports.SEED = SEED; exports.TICK_CROSSES_PER_IX = TICK_CROSSES_PER_IX; exports.TICK_LIMIT = TICK_LIMIT; exports.TICK_SEARCH_RANGE = TICK_SEARCH_RANGE; exports.calculatePriceSqrt = calculatePriceSqrt; exports.computeUnitsInstruction = computeUnitsInstruction; exports.findClosestTicks = findClosestTicks; exports.findTickmapChanges = findTickmapChanges; exports.fromInteger = fromInteger; exports.getMarketAddress = getMarketAddress; exports.signAndSend = signAndSend; exports.simulateSwap = simulateSwap; exports.sleep = sleep; exports.toDecimal = toDecimal;
//# sourceMappingURL=index.js.map