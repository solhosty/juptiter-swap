var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};

// src/index.ts
import Decimal3 from "decimal.js";

// src/context.ts
import { AnchorProvider, Program } from "@project-serum/anchor";

// src/artifacts/whirlpool.json
var whirlpool_exports = {};
__export(whirlpool_exports, {
  accounts: () => accounts,
  default: () => whirlpool_default,
  errors: () => errors,
  instructions: () => instructions,
  name: () => name,
  types: () => types,
  version: () => version
});
var version = "0.1.0";
var name = "whirlpool";
var instructions = [
  {
    name: "initializeConfig",
    accounts: [
      {
        name: "config",
        isMut: true,
        isSigner: true
      },
      {
        name: "funder",
        isMut: true,
        isSigner: true
      },
      {
        name: "systemProgram",
        isMut: false,
        isSigner: false
      }
    ],
    args: [
      {
        name: "feeAuthority",
        type: "publicKey"
      },
      {
        name: "collectProtocolFeesAuthority",
        type: "publicKey"
      },
      {
        name: "rewardEmissionsSuperAuthority",
        type: "publicKey"
      },
      {
        name: "defaultProtocolFeeRate",
        type: "u16"
      }
    ]
  },
  {
    name: "initializePool",
    accounts: [
      {
        name: "whirlpoolsConfig",
        isMut: false,
        isSigner: false
      },
      {
        name: "tokenMintA",
        isMut: false,
        isSigner: false
      },
      {
        name: "tokenMintB",
        isMut: false,
        isSigner: false
      },
      {
        name: "funder",
        isMut: true,
        isSigner: true
      },
      {
        name: "whirlpool",
        isMut: true,
        isSigner: false
      },
      {
        name: "tokenVaultA",
        isMut: true,
        isSigner: true
      },
      {
        name: "tokenVaultB",
        isMut: true,
        isSigner: true
      },
      {
        name: "feeTier",
        isMut: false,
        isSigner: false
      },
      {
        name: "tokenProgram",
        isMut: false,
        isSigner: false
      },
      {
        name: "systemProgram",
        isMut: false,
        isSigner: false
      },
      {
        name: "rent",
        isMut: false,
        isSigner: false
      }
    ],
    args: [
      {
        name: "bumps",
        type: {
          defined: "WhirlpoolBumps"
        }
      },
      {
        name: "tickSpacing",
        type: "u16"
      },
      {
        name: "initialSqrtPrice",
        type: "u128"
      }
    ]
  },
  {
    name: "initializeTickArray",
    accounts: [
      {
        name: "whirlpool",
        isMut: false,
        isSigner: false
      },
      {
        name: "funder",
        isMut: true,
        isSigner: true
      },
      {
        name: "tickArray",
        isMut: true,
        isSigner: false
      },
      {
        name: "systemProgram",
        isMut: false,
        isSigner: false
      }
    ],
    args: [
      {
        name: "startTickIndex",
        type: "i32"
      }
    ]
  },
  {
    name: "initializeFeeTier",
    accounts: [
      {
        name: "config",
        isMut: false,
        isSigner: false
      },
      {
        name: "feeTier",
        isMut: true,
        isSigner: false
      },
      {
        name: "funder",
        isMut: true,
        isSigner: true
      },
      {
        name: "feeAuthority",
        isMut: false,
        isSigner: true
      },
      {
        name: "systemProgram",
        isMut: false,
        isSigner: false
      }
    ],
    args: [
      {
        name: "tickSpacing",
        type: "u16"
      },
      {
        name: "defaultFeeRate",
        type: "u16"
      }
    ]
  },
  {
    name: "initializeReward",
    accounts: [
      {
        name: "rewardAuthority",
        isMut: false,
        isSigner: true
      },
      {
        name: "funder",
        isMut: true,
        isSigner: true
      },
      {
        name: "whirlpool",
        isMut: true,
        isSigner: false
      },
      {
        name: "rewardMint",
        isMut: false,
        isSigner: false
      },
      {
        name: "rewardVault",
        isMut: true,
        isSigner: true
      },
      {
        name: "tokenProgram",
        isMut: false,
        isSigner: false
      },
      {
        name: "systemProgram",
        isMut: false,
        isSigner: false
      },
      {
        name: "rent",
        isMut: false,
        isSigner: false
      }
    ],
    args: [
      {
        name: "rewardIndex",
        type: "u8"
      }
    ]
  },
  {
    name: "setRewardEmissions",
    accounts: [
      {
        name: "whirlpool",
        isMut: true,
        isSigner: false
      },
      {
        name: "rewardAuthority",
        isMut: false,
        isSigner: true
      },
      {
        name: "rewardVault",
        isMut: false,
        isSigner: false
      }
    ],
    args: [
      {
        name: "rewardIndex",
        type: "u8"
      },
      {
        name: "emissionsPerSecondX64",
        type: "u128"
      }
    ]
  },
  {
    name: "openPosition",
    accounts: [
      {
        name: "funder",
        isMut: true,
        isSigner: true
      },
      {
        name: "owner",
        isMut: false,
        isSigner: false
      },
      {
        name: "position",
        isMut: true,
        isSigner: false
      },
      {
        name: "positionMint",
        isMut: true,
        isSigner: true
      },
      {
        name: "positionTokenAccount",
        isMut: true,
        isSigner: false
      },
      {
        name: "whirlpool",
        isMut: false,
        isSigner: false
      },
      {
        name: "tokenProgram",
        isMut: false,
        isSigner: false
      },
      {
        name: "systemProgram",
        isMut: false,
        isSigner: false
      },
      {
        name: "rent",
        isMut: false,
        isSigner: false
      },
      {
        name: "associatedTokenProgram",
        isMut: false,
        isSigner: false
      }
    ],
    args: [
      {
        name: "bumps",
        type: {
          defined: "OpenPositionBumps"
        }
      },
      {
        name: "tickLowerIndex",
        type: "i32"
      },
      {
        name: "tickUpperIndex",
        type: "i32"
      }
    ]
  },
  {
    name: "openPositionWithMetadata",
    accounts: [
      {
        name: "funder",
        isMut: true,
        isSigner: true
      },
      {
        name: "owner",
        isMut: false,
        isSigner: false
      },
      {
        name: "position",
        isMut: true,
        isSigner: false
      },
      {
        name: "positionMint",
        isMut: true,
        isSigner: true
      },
      {
        name: "positionMetadataAccount",
        isMut: true,
        isSigner: false
      },
      {
        name: "positionTokenAccount",
        isMut: true,
        isSigner: false
      },
      {
        name: "whirlpool",
        isMut: false,
        isSigner: false
      },
      {
        name: "tokenProgram",
        isMut: false,
        isSigner: false
      },
      {
        name: "systemProgram",
        isMut: false,
        isSigner: false
      },
      {
        name: "rent",
        isMut: false,
        isSigner: false
      },
      {
        name: "associatedTokenProgram",
        isMut: false,
        isSigner: false
      },
      {
        name: "metadataProgram",
        isMut: false,
        isSigner: false
      },
      {
        name: "metadataUpdateAuth",
        isMut: false,
        isSigner: false
      }
    ],
    args: [
      {
        name: "bumps",
        type: {
          defined: "OpenPositionWithMetadataBumps"
        }
      },
      {
        name: "tickLowerIndex",
        type: "i32"
      },
      {
        name: "tickUpperIndex",
        type: "i32"
      }
    ]
  },
  {
    name: "increaseLiquidity",
    accounts: [
      {
        name: "whirlpool",
        isMut: true,
        isSigner: false
      },
      {
        name: "tokenProgram",
        isMut: false,
        isSigner: false
      },
      {
        name: "positionAuthority",
        isMut: false,
        isSigner: true
      },
      {
        name: "position",
        isMut: true,
        isSigner: false
      },
      {
        name: "positionTokenAccount",
        isMut: false,
        isSigner: false
      },
      {
        name: "tokenOwnerAccountA",
        isMut: true,
        isSigner: false
      },
      {
        name: "tokenOwnerAccountB",
        isMut: true,
        isSigner: false
      },
      {
        name: "tokenVaultA",
        isMut: true,
        isSigner: false
      },
      {
        name: "tokenVaultB",
        isMut: true,
        isSigner: false
      },
      {
        name: "tickArrayLower",
        isMut: true,
        isSigner: false
      },
      {
        name: "tickArrayUpper",
        isMut: true,
        isSigner: false
      }
    ],
    args: [
      {
        name: "liquidityAmount",
        type: "u128"
      },
      {
        name: "tokenMaxA",
        type: "u64"
      },
      {
        name: "tokenMaxB",
        type: "u64"
      }
    ]
  },
  {
    name: "decreaseLiquidity",
    accounts: [
      {
        name: "whirlpool",
        isMut: true,
        isSigner: false
      },
      {
        name: "tokenProgram",
        isMut: false,
        isSigner: false
      },
      {
        name: "positionAuthority",
        isMut: false,
        isSigner: true
      },
      {
        name: "position",
        isMut: true,
        isSigner: false
      },
      {
        name: "positionTokenAccount",
        isMut: false,
        isSigner: false
      },
      {
        name: "tokenOwnerAccountA",
        isMut: true,
        isSigner: false
      },
      {
        name: "tokenOwnerAccountB",
        isMut: true,
        isSigner: false
      },
      {
        name: "tokenVaultA",
        isMut: true,
        isSigner: false
      },
      {
        name: "tokenVaultB",
        isMut: true,
        isSigner: false
      },
      {
        name: "tickArrayLower",
        isMut: true,
        isSigner: false
      },
      {
        name: "tickArrayUpper",
        isMut: true,
        isSigner: false
      }
    ],
    args: [
      {
        name: "liquidityAmount",
        type: "u128"
      },
      {
        name: "tokenMinA",
        type: "u64"
      },
      {
        name: "tokenMinB",
        type: "u64"
      }
    ]
  },
  {
    name: "updateFeesAndRewards",
    accounts: [
      {
        name: "whirlpool",
        isMut: true,
        isSigner: false
      },
      {
        name: "position",
        isMut: true,
        isSigner: false
      },
      {
        name: "tickArrayLower",
        isMut: false,
        isSigner: false
      },
      {
        name: "tickArrayUpper",
        isMut: false,
        isSigner: false
      }
    ],
    args: []
  },
  {
    name: "collectFees",
    accounts: [
      {
        name: "whirlpool",
        isMut: false,
        isSigner: false
      },
      {
        name: "positionAuthority",
        isMut: false,
        isSigner: true
      },
      {
        name: "position",
        isMut: true,
        isSigner: false
      },
      {
        name: "positionTokenAccount",
        isMut: false,
        isSigner: false
      },
      {
        name: "tokenOwnerAccountA",
        isMut: true,
        isSigner: false
      },
      {
        name: "tokenVaultA",
        isMut: true,
        isSigner: false
      },
      {
        name: "tokenOwnerAccountB",
        isMut: true,
        isSigner: false
      },
      {
        name: "tokenVaultB",
        isMut: true,
        isSigner: false
      },
      {
        name: "tokenProgram",
        isMut: false,
        isSigner: false
      }
    ],
    args: []
  },
  {
    name: "collectReward",
    accounts: [
      {
        name: "whirlpool",
        isMut: false,
        isSigner: false
      },
      {
        name: "positionAuthority",
        isMut: false,
        isSigner: true
      },
      {
        name: "position",
        isMut: true,
        isSigner: false
      },
      {
        name: "positionTokenAccount",
        isMut: false,
        isSigner: false
      },
      {
        name: "rewardOwnerAccount",
        isMut: true,
        isSigner: false
      },
      {
        name: "rewardVault",
        isMut: true,
        isSigner: false
      },
      {
        name: "tokenProgram",
        isMut: false,
        isSigner: false
      }
    ],
    args: [
      {
        name: "rewardIndex",
        type: "u8"
      }
    ]
  },
  {
    name: "collectProtocolFees",
    accounts: [
      {
        name: "whirlpoolsConfig",
        isMut: false,
        isSigner: false
      },
      {
        name: "whirlpool",
        isMut: true,
        isSigner: false
      },
      {
        name: "collectProtocolFeesAuthority",
        isMut: false,
        isSigner: true
      },
      {
        name: "tokenVaultA",
        isMut: true,
        isSigner: false
      },
      {
        name: "tokenVaultB",
        isMut: true,
        isSigner: false
      },
      {
        name: "tokenDestinationA",
        isMut: true,
        isSigner: false
      },
      {
        name: "tokenDestinationB",
        isMut: true,
        isSigner: false
      },
      {
        name: "tokenProgram",
        isMut: false,
        isSigner: false
      }
    ],
    args: []
  },
  {
    name: "swap",
    accounts: [
      {
        name: "tokenProgram",
        isMut: false,
        isSigner: false
      },
      {
        name: "tokenAuthority",
        isMut: false,
        isSigner: true
      },
      {
        name: "whirlpool",
        isMut: true,
        isSigner: false
      },
      {
        name: "tokenOwnerAccountA",
        isMut: true,
        isSigner: false
      },
      {
        name: "tokenVaultA",
        isMut: true,
        isSigner: false
      },
      {
        name: "tokenOwnerAccountB",
        isMut: true,
        isSigner: false
      },
      {
        name: "tokenVaultB",
        isMut: true,
        isSigner: false
      },
      {
        name: "tickArray0",
        isMut: true,
        isSigner: false
      },
      {
        name: "tickArray1",
        isMut: true,
        isSigner: false
      },
      {
        name: "tickArray2",
        isMut: true,
        isSigner: false
      },
      {
        name: "oracle",
        isMut: false,
        isSigner: false
      }
    ],
    args: [
      {
        name: "amount",
        type: "u64"
      },
      {
        name: "otherAmountThreshold",
        type: "u64"
      },
      {
        name: "sqrtPriceLimit",
        type: "u128"
      },
      {
        name: "amountSpecifiedIsInput",
        type: "bool"
      },
      {
        name: "aToB",
        type: "bool"
      }
    ]
  },
  {
    name: "closePosition",
    accounts: [
      {
        name: "positionAuthority",
        isMut: false,
        isSigner: true
      },
      {
        name: "receiver",
        isMut: true,
        isSigner: false
      },
      {
        name: "position",
        isMut: true,
        isSigner: false
      },
      {
        name: "positionMint",
        isMut: true,
        isSigner: false
      },
      {
        name: "positionTokenAccount",
        isMut: true,
        isSigner: false
      },
      {
        name: "tokenProgram",
        isMut: false,
        isSigner: false
      }
    ],
    args: []
  },
  {
    name: "setDefaultFeeRate",
    accounts: [
      {
        name: "whirlpoolsConfig",
        isMut: false,
        isSigner: false
      },
      {
        name: "feeTier",
        isMut: true,
        isSigner: false
      },
      {
        name: "feeAuthority",
        isMut: false,
        isSigner: true
      }
    ],
    args: [
      {
        name: "defaultFeeRate",
        type: "u16"
      }
    ]
  },
  {
    name: "setDefaultProtocolFeeRate",
    accounts: [
      {
        name: "whirlpoolsConfig",
        isMut: true,
        isSigner: false
      },
      {
        name: "feeAuthority",
        isMut: false,
        isSigner: true
      }
    ],
    args: [
      {
        name: "defaultProtocolFeeRate",
        type: "u16"
      }
    ]
  },
  {
    name: "setFeeRate",
    accounts: [
      {
        name: "whirlpoolsConfig",
        isMut: false,
        isSigner: false
      },
      {
        name: "whirlpool",
        isMut: true,
        isSigner: false
      },
      {
        name: "feeAuthority",
        isMut: false,
        isSigner: true
      }
    ],
    args: [
      {
        name: "feeRate",
        type: "u16"
      }
    ]
  },
  {
    name: "setProtocolFeeRate",
    accounts: [
      {
        name: "whirlpoolsConfig",
        isMut: false,
        isSigner: false
      },
      {
        name: "whirlpool",
        isMut: true,
        isSigner: false
      },
      {
        name: "feeAuthority",
        isMut: false,
        isSigner: true
      }
    ],
    args: [
      {
        name: "protocolFeeRate",
        type: "u16"
      }
    ]
  },
  {
    name: "setFeeAuthority",
    accounts: [
      {
        name: "whirlpoolsConfig",
        isMut: true,
        isSigner: false
      },
      {
        name: "feeAuthority",
        isMut: false,
        isSigner: true
      },
      {
        name: "newFeeAuthority",
        isMut: false,
        isSigner: false
      }
    ],
    args: []
  },
  {
    name: "setCollectProtocolFeesAuthority",
    accounts: [
      {
        name: "whirlpoolsConfig",
        isMut: true,
        isSigner: false
      },
      {
        name: "collectProtocolFeesAuthority",
        isMut: false,
        isSigner: true
      },
      {
        name: "newCollectProtocolFeesAuthority",
        isMut: false,
        isSigner: false
      }
    ],
    args: []
  },
  {
    name: "setRewardAuthority",
    accounts: [
      {
        name: "whirlpool",
        isMut: true,
        isSigner: false
      },
      {
        name: "rewardAuthority",
        isMut: false,
        isSigner: true
      },
      {
        name: "newRewardAuthority",
        isMut: false,
        isSigner: false
      }
    ],
    args: [
      {
        name: "rewardIndex",
        type: "u8"
      }
    ]
  },
  {
    name: "setRewardAuthorityBySuperAuthority",
    accounts: [
      {
        name: "whirlpoolsConfig",
        isMut: false,
        isSigner: false
      },
      {
        name: "whirlpool",
        isMut: true,
        isSigner: false
      },
      {
        name: "rewardEmissionsSuperAuthority",
        isMut: false,
        isSigner: true
      },
      {
        name: "newRewardAuthority",
        isMut: false,
        isSigner: false
      }
    ],
    args: [
      {
        name: "rewardIndex",
        type: "u8"
      }
    ]
  },
  {
    name: "setRewardEmissionsSuperAuthority",
    accounts: [
      {
        name: "whirlpoolsConfig",
        isMut: true,
        isSigner: false
      },
      {
        name: "rewardEmissionsSuperAuthority",
        isMut: false,
        isSigner: true
      },
      {
        name: "newRewardEmissionsSuperAuthority",
        isMut: false,
        isSigner: false
      }
    ],
    args: []
  }
];
var accounts = [
  {
    name: "WhirlpoolsConfig",
    type: {
      kind: "struct",
      fields: [
        {
          name: "feeAuthority",
          type: "publicKey"
        },
        {
          name: "collectProtocolFeesAuthority",
          type: "publicKey"
        },
        {
          name: "rewardEmissionsSuperAuthority",
          type: "publicKey"
        },
        {
          name: "defaultProtocolFeeRate",
          type: "u16"
        }
      ]
    }
  },
  {
    name: "FeeTier",
    type: {
      kind: "struct",
      fields: [
        {
          name: "whirlpoolsConfig",
          type: "publicKey"
        },
        {
          name: "tickSpacing",
          type: "u16"
        },
        {
          name: "defaultFeeRate",
          type: "u16"
        }
      ]
    }
  },
  {
    name: "Position",
    type: {
      kind: "struct",
      fields: [
        {
          name: "whirlpool",
          type: "publicKey"
        },
        {
          name: "positionMint",
          type: "publicKey"
        },
        {
          name: "liquidity",
          type: "u128"
        },
        {
          name: "tickLowerIndex",
          type: "i32"
        },
        {
          name: "tickUpperIndex",
          type: "i32"
        },
        {
          name: "feeGrowthCheckpointA",
          type: "u128"
        },
        {
          name: "feeOwedA",
          type: "u64"
        },
        {
          name: "feeGrowthCheckpointB",
          type: "u128"
        },
        {
          name: "feeOwedB",
          type: "u64"
        },
        {
          name: "rewardInfos",
          type: {
            array: [
              {
                defined: "PositionRewardInfo"
              },
              3
            ]
          }
        }
      ]
    }
  },
  {
    name: "TickArray",
    type: {
      kind: "struct",
      fields: [
        {
          name: "startTickIndex",
          type: "i32"
        },
        {
          name: "ticks",
          type: {
            array: [
              {
                defined: "Tick"
              },
              88
            ]
          }
        },
        {
          name: "whirlpool",
          type: "publicKey"
        }
      ]
    }
  },
  {
    name: "Whirlpool",
    type: {
      kind: "struct",
      fields: [
        {
          name: "whirlpoolsConfig",
          type: "publicKey"
        },
        {
          name: "whirlpoolBump",
          type: {
            array: [
              "u8",
              1
            ]
          }
        },
        {
          name: "tickSpacing",
          type: "u16"
        },
        {
          name: "tickSpacingSeed",
          type: {
            array: [
              "u8",
              2
            ]
          }
        },
        {
          name: "feeRate",
          type: "u16"
        },
        {
          name: "protocolFeeRate",
          type: "u16"
        },
        {
          name: "liquidity",
          type: "u128"
        },
        {
          name: "sqrtPrice",
          type: "u128"
        },
        {
          name: "tickCurrentIndex",
          type: "i32"
        },
        {
          name: "protocolFeeOwedA",
          type: "u64"
        },
        {
          name: "protocolFeeOwedB",
          type: "u64"
        },
        {
          name: "tokenMintA",
          type: "publicKey"
        },
        {
          name: "tokenVaultA",
          type: "publicKey"
        },
        {
          name: "feeGrowthGlobalA",
          type: "u128"
        },
        {
          name: "tokenMintB",
          type: "publicKey"
        },
        {
          name: "tokenVaultB",
          type: "publicKey"
        },
        {
          name: "feeGrowthGlobalB",
          type: "u128"
        },
        {
          name: "rewardLastUpdatedTimestamp",
          type: "u64"
        },
        {
          name: "rewardInfos",
          type: {
            array: [
              {
                defined: "WhirlpoolRewardInfo"
              },
              3
            ]
          }
        }
      ]
    }
  }
];
var types = [
  {
    name: "OpenPositionBumps",
    type: {
      kind: "struct",
      fields: [
        {
          name: "positionBump",
          type: "u8"
        }
      ]
    }
  },
  {
    name: "OpenPositionWithMetadataBumps",
    type: {
      kind: "struct",
      fields: [
        {
          name: "positionBump",
          type: "u8"
        },
        {
          name: "metadataBump",
          type: "u8"
        }
      ]
    }
  },
  {
    name: "PositionRewardInfo",
    type: {
      kind: "struct",
      fields: [
        {
          name: "growthInsideCheckpoint",
          type: "u128"
        },
        {
          name: "amountOwed",
          type: "u64"
        }
      ]
    }
  },
  {
    name: "Tick",
    type: {
      kind: "struct",
      fields: [
        {
          name: "initialized",
          type: "bool"
        },
        {
          name: "liquidityNet",
          type: "i128"
        },
        {
          name: "liquidityGross",
          type: "u128"
        },
        {
          name: "feeGrowthOutsideA",
          type: "u128"
        },
        {
          name: "feeGrowthOutsideB",
          type: "u128"
        },
        {
          name: "rewardGrowthsOutside",
          type: {
            array: [
              "u128",
              3
            ]
          }
        }
      ]
    }
  },
  {
    name: "WhirlpoolRewardInfo",
    type: {
      kind: "struct",
      fields: [
        {
          name: "mint",
          type: "publicKey"
        },
        {
          name: "vault",
          type: "publicKey"
        },
        {
          name: "authority",
          type: "publicKey"
        },
        {
          name: "emissionsPerSecondX64",
          type: "u128"
        },
        {
          name: "growthGlobalX64",
          type: "u128"
        }
      ]
    }
  },
  {
    name: "WhirlpoolBumps",
    type: {
      kind: "struct",
      fields: [
        {
          name: "whirlpoolBump",
          type: "u8"
        }
      ]
    }
  },
  {
    name: "CurrIndex",
    type: {
      kind: "enum",
      variants: [
        {
          name: "Below"
        },
        {
          name: "Inside"
        },
        {
          name: "Above"
        }
      ]
    }
  },
  {
    name: "TickLabel",
    type: {
      kind: "enum",
      variants: [
        {
          name: "Upper"
        },
        {
          name: "Lower"
        }
      ]
    }
  },
  {
    name: "Direction",
    type: {
      kind: "enum",
      variants: [
        {
          name: "Left"
        },
        {
          name: "Right"
        }
      ]
    }
  }
];
var errors = [
  {
    code: 6e3,
    name: "InvalidEnum",
    msg: "Enum value could not be converted"
  },
  {
    code: 6001,
    name: "InvalidStartTick",
    msg: "Invalid start tick index provided."
  },
  {
    code: 6002,
    name: "TickArrayExistInPool",
    msg: "Tick-array already exists in this whirlpool"
  },
  {
    code: 6003,
    name: "TickArrayIndexOutofBounds",
    msg: "Attempt to search for a tick-array failed"
  },
  {
    code: 6004,
    name: "InvalidTickSpacing",
    msg: "Tick-spacing is not supported"
  },
  {
    code: 6005,
    name: "ClosePositionNotEmpty",
    msg: "Position is not empty It cannot be closed"
  },
  {
    code: 6006,
    name: "DivideByZero",
    msg: "Unable to divide by zero"
  },
  {
    code: 6007,
    name: "NumberCastError",
    msg: "Unable to cast number into BigInt"
  },
  {
    code: 6008,
    name: "NumberDownCastError",
    msg: "Unable to down cast number"
  },
  {
    code: 6009,
    name: "TickNotFound",
    msg: "Tick not found within tick array"
  },
  {
    code: 6010,
    name: "InvalidTickIndex",
    msg: "Provided tick index is either out of bounds or uninitializable"
  },
  {
    code: 6011,
    name: "SqrtPriceOutOfBounds",
    msg: "Provided sqrt price out of bounds"
  },
  {
    code: 6012,
    name: "LiquidityZero",
    msg: "Liquidity amount must be greater than zero"
  },
  {
    code: 6013,
    name: "LiquidityTooHigh",
    msg: "Liquidity amount must be less than i64::MAX"
  },
  {
    code: 6014,
    name: "LiquidityOverflow",
    msg: "Liquidity overflow"
  },
  {
    code: 6015,
    name: "LiquidityUnderflow",
    msg: "Liquidity underflow"
  },
  {
    code: 6016,
    name: "LiquidityNetError",
    msg: "Tick liquidity net underflowed or overflowed"
  },
  {
    code: 6017,
    name: "TokenMaxExceeded",
    msg: "Exceeded token max"
  },
  {
    code: 6018,
    name: "TokenMinSubceeded",
    msg: "Did not meet token min"
  },
  {
    code: 6019,
    name: "MissingOrInvalidDelegate",
    msg: "Position token account has a missing or invalid delegate"
  },
  {
    code: 6020,
    name: "InvalidPositionTokenAmount",
    msg: "Position token amount must be 1"
  },
  {
    code: 6021,
    name: "InvalidTimestampConversion",
    msg: "Timestamp should be convertible from i64 to u64"
  },
  {
    code: 6022,
    name: "InvalidTimestamp",
    msg: "Timestamp should be greater than the last updated timestamp"
  },
  {
    code: 6023,
    name: "InvalidTickArraySequence",
    msg: "Invalid tick array sequence provided for instruction."
  },
  {
    code: 6024,
    name: "InvalidTokenMintOrder",
    msg: "Token Mint in wrong order"
  },
  {
    code: 6025,
    name: "RewardNotInitialized",
    msg: "Reward not initialized"
  },
  {
    code: 6026,
    name: "InvalidRewardIndex",
    msg: "Invalid reward index"
  },
  {
    code: 6027,
    name: "RewardVaultAmountInsufficient",
    msg: "Reward vault requires amount to support emissions for at least one day"
  },
  {
    code: 6028,
    name: "FeeRateMaxExceeded",
    msg: "Exceeded max fee rate"
  },
  {
    code: 6029,
    name: "ProtocolFeeRateMaxExceeded",
    msg: "Exceeded max protocol fee rate"
  },
  {
    code: 6030,
    name: "MultiplicationShiftRightOverflow",
    msg: "Multiplication with shift right overflow"
  },
  {
    code: 6031,
    name: "MulDivOverflow",
    msg: "Muldiv overflow"
  },
  {
    code: 6032,
    name: "MulDivInvalidInput",
    msg: "Invalid div_u256 input"
  },
  {
    code: 6033,
    name: "MultiplicationOverflow",
    msg: "Multiplication overflow"
  },
  {
    code: 6034,
    name: "InvalidSqrtPriceLimitDirection",
    msg: "Provided SqrtPriceLimit not in the same direction as the swap."
  },
  {
    code: 6035,
    name: "ZeroTradableAmount",
    msg: "There are no tradable amount to swap."
  },
  {
    code: 6036,
    name: "AmountOutBelowMinimum",
    msg: "Amount out below minimum threshold"
  },
  {
    code: 6037,
    name: "AmountInAboveMaximum",
    msg: "Amount in above maximum threshold"
  },
  {
    code: 6038,
    name: "TickArraySequenceInvalidIndex",
    msg: "Invalid index for tick array sequence"
  },
  {
    code: 6039,
    name: "AmountCalcOverflow",
    msg: "Amount calculated overflows"
  },
  {
    code: 6040,
    name: "AmountRemainingOverflow",
    msg: "Amount remaining overflows"
  }
];
var whirlpool_default = {
  version,
  name,
  instructions,
  accounts,
  types,
  errors
};

// src/network/public/fetcher.ts
import invariant2 from "tiny-invariant";
import { AccountLayout as AccountLayout2 } from "@solana/spl-token";

// src/network/public/parsing.ts
import { MintLayout, u64 as u644 } from "@solana/spl-token";
import { PublicKey as PublicKey10 } from "@solana/web3.js";

// src/types/public/constants.ts
import { BN } from "@project-serum/anchor";
import { PublicKey } from "@solana/web3.js";
var ORCA_WHIRLPOOL_PROGRAM_ID = new PublicKey(
  "whirLbMiicVdio4qvUfM5KAg6Ct8VwpYzGff3uctyCc"
);
var ORCA_WHIRLPOOLS_CONFIG = new PublicKey("2LecshUwdy9xi7meFgHtFJQNSKk4KdTrcpvaB56dP2NQ");
var NUM_REWARDS = 3;
var MAX_TICK_INDEX = 443636;
var MIN_TICK_INDEX = -443636;
var MAX_SQRT_PRICE = "79226673515401279992447579055";
var MIN_SQRT_PRICE = "4295048016";
var TICK_ARRAY_SIZE = 88;
var METADATA_PROGRAM_ADDRESS = new PublicKey(
  "metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s"
);
var MAX_SWAP_TICK_ARRAYS = 3;
var PROTOCOL_FEE_RATE_MUL_VALUE = new BN(1e4);
var FEE_RATE_MUL_VALUE = new BN(1e6);

// src/types/public/anchor-types.ts
import { BorshAccountsCoder } from "@project-serum/anchor";
var AccountName = /* @__PURE__ */ ((AccountName2) => {
  AccountName2["WhirlpoolsConfig"] = "WhirlpoolsConfig";
  AccountName2["Position"] = "Position";
  AccountName2["TickArray"] = "TickArray";
  AccountName2["Whirlpool"] = "Whirlpool";
  AccountName2["FeeTier"] = "FeeTier";
  return AccountName2;
})(AccountName || {});
var IDL = whirlpool_default;
var WHIRLPOOL_CODER = new BorshAccountsCoder(IDL);
var WHIRLPOOL_ACCOUNT_SIZE = WHIRLPOOL_CODER.size(IDL.accounts[4]);

// src/instructions/close-position-ix.ts
import { TOKEN_PROGRAM_ID } from "@solana/spl-token";
function closePositionIx(program, params) {
  const {
    positionAuthority,
    receiver,
    position,
    positionMint,
    positionTokenAccount
  } = params;
  const ix = program.instruction.closePosition({
    accounts: {
      positionAuthority,
      receiver,
      position,
      positionMint,
      positionTokenAccount,
      tokenProgram: TOKEN_PROGRAM_ID
    }
  });
  return {
    instructions: [ix],
    cleanupInstructions: [],
    signers: []
  };
}

// src/instructions/collect-fees-ix.ts
import { TOKEN_PROGRAM_ID as TOKEN_PROGRAM_ID2 } from "@solana/spl-token";
function collectFeesIx(program, params) {
  const {
    whirlpool,
    positionAuthority,
    position,
    positionTokenAccount,
    tokenOwnerAccountA,
    tokenOwnerAccountB,
    tokenVaultA,
    tokenVaultB
  } = params;
  const ix = program.instruction.collectFees({
    accounts: {
      whirlpool,
      positionAuthority,
      position,
      positionTokenAccount,
      tokenOwnerAccountA,
      tokenOwnerAccountB,
      tokenVaultA,
      tokenVaultB,
      tokenProgram: TOKEN_PROGRAM_ID2
    }
  });
  return {
    instructions: [ix],
    cleanupInstructions: [],
    signers: []
  };
}

// src/instructions/collect-protocol-fees-ix.ts
import { TOKEN_PROGRAM_ID as TOKEN_PROGRAM_ID3 } from "@solana/spl-token";
function collectProtocolFeesIx(program, params) {
  const {
    whirlpoolsConfig,
    whirlpool,
    collectProtocolFeesAuthority,
    tokenVaultA,
    tokenVaultB,
    tokenOwnerAccountA: tokenDestinationA,
    tokenOwnerAccountB: tokenDestinationB
  } = params;
  const ix = program.instruction.collectProtocolFees({
    accounts: {
      whirlpoolsConfig,
      whirlpool,
      collectProtocolFeesAuthority,
      tokenVaultA,
      tokenVaultB,
      tokenDestinationA,
      tokenDestinationB,
      tokenProgram: TOKEN_PROGRAM_ID3
    }
  });
  return {
    instructions: [ix],
    cleanupInstructions: [],
    signers: []
  };
}

// src/instructions/collect-reward-ix.ts
import { TOKEN_PROGRAM_ID as TOKEN_PROGRAM_ID4 } from "@solana/spl-token";
function collectRewardIx(program, params) {
  const {
    whirlpool,
    positionAuthority,
    position,
    positionTokenAccount,
    rewardOwnerAccount,
    rewardVault,
    rewardIndex
  } = params;
  const ix = program.instruction.collectReward(rewardIndex, {
    accounts: {
      whirlpool,
      positionAuthority,
      position,
      positionTokenAccount,
      rewardOwnerAccount,
      rewardVault,
      tokenProgram: TOKEN_PROGRAM_ID4
    }
  });
  return {
    instructions: [ix],
    cleanupInstructions: [],
    signers: []
  };
}

// src/instructions/composites/collect-all-txn.ts
import { TokenUtil as TokenUtil2, TransactionBuilder as TransactionBuilder2, ZERO as ZERO2 } from "@orca-so/common-sdk";
import { createWSOLAccountInstructions as createWSOLAccountInstructions2 } from "@orca-so/common-sdk/dist/helpers/token-instructions";
import { NATIVE_MINT as NATIVE_MINT2 } from "@solana/spl-token";
import { PACKET_DATA_SIZE, PublicKey as PublicKey4 } from "@solana/web3.js";

// src/ix.ts
var WhirlpoolIx = class {
  static initializeConfigIx(program, params) {
    return initializeConfigIx(program, params);
  }
  static initializeFeeTierIx(program, params) {
    return initializeFeeTierIx(program, params);
  }
  static initializePoolIx(program, params) {
    return initializePoolIx(program, params);
  }
  static initializeRewardIx(program, params) {
    return initializeRewardIx(program, params);
  }
  static initTickArrayIx(program, params) {
    return initTickArrayIx(program, params);
  }
  static openPositionIx(program, params) {
    return openPositionIx(program, params);
  }
  static openPositionWithMetadataIx(program, params) {
    return openPositionWithMetadataIx(program, params);
  }
  static increaseLiquidityIx(program, params) {
    return increaseLiquidityIx(program, params);
  }
  static decreaseLiquidityIx(program, params) {
    return decreaseLiquidityIx(program, params);
  }
  static closePositionIx(program, params) {
    return closePositionIx(program, params);
  }
  static swapIx(program, params) {
    return swapIx(program, params);
  }
  static updateFeesAndRewardsIx(program, params) {
    return updateFeesAndRewardsIx(program, params);
  }
  static collectFeesIx(program, params) {
    return collectFeesIx(program, params);
  }
  static collectProtocolFeesIx(program, params) {
    return collectProtocolFeesIx(program, params);
  }
  static collectRewardIx(program, params) {
    return collectRewardIx(program, params);
  }
  static setCollectProtocolFeesAuthorityIx(program, params) {
    return setCollectProtocolFeesAuthorityIx(program, params);
  }
  static setDefaultFeeRateIx(program, params) {
    return setDefaultFeeRateIx(program, params);
  }
  static setDefaultProtocolFeeRateIx(program, params) {
    return setDefaultProtocolFeeRateIx(program, params);
  }
  static setFeeAuthorityIx(program, params) {
    return setFeeAuthorityIx(program, params);
  }
  static setFeeRateIx(program, params) {
    return setFeeRateIx(program, params);
  }
  static setProtocolFeeRateIx(program, params) {
    return setProtocolFeeRateIx(program, params);
  }
  static setRewardAuthorityBySuperAuthorityIx(program, params) {
    return setRewardAuthorityBySuperAuthorityIx(program, params);
  }
  static setRewardAuthorityIx(program, params) {
    return setRewardAuthorityIx(program, params);
  }
  static setRewardEmissionsIx(program, params) {
    return setRewardEmissionsIx(program, params);
  }
  static setRewardEmissionsSuperAuthorityIx(program, params) {
    return setRewardEmissionsSuperAuthorityIx(program, params);
  }
  static collectAllForPositionsTxns(ctx, params, refresh) {
    return collectAllForPositionAddressesTxns(ctx, params, refresh);
  }
};

// src/utils/public/ix-utils.ts
import { TransactionBuilder } from "@orca-so/common-sdk";
function toTx(ctx, ix) {
  return new TransactionBuilder(ctx.provider.connection, ctx.provider.wallet).addInstruction(ix);
}

// src/utils/public/pda-utils.ts
import { AddressUtil } from "@orca-so/common-sdk";
import { BN as BN4 } from "@project-serum/anchor";

// src/utils/public/price-math.ts
import { MathUtil } from "@orca-so/common-sdk";
import { BN as BN3 } from "@project-serum/anchor";
import Decimal from "decimal.js";

// src/utils/public/tick-utils.ts
import invariant from "tiny-invariant";
var TickUtil = class {
  constructor() {
  }
  static getOffsetIndex(tickIndex, arrayStartIndex, tickSpacing) {
    return Math.floor((tickIndex - arrayStartIndex) / tickSpacing);
  }
  static getStartTickIndex(tickIndex, tickSpacing, offset = 0) {
    const realIndex = Math.floor(tickIndex / tickSpacing / TICK_ARRAY_SIZE);
    const startTickIndex = (realIndex + offset) * tickSpacing * TICK_ARRAY_SIZE;
    const ticksInArray = TICK_ARRAY_SIZE * tickSpacing;
    const minTickIndex = MIN_TICK_INDEX - (MIN_TICK_INDEX % ticksInArray + ticksInArray);
    invariant(startTickIndex >= minTickIndex, `startTickIndex is too small - - ${startTickIndex}`);
    invariant(startTickIndex <= MAX_TICK_INDEX, `startTickIndex is too large - ${startTickIndex}`);
    return startTickIndex;
  }
  static getInitializableTickIndex(tickIndex, tickSpacing) {
    return tickIndex - tickIndex % tickSpacing;
  }
  static getNextInitializableTickIndex(tickIndex, tickSpacing) {
    return TickUtil.getInitializableTickIndex(tickIndex, tickSpacing) + tickSpacing;
  }
  static getPrevInitializableTickIndex(tickIndex, tickSpacing) {
    return TickUtil.getInitializableTickIndex(tickIndex, tickSpacing) - tickSpacing;
  }
  static findPreviousInitializedTickIndex(account, currentTickIndex, tickSpacing) {
    return TickUtil.findInitializedTick(
      account,
      currentTickIndex,
      tickSpacing,
      0 /* Left */
    );
  }
  static findNextInitializedTickIndex(account, currentTickIndex, tickSpacing) {
    return TickUtil.findInitializedTick(
      account,
      currentTickIndex,
      tickSpacing,
      1 /* Right */
    );
  }
  static findInitializedTick(account, currentTickIndex, tickSpacing, searchDirection) {
    var _a;
    const currentTickArrayIndex = tickIndexToInnerIndex(
      account.startTickIndex,
      currentTickIndex,
      tickSpacing
    );
    const increment = searchDirection === 1 /* Right */ ? 1 : -1;
    let stepInitializedTickArrayIndex = searchDirection === 1 /* Right */ ? currentTickArrayIndex + increment : currentTickArrayIndex;
    while (stepInitializedTickArrayIndex >= 0 && stepInitializedTickArrayIndex < account.ticks.length) {
      if ((_a = account.ticks[stepInitializedTickArrayIndex]) == null ? void 0 : _a.initialized) {
        return innerIndexToTickIndex(
          account.startTickIndex,
          stepInitializedTickArrayIndex,
          tickSpacing
        );
      }
      stepInitializedTickArrayIndex += increment;
    }
    return null;
  }
  static checkTickInBounds(tick) {
    return tick <= MAX_TICK_INDEX && tick >= MIN_TICK_INDEX;
  }
  static isTickInitializable(tick, tickSpacing) {
    return tick % tickSpacing === 0;
  }
  static invertTick(tick) {
    return -tick;
  }
};
var TickArrayUtil = class {
  static getTickFromArray(tickArray, tickIndex, tickSpacing) {
    const realIndex = tickIndexToInnerIndex(tickArray.startTickIndex, tickIndex, tickSpacing);
    const tick = tickArray.ticks[realIndex];
    invariant(
      !!tick,
      `tick realIndex out of range - start - ${tickArray.startTickIndex} index - ${tickIndex}, realIndex - ${realIndex}`
    );
    return tick;
  }
  static async getTickArrayPDAs(tick, tickSpacing, numOfTickArrays, programId, whirlpoolAddress, aToB) {
    let arrayIndexList = [...Array(numOfTickArrays).keys()];
    if (aToB) {
      arrayIndexList = arrayIndexList.map((value) => -value);
    }
    return arrayIndexList.map((value) => {
      const startTick = TickUtil.getStartTickIndex(tick, tickSpacing, value);
      return PDAUtil.getTickArray(programId, whirlpoolAddress, startTick);
    });
  }
  static async getUninitializedArraysPDAs(ticks, programId, whirlpoolAddress, tickSpacing, fetcher, refresh) {
    const startTicks = ticks.map((tick) => TickUtil.getStartTickIndex(tick, tickSpacing));
    const removeDupeTicks = [...new Set(startTicks)];
    const tickArrayPDAs = removeDupeTicks.map(
      (tick) => PDAUtil.getTickArray(programId, whirlpoolAddress, tick)
    );
    const fetchedArrays = await fetcher.listTickArrays(
      tickArrayPDAs.map((pda) => pda.publicKey),
      refresh
    );
    const uninitializedIndices = TickArrayUtil.getUninitializedArrays(fetchedArrays);
    return uninitializedIndices.map((index) => {
      return {
        startIndex: removeDupeTicks[index],
        pda: tickArrayPDAs[index]
      };
    });
  }
  static getUninitializedArrays(tickArrays) {
    return tickArrays.map((value, index) => {
      if (!value) {
        return index;
      }
      return -1;
    }).filter((index) => index >= 0);
  }
};
function tickIndexToInnerIndex(startTickIndex, tickIndex, tickSpacing) {
  return Math.floor((tickIndex - startTickIndex) / tickSpacing);
}
function innerIndexToTickIndex(startTickIndex, tickArrayIndex, tickSpacing) {
  return startTickIndex + tickArrayIndex * tickSpacing;
}

// src/utils/public/price-math.ts
var BIT_PRECISION = 14;
var LOG_B_2_X32 = "59543866431248";
var LOG_B_P_ERR_MARGIN_LOWER_X64 = "184467440737095516";
var LOG_B_P_ERR_MARGIN_UPPER_X64 = "15793534762490258745";
var PriceMath = class {
  static priceToSqrtPriceX64(price, decimalsA, decimalsB) {
    return MathUtil.toX64(price.mul(Decimal.pow(10, decimalsB - decimalsA)).sqrt());
  }
  static sqrtPriceX64ToPrice(sqrtPriceX64, decimalsA, decimalsB) {
    return MathUtil.fromX64(sqrtPriceX64).pow(2).mul(Decimal.pow(10, decimalsA - decimalsB));
  }
  static tickIndexToSqrtPriceX64(tickIndex) {
    if (tickIndex > 0) {
      return new BN3(tickIndexToSqrtPricePositive(tickIndex));
    } else {
      return new BN3(tickIndexToSqrtPriceNegative(tickIndex));
    }
  }
  static sqrtPriceX64ToTickIndex(sqrtPriceX64) {
    if (sqrtPriceX64.gt(new BN3(MAX_SQRT_PRICE)) || sqrtPriceX64.lt(new BN3(MIN_SQRT_PRICE))) {
      throw new Error("Provided sqrtPrice is not within the supported sqrtPrice range.");
    }
    const msb = sqrtPriceX64.bitLength() - 1;
    const adjustedMsb = new BN3(msb - 64);
    const log2pIntegerX32 = signedShiftLeft(adjustedMsb, 32, 128);
    let bit = new BN3("8000000000000000", "hex");
    let precision = 0;
    let log2pFractionX64 = new BN3(0);
    let r = msb >= 64 ? sqrtPriceX64.shrn(msb - 63) : sqrtPriceX64.shln(63 - msb);
    while (bit.gt(new BN3(0)) && precision < BIT_PRECISION) {
      r = r.mul(r);
      let rMoreThanTwo = r.shrn(127);
      r = r.shrn(63 + rMoreThanTwo.toNumber());
      log2pFractionX64 = log2pFractionX64.add(bit.mul(rMoreThanTwo));
      bit = bit.shrn(1);
      precision += 1;
    }
    const log2pFractionX32 = log2pFractionX64.shrn(32);
    const log2pX32 = log2pIntegerX32.add(log2pFractionX32);
    const logbpX64 = log2pX32.mul(new BN3(LOG_B_2_X32));
    const tickLow = signedShiftRight(
      logbpX64.sub(new BN3(LOG_B_P_ERR_MARGIN_LOWER_X64)),
      64,
      128
    ).toNumber();
    const tickHigh = signedShiftRight(
      logbpX64.add(new BN3(LOG_B_P_ERR_MARGIN_UPPER_X64)),
      64,
      128
    ).toNumber();
    if (tickLow == tickHigh) {
      return tickLow;
    } else {
      const derivedTickHighSqrtPriceX64 = PriceMath.tickIndexToSqrtPriceX64(tickHigh);
      if (derivedTickHighSqrtPriceX64.lte(sqrtPriceX64)) {
        return tickHigh;
      } else {
        return tickLow;
      }
    }
  }
  static tickIndexToPrice(tickIndex, decimalsA, decimalsB) {
    return PriceMath.sqrtPriceX64ToPrice(
      PriceMath.tickIndexToSqrtPriceX64(tickIndex),
      decimalsA,
      decimalsB
    );
  }
  static priceToTickIndex(price, decimalsA, decimalsB) {
    return PriceMath.sqrtPriceX64ToTickIndex(
      PriceMath.priceToSqrtPriceX64(price, decimalsA, decimalsB)
    );
  }
  static priceToInitializableTickIndex(price, decimalsA, decimalsB, tickSpacing) {
    return TickUtil.getInitializableTickIndex(
      PriceMath.priceToTickIndex(price, decimalsA, decimalsB),
      tickSpacing
    );
  }
  static invertPrice(price, decimalsA, decimalsB) {
    const tick = PriceMath.priceToTickIndex(price, decimalsA, decimalsB);
    const invTick = TickUtil.invertTick(tick);
    return PriceMath.tickIndexToPrice(invTick, decimalsB, decimalsA);
  }
  static invertSqrtPriceX64(sqrtPriceX64) {
    const tick = PriceMath.sqrtPriceX64ToTickIndex(sqrtPriceX64);
    const invTick = TickUtil.invertTick(tick);
    return PriceMath.tickIndexToSqrtPriceX64(invTick);
  }
};
function tickIndexToSqrtPricePositive(tick) {
  let ratio;
  if ((tick & 1) != 0) {
    ratio = new BN3("79232123823359799118286999567");
  } else {
    ratio = new BN3("79228162514264337593543950336");
  }
  if ((tick & 2) != 0) {
    ratio = signedShiftRight(ratio.mul(new BN3("79236085330515764027303304731")), 96, 256);
  }
  if ((tick & 4) != 0) {
    ratio = signedShiftRight(ratio.mul(new BN3("79244008939048815603706035061")), 96, 256);
  }
  if ((tick & 8) != 0) {
    ratio = signedShiftRight(ratio.mul(new BN3("79259858533276714757314932305")), 96, 256);
  }
  if ((tick & 16) != 0) {
    ratio = signedShiftRight(ratio.mul(new BN3("79291567232598584799939703904")), 96, 256);
  }
  if ((tick & 32) != 0) {
    ratio = signedShiftRight(ratio.mul(new BN3("79355022692464371645785046466")), 96, 256);
  }
  if ((tick & 64) != 0) {
    ratio = signedShiftRight(ratio.mul(new BN3("79482085999252804386437311141")), 96, 256);
  }
  if ((tick & 128) != 0) {
    ratio = signedShiftRight(ratio.mul(new BN3("79736823300114093921829183326")), 96, 256);
  }
  if ((tick & 256) != 0) {
    ratio = signedShiftRight(ratio.mul(new BN3("80248749790819932309965073892")), 96, 256);
  }
  if ((tick & 512) != 0) {
    ratio = signedShiftRight(ratio.mul(new BN3("81282483887344747381513967011")), 96, 256);
  }
  if ((tick & 1024) != 0) {
    ratio = signedShiftRight(ratio.mul(new BN3("83390072131320151908154831281")), 96, 256);
  }
  if ((tick & 2048) != 0) {
    ratio = signedShiftRight(ratio.mul(new BN3("87770609709833776024991924138")), 96, 256);
  }
  if ((tick & 4096) != 0) {
    ratio = signedShiftRight(ratio.mul(new BN3("97234110755111693312479820773")), 96, 256);
  }
  if ((tick & 8192) != 0) {
    ratio = signedShiftRight(ratio.mul(new BN3("119332217159966728226237229890")), 96, 256);
  }
  if ((tick & 16384) != 0) {
    ratio = signedShiftRight(ratio.mul(new BN3("179736315981702064433883588727")), 96, 256);
  }
  if ((tick & 32768) != 0) {
    ratio = signedShiftRight(ratio.mul(new BN3("407748233172238350107850275304")), 96, 256);
  }
  if ((tick & 65536) != 0) {
    ratio = signedShiftRight(ratio.mul(new BN3("2098478828474011932436660412517")), 96, 256);
  }
  if ((tick & 131072) != 0) {
    ratio = signedShiftRight(ratio.mul(new BN3("55581415166113811149459800483533")), 96, 256);
  }
  if ((tick & 262144) != 0) {
    ratio = signedShiftRight(ratio.mul(new BN3("38992368544603139932233054999993551")), 96, 256);
  }
  return signedShiftRight(ratio, 32, 256);
}
function tickIndexToSqrtPriceNegative(tickIndex) {
  let tick = Math.abs(tickIndex);
  let ratio;
  if ((tick & 1) != 0) {
    ratio = new BN3("18445821805675392311");
  } else {
    ratio = new BN3("18446744073709551616");
  }
  if ((tick & 2) != 0) {
    ratio = signedShiftRight(ratio.mul(new BN3("18444899583751176498")), 64, 256);
  }
  if ((tick & 4) != 0) {
    ratio = signedShiftRight(ratio.mul(new BN3("18443055278223354162")), 64, 256);
  }
  if ((tick & 8) != 0) {
    ratio = signedShiftRight(ratio.mul(new BN3("18439367220385604838")), 64, 256);
  }
  if ((tick & 16) != 0) {
    ratio = signedShiftRight(ratio.mul(new BN3("18431993317065449817")), 64, 256);
  }
  if ((tick & 32) != 0) {
    ratio = signedShiftRight(ratio.mul(new BN3("18417254355718160513")), 64, 256);
  }
  if ((tick & 64) != 0) {
    ratio = signedShiftRight(ratio.mul(new BN3("18387811781193591352")), 64, 256);
  }
  if ((tick & 128) != 0) {
    ratio = signedShiftRight(ratio.mul(new BN3("18329067761203520168")), 64, 256);
  }
  if ((tick & 256) != 0) {
    ratio = signedShiftRight(ratio.mul(new BN3("18212142134806087854")), 64, 256);
  }
  if ((tick & 512) != 0) {
    ratio = signedShiftRight(ratio.mul(new BN3("17980523815641551639")), 64, 256);
  }
  if ((tick & 1024) != 0) {
    ratio = signedShiftRight(ratio.mul(new BN3("17526086738831147013")), 64, 256);
  }
  if ((tick & 2048) != 0) {
    ratio = signedShiftRight(ratio.mul(new BN3("16651378430235024244")), 64, 256);
  }
  if ((tick & 4096) != 0) {
    ratio = signedShiftRight(ratio.mul(new BN3("15030750278693429944")), 64, 256);
  }
  if ((tick & 8192) != 0) {
    ratio = signedShiftRight(ratio.mul(new BN3("12247334978882834399")), 64, 256);
  }
  if ((tick & 16384) != 0) {
    ratio = signedShiftRight(ratio.mul(new BN3("8131365268884726200")), 64, 256);
  }
  if ((tick & 32768) != 0) {
    ratio = signedShiftRight(ratio.mul(new BN3("3584323654723342297")), 64, 256);
  }
  if ((tick & 65536) != 0) {
    ratio = signedShiftRight(ratio.mul(new BN3("696457651847595233")), 64, 256);
  }
  if ((tick & 131072) != 0) {
    ratio = signedShiftRight(ratio.mul(new BN3("26294789957452057")), 64, 256);
  }
  if ((tick & 262144) != 0) {
    ratio = signedShiftRight(ratio.mul(new BN3("37481735321082")), 64, 256);
  }
  return ratio;
}
function signedShiftLeft(n0, shiftBy, bitWidth) {
  let twosN0 = n0.toTwos(bitWidth).shln(shiftBy);
  twosN0.imaskn(bitWidth + 1);
  return twosN0.fromTwos(bitWidth);
}
function signedShiftRight(n0, shiftBy, bitWidth) {
  let twoN0 = n0.toTwos(bitWidth).shrn(shiftBy);
  twoN0.imaskn(bitWidth - shiftBy + 1);
  return twoN0.fromTwos(bitWidth - shiftBy);
}

// src/utils/public/pda-utils.ts
var PDA_WHIRLPOOL_SEED = "whirlpool";
var PDA_POSITION_SEED = "position";
var PDA_METADATA_SEED = "metadata";
var PDA_TICK_ARRAY_SEED = "tick_array";
var PDA_FEE_TIER_SEED = "fee_tier";
var PDA_ORACLE_SEED = "oracle";
var PDAUtil = class {
  static getWhirlpool(programId, whirlpoolsConfigKey, tokenMintAKey, tokenMintBKey, tickSpacing) {
    return AddressUtil.findProgramAddress(
      [
        Buffer.from(PDA_WHIRLPOOL_SEED),
        whirlpoolsConfigKey.toBuffer(),
        tokenMintAKey.toBuffer(),
        tokenMintBKey.toBuffer(),
        new BN4(tickSpacing).toArrayLike(Buffer, "le", 2)
      ],
      programId
    );
  }
  static getPosition(programId, positionMintKey) {
    return AddressUtil.findProgramAddress(
      [Buffer.from(PDA_POSITION_SEED), positionMintKey.toBuffer()],
      programId
    );
  }
  static getPositionMetadata(positionMintKey) {
    return AddressUtil.findProgramAddress(
      [
        Buffer.from(PDA_METADATA_SEED),
        METADATA_PROGRAM_ADDRESS.toBuffer(),
        positionMintKey.toBuffer()
      ],
      METADATA_PROGRAM_ADDRESS
    );
  }
  static getTickArray(programId, whirlpoolAddress, startTick) {
    return AddressUtil.findProgramAddress(
      [
        Buffer.from(PDA_TICK_ARRAY_SEED),
        whirlpoolAddress.toBuffer(),
        Buffer.from(startTick.toString())
      ],
      programId
    );
  }
  static getTickArrayFromTickIndex(tickIndex, tickSpacing, whirlpool, programId, tickArrayOffset = 0) {
    const startIndex = TickUtil.getStartTickIndex(tickIndex, tickSpacing, tickArrayOffset);
    return PDAUtil.getTickArray(
      AddressUtil.toPubKey(programId),
      AddressUtil.toPubKey(whirlpool),
      startIndex
    );
  }
  static getTickArrayFromSqrtPrice(sqrtPriceX64, tickSpacing, whirlpool, programId, tickArrayOffset = 0) {
    const tickIndex = PriceMath.sqrtPriceX64ToTickIndex(sqrtPriceX64);
    return PDAUtil.getTickArrayFromTickIndex(
      tickIndex,
      tickSpacing,
      whirlpool,
      programId,
      tickArrayOffset
    );
  }
  static getFeeTier(programId, whirlpoolsConfigAddress, tickSpacing) {
    return AddressUtil.findProgramAddress(
      [
        Buffer.from(PDA_FEE_TIER_SEED),
        whirlpoolsConfigAddress.toBuffer(),
        new BN4(tickSpacing).toArrayLike(Buffer, "le", 2)
      ],
      programId
    );
  }
  static getOracle(programId, whirlpoolAddress) {
    return AddressUtil.findProgramAddress(
      [Buffer.from(PDA_ORACLE_SEED), whirlpoolAddress.toBuffer()],
      programId
    );
  }
};

// src/utils/public/pool-utils.ts
import { AddressUtil as AddressUtil2, MathUtil as MathUtil2, Percentage } from "@orca-so/common-sdk";
import { BN as BN5 } from "@project-serum/anchor";
import { u64 } from "@solana/spl-token";
import { PublicKey as PublicKey2 } from "@solana/web3.js";
import Decimal2 from "decimal.js";

// src/utils/public/types.ts
var SwapDirection = /* @__PURE__ */ ((SwapDirection2) => {
  SwapDirection2["AtoB"] = "aToB";
  SwapDirection2["BtoA"] = "bToA";
  return SwapDirection2;
})(SwapDirection || {});
var TokenType = /* @__PURE__ */ ((TokenType2) => {
  TokenType2[TokenType2["TokenA"] = 1] = "TokenA";
  TokenType2[TokenType2["TokenB"] = 2] = "TokenB";
  return TokenType2;
})(TokenType || {});

// src/utils/public/pool-utils.ts
var PoolUtil = class {
  constructor() {
  }
  static isRewardInitialized(rewardInfo) {
    return !PublicKey2.default.equals(rewardInfo.mint) && !PublicKey2.default.equals(rewardInfo.vault);
  }
  static getTokenType(pool, mint) {
    if (pool.tokenMintA.equals(mint)) {
      return 1 /* TokenA */;
    } else if (pool.tokenMintB.equals(mint)) {
      return 2 /* TokenB */;
    }
    return void 0;
  }
  static getFeeRate(feeRate) {
    return Percentage.fromFraction(feeRate, 1e6);
  }
  static getProtocolFeeRate(protocolFeeRate) {
    return Percentage.fromFraction(protocolFeeRate, 1e4);
  }
  static orderMints(mintX, mintY) {
    let mintA, mintB;
    if (Buffer.compare(
      AddressUtil2.toPubKey(mintX).toBuffer(),
      AddressUtil2.toPubKey(mintY).toBuffer()
    ) < 0) {
      mintA = mintX;
      mintB = mintY;
    } else {
      mintA = mintY;
      mintB = mintX;
    }
    return [mintA, mintB];
  }
  static getTokenAmountsFromLiquidity(liquidity, currentSqrtPrice, lowerSqrtPrice, upperSqrtPrice, round_up) {
    const _liquidity = new Decimal2(liquidity.toString());
    const _currentPrice = new Decimal2(currentSqrtPrice.toString());
    const _lowerPrice = new Decimal2(lowerSqrtPrice.toString());
    const _upperPrice = new Decimal2(upperSqrtPrice.toString());
    let tokenA, tokenB;
    if (currentSqrtPrice.lt(lowerSqrtPrice)) {
      tokenA = MathUtil2.toX64_Decimal(_liquidity).mul(_upperPrice.sub(_lowerPrice)).div(_lowerPrice.mul(_upperPrice));
      tokenB = new Decimal2(0);
    } else if (currentSqrtPrice.lt(upperSqrtPrice)) {
      tokenA = MathUtil2.toX64_Decimal(_liquidity).mul(_upperPrice.sub(_currentPrice)).div(_currentPrice.mul(_upperPrice));
      tokenB = MathUtil2.fromX64_Decimal(_liquidity.mul(_currentPrice.sub(_lowerPrice)));
    } else {
      tokenA = new Decimal2(0);
      tokenB = MathUtil2.fromX64_Decimal(_liquidity.mul(_upperPrice.sub(_lowerPrice)));
    }
    if (round_up) {
      return {
        tokenA: new u64(tokenA.ceil().toString()),
        tokenB: new u64(tokenB.ceil().toString())
      };
    } else {
      return {
        tokenA: new u64(tokenA.floor().toString()),
        tokenB: new u64(tokenB.floor().toString())
      };
    }
  }
  static estimateLiquidityFromTokenAmounts(currTick, lowerTick, upperTick, tokenAmount) {
    if (upperTick < lowerTick) {
      throw new Error("upper tick cannot be lower than the lower tick");
    }
    const currSqrtPrice = PriceMath.tickIndexToSqrtPriceX64(currTick);
    const lowerSqrtPrice = PriceMath.tickIndexToSqrtPriceX64(lowerTick);
    const upperSqrtPrice = PriceMath.tickIndexToSqrtPriceX64(upperTick);
    if (currTick >= upperTick) {
      return estLiquidityForTokenB(upperSqrtPrice, lowerSqrtPrice, tokenAmount.tokenB);
    } else if (currTick < lowerTick) {
      return estLiquidityForTokenA(lowerSqrtPrice, upperSqrtPrice, tokenAmount.tokenA);
    } else {
      const estLiquidityAmountA = estLiquidityForTokenA(
        currSqrtPrice,
        upperSqrtPrice,
        tokenAmount.tokenA
      );
      const estLiquidityAmountB = estLiquidityForTokenB(
        currSqrtPrice,
        lowerSqrtPrice,
        tokenAmount.tokenB
      );
      return BN5.min(estLiquidityAmountA, estLiquidityAmountB);
    }
  }
  static toBaseQuoteOrder(tokenMintAKey, tokenMintBKey) {
    const pair = [tokenMintAKey, tokenMintBKey];
    return pair.sort(sortByQuotePriority);
  }
};
function toTokenAmount(a, b) {
  return {
    tokenA: new u64(a.toString()),
    tokenB: new u64(b.toString())
  };
}
var QUOTE_TOKENS = {
  Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB: 100,
  EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v: 90,
  USDH1SM1ojwWUga67PGrgFWUHibbjqMvuMaDkRJTgkX: 80,
  So11111111111111111111111111111111111111112: 70,
  mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So: 60,
  "7dHbWXmci3dT8UFYWYZweBLXgycu7Y3iL6trKn1Y7ARj": 50
};
var DEFAULT_QUOTE_PRIORITY = 0;
function getQuoteTokenPriority(mint) {
  const value = QUOTE_TOKENS[mint];
  if (value) {
    return value;
  }
  return DEFAULT_QUOTE_PRIORITY;
}
function sortByQuotePriority(mintLeft, mintRight) {
  return getQuoteTokenPriority(mintLeft.toString()) - getQuoteTokenPriority(mintRight.toString());
}
function estLiquidityForTokenA(sqrtPrice1, sqrtPrice2, tokenAmount) {
  const lowerSqrtPriceX64 = BN5.min(sqrtPrice1, sqrtPrice2);
  const upperSqrtPriceX64 = BN5.max(sqrtPrice1, sqrtPrice2);
  const num = MathUtil2.fromX64_BN(tokenAmount.mul(upperSqrtPriceX64).mul(lowerSqrtPriceX64));
  const dem = upperSqrtPriceX64.sub(lowerSqrtPriceX64);
  return num.div(dem);
}
function estLiquidityForTokenB(sqrtPrice1, sqrtPrice2, tokenAmount) {
  const lowerSqrtPriceX64 = BN5.min(sqrtPrice1, sqrtPrice2);
  const upperSqrtPriceX64 = BN5.max(sqrtPrice1, sqrtPrice2);
  const delta = upperSqrtPriceX64.sub(lowerSqrtPriceX64);
  return tokenAmount.shln(64).div(delta);
}

// src/utils/public/swap-utils.ts
import { ZERO, U64_MAX } from "@orca-so/common-sdk";
import BN6 from "bn.js";
var SwapUtils = class {
  static getDefaultSqrtPriceLimit(aToB) {
    return new BN6(aToB ? MIN_SQRT_PRICE : MAX_SQRT_PRICE);
  }
  static getDefaultOtherAmountThreshold(amountSpecifiedIsInput) {
    return amountSpecifiedIsInput ? ZERO : U64_MAX;
  }
  static getSwapDirection(pool, swapTokenMint, swapTokenIsInput) {
    const tokenType = PoolUtil.getTokenType(pool, swapTokenMint);
    if (!tokenType) {
      return void 0;
    }
    return tokenType === 1 /* TokenA */ === swapTokenIsInput ? "aToB" /* AtoB */ : "bToA" /* BtoA */;
  }
  static getTickArrayPublicKeys(tickCurrentIndex, tickSpacing, aToB, programId, whirlpoolAddress) {
    const shift = aToB ? 0 : tickSpacing;
    let offset = 0;
    let tickArrayAddresses = [];
    for (let i = 0; i < MAX_SWAP_TICK_ARRAYS; i++) {
      let startIndex;
      try {
        startIndex = TickUtil.getStartTickIndex(tickCurrentIndex + shift, tickSpacing, offset);
      } catch {
        return tickArrayAddresses;
      }
      const pda = PDAUtil.getTickArray(programId, whirlpoolAddress, startIndex);
      tickArrayAddresses.push(pda.publicKey);
      offset = aToB ? offset - 1 : offset + 1;
    }
    return tickArrayAddresses;
  }
  static async getTickArrays(tickCurrentIndex, tickSpacing, aToB, programId, whirlpoolAddress, fetcher, refresh) {
    const addresses = SwapUtils.getTickArrayPublicKeys(
      tickCurrentIndex,
      tickSpacing,
      aToB,
      programId,
      whirlpoolAddress
    );
    const data = await fetcher.listTickArrays(addresses, refresh);
    return addresses.map((addr, index) => {
      return {
        address: addr,
        data: data[index]
      };
    });
  }
  static calculateSwapAmountsFromQuote(amount, amountSpecifiedIsInput) {
    if (amountSpecifiedIsInput) {
      return {
        amount
      };
    } else {
      return {
        amount
      };
    }
  }
};

// src/utils/spl-token-utils.ts
import {
  AccountLayout,
  ASSOCIATED_TOKEN_PROGRAM_ID,
  NATIVE_MINT,
  Token,
  TOKEN_PROGRAM_ID as TOKEN_PROGRAM_ID5
} from "@solana/spl-token";
import { Keypair, PublicKey as PublicKey3, SystemProgram } from "@solana/web3.js";
function getAssociatedTokenAddressSync(mint, owner, programId = TOKEN_PROGRAM_ID5, associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID) {
  const [address] = PublicKey3.findProgramAddressSync(
    [new PublicKey3(owner).toBuffer(), programId.toBuffer(), new PublicKey3(mint).toBuffer()],
    associatedTokenProgramId
  );
  return address;
}
function createWSOLAccountInstructions(owner, amountToWrap, accountExemption, payer, unwrapDestination) {
  const payerKey = payer ?? owner;
  const unwrapDestinationKey = unwrapDestination ?? payer ?? owner;
  const tempAccount = new Keypair();
  const createIx = SystemProgram.createAccount({
    fromPubkey: payerKey,
    newAccountPubkey: tempAccount.publicKey,
    lamports: amountToWrap.toNumber() + accountExemption,
    space: AccountLayout.span,
    programId: TOKEN_PROGRAM_ID5
  });
  const initIx = Token.createInitAccountInstruction(
    TOKEN_PROGRAM_ID5,
    NATIVE_MINT,
    tempAccount.publicKey,
    owner
  );
  const closeIx = Token.createCloseAccountInstruction(
    TOKEN_PROGRAM_ID5,
    tempAccount.publicKey,
    unwrapDestinationKey,
    owner,
    []
  );
  return {
    address: tempAccount.publicKey,
    instructions: [createIx, initIx],
    cleanupInstructions: [closeIx],
    signers: [tempAccount]
  };
}

// src/utils/txn-utils.ts
function convertListToMap(fetchedData, addresses) {
  const result = {};
  fetchedData.forEach((data, index) => {
    if (data) {
      const addr = addresses[index];
      result[addr] = data;
    }
  });
  return result;
}

// src/utils/whirlpool-ata-utils.ts
import { resolveOrCreateATAs, TokenUtil } from "@orca-so/common-sdk";
function getTokenMintsFromWhirlpools(whirlpoolDatas, mintTypes = "ALL" /* ALL */) {
  let hasNativeMint = false;
  const mints = Array.from(
    whirlpoolDatas.reduce((accu, whirlpoolData) => {
      if (whirlpoolData) {
        if (mintTypes === "ALL" /* ALL */ || mintTypes === "POOL_ONLY" /* POOL_ONLY */) {
          const { tokenMintA, tokenMintB } = whirlpoolData;
          if (!TokenUtil.isNativeMint(tokenMintA)) {
            accu.add(tokenMintA);
          } else {
            hasNativeMint = true;
          }
          if (!TokenUtil.isNativeMint(tokenMintB)) {
            accu.add(tokenMintB);
          } else {
            hasNativeMint = true;
          }
        }
        if (mintTypes === "ALL" /* ALL */ || mintTypes === "REWARDS_ONLY" /* REWARD_ONLY */) {
          const rewardInfos = whirlpoolData.rewardInfos;
          rewardInfos.forEach((reward) => {
            if (TokenUtil.isNativeMint(reward.mint)) {
              hasNativeMint = true;
            }
            if (PoolUtil.isRewardInitialized(reward)) {
              accu.add(reward.mint);
            }
          });
        }
      }
      return accu;
    }, /* @__PURE__ */ new Set())
  );
  return {
    mintMap: mints,
    hasNativeMint
  };
}
async function resolveAtaForMints(ctx, params) {
  const { mints, receiver, payer, accountExemption } = params;
  const receiverKey = receiver ?? ctx.wallet.publicKey;
  const payerKey = payer ?? ctx.wallet.publicKey;
  const resolvedAtaResults = await resolveOrCreateATAs(
    ctx.connection,
    receiverKey,
    mints.map((tokenMint) => {
      return { tokenMint };
    }),
    async () => accountExemption,
    payerKey
  );
  const { resolveAtaIxs, resolvedAtas } = resolvedAtaResults.reduce(
    (accu, curr) => {
      const { address, ...ix } = curr;
      accu.resolvedAtas.push(address);
      if (ix.instructions.length) {
        accu.resolveAtaIxs.push(ix);
      }
      return accu;
    },
    { resolvedAtas: [], resolveAtaIxs: [] }
  );
  const affliatedTokenAtaMap = convertListToMap(
    resolvedAtas,
    mints.map((mint) => mint.toBase58())
  );
  return {
    ataTokenAddresses: affliatedTokenAtaMap,
    resolveAtaIxs
  };
}

// src/instructions/update-fees-and-rewards-ix.ts
function updateFeesAndRewardsIx(program, params) {
  const { whirlpool, position, tickArrayLower, tickArrayUpper } = params;
  const ix = program.instruction.updateFeesAndRewards({
    accounts: {
      whirlpool,
      position,
      tickArrayLower,
      tickArrayUpper
    }
  });
  return {
    instructions: [ix],
    cleanupInstructions: [],
    signers: []
  };
}

// src/instructions/composites/collect-all-txn.ts
async function collectAllForPositionAddressesTxns(ctx, params, refresh = false) {
  const { positions, ...rest } = params;
  const posData = convertListToMap(
    await ctx.fetcher.listPositions(positions, refresh),
    positions.map((pos) => pos.toString())
  );
  const positionMap = {};
  Object.entries(posData).forEach(([addr, pos]) => {
    if (pos) {
      positionMap[addr] = pos;
    }
  });
  return collectAllForPositionsTxns(ctx, { positions: positionMap, ...rest });
}
async function collectAllForPositionsTxns(ctx, params) {
  const { positions, receiver, positionAuthority, positionOwner, payer } = params;
  const receiverKey = receiver ?? ctx.wallet.publicKey;
  const positionAuthorityKey = positionAuthority ?? ctx.wallet.publicKey;
  const positionOwnerKey = positionOwner ?? ctx.wallet.publicKey;
  const payerKey = payer ?? ctx.wallet.publicKey;
  const positionList = Object.entries(positions);
  if (positionList.length === 0) {
    return [];
  }
  const whirlpoolAddrs = positionList.map(([, pos]) => pos.whirlpool.toBase58());
  const whirlpoolDatas = await ctx.fetcher.listPools(whirlpoolAddrs, false);
  const whirlpools = convertListToMap(whirlpoolDatas, whirlpoolAddrs);
  const accountExemption = await ctx.fetcher.getAccountRentExempt();
  const { ataTokenAddresses: affliatedTokenAtaMap, resolveAtaIxs } = await resolveAtaForMints(ctx, {
    mints: getTokenMintsFromWhirlpools(whirlpoolDatas).mintMap,
    accountExemption,
    receiver: receiverKey,
    payer: payerKey
  });
  const latestBlockhash = await ctx.connection.getLatestBlockhash("singleGossip");
  const txBuilders = [];
  let pendingTxBuilder = new TransactionBuilder2(ctx.connection, ctx.wallet).addInstructions(
    resolveAtaIxs
  );
  let pendingTxBuilderTxSize = await pendingTxBuilder.txnSize({ latestBlockhash });
  let posIndex = 0;
  let reattempt = false;
  while (posIndex < positionList.length) {
    const [positionAddr, position] = positionList[posIndex];
    let positionTxBuilder = new TransactionBuilder2(ctx.connection, ctx.wallet);
    const { whirlpool: whirlpoolKey, positionMint } = position;
    const whirlpool = whirlpools[whirlpoolKey.toBase58()];
    if (!whirlpool) {
      throw new Error(
        `Unable to process positionMint ${positionMint} - unable to derive whirlpool ${whirlpoolKey.toBase58()}`
      );
    }
    const posHandlesNativeMint = TokenUtil2.isNativeMint(whirlpool.tokenMintA) || TokenUtil2.isNativeMint(whirlpool.tokenMintB);
    const txBuilderHasNativeMint = !!affliatedTokenAtaMap[NATIVE_MINT2.toBase58()];
    if (posHandlesNativeMint && !txBuilderHasNativeMint) {
      addNativeMintHandlingIx(
        positionTxBuilder,
        affliatedTokenAtaMap,
        receiverKey,
        accountExemption
      );
    }
    const collectIxForPosition = constructCollectPositionIx(
      ctx,
      new PublicKey4(positionAddr),
      position,
      whirlpools,
      positionOwnerKey,
      positionAuthorityKey,
      affliatedTokenAtaMap
    );
    positionTxBuilder.addInstructions(collectIxForPosition);
    const incrementTxSize = await positionTxBuilder.txnSize({ latestBlockhash });
    if (pendingTxBuilderTxSize + incrementTxSize < PACKET_DATA_SIZE) {
      pendingTxBuilder.addInstruction(positionTxBuilder.compressIx(false));
      pendingTxBuilderTxSize = pendingTxBuilderTxSize + incrementTxSize;
      posIndex += 1;
      reattempt = false;
    } else {
      if (reattempt) {
        throw new Error(
          `Unable to fit collection ix for ${position.positionMint.toBase58()} in a Transaction.`
        );
      }
      txBuilders.push(pendingTxBuilder);
      delete affliatedTokenAtaMap[NATIVE_MINT2.toBase58()];
      pendingTxBuilder = new TransactionBuilder2(ctx.connection, ctx.provider.wallet);
      pendingTxBuilderTxSize = 0;
      reattempt = true;
    }
  }
  txBuilders.push(pendingTxBuilder);
  return txBuilders;
}
function addNativeMintHandlingIx(txBuilder, affliatedTokenAtaMap, destinationWallet, accountExemption) {
  let { address: wSOLAta, ...resolveWSolIx } = createWSOLAccountInstructions2(
    destinationWallet,
    ZERO2,
    accountExemption
  );
  affliatedTokenAtaMap[NATIVE_MINT2.toBase58()] = wSOLAta;
  txBuilder.prependInstruction(resolveWSolIx);
}
var constructCollectPositionIx = (ctx, positionKey, position, whirlpools, positionOwner, positionAuthority, affliatedTokenAtaMap) => {
  const ixForPosition = [];
  const {
    whirlpool: whirlpoolKey,
    liquidity,
    tickLowerIndex,
    tickUpperIndex,
    positionMint,
    rewardInfos: positionRewardInfos
  } = position;
  const whirlpool = whirlpools[whirlpoolKey.toBase58()];
  if (!whirlpool) {
    throw new Error(
      `Unable to process positionMint ${positionMint} - unable to derive whirlpool ${whirlpoolKey.toBase58()}`
    );
  }
  const { tickSpacing } = whirlpool;
  if (!liquidity.eq(ZERO2)) {
    ixForPosition.push(
      updateFeesAndRewardsIx(ctx.program, {
        position: positionKey,
        whirlpool: whirlpoolKey,
        tickArrayLower: PDAUtil.getTickArray(
          ctx.program.programId,
          whirlpoolKey,
          TickUtil.getStartTickIndex(tickLowerIndex, tickSpacing)
        ).publicKey,
        tickArrayUpper: PDAUtil.getTickArray(
          ctx.program.programId,
          whirlpoolKey,
          TickUtil.getStartTickIndex(tickUpperIndex, tickSpacing)
        ).publicKey
      })
    );
  }
  const positionTokenAccount = getAssociatedTokenAddressSync(
    positionMint.toBase58(),
    positionOwner.toBase58()
  );
  ixForPosition.push(
    WhirlpoolIx.collectFeesIx(ctx.program, {
      whirlpool: whirlpoolKey,
      position: positionKey,
      positionAuthority,
      positionTokenAccount,
      tokenOwnerAccountA: affliatedTokenAtaMap[whirlpool.tokenMintA.toBase58()],
      tokenOwnerAccountB: affliatedTokenAtaMap[whirlpool.tokenMintB.toBase58()],
      tokenVaultA: whirlpool.tokenVaultA,
      tokenVaultB: whirlpool.tokenVaultB
    })
  );
  positionRewardInfos.forEach((_, index) => {
    const rewardInfo = whirlpool.rewardInfos[index];
    if (PoolUtil.isRewardInitialized(rewardInfo)) {
      ixForPosition.push(
        WhirlpoolIx.collectRewardIx(ctx.program, {
          whirlpool: whirlpoolKey,
          position: positionKey,
          positionAuthority,
          positionTokenAccount,
          rewardIndex: index,
          rewardOwnerAccount: affliatedTokenAtaMap[rewardInfo.mint.toBase58()],
          rewardVault: rewardInfo.vault
        })
      );
    }
  });
  return ixForPosition;
};

// src/instructions/decrease-liquidity-ix.ts
import { TOKEN_PROGRAM_ID as TOKEN_PROGRAM_ID6 } from "@solana/spl-token";
function decreaseLiquidityIx(program, params) {
  const {
    liquidityAmount,
    tokenMinA,
    tokenMinB,
    whirlpool,
    positionAuthority,
    position,
    positionTokenAccount,
    tokenOwnerAccountA,
    tokenOwnerAccountB,
    tokenVaultA,
    tokenVaultB,
    tickArrayLower,
    tickArrayUpper
  } = params;
  const ix = program.instruction.decreaseLiquidity(liquidityAmount, tokenMinA, tokenMinB, {
    accounts: {
      whirlpool,
      tokenProgram: TOKEN_PROGRAM_ID6,
      positionAuthority,
      position,
      positionTokenAccount,
      tokenOwnerAccountA,
      tokenOwnerAccountB,
      tokenVaultA,
      tokenVaultB,
      tickArrayLower,
      tickArrayUpper
    }
  });
  return {
    instructions: [ix],
    cleanupInstructions: [],
    signers: []
  };
}

// src/instructions/increase-liquidity-ix.ts
import { TOKEN_PROGRAM_ID as TOKEN_PROGRAM_ID7 } from "@solana/spl-token";
function increaseLiquidityIx(program, params) {
  const {
    liquidityAmount,
    tokenMaxA,
    tokenMaxB,
    whirlpool,
    positionAuthority,
    position,
    positionTokenAccount,
    tokenOwnerAccountA,
    tokenOwnerAccountB,
    tokenVaultA,
    tokenVaultB,
    tickArrayLower,
    tickArrayUpper
  } = params;
  const ix = program.instruction.increaseLiquidity(liquidityAmount, tokenMaxA, tokenMaxB, {
    accounts: {
      whirlpool,
      tokenProgram: TOKEN_PROGRAM_ID7,
      positionAuthority,
      position,
      positionTokenAccount,
      tokenOwnerAccountA,
      tokenOwnerAccountB,
      tokenVaultA,
      tokenVaultB,
      tickArrayLower,
      tickArrayUpper
    }
  });
  return {
    instructions: [ix],
    cleanupInstructions: [],
    signers: []
  };
}

// src/instructions/initialize-config-ix.ts
import { SystemProgram as SystemProgram2 } from "@solana/web3.js";
function initializeConfigIx(program, params) {
  const {
    feeAuthority,
    collectProtocolFeesAuthority,
    rewardEmissionsSuperAuthority,
    defaultProtocolFeeRate,
    funder
  } = params;
  const ix = program.instruction.initializeConfig(
    feeAuthority,
    collectProtocolFeesAuthority,
    rewardEmissionsSuperAuthority,
    defaultProtocolFeeRate,
    {
      accounts: {
        config: params.whirlpoolsConfigKeypair.publicKey,
        funder,
        systemProgram: SystemProgram2.programId
      }
    }
  );
  return {
    instructions: [ix],
    cleanupInstructions: [],
    signers: [params.whirlpoolsConfigKeypair]
  };
}

// src/instructions/initialize-fee-tier-ix.ts
import { SystemProgram as SystemProgram3 } from "@solana/web3.js";
function initializeFeeTierIx(program, params) {
  const { feeTierPda, whirlpoolsConfig, tickSpacing, feeAuthority, defaultFeeRate, funder } = params;
  const ix = program.instruction.initializeFeeTier(tickSpacing, defaultFeeRate, {
    accounts: {
      config: whirlpoolsConfig,
      feeTier: feeTierPda.publicKey,
      feeAuthority,
      funder,
      systemProgram: SystemProgram3.programId
    }
  });
  return {
    instructions: [ix],
    cleanupInstructions: [],
    signers: []
  };
}

// src/instructions/initialize-pool-ix.ts
import { SystemProgram as SystemProgram4, SYSVAR_RENT_PUBKEY } from "@solana/web3.js";
import { TOKEN_PROGRAM_ID as TOKEN_PROGRAM_ID8 } from "@solana/spl-token";
function initializePoolIx(program, params) {
  const {
    initSqrtPrice,
    tokenMintA,
    tokenMintB,
    whirlpoolsConfig,
    whirlpoolPda,
    feeTierKey,
    tokenVaultAKeypair,
    tokenVaultBKeypair,
    tickSpacing,
    funder
  } = params;
  const whirlpoolBumps = {
    whirlpoolBump: whirlpoolPda.bump
  };
  const ix = program.instruction.initializePool(whirlpoolBumps, tickSpacing, initSqrtPrice, {
    accounts: {
      whirlpoolsConfig,
      tokenMintA,
      tokenMintB,
      funder,
      whirlpool: whirlpoolPda.publicKey,
      tokenVaultA: tokenVaultAKeypair.publicKey,
      tokenVaultB: tokenVaultBKeypair.publicKey,
      feeTier: feeTierKey,
      tokenProgram: TOKEN_PROGRAM_ID8,
      systemProgram: SystemProgram4.programId,
      rent: SYSVAR_RENT_PUBKEY
    }
  });
  return {
    instructions: [ix],
    cleanupInstructions: [],
    signers: [tokenVaultAKeypair, tokenVaultBKeypair]
  };
}

// src/instructions/initialize-reward-ix.ts
import * as anchor from "@project-serum/anchor";
import { TOKEN_PROGRAM_ID as TOKEN_PROGRAM_ID9 } from "@solana/spl-token";
import { SystemProgram as SystemProgram5 } from "@solana/web3.js";
function initializeRewardIx(program, params) {
  const { rewardAuthority, funder, whirlpool, rewardMint, rewardVaultKeypair, rewardIndex } = params;
  const ix = program.instruction.initializeReward(rewardIndex, {
    accounts: {
      rewardAuthority,
      funder,
      whirlpool,
      rewardMint,
      rewardVault: rewardVaultKeypair.publicKey,
      tokenProgram: TOKEN_PROGRAM_ID9,
      systemProgram: SystemProgram5.programId,
      rent: anchor.web3.SYSVAR_RENT_PUBKEY
    }
  });
  return {
    instructions: [ix],
    cleanupInstructions: [],
    signers: [rewardVaultKeypair]
  };
}

// src/instructions/initialize-tick-array-ix.ts
import * as anchor2 from "@project-serum/anchor";
function initTickArrayIx(program, params) {
  const { whirlpool, funder, tickArrayPda } = params;
  const ix = program.instruction.initializeTickArray(params.startTick, {
    accounts: {
      whirlpool,
      funder,
      tickArray: tickArrayPda.publicKey,
      systemProgram: anchor2.web3.SystemProgram.programId
    }
  });
  return {
    instructions: [ix],
    cleanupInstructions: [],
    signers: []
  };
}

// src/instructions/open-position-ix.ts
import { PublicKey as PublicKey9 } from "@solana/web3.js";

// src/utils/instructions-util.ts
import { TOKEN_PROGRAM_ID as TOKEN_PROGRAM_ID10, ASSOCIATED_TOKEN_PROGRAM_ID as ASSOCIATED_TOKEN_PROGRAM_ID2 } from "@solana/spl-token";
import * as anchor3 from "@project-serum/anchor";
import { SystemProgram as SystemProgram6 } from "@solana/web3.js";
function openPositionAccounts(params) {
  const {
    funder,
    owner,
    positionPda,
    positionMintAddress,
    positionTokenAccount: positionTokenAccountAddress,
    whirlpool: whirlpoolKey
  } = params;
  return {
    funder,
    owner,
    position: positionPda.publicKey,
    positionMint: positionMintAddress,
    positionTokenAccount: positionTokenAccountAddress,
    whirlpool: whirlpoolKey,
    tokenProgram: TOKEN_PROGRAM_ID10,
    systemProgram: SystemProgram6.programId,
    rent: anchor3.web3.SYSVAR_RENT_PUBKEY,
    associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID2
  };
}

// src/instructions/open-position-ix.ts
function openPositionIx(program, params) {
  const { positionPda, tickLowerIndex, tickUpperIndex } = params;
  const bumps = {
    positionBump: positionPda.bump
  };
  const ix = program.instruction.openPosition(bumps, tickLowerIndex, tickUpperIndex, {
    accounts: openPositionAccounts(params)
  });
  return {
    instructions: [ix],
    cleanupInstructions: [],
    signers: []
  };
}
function openPositionWithMetadataIx(program, params) {
  const { positionPda, metadataPda, tickLowerIndex, tickUpperIndex } = params;
  const bumps = {
    positionBump: positionPda.bump,
    metadataBump: metadataPda.bump
  };
  const ix = program.instruction.openPositionWithMetadata(bumps, tickLowerIndex, tickUpperIndex, {
    accounts: {
      ...openPositionAccounts(params),
      positionMetadataAccount: metadataPda.publicKey,
      metadataProgram: METADATA_PROGRAM_ADDRESS,
      metadataUpdateAuth: new PublicKey9("3axbTs2z5GBy6usVbNVoqEgZMng3vZvMnAoX29BFfwhr")
    }
  });
  return {
    instructions: [ix],
    cleanupInstructions: [],
    signers: []
  };
}

// src/instructions/set-collect-protocol-fees-authority-ix.ts
function setCollectProtocolFeesAuthorityIx(program, params) {
  const { whirlpoolsConfig, collectProtocolFeesAuthority, newCollectProtocolFeesAuthority } = params;
  const ix = program.instruction.setCollectProtocolFeesAuthority({
    accounts: {
      whirlpoolsConfig,
      collectProtocolFeesAuthority,
      newCollectProtocolFeesAuthority
    }
  });
  return {
    instructions: [ix],
    cleanupInstructions: [],
    signers: []
  };
}

// src/instructions/set-default-fee-rate-ix.ts
function setDefaultFeeRateIx(program, params) {
  const { whirlpoolsConfig, feeAuthority, tickSpacing, defaultFeeRate } = params;
  const feeTierPda = PDAUtil.getFeeTier(program.programId, whirlpoolsConfig, tickSpacing);
  const ix = program.instruction.setDefaultFeeRate(defaultFeeRate, {
    accounts: {
      whirlpoolsConfig,
      feeTier: feeTierPda.publicKey,
      feeAuthority
    }
  });
  return {
    instructions: [ix],
    cleanupInstructions: [],
    signers: []
  };
}

// src/instructions/set-default-protocol-fee-rate-ix.ts
function setDefaultProtocolFeeRateIx(program, params) {
  const { whirlpoolsConfig, feeAuthority, defaultProtocolFeeRate } = params;
  const ix = program.instruction.setDefaultProtocolFeeRate(defaultProtocolFeeRate, {
    accounts: {
      whirlpoolsConfig,
      feeAuthority
    }
  });
  return {
    instructions: [ix],
    cleanupInstructions: [],
    signers: []
  };
}

// src/instructions/set-fee-authority-ix.ts
function setFeeAuthorityIx(program, params) {
  const { whirlpoolsConfig, feeAuthority, newFeeAuthority } = params;
  const ix = program.instruction.setFeeAuthority({
    accounts: {
      whirlpoolsConfig,
      feeAuthority,
      newFeeAuthority
    }
  });
  return {
    instructions: [ix],
    cleanupInstructions: [],
    signers: []
  };
}

// src/instructions/set-fee-rate-ix.ts
function setFeeRateIx(program, params) {
  const { whirlpoolsConfig, whirlpool, feeAuthority, feeRate } = params;
  const ix = program.instruction.setFeeRate(feeRate, {
    accounts: {
      whirlpoolsConfig,
      whirlpool,
      feeAuthority
    }
  });
  return {
    instructions: [ix],
    cleanupInstructions: [],
    signers: []
  };
}

// src/instructions/set-protocol-fee-rate-ix.ts
function setProtocolFeeRateIx(program, params) {
  const { whirlpoolsConfig, whirlpool, feeAuthority, protocolFeeRate } = params;
  const ix = program.instruction.setProtocolFeeRate(protocolFeeRate, {
    accounts: {
      whirlpoolsConfig,
      whirlpool,
      feeAuthority
    }
  });
  return {
    instructions: [ix],
    cleanupInstructions: [],
    signers: []
  };
}

// src/instructions/set-reward-authority-by-super-authority-ix.ts
function setRewardAuthorityBySuperAuthorityIx(program, params) {
  const {
    whirlpoolsConfig,
    whirlpool,
    rewardEmissionsSuperAuthority,
    newRewardAuthority,
    rewardIndex
  } = params;
  const ix = program.instruction.setRewardAuthorityBySuperAuthority(rewardIndex, {
    accounts: {
      whirlpoolsConfig,
      whirlpool,
      rewardEmissionsSuperAuthority,
      newRewardAuthority
    }
  });
  return {
    instructions: [ix],
    cleanupInstructions: [],
    signers: []
  };
}

// src/instructions/set-reward-authority-ix.ts
function setRewardAuthorityIx(program, params) {
  const { whirlpool, rewardAuthority, newRewardAuthority, rewardIndex } = params;
  const ix = program.instruction.setRewardAuthority(rewardIndex, {
    accounts: {
      whirlpool,
      rewardAuthority,
      newRewardAuthority
    }
  });
  return {
    instructions: [ix],
    cleanupInstructions: [],
    signers: []
  };
}

// src/instructions/set-reward-emissions-ix.ts
function setRewardEmissionsIx(program, params) {
  const {
    rewardAuthority,
    whirlpool,
    rewardIndex,
    rewardVaultKey: rewardVault,
    emissionsPerSecondX64
  } = params;
  const ix = program.instruction.setRewardEmissions(rewardIndex, emissionsPerSecondX64, {
    accounts: {
      rewardAuthority,
      whirlpool,
      rewardVault
    }
  });
  return {
    instructions: [ix],
    cleanupInstructions: [],
    signers: []
  };
}

// src/instructions/set-reward-emissions-super-authority-ix.ts
function setRewardEmissionsSuperAuthorityIx(program, params) {
  const { whirlpoolsConfig, rewardEmissionsSuperAuthority, newRewardEmissionsSuperAuthority } = params;
  const ix = program.instruction.setRewardEmissionsSuperAuthority({
    accounts: {
      whirlpoolsConfig,
      rewardEmissionsSuperAuthority,
      newRewardEmissionsSuperAuthority
    }
  });
  return {
    instructions: [ix],
    cleanupInstructions: [],
    signers: []
  };
}

// src/instructions/swap-ix.ts
import { TOKEN_PROGRAM_ID as TOKEN_PROGRAM_ID11 } from "@solana/spl-token";
function swapIx(program, params) {
  const {
    amount,
    otherAmountThreshold,
    sqrtPriceLimit,
    amountSpecifiedIsInput,
    aToB,
    whirlpool,
    tokenAuthority,
    tokenOwnerAccountA,
    tokenVaultA,
    tokenOwnerAccountB,
    tokenVaultB,
    tickArray0,
    tickArray1,
    tickArray2,
    oracle
  } = params;
  const ix = program.instruction.swap(
    amount,
    otherAmountThreshold,
    sqrtPriceLimit,
    amountSpecifiedIsInput,
    aToB,
    {
      accounts: {
        tokenProgram: TOKEN_PROGRAM_ID11,
        tokenAuthority,
        whirlpool,
        tokenOwnerAccountA,
        tokenVaultA,
        tokenOwnerAccountB,
        tokenVaultB,
        tickArray0,
        tickArray1,
        tickArray2,
        oracle
      }
    }
  );
  return {
    instructions: [ix],
    cleanupInstructions: [],
    signers: []
  };
}

// src/network/public/parsing.ts
import { BorshAccountsCoder as BorshAccountsCoder2 } from "@project-serum/anchor";
import { TokenUtil as TokenUtil3 } from "@orca-so/common-sdk";
var ParsableWhirlpoolsConfig = class {
  constructor() {
  }
  static parse(data) {
    if (!data) {
      return null;
    }
    try {
      return parseAnchorAccount("WhirlpoolsConfig" /* WhirlpoolsConfig */, data);
    } catch (e) {
      console.error(`error while parsing WhirlpoolsConfig: ${e}`);
      return null;
    }
  }
};
ParsableWhirlpoolsConfig = __decorateClass([
  staticImplements()
], ParsableWhirlpoolsConfig);
var ParsableWhirlpool = class {
  constructor() {
  }
  static parse(data) {
    if (!data) {
      return null;
    }
    try {
      return parseAnchorAccount("Whirlpool" /* Whirlpool */, data);
    } catch (e) {
      console.error(`error while parsing Whirlpool: ${e}`);
      return null;
    }
  }
};
ParsableWhirlpool = __decorateClass([
  staticImplements()
], ParsableWhirlpool);
var ParsablePosition = class {
  constructor() {
  }
  static parse(data) {
    if (!data) {
      return null;
    }
    try {
      return parseAnchorAccount("Position" /* Position */, data);
    } catch (e) {
      console.error(`error while parsing Position: ${e}`);
      return null;
    }
  }
};
ParsablePosition = __decorateClass([
  staticImplements()
], ParsablePosition);
var ParsableTickArray = class {
  constructor() {
  }
  static parse(data) {
    if (!data) {
      return null;
    }
    try {
      return parseAnchorAccount("TickArray" /* TickArray */, data);
    } catch (e) {
      console.error(`error while parsing TickArray: ${e}`);
      return null;
    }
  }
};
ParsableTickArray = __decorateClass([
  staticImplements()
], ParsableTickArray);
var ParsableFeeTier = class {
  constructor() {
  }
  static parse(data) {
    if (!data) {
      return null;
    }
    try {
      return parseAnchorAccount("FeeTier" /* FeeTier */, data);
    } catch (e) {
      console.error(`error while parsing FeeTier: ${e}`);
      return null;
    }
  }
};
ParsableFeeTier = __decorateClass([
  staticImplements()
], ParsableFeeTier);
var ParsableTokenInfo = class {
  constructor() {
  }
  static parse(data) {
    if (!data) {
      return null;
    }
    try {
      return TokenUtil3.deserializeTokenAccount(data);
    } catch (e) {
      console.error(`error while parsing TokenAccount: ${e}`);
      return null;
    }
  }
};
ParsableTokenInfo = __decorateClass([
  staticImplements()
], ParsableTokenInfo);
var ParsableMintInfo = class {
  constructor() {
  }
  static parse(data) {
    if (!data) {
      return null;
    }
    try {
      const buffer = MintLayout.decode(data);
      const mintInfo = {
        mintAuthority: buffer.mintAuthorityOption === 0 ? null : new PublicKey10(buffer.mintAuthority),
        supply: u644.fromBuffer(buffer.supply),
        decimals: buffer.decimals,
        isInitialized: buffer.isInitialized !== 0,
        freezeAuthority: buffer.freezeAuthority === 0 ? null : new PublicKey10(buffer.freezeAuthority)
      };
      return mintInfo;
    } catch (e) {
      console.error(`error while parsing MintInfo: ${e}`);
      return null;
    }
  }
};
ParsableMintInfo = __decorateClass([
  staticImplements()
], ParsableMintInfo);
function staticImplements() {
  return (constructor) => {
    constructor;
  };
}
var WhirlpoolCoder = new BorshAccountsCoder2(whirlpool_exports);
function parseAnchorAccount(accountName, data) {
  const discriminator = BorshAccountsCoder2.accountDiscriminator(accountName);
  if (discriminator.compare(data.slice(0, 8))) {
    console.error("incorrect account name during parsing");
    return null;
  }
  try {
    return WhirlpoolCoder.decode(accountName, data);
  } catch (_e) {
    console.error("unknown account name during parsing");
    return null;
  }
}

// src/network/public/fetcher.ts
import { AddressUtil as AddressUtil3 } from "@orca-so/common-sdk";
var AccountFetcher = class {
  constructor(connection, cache) {
    this._cache = {};
    this.connection = connection;
    this._cache = cache ?? {};
  }
  async getAccountRentExempt(refresh = false) {
    if (!this._accountRentExempt || refresh) {
      this._accountRentExempt = await this.connection.getMinimumBalanceForRentExemption(
        AccountLayout2.span
      );
    }
    return this._accountRentExempt;
  }
  async getPool(address, refresh = false) {
    return this.get(AddressUtil3.toPubKey(address), ParsableWhirlpool, refresh);
  }
  async getPosition(address, refresh = false) {
    return this.get(AddressUtil3.toPubKey(address), ParsablePosition, refresh);
  }
  async getTickArray(address, refresh = false) {
    return this.get(AddressUtil3.toPubKey(address), ParsableTickArray, refresh);
  }
  async getFeeTier(address, refresh = false) {
    return this.get(AddressUtil3.toPubKey(address), ParsableFeeTier, refresh);
  }
  async getTokenInfo(address, refresh = false) {
    return this.get(AddressUtil3.toPubKey(address), ParsableTokenInfo, refresh);
  }
  async getMintInfo(address, refresh = false) {
    return this.get(AddressUtil3.toPubKey(address), ParsableMintInfo, refresh);
  }
  async getConfig(address, refresh = false) {
    return this.get(AddressUtil3.toPubKey(address), ParsableWhirlpoolsConfig, refresh);
  }
  async listPools(addresses, refresh) {
    return this.list(AddressUtil3.toPubKeys(addresses), ParsableWhirlpool, refresh);
  }
  async listPoolsWithParams({
    programId,
    configId
  }) {
    const filters = [
      { dataSize: WHIRLPOOL_ACCOUNT_SIZE },
      {
        memcmp: WHIRLPOOL_CODER.memcmp(
          "Whirlpool" /* Whirlpool */,
          AddressUtil3.toPubKey(configId).toBuffer()
        )
      }
    ];
    const accounts2 = await this.connection.getProgramAccounts(AddressUtil3.toPubKey(programId), {
      filters
    });
    const parsedAccounts = [];
    accounts2.forEach(({ pubkey, account }) => {
      const parsedAccount = ParsableWhirlpool.parse(account.data);
      invariant2(!!parsedAccount, `could not parse whirlpool: ${pubkey.toBase58()}`);
      parsedAccounts.push([pubkey, parsedAccount]);
      this._cache[pubkey.toBase58()] = { entity: ParsableWhirlpool, value: parsedAccount };
    });
    return parsedAccounts;
  }
  async listPositions(addresses, refresh) {
    return this.list(AddressUtil3.toPubKeys(addresses), ParsablePosition, refresh);
  }
  async listTickArrays(addresses, refresh) {
    return this.list(AddressUtil3.toPubKeys(addresses), ParsableTickArray, refresh);
  }
  async listTokenInfos(addresses, refresh) {
    return this.list(AddressUtil3.toPubKeys(addresses), ParsableTokenInfo, refresh);
  }
  async listMintInfos(addresses, refresh) {
    return this.list(AddressUtil3.toPubKeys(addresses), ParsableMintInfo, refresh);
  }
  async refreshAll() {
    const addresses = Object.keys(this._cache);
    const data = await this.bulkRequest(addresses);
    for (const [idx, [key, cachedContent]] of Object.entries(this._cache).entries()) {
      const entity = cachedContent.entity;
      const value = entity.parse(data[idx]);
      this._cache[key] = { entity, value };
    }
  }
  async get(address, entity, refresh) {
    var _a;
    const key = address.toBase58();
    const cachedValue = (_a = this._cache[key]) == null ? void 0 : _a.value;
    if (cachedValue !== void 0 && !refresh) {
      return cachedValue;
    }
    const accountInfo = await this.connection.getAccountInfo(address);
    const accountData = accountInfo == null ? void 0 : accountInfo.data;
    const value = entity.parse(accountData);
    this._cache[key] = { entity, value };
    return value;
  }
  async list(addresses, entity, refresh) {
    const keys = addresses.map((address) => address.toBase58());
    const cachedValues = keys.map((key) => {
      var _a;
      return [
        key,
        refresh ? void 0 : (_a = this._cache[key]) == null ? void 0 : _a.value
      ];
    });
    const undefinedAccounts = [];
    cachedValues.forEach(([key, value], cacheIndex) => {
      if (value === void 0) {
        undefinedAccounts.push({ cacheIndex, key });
      }
    });
    if (undefinedAccounts.length > 0) {
      const data = await this.bulkRequest(undefinedAccounts.map((account) => account.key));
      undefinedAccounts.forEach(({ cacheIndex, key }, dataIndex) => {
        var _a;
        const value = entity.parse(data[dataIndex]);
        invariant2(((_a = cachedValues[cacheIndex]) == null ? void 0 : _a[1]) === void 0, "unexpected non-undefined value");
        cachedValues[cacheIndex] = [key, value];
        this._cache[key] = { entity, value };
      });
    }
    const result = cachedValues.map(([_, value]) => value).filter((value) => value !== void 0);
    invariant2(result.length === addresses.length, "not enough results fetched");
    return result;
  }
  async bulkRequest(addresses) {
    const responses = [];
    const chunk = 100;
    for (let i = 0; i < addresses.length; i += chunk) {
      const addressesSubset = addresses.slice(i, i + chunk);
      const res = this.connection._rpcRequest("getMultipleAccounts", [
        addressesSubset,
        { commitment: this.connection.commitment }
      ]);
      responses.push(res);
    }
    const combinedResult = [];
    (await Promise.all(responses)).forEach((res) => {
      var _a;
      invariant2(!res.error, `bulkRequest result error: ${res.error}`);
      invariant2(!!((_a = res.result) == null ? void 0 : _a.value), "bulkRequest no value");
      res.result.value.forEach((account) => {
        if (!account || account.data[1] !== "base64") {
          combinedResult.push(null);
        } else {
          combinedResult.push(Buffer.from(account.data[0], account.data[1]));
        }
      });
    });
    invariant2(combinedResult.length === addresses.length, "bulkRequest not enough results");
    return combinedResult;
  }
};

// src/context.ts
var WhirlpoolContext2 = class {
  static from(connection, wallet, programId, fetcher = new AccountFetcher(connection), opts = AnchorProvider.defaultOptions()) {
    const anchorProvider = new AnchorProvider(connection, wallet, opts);
    const program = new Program(whirlpool_default, programId, anchorProvider);
    return new WhirlpoolContext2(anchorProvider, anchorProvider.wallet, program, fetcher, opts);
  }
  static fromWorkspace(provider, program, fetcher = new AccountFetcher(provider.connection), opts = AnchorProvider.defaultOptions()) {
    return new WhirlpoolContext2(provider, provider.wallet, program, fetcher, opts);
  }
  static withProvider(provider, programId, fetcher = new AccountFetcher(provider.connection), opts = AnchorProvider.defaultOptions()) {
    const program = new Program(whirlpool_default, programId, provider);
    return new WhirlpoolContext2(provider, provider.wallet, program, fetcher, opts);
  }
  constructor(provider, wallet, program, fetcher, opts) {
    this.connection = provider.connection;
    this.wallet = wallet;
    this.opts = opts;
    this.program = program;
    this.provider = provider;
    this.fetcher = fetcher;
  }
};

// src/impl/position-impl.ts
import {
  AddressUtil as AddressUtil4,
  deriveATA,
  resolveOrCreateATAs as resolveOrCreateATAs2,
  TransactionBuilder as TransactionBuilder3,
  ZERO as ZERO3
} from "@orca-so/common-sdk";
import { NATIVE_MINT as NATIVE_MINT3 } from "@solana/spl-token";
import invariant3 from "tiny-invariant";

// src/utils/builder/position-builder-util.ts
async function getTickArrayDataForPosition(ctx, position, whirlpool, refresh) {
  const lowerTickArrayKey = PDAUtil.getTickArrayFromTickIndex(
    position.tickLowerIndex,
    whirlpool.tickSpacing,
    position.whirlpool,
    ctx.program.programId
  ).publicKey;
  const upperTickArrayKey = PDAUtil.getTickArrayFromTickIndex(
    position.tickUpperIndex,
    whirlpool.tickSpacing,
    position.whirlpool,
    ctx.program.programId
  ).publicKey;
  return await ctx.fetcher.listTickArrays([lowerTickArrayKey, upperTickArrayKey], refresh);
}

// src/impl/position-impl.ts
var PositionImpl = class {
  constructor(ctx, address, data, whirlpoolData, lowerTickArrayData, upperTickArrayData) {
    this.ctx = ctx;
    this.address = address;
    this.data = data;
    this.whirlpoolData = whirlpoolData;
    this.lowerTickArrayData = lowerTickArrayData;
    this.upperTickArrayData = upperTickArrayData;
  }
  getAddress() {
    return this.address;
  }
  getData() {
    return this.data;
  }
  getWhirlpoolData() {
    return this.whirlpoolData;
  }
  getLowerTickData() {
    return TickArrayUtil.getTickFromArray(
      this.lowerTickArrayData,
      this.data.tickLowerIndex,
      this.whirlpoolData.tickSpacing
    );
  }
  getUpperTickData() {
    return TickArrayUtil.getTickFromArray(
      this.upperTickArrayData,
      this.data.tickUpperIndex,
      this.whirlpoolData.tickSpacing
    );
  }
  async refreshData() {
    await this.refresh();
    return this.data;
  }
  async increaseLiquidity(liquidityInput, resolveATA = true, sourceWallet, positionWallet, ataPayer) {
    const sourceWalletKey = sourceWallet ? AddressUtil4.toPubKey(sourceWallet) : this.ctx.wallet.publicKey;
    const positionWalletKey = positionWallet ? AddressUtil4.toPubKey(positionWallet) : this.ctx.wallet.publicKey;
    const ataPayerKey = ataPayer ? AddressUtil4.toPubKey(ataPayer) : this.ctx.wallet.publicKey;
    const whirlpool = await this.ctx.fetcher.getPool(this.data.whirlpool, true);
    if (!whirlpool) {
      throw new Error("Unable to fetch whirlpool for this position.");
    }
    const txBuilder = new TransactionBuilder3(
      this.ctx.provider.connection,
      this.ctx.provider.wallet
    );
    let tokenOwnerAccountA;
    let tokenOwnerAccountB;
    if (resolveATA) {
      const [ataA, ataB] = await resolveOrCreateATAs2(
        this.ctx.connection,
        sourceWalletKey,
        [
          { tokenMint: whirlpool.tokenMintA, wrappedSolAmountIn: liquidityInput.tokenMaxA },
          { tokenMint: whirlpool.tokenMintB, wrappedSolAmountIn: liquidityInput.tokenMaxB }
        ],
        () => this.ctx.fetcher.getAccountRentExempt(),
        ataPayerKey
      );
      const { address: ataAddrA, ...tokenOwnerAccountAIx } = ataA;
      const { address: ataAddrB, ...tokenOwnerAccountBIx } = ataB;
      tokenOwnerAccountA = ataAddrA;
      tokenOwnerAccountB = ataAddrB;
      txBuilder.addInstruction(tokenOwnerAccountAIx);
      txBuilder.addInstruction(tokenOwnerAccountBIx);
    } else {
      tokenOwnerAccountA = await deriveATA(sourceWalletKey, whirlpool.tokenMintA);
      tokenOwnerAccountB = await deriveATA(sourceWalletKey, whirlpool.tokenMintB);
    }
    const positionTokenAccount = await deriveATA(positionWalletKey, this.data.positionMint);
    const increaseIx = increaseLiquidityIx(this.ctx.program, {
      ...liquidityInput,
      whirlpool: this.data.whirlpool,
      position: this.address,
      positionTokenAccount,
      tokenOwnerAccountA,
      tokenOwnerAccountB,
      tokenVaultA: whirlpool.tokenVaultA,
      tokenVaultB: whirlpool.tokenVaultB,
      tickArrayLower: PDAUtil.getTickArray(
        this.ctx.program.programId,
        this.data.whirlpool,
        TickUtil.getStartTickIndex(this.data.tickLowerIndex, whirlpool.tickSpacing)
      ).publicKey,
      tickArrayUpper: PDAUtil.getTickArray(
        this.ctx.program.programId,
        this.data.whirlpool,
        TickUtil.getStartTickIndex(this.data.tickUpperIndex, whirlpool.tickSpacing)
      ).publicKey,
      positionAuthority: positionWalletKey
    });
    txBuilder.addInstruction(increaseIx);
    return txBuilder;
  }
  async decreaseLiquidity(liquidityInput, resolveATA = true, sourceWallet, positionWallet, ataPayer) {
    const sourceWalletKey = sourceWallet ? AddressUtil4.toPubKey(sourceWallet) : this.ctx.wallet.publicKey;
    const positionWalletKey = positionWallet ? AddressUtil4.toPubKey(positionWallet) : this.ctx.wallet.publicKey;
    const ataPayerKey = ataPayer ? AddressUtil4.toPubKey(ataPayer) : this.ctx.wallet.publicKey;
    const whirlpool = await this.ctx.fetcher.getPool(this.data.whirlpool, true);
    if (!whirlpool) {
      throw new Error("Unable to fetch whirlpool for this position.");
    }
    const txBuilder = new TransactionBuilder3(
      this.ctx.provider.connection,
      this.ctx.provider.wallet
    );
    let tokenOwnerAccountA;
    let tokenOwnerAccountB;
    if (resolveATA) {
      const [ataA, ataB] = await resolveOrCreateATAs2(
        this.ctx.connection,
        sourceWalletKey,
        [{ tokenMint: whirlpool.tokenMintA }, { tokenMint: whirlpool.tokenMintB }],
        () => this.ctx.fetcher.getAccountRentExempt(),
        ataPayerKey
      );
      const { address: ataAddrA, ...tokenOwnerAccountAIx } = ataA;
      const { address: ataAddrB, ...tokenOwnerAccountBIx } = ataB;
      tokenOwnerAccountA = ataAddrA;
      tokenOwnerAccountB = ataAddrB;
      txBuilder.addInstruction(tokenOwnerAccountAIx);
      txBuilder.addInstruction(tokenOwnerAccountBIx);
    } else {
      tokenOwnerAccountA = await deriveATA(sourceWalletKey, whirlpool.tokenMintA);
      tokenOwnerAccountB = await deriveATA(sourceWalletKey, whirlpool.tokenMintB);
    }
    const decreaseIx = decreaseLiquidityIx(this.ctx.program, {
      ...liquidityInput,
      whirlpool: this.data.whirlpool,
      position: this.address,
      positionTokenAccount: await deriveATA(positionWalletKey, this.data.positionMint),
      tokenOwnerAccountA,
      tokenOwnerAccountB,
      tokenVaultA: whirlpool.tokenVaultA,
      tokenVaultB: whirlpool.tokenVaultB,
      tickArrayLower: PDAUtil.getTickArray(
        this.ctx.program.programId,
        this.data.whirlpool,
        TickUtil.getStartTickIndex(this.data.tickLowerIndex, whirlpool.tickSpacing)
      ).publicKey,
      tickArrayUpper: PDAUtil.getTickArray(
        this.ctx.program.programId,
        this.data.whirlpool,
        TickUtil.getStartTickIndex(this.data.tickUpperIndex, whirlpool.tickSpacing)
      ).publicKey,
      positionAuthority: positionWalletKey
    });
    txBuilder.addInstruction(decreaseIx);
    return txBuilder;
  }
  async collectFees(updateFeesAndRewards = true, ownerTokenAccountMap, destinationWallet, positionWallet, ataPayer, refresh = false) {
    const [destinationWalletKey, positionWalletKey, ataPayerKey] = AddressUtil4.toPubKeys([
      destinationWallet ?? this.ctx.wallet.publicKey,
      positionWallet ?? this.ctx.wallet.publicKey,
      ataPayer ?? this.ctx.wallet.publicKey
    ]);
    const whirlpool = await this.ctx.fetcher.getPool(this.data.whirlpool, refresh);
    if (!whirlpool) {
      throw new Error(
        `Unable to fetch whirlpool (${this.data.whirlpool}) for this position (${this.address}).`
      );
    }
    let txBuilder = new TransactionBuilder3(this.ctx.provider.connection, this.ctx.provider.wallet);
    const accountExemption = await this.ctx.fetcher.getAccountRentExempt();
    let ataMap = { ...ownerTokenAccountMap };
    if (!ownerTokenAccountMap) {
      const affliatedMints = getTokenMintsFromWhirlpools([whirlpool], "POOL_ONLY" /* POOL_ONLY */);
      const { ataTokenAddresses: affliatedTokenAtaMap, resolveAtaIxs } = await resolveAtaForMints(
        this.ctx,
        {
          mints: affliatedMints.mintMap,
          accountExemption,
          receiver: destinationWalletKey,
          payer: ataPayerKey
        }
      );
      txBuilder.addInstructions(resolveAtaIxs);
      if (affliatedMints.hasNativeMint) {
        let { address: wSOLAta, ...resolveWSolIx } = createWSOLAccountInstructions(
          destinationWalletKey,
          ZERO3,
          accountExemption,
          ataPayerKey,
          destinationWalletKey
        );
        affliatedTokenAtaMap[NATIVE_MINT3.toBase58()] = wSOLAta;
        txBuilder.addInstruction(resolveWSolIx);
      }
      ataMap = { ...affliatedTokenAtaMap };
    }
    const tokenOwnerAccountA = ataMap[whirlpool.tokenMintA.toBase58()];
    invariant3(
      !!tokenOwnerAccountA,
      `No owner token account provided for wallet ${destinationWalletKey.toBase58()} for token A ${whirlpool.tokenMintA.toBase58()} `
    );
    const tokenOwnerAccountB = ataMap[whirlpool.tokenMintB.toBase58()];
    invariant3(
      !!tokenOwnerAccountB,
      `No owner token account provided for wallet ${destinationWalletKey.toBase58()} for token B ${whirlpool.tokenMintB.toBase58()} `
    );
    const positionTokenAccount = await deriveATA(positionWalletKey, this.data.positionMint);
    if (updateFeesAndRewards) {
      const updateIx = await this.updateFeesAndRewards();
      txBuilder.addInstruction(updateIx);
    }
    const ix = collectFeesIx(this.ctx.program, {
      whirlpool: this.data.whirlpool,
      position: this.address,
      positionTokenAccount,
      tokenOwnerAccountA: AddressUtil4.toPubKey(tokenOwnerAccountA),
      tokenOwnerAccountB: AddressUtil4.toPubKey(tokenOwnerAccountB),
      tokenVaultA: whirlpool.tokenVaultA,
      tokenVaultB: whirlpool.tokenVaultB,
      positionAuthority: positionWalletKey
    });
    txBuilder.addInstruction(ix);
    return txBuilder;
  }
  async collectRewards(rewardsToCollect, updateFeesAndRewards = true, ownerTokenAccountMap, destinationWallet, positionWallet, ataPayer, refresh = true) {
    const [destinationWalletKey, positionWalletKey, ataPayerKey] = AddressUtil4.toPubKeys([
      destinationWallet ?? this.ctx.wallet.publicKey,
      positionWallet ?? this.ctx.wallet.publicKey,
      ataPayer ?? this.ctx.wallet.publicKey
    ]);
    const whirlpool = await this.ctx.fetcher.getPool(this.data.whirlpool, refresh);
    if (!whirlpool) {
      throw new Error(
        `Unable to fetch whirlpool(${this.data.whirlpool}) for this position(${this.address}).`
      );
    }
    const initializedRewards = whirlpool.rewardInfos.filter(
      (info) => PoolUtil.isRewardInitialized(info)
    );
    const txBuilder = new TransactionBuilder3(
      this.ctx.provider.connection,
      this.ctx.provider.wallet
    );
    const accountExemption = await this.ctx.fetcher.getAccountRentExempt();
    let ataMap = { ...ownerTokenAccountMap };
    if (!ownerTokenAccountMap) {
      const rewardMints = getTokenMintsFromWhirlpools([whirlpool], "REWARDS_ONLY" /* REWARD_ONLY */);
      const { ataTokenAddresses: affliatedTokenAtaMap, resolveAtaIxs } = await resolveAtaForMints(
        this.ctx,
        {
          mints: rewardMints.mintMap,
          accountExemption,
          receiver: destinationWalletKey,
          payer: ataPayerKey
        }
      );
      if (rewardMints.hasNativeMint) {
        let { address: wSOLAta, ...resolveWSolIx } = createWSOLAccountInstructions(
          destinationWalletKey,
          ZERO3,
          accountExemption
        );
        affliatedTokenAtaMap[NATIVE_MINT3.toBase58()] = wSOLAta;
        txBuilder.addInstruction(resolveWSolIx);
      }
      txBuilder.addInstructions(resolveAtaIxs);
      ataMap = { ...affliatedTokenAtaMap };
    }
    const positionTokenAccount = await deriveATA(positionWalletKey, this.data.positionMint);
    if (updateFeesAndRewards) {
      const updateIx = await this.updateFeesAndRewards();
      txBuilder.addInstruction(updateIx);
    }
    initializedRewards.forEach((info, index) => {
      if (rewardsToCollect && !rewardsToCollect.some((r) => r.toString() === info.mint.toBase58())) {
        return;
      }
      const rewardOwnerAccount = ataMap[info.mint.toBase58()];
      invariant3(
        !!rewardOwnerAccount,
        `No owner token account provided for wallet ${destinationWalletKey.toBase58()} for reward ${index} token ${info.mint.toBase58()} `
      );
      const ix = collectRewardIx(this.ctx.program, {
        whirlpool: this.data.whirlpool,
        position: this.address,
        positionTokenAccount,
        rewardIndex: index,
        rewardOwnerAccount: AddressUtil4.toPubKey(rewardOwnerAccount),
        rewardVault: info.vault,
        positionAuthority: positionWalletKey
      });
      txBuilder.addInstruction(ix);
    });
    return txBuilder;
  }
  async refresh() {
    const positionAccount = await this.ctx.fetcher.getPosition(this.address, true);
    if (!!positionAccount) {
      this.data = positionAccount;
    }
    const whirlpoolAccount = await this.ctx.fetcher.getPool(this.data.whirlpool, true);
    if (!!whirlpoolAccount) {
      this.whirlpoolData = whirlpoolAccount;
    }
    const [lowerTickArray, upperTickArray] = await getTickArrayDataForPosition(
      this.ctx,
      this.data,
      this.whirlpoolData,
      true
    );
    if (lowerTickArray) {
      this.lowerTickArrayData = lowerTickArray;
    }
    if (upperTickArray) {
      this.upperTickArrayData = upperTickArray;
    }
  }
  async updateFeesAndRewards() {
    const whirlpool = await this.ctx.fetcher.getPool(this.data.whirlpool);
    if (!whirlpool) {
      throw new Error(
        `Unable to fetch whirlpool(${this.data.whirlpool}) for this position(${this.address}).`
      );
    }
    const [tickArrayLowerPda, tickArrayUpperPda] = [
      this.data.tickLowerIndex,
      this.data.tickUpperIndex
    ].map(
      (tickIndex) => PDAUtil.getTickArrayFromTickIndex(
        tickIndex,
        whirlpool.tickSpacing,
        this.data.whirlpool,
        this.ctx.program.programId
      )
    );
    const updateIx = updateFeesAndRewardsIx(this.ctx.program, {
      whirlpool: this.data.whirlpool,
      position: this.address,
      tickArrayLower: tickArrayLowerPda.publicKey,
      tickArrayUpper: tickArrayUpperPda.publicKey
    });
    return updateIx;
  }
};

// src/quotes/public/increase-liquidity-quote.ts
import { AddressUtil as AddressUtil5, DecimalUtil, ZERO as ZERO4 } from "@orca-so/common-sdk";
import invariant4 from "tiny-invariant";

// src/utils/position-util.ts
import { MathUtil as MathUtil4 } from "@orca-so/common-sdk";

// src/utils/swap-utils.ts
import { MathUtil as MathUtil3 } from "@orca-so/common-sdk";

// src/utils/position-util.ts
var PositionUtil = class {
  constructor() {
  }
  static getPositionStatus(tickCurrentIndex, tickLowerIndex, tickUpperIndex) {
    if (tickCurrentIndex < tickLowerIndex) {
      return 0 /* BelowRange */;
    } else if (tickCurrentIndex < tickUpperIndex) {
      return 1 /* InRange */;
    } else {
      return 2 /* AboveRange */;
    }
  }
};
function adjustForSlippage(n, { numerator, denominator }, adjustUp) {
  if (adjustUp) {
    return n.mul(denominator.add(numerator)).div(denominator);
  } else {
    return n.mul(denominator).div(denominator.add(numerator));
  }
}
function getLiquidityFromTokenA(amount, sqrtPriceLowerX64, sqrtPriceUpperX64, roundUp) {
  const result = amount.mul(sqrtPriceLowerX64).mul(sqrtPriceUpperX64).div(sqrtPriceUpperX64.sub(sqrtPriceLowerX64));
  if (roundUp) {
    return MathUtil4.shiftRightRoundUp(result);
  } else {
    return result.shrn(64);
  }
}
function getLiquidityFromTokenB(amount, sqrtPriceLowerX64, sqrtPriceUpperX64, roundUp) {
  const numerator = amount.shln(64);
  const denominator = sqrtPriceUpperX64.sub(sqrtPriceLowerX64);
  if (roundUp) {
    return MathUtil4.divRoundUp(numerator, denominator);
  } else {
    return numerator.div(denominator);
  }
}
function getTokenAFromLiquidity(liquidity, sqrtPrice0X64, sqrtPrice1X64, roundUp) {
  const [sqrtPriceLowerX64, sqrtPriceUpperX64] = orderSqrtPrice(sqrtPrice0X64, sqrtPrice1X64);
  const numerator = liquidity.mul(sqrtPriceUpperX64.sub(sqrtPriceLowerX64)).shln(64);
  const denominator = sqrtPriceUpperX64.mul(sqrtPriceLowerX64);
  if (roundUp) {
    return MathUtil4.divRoundUp(numerator, denominator);
  } else {
    return numerator.div(denominator);
  }
}
function getTokenBFromLiquidity(liquidity, sqrtPrice0X64, sqrtPrice1X64, roundUp) {
  const [sqrtPriceLowerX64, sqrtPriceUpperX64] = orderSqrtPrice(sqrtPrice0X64, sqrtPrice1X64);
  const result = liquidity.mul(sqrtPriceUpperX64.sub(sqrtPriceLowerX64));
  if (roundUp) {
    return MathUtil4.shiftRightRoundUp(result);
  } else {
    return result.shrn(64);
  }
}
function orderSqrtPrice(sqrtPrice0X64, sqrtPrice1X64) {
  if (sqrtPrice0X64.lt(sqrtPrice1X64)) {
    return [sqrtPrice0X64, sqrtPrice1X64];
  } else {
    return [sqrtPrice1X64, sqrtPrice0X64];
  }
}

// src/quotes/public/increase-liquidity-quote.ts
function increaseLiquidityQuoteByInputToken(inputTokenMint, inputTokenAmount, tickLower, tickUpper, slippageTolerance, whirlpool) {
  const data = whirlpool.getData();
  const tokenAInfo = whirlpool.getTokenAInfo();
  const tokenBInfo = whirlpool.getTokenBInfo();
  const inputMint = AddressUtil5.toPubKey(inputTokenMint);
  const inputTokenInfo = inputMint.equals(tokenAInfo.mint) ? tokenAInfo : tokenBInfo;
  return increaseLiquidityQuoteByInputTokenWithParams({
    inputTokenMint: inputMint,
    inputTokenAmount: DecimalUtil.toU64(inputTokenAmount, inputTokenInfo.decimals),
    tickLowerIndex: TickUtil.getInitializableTickIndex(tickLower, data.tickSpacing),
    tickUpperIndex: TickUtil.getInitializableTickIndex(tickUpper, data.tickSpacing),
    slippageTolerance,
    ...data
  });
}
function increaseLiquidityQuoteByInputTokenWithParams(param) {
  invariant4(TickUtil.checkTickInBounds(param.tickLowerIndex), "tickLowerIndex is out of bounds.");
  invariant4(TickUtil.checkTickInBounds(param.tickUpperIndex), "tickUpperIndex is out of bounds.");
  invariant4(
    param.inputTokenMint.equals(param.tokenMintA) || param.inputTokenMint.equals(param.tokenMintB),
    `input token mint ${param.inputTokenMint.toBase58()} does not match any tokens in the provided pool.`
  );
  const positionStatus = PositionUtil.getPositionStatus(
    param.tickCurrentIndex,
    param.tickLowerIndex,
    param.tickUpperIndex
  );
  switch (positionStatus) {
    case 0 /* BelowRange */:
      return quotePositionBelowRange(param);
    case 1 /* InRange */:
      return quotePositionInRange(param);
    case 2 /* AboveRange */:
      return quotePositionAboveRange(param);
    default:
      throw new Error(`type ${positionStatus} is an unknown PositionStatus`);
  }
}
function quotePositionBelowRange(param) {
  const {
    tokenMintA,
    inputTokenMint,
    inputTokenAmount,
    tickLowerIndex,
    tickUpperIndex,
    slippageTolerance
  } = param;
  if (!tokenMintA.equals(inputTokenMint)) {
    return {
      tokenMaxA: ZERO4,
      tokenMaxB: ZERO4,
      tokenEstA: ZERO4,
      tokenEstB: ZERO4,
      liquidityAmount: ZERO4
    };
  }
  const sqrtPriceLowerX64 = PriceMath.tickIndexToSqrtPriceX64(tickLowerIndex);
  const sqrtPriceUpperX64 = PriceMath.tickIndexToSqrtPriceX64(tickUpperIndex);
  const liquidityAmount = getLiquidityFromTokenA(
    inputTokenAmount,
    sqrtPriceLowerX64,
    sqrtPriceUpperX64,
    false
  );
  const tokenEstA = getTokenAFromLiquidity(
    liquidityAmount,
    sqrtPriceLowerX64,
    sqrtPriceUpperX64,
    true
  );
  const tokenMaxA = adjustForSlippage(tokenEstA, slippageTolerance, true);
  return {
    tokenMaxA,
    tokenMaxB: ZERO4,
    tokenEstA,
    tokenEstB: ZERO4,
    liquidityAmount
  };
}
function quotePositionInRange(param) {
  const {
    tokenMintA,
    sqrtPrice,
    inputTokenMint,
    inputTokenAmount,
    tickLowerIndex,
    tickUpperIndex,
    slippageTolerance
  } = param;
  const sqrtPriceX64 = sqrtPrice;
  const sqrtPriceLowerX64 = PriceMath.tickIndexToSqrtPriceX64(tickLowerIndex);
  const sqrtPriceUpperX64 = PriceMath.tickIndexToSqrtPriceX64(tickUpperIndex);
  let [tokenEstA, tokenEstB] = tokenMintA.equals(inputTokenMint) ? [inputTokenAmount, void 0] : [void 0, inputTokenAmount];
  let liquidityAmount;
  if (tokenEstA) {
    liquidityAmount = getLiquidityFromTokenA(tokenEstA, sqrtPriceX64, sqrtPriceUpperX64, false);
    tokenEstA = getTokenAFromLiquidity(liquidityAmount, sqrtPriceX64, sqrtPriceUpperX64, true);
    tokenEstB = getTokenBFromLiquidity(liquidityAmount, sqrtPriceLowerX64, sqrtPriceX64, true);
  } else if (tokenEstB) {
    liquidityAmount = getLiquidityFromTokenB(tokenEstB, sqrtPriceLowerX64, sqrtPriceX64, false);
    tokenEstA = getTokenAFromLiquidity(liquidityAmount, sqrtPriceX64, sqrtPriceUpperX64, true);
    tokenEstB = getTokenBFromLiquidity(liquidityAmount, sqrtPriceLowerX64, sqrtPriceX64, true);
  } else {
    throw new Error("invariant violation");
  }
  const tokenMaxA = adjustForSlippage(tokenEstA, slippageTolerance, true);
  const tokenMaxB = adjustForSlippage(tokenEstB, slippageTolerance, true);
  return {
    tokenMaxA,
    tokenMaxB,
    tokenEstA,
    tokenEstB,
    liquidityAmount
  };
}
function quotePositionAboveRange(param) {
  const {
    tokenMintB,
    inputTokenMint,
    inputTokenAmount,
    tickLowerIndex,
    tickUpperIndex,
    slippageTolerance
  } = param;
  if (!tokenMintB.equals(inputTokenMint)) {
    return {
      tokenMaxA: ZERO4,
      tokenMaxB: ZERO4,
      tokenEstA: ZERO4,
      tokenEstB: ZERO4,
      liquidityAmount: ZERO4
    };
  }
  const sqrtPriceLowerX64 = PriceMath.tickIndexToSqrtPriceX64(tickLowerIndex);
  const sqrtPriceUpperX64 = PriceMath.tickIndexToSqrtPriceX64(tickUpperIndex);
  const liquidityAmount = getLiquidityFromTokenB(
    inputTokenAmount,
    sqrtPriceLowerX64,
    sqrtPriceUpperX64,
    false
  );
  const tokenEstB = getTokenBFromLiquidity(
    liquidityAmount,
    sqrtPriceLowerX64,
    sqrtPriceUpperX64,
    true
  );
  const tokenMaxB = adjustForSlippage(tokenEstB, slippageTolerance, true);
  return {
    tokenMaxA: ZERO4,
    tokenMaxB,
    tokenEstA: ZERO4,
    tokenEstB,
    liquidityAmount
  };
}

// src/quotes/public/decrease-liquidity-quote.ts
import { ZERO as ZERO5 } from "@orca-so/common-sdk";
import invariant5 from "tiny-invariant";
function decreaseLiquidityQuoteByLiquidity(liquidity, slippageTolerance, position, whirlpool) {
  const positionData = position.getData();
  const whirlpoolData = whirlpool.getData();
  invariant5(
    liquidity.lte(positionData.liquidity),
    "Quote liquidity is more than the position liquidity."
  );
  return decreaseLiquidityQuoteByLiquidityWithParams({
    liquidity,
    slippageTolerance,
    tickLowerIndex: positionData.tickLowerIndex,
    tickUpperIndex: positionData.tickUpperIndex,
    sqrtPrice: whirlpoolData.sqrtPrice,
    tickCurrentIndex: whirlpoolData.tickCurrentIndex
  });
}
function decreaseLiquidityQuoteByLiquidityWithParams(param) {
  invariant5(TickUtil.checkTickInBounds(param.tickLowerIndex), "tickLowerIndex is out of bounds.");
  invariant5(TickUtil.checkTickInBounds(param.tickUpperIndex), "tickUpperIndex is out of bounds.");
  invariant5(
    TickUtil.checkTickInBounds(param.tickCurrentIndex),
    "tickCurrentIndex is out of bounds."
  );
  const positionStatus = PositionUtil.getPositionStatus(
    param.tickCurrentIndex,
    param.tickLowerIndex,
    param.tickUpperIndex
  );
  switch (positionStatus) {
    case 0 /* BelowRange */:
      return quotePositionBelowRange2(param);
    case 1 /* InRange */:
      return quotePositionInRange2(param);
    case 2 /* AboveRange */:
      return quotePositionAboveRange2(param);
    default:
      throw new Error(`type ${positionStatus} is an unknown PositionStatus`);
  }
}
function quotePositionBelowRange2(param) {
  const { tickLowerIndex, tickUpperIndex, liquidity, slippageTolerance } = param;
  const sqrtPriceLowerX64 = PriceMath.tickIndexToSqrtPriceX64(tickLowerIndex);
  const sqrtPriceUpperX64 = PriceMath.tickIndexToSqrtPriceX64(tickUpperIndex);
  const tokenEstA = getTokenAFromLiquidity(liquidity, sqrtPriceLowerX64, sqrtPriceUpperX64, false);
  const tokenMinA = adjustForSlippage(tokenEstA, slippageTolerance, false);
  return {
    tokenMinA,
    tokenMinB: ZERO5,
    tokenEstA,
    tokenEstB: ZERO5,
    liquidityAmount: liquidity
  };
}
function quotePositionInRange2(param) {
  const { sqrtPrice, tickLowerIndex, tickUpperIndex, liquidity, slippageTolerance } = param;
  const sqrtPriceX64 = sqrtPrice;
  const sqrtPriceLowerX64 = PriceMath.tickIndexToSqrtPriceX64(tickLowerIndex);
  const sqrtPriceUpperX64 = PriceMath.tickIndexToSqrtPriceX64(tickUpperIndex);
  const tokenEstA = getTokenAFromLiquidity(liquidity, sqrtPriceX64, sqrtPriceUpperX64, false);
  const tokenMinA = adjustForSlippage(tokenEstA, slippageTolerance, false);
  const tokenEstB = getTokenBFromLiquidity(liquidity, sqrtPriceLowerX64, sqrtPriceX64, false);
  const tokenMinB = adjustForSlippage(tokenEstB, slippageTolerance, false);
  return {
    tokenMinA,
    tokenMinB,
    tokenEstA,
    tokenEstB,
    liquidityAmount: liquidity
  };
}
function quotePositionAboveRange2(param) {
  const { tickLowerIndex, tickUpperIndex, liquidity, slippageTolerance } = param;
  const sqrtPriceLowerX64 = PriceMath.tickIndexToSqrtPriceX64(tickLowerIndex);
  const sqrtPriceUpperX64 = PriceMath.tickIndexToSqrtPriceX64(tickUpperIndex);
  const tokenEstB = getTokenBFromLiquidity(liquidity, sqrtPriceLowerX64, sqrtPriceUpperX64, false);
  const tokenMinB = adjustForSlippage(tokenEstB, slippageTolerance, false);
  return {
    tokenMinA: ZERO5,
    tokenMinB,
    tokenEstA: ZERO5,
    tokenEstB,
    liquidityAmount: liquidity
  };
}

// src/quotes/public/collect-fees-quote.ts
import { MathUtil as MathUtil5 } from "@orca-so/common-sdk";
function collectFeesQuote(param) {
  const { whirlpool, position, tickLower, tickUpper } = param;
  const {
    tickCurrentIndex,
    feeGrowthGlobalA: feeGrowthGlobalAX64,
    feeGrowthGlobalB: feeGrowthGlobalBX64
  } = whirlpool;
  const {
    tickLowerIndex,
    tickUpperIndex,
    liquidity,
    feeOwedA,
    feeOwedB,
    feeGrowthCheckpointA: feeGrowthCheckpointAX64,
    feeGrowthCheckpointB: feeGrowthCheckpointBX64
  } = position;
  const {
    feeGrowthOutsideA: tickLowerFeeGrowthOutsideAX64,
    feeGrowthOutsideB: tickLowerFeeGrowthOutsideBX64
  } = tickLower;
  const {
    feeGrowthOutsideA: tickUpperFeeGrowthOutsideAX64,
    feeGrowthOutsideB: tickUpperFeeGrowthOutsideBX64
  } = tickUpper;
  let feeGrowthBelowAX64 = null;
  let feeGrowthBelowBX64 = null;
  if (tickCurrentIndex < tickLowerIndex) {
    feeGrowthBelowAX64 = MathUtil5.subUnderflowU128(
      feeGrowthGlobalAX64,
      tickLowerFeeGrowthOutsideAX64
    );
    feeGrowthBelowBX64 = MathUtil5.subUnderflowU128(
      feeGrowthGlobalBX64,
      tickLowerFeeGrowthOutsideBX64
    );
  } else {
    feeGrowthBelowAX64 = tickLowerFeeGrowthOutsideAX64;
    feeGrowthBelowBX64 = tickLowerFeeGrowthOutsideBX64;
  }
  let feeGrowthAboveAX64 = null;
  let feeGrowthAboveBX64 = null;
  if (tickCurrentIndex < tickUpperIndex) {
    feeGrowthAboveAX64 = tickUpperFeeGrowthOutsideAX64;
    feeGrowthAboveBX64 = tickUpperFeeGrowthOutsideBX64;
  } else {
    feeGrowthAboveAX64 = MathUtil5.subUnderflowU128(
      feeGrowthGlobalAX64,
      tickUpperFeeGrowthOutsideAX64
    );
    feeGrowthAboveBX64 = MathUtil5.subUnderflowU128(
      feeGrowthGlobalBX64,
      tickUpperFeeGrowthOutsideBX64
    );
  }
  const feeGrowthInsideAX64 = MathUtil5.subUnderflowU128(
    MathUtil5.subUnderflowU128(feeGrowthGlobalAX64, feeGrowthBelowAX64),
    feeGrowthAboveAX64
  );
  const feeGrowthInsideBX64 = MathUtil5.subUnderflowU128(
    MathUtil5.subUnderflowU128(feeGrowthGlobalBX64, feeGrowthBelowBX64),
    feeGrowthAboveBX64
  );
  const feeOwedADelta = MathUtil5.subUnderflowU128(feeGrowthInsideAX64, feeGrowthCheckpointAX64).mul(liquidity).shrn(64);
  const feeOwedBDelta = MathUtil5.subUnderflowU128(feeGrowthInsideBX64, feeGrowthCheckpointBX64).mul(liquidity).shrn(64);
  const updatedFeeOwedA = feeOwedA.add(feeOwedADelta);
  const updatedFeeOwedB = feeOwedB.add(feeOwedBDelta);
  return {
    feeOwedA: updatedFeeOwedA,
    feeOwedB: updatedFeeOwedB
  };
}

// src/quotes/public/collect-rewards-quote.ts
import { MathUtil as MathUtil6 } from "@orca-so/common-sdk";
import { BN as BN7 } from "@project-serum/anchor";
import invariant6 from "tiny-invariant";
function collectRewardsQuote(param) {
  var _a, _b, _c, _d, _e, _f;
  const { whirlpool, position, tickLower, tickUpper } = param;
  const { tickCurrentIndex, rewardInfos: whirlpoolRewardsInfos } = whirlpool;
  const { tickLowerIndex, tickUpperIndex, liquidity, rewardInfos } = position;
  const range = [...Array(NUM_REWARDS).keys()];
  const rewardGrowthsBelowX64 = range.map(() => new BN7(0));
  const rewardGrowthsAboveX64 = range.map(() => new BN7(0));
  for (const i of range) {
    const rewardInfo = whirlpoolRewardsInfos[i];
    invariant6(!!rewardInfo, "whirlpoolRewardsInfos cannot be undefined");
    const growthGlobalX64 = rewardInfo.growthGlobalX64;
    const lowerRewardGrowthsOutside = tickLower.rewardGrowthsOutside[i];
    const upperRewardGrowthsOutside = tickUpper.rewardGrowthsOutside[i];
    invariant6(!!lowerRewardGrowthsOutside, "lowerRewardGrowthsOutside cannot be undefined");
    invariant6(!!upperRewardGrowthsOutside, "upperRewardGrowthsOutside cannot be undefined");
    if (tickCurrentIndex < tickLowerIndex) {
      rewardGrowthsBelowX64[i] = MathUtil6.subUnderflowU128(
        growthGlobalX64,
        lowerRewardGrowthsOutside
      );
    } else {
      rewardGrowthsBelowX64[i] = lowerRewardGrowthsOutside;
    }
    if (tickCurrentIndex < tickUpperIndex) {
      rewardGrowthsAboveX64[i] = upperRewardGrowthsOutside;
    } else {
      rewardGrowthsAboveX64[i] = MathUtil6.subUnderflowU128(
        growthGlobalX64,
        upperRewardGrowthsOutside
      );
    }
  }
  const rewardGrowthsInsideX64 = range.map(() => [new BN7(0), false]);
  for (const i of range) {
    const rewardInfo = whirlpoolRewardsInfos[i];
    invariant6(!!rewardInfo, "whirlpoolRewardsInfos cannot be undefined");
    const isRewardInitialized = PoolUtil.isRewardInitialized(rewardInfo);
    if (isRewardInitialized) {
      const growthBelowX64 = rewardGrowthsBelowX64[i];
      const growthAboveX64 = rewardGrowthsAboveX64[i];
      invariant6(!!growthBelowX64, "growthBelowX64 cannot be undefined");
      invariant6(!!growthAboveX64, "growthAboveX64 cannot be undefined");
      const growthInsde = MathUtil6.subUnderflowU128(
        MathUtil6.subUnderflowU128(rewardInfo.growthGlobalX64, growthBelowX64),
        growthAboveX64
      );
      rewardGrowthsInsideX64[i] = [growthInsde, true];
    }
  }
  const updatedRewardInfosX64 = range.map(() => new BN7(0));
  for (const i of range) {
    const growthInsideX64 = rewardGrowthsInsideX64[i];
    invariant6(!!growthInsideX64, "growthInsideX64 cannot be undefined");
    const [rewardGrowthInsideX64, isRewardInitialized] = growthInsideX64;
    if (isRewardInitialized) {
      const rewardInfo = rewardInfos[i];
      invariant6(!!rewardInfo, "rewardInfo cannot be undefined");
      const amountOwedX64 = rewardInfo.amountOwed.shln(64);
      const growthInsideCheckpointX64 = rewardInfo.growthInsideCheckpoint;
      updatedRewardInfosX64[i] = amountOwedX64.add(
        MathUtil6.subUnderflowU128(rewardGrowthInsideX64, growthInsideCheckpointX64).mul(liquidity)
      );
    }
  }
  invariant6(rewardGrowthsInsideX64.length >= 3, "rewards length is less than 3");
  const rewardExistsA = (_a = rewardGrowthsInsideX64[0]) == null ? void 0 : _a[1];
  const rewardExistsB = (_b = rewardGrowthsInsideX64[1]) == null ? void 0 : _b[1];
  const rewardExistsC = (_c = rewardGrowthsInsideX64[2]) == null ? void 0 : _c[1];
  const rewardOwedA = rewardExistsA ? (_d = updatedRewardInfosX64[0]) == null ? void 0 : _d.shrn(64) : void 0;
  const rewardOwedB = rewardExistsB ? (_e = updatedRewardInfosX64[1]) == null ? void 0 : _e.shrn(64) : void 0;
  const rewardOwedC = rewardExistsC ? (_f = updatedRewardInfosX64[2]) == null ? void 0 : _f.shrn(64) : void 0;
  return [rewardOwedA, rewardOwedB, rewardOwedC];
}

// src/quotes/public/swap-quote.ts
import { AddressUtil as AddressUtil6 } from "@orca-so/common-sdk";
import invariant7 from "tiny-invariant";

// src/quotes/swap/swap-quote-impl.ts
import { ZERO as ZERO9 } from "@orca-so/common-sdk";
import { BN as BN12 } from "@project-serum/anchor";

// src/errors/errors.ts
var WhirlpoolsError = class extends Error {
  constructor(message, errorCode) {
    super(message);
    this.message = message;
    this.errorCode = errorCode;
  }
  static isWhirlpoolsErrorCode(e, code) {
    return e instanceof WhirlpoolsError && e.errorCode === code;
  }
};

// src/quotes/swap/tick-array-index.ts
var TickArrayIndex = class {
  constructor(arrayIndex, offsetIndex, tickSpacing) {
    this.arrayIndex = arrayIndex;
    this.offsetIndex = offsetIndex;
    this.tickSpacing = tickSpacing;
    if (offsetIndex >= TICK_ARRAY_SIZE) {
      throw new Error("Invalid offsetIndex - value has to be smaller than TICK_ARRAY_SIZE");
    }
    if (offsetIndex < 0) {
      throw new Error("Invalid offsetIndex - value is smaller than 0");
    }
    if (tickSpacing < 0) {
      throw new Error("Invalid tickSpacing - value is less than 0");
    }
  }
  static fromTickIndex(index, tickSpacing) {
    const arrayIndex = Math.floor(Math.floor(index / tickSpacing) / TICK_ARRAY_SIZE);
    let offsetIndex = Math.floor(index % (tickSpacing * TICK_ARRAY_SIZE) / tickSpacing);
    if (offsetIndex < 0) {
      offsetIndex = TICK_ARRAY_SIZE + offsetIndex;
    }
    return new TickArrayIndex(arrayIndex, offsetIndex, tickSpacing);
  }
  toTickIndex() {
    return this.arrayIndex * TICK_ARRAY_SIZE * this.tickSpacing + this.offsetIndex * this.tickSpacing;
  }
  toNextInitializableTickIndex() {
    return TickArrayIndex.fromTickIndex(this.toTickIndex() + this.tickSpacing, this.tickSpacing);
  }
  toPrevInitializableTickIndex() {
    return TickArrayIndex.fromTickIndex(this.toTickIndex() - this.tickSpacing, this.tickSpacing);
  }
};

// src/quotes/swap/tick-array-sequence.ts
var TickArraySequence = class {
  constructor(tickArrays, tickSpacing, aToB) {
    this.tickSpacing = tickSpacing;
    this.aToB = aToB;
    if (!tickArrays[0] || !tickArrays[0].data) {
      throw new Error("TickArray index 0 must be initialized");
    }
    this.sequence = [];
    for (const tickArray of tickArrays) {
      if (!tickArray || !tickArray.data) {
        break;
      }
      this.sequence.push({
        address: tickArray.address,
        data: tickArray.data
      });
    }
    this.touchedArrays = [...Array(this.sequence.length).fill(false)];
    this.startArrayIndex = TickArrayIndex.fromTickIndex(
      this.sequence[0].data.startTickIndex,
      this.tickSpacing
    ).arrayIndex;
  }
  isValidTickArray0(tickCurrentIndex) {
    const shift = this.aToB ? 0 : this.tickSpacing;
    const tickArray = this.sequence[0].data;
    return this.checkIfIndexIsInTickArrayRange(tickArray.startTickIndex, tickCurrentIndex + shift);
  }
  getNumOfTouchedArrays() {
    return this.touchedArrays.filter((val) => !!val).length;
  }
  getTouchedArrays(minArraySize) {
    let result = this.touchedArrays.reduce((prev, curr, index) => {
      if (curr) {
        prev.push(this.sequence[index].address);
      }
      return prev;
    }, []);
    if (result.length === 0) {
      return [];
    }
    const sizeDiff = minArraySize - result.length;
    if (sizeDiff > 0) {
      result = result.concat(Array(sizeDiff).fill(result[result.length - 1]));
    }
    return result;
  }
  getTick(index) {
    const targetTaIndex = TickArrayIndex.fromTickIndex(index, this.tickSpacing);
    if (!this.isArrayIndexInBounds(targetTaIndex, this.aToB)) {
      throw new Error("Provided tick index is out of bounds for this sequence.");
    }
    const localArrayIndex = this.getLocalArrayIndex(targetTaIndex.arrayIndex, this.aToB);
    const tickArray = this.sequence[localArrayIndex].data;
    this.touchedArrays[localArrayIndex] = true;
    if (!tickArray) {
      throw new WhirlpoolsError(
        `TickArray at index ${localArrayIndex} is not initialized.`,
        "TickArrayIndexNotInitialized" /* TickArrayIndexNotInitialized */
      );
    }
    if (!this.checkIfIndexIsInTickArrayRange(tickArray.startTickIndex, index)) {
      throw new WhirlpoolsError(
        `TickArray at index ${localArrayIndex} is unexpected for this sequence.`,
        "TickArraySequenceInvalid" /* TickArraySequenceInvalid */
      );
    }
    return tickArray.ticks[targetTaIndex.offsetIndex];
  }
  findNextInitializedTickIndex(currIndex) {
    const searchIndex = this.aToB ? currIndex : currIndex + this.tickSpacing;
    let currTaIndex = TickArrayIndex.fromTickIndex(searchIndex, this.tickSpacing);
    if (!this.isArrayIndexInBounds(currTaIndex, this.aToB)) {
      throw new WhirlpoolsError(
        `Swap input value traversed too many arrays. Out of bounds at attempt to traverse tick index - ${currTaIndex.toTickIndex()}.`,
        "TickArraySequenceInvalid" /* TickArraySequenceInvalid */
      );
    }
    while (this.isArrayIndexInBounds(currTaIndex, this.aToB)) {
      const currTickData = this.getTick(currTaIndex.toTickIndex());
      if (currTickData.initialized) {
        return { nextIndex: currTaIndex.toTickIndex(), nextTickData: currTickData };
      }
      currTaIndex = this.aToB ? currTaIndex.toPrevInitializableTickIndex() : currTaIndex.toNextInitializableTickIndex();
    }
    const lastIndexInArray = Math.max(
      Math.min(
        this.aToB ? currTaIndex.toTickIndex() + this.tickSpacing : currTaIndex.toTickIndex() - 1,
        MAX_TICK_INDEX
      ),
      MIN_TICK_INDEX
    );
    return { nextIndex: lastIndexInArray, nextTickData: null };
  }
  getLocalArrayIndex(arrayIndex, aToB) {
    return aToB ? this.startArrayIndex - arrayIndex : arrayIndex - this.startArrayIndex;
  }
  isArrayIndexInBounds(index, aToB) {
    const localArrayIndex = this.getLocalArrayIndex(index.arrayIndex, aToB);
    const seqLength = this.sequence.length;
    return localArrayIndex >= 0 && localArrayIndex < seqLength;
  }
  checkIfIndexIsInTickArrayRange(startTick, tickIndex) {
    const upperBound = startTick + this.tickSpacing * TICK_ARRAY_SIZE;
    return tickIndex >= startTick && tickIndex < upperBound;
  }
};

// src/quotes/swap/swap-manager.ts
import { ZERO as ZERO8 } from "@orca-so/common-sdk";
import { u64 as u645 } from "@solana/spl-token";
import BN11 from "bn.js";

// src/utils/math/swap-math.ts
import { BN as BN10 } from "@project-serum/anchor";

// src/utils/math/token-math.ts
import { U64_MAX as U64_MAX3, ZERO as ZERO7 } from "@orca-so/common-sdk";
import { BN as BN9 } from "@project-serum/anchor";

// src/utils/math/bit-math.ts
import { ZERO as ZERO6, ONE, MathUtil as MathUtil7, TWO, U64_MAX as U64_MAX2 } from "@orca-so/common-sdk";
import { BN as BN8 } from "@project-serum/anchor";
var BitMath = class {
  static mul(n0, n1, limit) {
    const result = n0.mul(n1);
    if (this.isOverLimit(result, limit)) {
      throw new WhirlpoolsError(
        `Mul result higher than u${limit}`,
        "MultiplicationOverflow" /* MultiplicationOverflow */
      );
    }
    return result;
  }
  static mulDiv(n0, n1, d, limit) {
    return this.mulDivRoundUpIf(n0, n1, d, false, limit);
  }
  static mulDivRoundUp(n0, n1, d, limit) {
    return this.mulDivRoundUpIf(n0, n1, d, true, limit);
  }
  static mulDivRoundUpIf(n0, n1, d, roundUp, limit) {
    if (d.eq(ZERO6)) {
      throw new WhirlpoolsError("mulDiv denominator is zero", "DivideByZero" /* DivideByZero */);
    }
    const p = this.mul(n0, n1, limit);
    const n = p.div(d);
    return roundUp && p.mod(d).gt(ZERO6) ? n.add(ONE) : n;
  }
  static checked_mul_shift_right(n0, n1, limit) {
    return this.checked_mul_shift_right_round_up_if(n0, n1, false, limit);
  }
  static checked_mul_shift_right_round_up_if(n0, n1, roundUp, limit) {
    if (n0.eq(ZERO6) || n1.eq(ZERO6)) {
      return ZERO6;
    }
    const p = this.mul(n0, n1, limit);
    if (this.isOverLimit(p, limit)) {
      throw new WhirlpoolsError(
        `MulShiftRight overflowed u${limit}.`,
        "MultiplicationShiftRightOverflow" /* MultiplicationShiftRightOverflow */
      );
    }
    const result = MathUtil7.fromX64_BN(p);
    const shouldRound = roundUp && result.and(U64_MAX2).gt(ZERO6);
    if (shouldRound && result.eq(U64_MAX2)) {
      throw new WhirlpoolsError(
        `MulShiftRight overflowed u${limit}.`,
        "MultiplicationOverflow" /* MultiplicationOverflow */
      );
    }
    return shouldRound ? result.add(ONE) : result;
  }
  static isOverLimit(n0, limit) {
    const limitBN = TWO.pow(new BN8(limit)).sub(ONE);
    return n0.gt(limitBN);
  }
  static divRoundUp(n, d) {
    return this.divRoundUpIf(n, d, true);
  }
  static divRoundUpIf(n, d, roundUp) {
    if (d.eq(ZERO6)) {
      throw new WhirlpoolsError("divRoundUpIf - divide by zero", "DivideByZero" /* DivideByZero */);
    }
    let q = n.div(d);
    return roundUp && n.mod(d).gt(ZERO6) ? q.add(ONE) : q;
  }
};

// src/utils/math/token-math.ts
function getAmountDeltaA(currSqrtPrice, targetSqrtPrice, currLiquidity, roundUp) {
  let [sqrtPriceLower, sqrtPriceUpper] = toIncreasingPriceOrder(currSqrtPrice, targetSqrtPrice);
  let sqrtPriceDiff = sqrtPriceUpper.sub(sqrtPriceLower);
  let numerator = currLiquidity.mul(sqrtPriceDiff).shln(64);
  let denominator = sqrtPriceLower.mul(sqrtPriceUpper);
  let quotient = numerator.div(denominator);
  let remainder = numerator.mod(denominator);
  let result = roundUp && !remainder.eq(ZERO7) ? quotient.add(new BN9(1)) : quotient;
  if (result.gt(U64_MAX3)) {
    throw new WhirlpoolsError("Results larger than U64", "TokenMaxExceeded" /* TokenMaxExceeded */);
  }
  return result;
}
function getAmountDeltaB(currSqrtPrice, targetSqrtPrice, currLiquidity, roundUp) {
  let [sqrtPriceLower, sqrtPriceUpper] = toIncreasingPriceOrder(currSqrtPrice, targetSqrtPrice);
  let sqrtPriceDiff = sqrtPriceUpper.sub(sqrtPriceLower);
  return BitMath.checked_mul_shift_right_round_up_if(currLiquidity, sqrtPriceDiff, roundUp, 128);
}
function getNextSqrtPrice(sqrtPrice, currLiquidity, amount, amountSpecifiedIsInput, aToB) {
  if (amountSpecifiedIsInput === aToB) {
    return getNextSqrtPriceFromARoundUp(sqrtPrice, currLiquidity, amount, amountSpecifiedIsInput);
  } else {
    return getNextSqrtPriceFromBRoundDown(sqrtPrice, currLiquidity, amount, amountSpecifiedIsInput);
  }
}
function toIncreasingPriceOrder(sqrtPrice0, sqrtPrice1) {
  if (sqrtPrice0.gt(sqrtPrice1)) {
    return [sqrtPrice1, sqrtPrice0];
  } else {
    return [sqrtPrice0, sqrtPrice1];
  }
}
function getNextSqrtPriceFromARoundUp(sqrtPrice, currLiquidity, amount, amountSpecifiedIsInput) {
  if (amount.eq(ZERO7)) {
    return sqrtPrice;
  }
  let p = BitMath.mul(sqrtPrice, amount, 256);
  let numerator = BitMath.mul(currLiquidity, sqrtPrice, 256).shln(64);
  if (BitMath.isOverLimit(numerator, 256)) {
    throw new WhirlpoolsError(
      "getNextSqrtPriceFromARoundUp - numerator overflow u256",
      "MultiplicationOverflow" /* MultiplicationOverflow */
    );
  }
  let currLiquidityShiftLeft = currLiquidity.shln(64);
  if (!amountSpecifiedIsInput && currLiquidityShiftLeft.lte(p)) {
    throw new WhirlpoolsError(
      "getNextSqrtPriceFromARoundUp - Unable to divide currLiquidityX64 by product",
      "DivideByZero" /* DivideByZero */
    );
  }
  let denominator = amountSpecifiedIsInput ? currLiquidityShiftLeft.add(p) : currLiquidityShiftLeft.sub(p);
  let price = BitMath.divRoundUp(numerator, denominator);
  if (price.lt(new BN9(MIN_SQRT_PRICE))) {
    throw new WhirlpoolsError(
      "getNextSqrtPriceFromARoundUp - price less than min sqrt price",
      "TokenMinSubceeded" /* TokenMinSubceeded */
    );
  } else if (price.gt(new BN9(MAX_SQRT_PRICE))) {
    throw new WhirlpoolsError(
      "getNextSqrtPriceFromARoundUp - price less than max sqrt price",
      "TokenMaxExceeded" /* TokenMaxExceeded */
    );
  }
  return price;
}
function getNextSqrtPriceFromBRoundDown(sqrtPrice, currLiquidity, amount, amountSpecifiedIsInput) {
  let amountX64 = amount.shln(64);
  let delta = BitMath.divRoundUpIf(amountX64, currLiquidity, !amountSpecifiedIsInput);
  if (amountSpecifiedIsInput) {
    sqrtPrice = sqrtPrice.add(delta);
  } else {
    sqrtPrice = sqrtPrice.sub(delta);
  }
  return sqrtPrice;
}

// src/utils/math/swap-math.ts
function computeSwapStep(amountRemaining, feeRate, currLiquidity, currSqrtPrice, targetSqrtPrice, amountSpecifiedIsInput, aToB) {
  let amountFixedDelta = getAmountFixedDelta(
    currSqrtPrice,
    targetSqrtPrice,
    currLiquidity,
    amountSpecifiedIsInput,
    aToB
  );
  let amountCalc = amountRemaining;
  if (amountSpecifiedIsInput) {
    const result = BitMath.mulDiv(
      amountRemaining,
      FEE_RATE_MUL_VALUE.sub(new BN10(feeRate)),
      FEE_RATE_MUL_VALUE,
      128
    );
    amountCalc = result;
  }
  let nextSqrtPrice = amountCalc.gte(amountFixedDelta) ? targetSqrtPrice : getNextSqrtPrice(currSqrtPrice, currLiquidity, amountCalc, amountSpecifiedIsInput, aToB);
  let isMaxSwap = nextSqrtPrice.eq(targetSqrtPrice);
  let amountUnfixedDelta = getAmountUnfixedDelta(
    currSqrtPrice,
    nextSqrtPrice,
    currLiquidity,
    amountSpecifiedIsInput,
    aToB
  );
  if (!isMaxSwap) {
    amountFixedDelta = getAmountFixedDelta(
      currSqrtPrice,
      nextSqrtPrice,
      currLiquidity,
      amountSpecifiedIsInput,
      aToB
    );
  }
  let amountIn = amountSpecifiedIsInput ? amountFixedDelta : amountUnfixedDelta;
  let amountOut = amountSpecifiedIsInput ? amountUnfixedDelta : amountFixedDelta;
  if (!amountSpecifiedIsInput && amountOut.gt(amountRemaining)) {
    amountOut = amountRemaining;
  }
  let feeAmount;
  if (amountSpecifiedIsInput && !isMaxSwap) {
    feeAmount = amountRemaining.sub(amountIn);
  } else {
    const feeRateBN = new BN10(feeRate);
    feeAmount = BitMath.mulDivRoundUp(amountIn, feeRateBN, FEE_RATE_MUL_VALUE.sub(feeRateBN), 128);
  }
  return {
    amountIn,
    amountOut,
    nextPrice: nextSqrtPrice,
    feeAmount
  };
}
function getAmountFixedDelta(currSqrtPrice, targetSqrtPrice, currLiquidity, amountSpecifiedIsInput, aToB) {
  if (aToB === amountSpecifiedIsInput) {
    return getAmountDeltaA(currSqrtPrice, targetSqrtPrice, currLiquidity, amountSpecifiedIsInput);
  } else {
    return getAmountDeltaB(currSqrtPrice, targetSqrtPrice, currLiquidity, amountSpecifiedIsInput);
  }
}
function getAmountUnfixedDelta(currSqrtPrice, targetSqrtPrice, currLiquidity, amountSpecifiedIsInput, aToB) {
  if (aToB === amountSpecifiedIsInput) {
    return getAmountDeltaB(currSqrtPrice, targetSqrtPrice, currLiquidity, !amountSpecifiedIsInput);
  } else {
    return getAmountDeltaA(currSqrtPrice, targetSqrtPrice, currLiquidity, !amountSpecifiedIsInput);
  }
}

// src/quotes/swap/swap-manager.ts
function computeSwap(whirlpoolData, tickSequence, tokenAmount, sqrtPriceLimit, amountSpecifiedIsInput, aToB) {
  let amountRemaining = tokenAmount;
  let amountCalculated = ZERO8;
  let currSqrtPrice = whirlpoolData.sqrtPrice;
  let currLiquidity = whirlpoolData.liquidity;
  let currTickIndex = whirlpoolData.tickCurrentIndex;
  let totalFeeAmount = ZERO8;
  const feeRate = whirlpoolData.feeRate;
  const protocolFeeRate = whirlpoolData.protocolFeeRate;
  let currProtocolFee = new u645(0);
  let currFeeGrowthGlobalInput = aToB ? whirlpoolData.feeGrowthGlobalA : whirlpoolData.feeGrowthGlobalB;
  while (amountRemaining.gt(ZERO8) && !sqrtPriceLimit.eq(currSqrtPrice)) {
    let { nextIndex: nextTickIndex } = tickSequence.findNextInitializedTickIndex(currTickIndex);
    let { nextTickPrice, nextSqrtPriceLimit: targetSqrtPrice } = getNextSqrtPrices(
      nextTickIndex,
      sqrtPriceLimit,
      aToB
    );
    const swapComputation = computeSwapStep(
      amountRemaining,
      feeRate,
      currLiquidity,
      currSqrtPrice,
      targetSqrtPrice,
      amountSpecifiedIsInput,
      aToB
    );
    totalFeeAmount = totalFeeAmount.add(swapComputation.feeAmount);
    if (amountSpecifiedIsInput) {
      amountRemaining = amountRemaining.sub(swapComputation.amountIn);
      amountRemaining = amountRemaining.sub(swapComputation.feeAmount);
      amountCalculated = amountCalculated.add(swapComputation.amountOut);
    } else {
      amountRemaining = amountRemaining.sub(swapComputation.amountOut);
      amountCalculated = amountCalculated.add(swapComputation.amountIn);
      amountCalculated = amountCalculated.add(swapComputation.feeAmount);
    }
    let { nextProtocolFee, nextFeeGrowthGlobalInput } = calculateFees(
      swapComputation.feeAmount,
      protocolFeeRate,
      currLiquidity,
      currProtocolFee,
      currFeeGrowthGlobalInput
    );
    currProtocolFee = nextProtocolFee;
    currFeeGrowthGlobalInput = nextFeeGrowthGlobalInput;
    if (swapComputation.nextPrice.eq(nextTickPrice)) {
      const nextTick = tickSequence.getTick(nextTickIndex);
      if (nextTick.initialized) {
        currLiquidity = calculateNextLiquidity(nextTick.liquidityNet, currLiquidity, aToB);
      }
      currTickIndex = aToB ? nextTickIndex - 1 : nextTickIndex;
    } else {
      currTickIndex = PriceMath.sqrtPriceX64ToTickIndex(swapComputation.nextPrice);
    }
    currSqrtPrice = swapComputation.nextPrice;
  }
  let { amountA, amountB } = calculateEstTokens(
    tokenAmount,
    amountRemaining,
    amountCalculated,
    aToB,
    amountSpecifiedIsInput
  );
  return {
    amountA,
    amountB,
    nextTickIndex: currTickIndex,
    nextSqrtPrice: currSqrtPrice,
    totalFeeAmount
  };
}
function getNextSqrtPrices(nextTick, sqrtPriceLimit, aToB) {
  const nextTickPrice = PriceMath.tickIndexToSqrtPriceX64(nextTick);
  const nextSqrtPriceLimit = aToB ? BN11.max(sqrtPriceLimit, nextTickPrice) : BN11.min(sqrtPriceLimit, nextTickPrice);
  return { nextTickPrice, nextSqrtPriceLimit };
}
function calculateFees(feeAmount, protocolFeeRate, currLiquidity, currProtocolFee, currFeeGrowthGlobalInput) {
  let nextProtocolFee = currProtocolFee;
  let nextFeeGrowthGlobalInput = currFeeGrowthGlobalInput;
  let globalFee = feeAmount;
  if (protocolFeeRate > 0) {
    let delta = calculateProtocolFee(globalFee, protocolFeeRate);
    globalFee = globalFee.sub(delta);
    nextProtocolFee = nextProtocolFee.add(currProtocolFee);
  }
  if (currLiquidity.gt(ZERO8)) {
    const globalFeeIncrement = globalFee.shln(64).div(currLiquidity);
    nextFeeGrowthGlobalInput = nextFeeGrowthGlobalInput.add(globalFeeIncrement);
  }
  return {
    nextProtocolFee,
    nextFeeGrowthGlobalInput
  };
}
function calculateProtocolFee(globalFee, protocolFeeRate) {
  return globalFee.mul(new u645(protocolFeeRate).div(PROTOCOL_FEE_RATE_MUL_VALUE));
}
function calculateEstTokens(amount, amountRemaining, amountCalculated, aToB, amountSpecifiedIsInput) {
  return aToB === amountSpecifiedIsInput ? {
    amountA: amount.sub(amountRemaining),
    amountB: amountCalculated
  } : {
    amountA: amountCalculated,
    amountB: amount.sub(amountRemaining)
  };
}
function calculateNextLiquidity(tickNetLiquidity, currLiquidity, aToB) {
  return aToB ? currLiquidity.sub(tickNetLiquidity) : currLiquidity.add(tickNetLiquidity);
}

// src/quotes/swap/swap-quote-impl.ts
function simulateSwap(params) {
  const {
    aToB,
    whirlpoolData,
    tickArrays,
    tokenAmount,
    sqrtPriceLimit,
    otherAmountThreshold,
    amountSpecifiedIsInput
  } = params;
  if (sqrtPriceLimit.gt(new BN12(MAX_SQRT_PRICE)) || sqrtPriceLimit.lt(new BN12(MIN_SQRT_PRICE))) {
    throw new WhirlpoolsError(
      "Provided SqrtPriceLimit is out of bounds.",
      "SqrtPriceOutOfBounds" /* SqrtPriceOutOfBounds */
    );
  }
  if (aToB && sqrtPriceLimit.gt(whirlpoolData.sqrtPrice) || !aToB && sqrtPriceLimit.lt(whirlpoolData.sqrtPrice)) {
    throw new WhirlpoolsError(
      "Provided SqrtPriceLimit is in the opposite direction of the trade.",
      "InvalidSqrtPriceLimitDirection" /* InvalidSqrtPriceLimitDirection */
    );
  }
  if (tokenAmount.eq(ZERO9)) {
    throw new WhirlpoolsError("Provided tokenAmount is zero.", "ZeroTradableAmount" /* ZeroTradableAmount */);
  }
  const tickSequence = new TickArraySequence(tickArrays, whirlpoolData.tickSpacing, aToB);
  if (!tickSequence.isValidTickArray0(whirlpoolData.tickCurrentIndex)) {
    throw new WhirlpoolsError(
      "TickArray at index 0 does not contain the Whirlpool current tick index.",
      "TickArraySequenceInvalid" /* TickArraySequenceInvalid */
    );
  }
  const swapResults = computeSwap(
    whirlpoolData,
    tickSequence,
    tokenAmount,
    sqrtPriceLimit,
    amountSpecifiedIsInput,
    aToB
  );
  if (amountSpecifiedIsInput) {
    if (aToB && otherAmountThreshold.gt(swapResults.amountB) || !aToB && otherAmountThreshold.gt(swapResults.amountA)) {
      throw new WhirlpoolsError(
        "Quoted amount for the other token is below the otherAmountThreshold.",
        "AmountOutBelowMinimum" /* AmountOutBelowMinimum */
      );
    }
  } else {
    if (aToB && otherAmountThreshold.lt(swapResults.amountA) || !aToB && otherAmountThreshold.lt(swapResults.amountB)) {
      throw new WhirlpoolsError(
        "Quoted amount for the other token is above the otherAmountThreshold.",
        "AmountInAboveMaximum" /* AmountInAboveMaximum */
      );
    }
  }
  const { estimatedAmountIn, estimatedAmountOut } = remapAndAdjustTokens(
    swapResults.amountA,
    swapResults.amountB,
    aToB
  );
  const numOfTickCrossings = tickSequence.getNumOfTouchedArrays();
  if (numOfTickCrossings > MAX_SWAP_TICK_ARRAYS) {
    throw new WhirlpoolsError(
      `Input amount causes the quote to traverse more than the allowable amount of tick-arrays ${numOfTickCrossings}`,
      "TickArrayCrossingAboveMax" /* TickArrayCrossingAboveMax */
    );
  }
  const touchedArrays = tickSequence.getTouchedArrays(MAX_SWAP_TICK_ARRAYS);
  return {
    estimatedAmountIn,
    estimatedAmountOut,
    estimatedEndTickIndex: swapResults.nextTickIndex,
    estimatedEndSqrtPrice: swapResults.nextSqrtPrice,
    estimatedFeeAmount: swapResults.totalFeeAmount,
    amount: tokenAmount,
    amountSpecifiedIsInput,
    aToB,
    otherAmountThreshold,
    sqrtPriceLimit,
    tickArray0: touchedArrays[0],
    tickArray1: touchedArrays[1],
    tickArray2: touchedArrays[2]
  };
}
function remapAndAdjustTokens(amountA, amountB, aToB) {
  const estimatedAmountIn = aToB ? amountA : amountB;
  const estimatedAmountOut = aToB ? amountB : amountA;
  return {
    estimatedAmountIn,
    estimatedAmountOut
  };
}

// src/quotes/public/swap-quote.ts
async function swapQuoteByInputToken(whirlpool, inputTokenMint, tokenAmount, slippageTolerance, programId, fetcher, refresh) {
  const params = await swapQuoteByToken(
    whirlpool,
    inputTokenMint,
    tokenAmount,
    1 /* TokenA */,
    true,
    programId,
    fetcher,
    refresh
  );
  return swapQuoteWithParams(params);
}
async function swapQuoteByOutputToken(whirlpool, outputTokenMint, tokenAmount, slippageTolerance, programId, fetcher, refresh) {
  const params = await swapQuoteByToken(
    whirlpool,
    outputTokenMint,
    tokenAmount,
    2 /* TokenB */,
    false,
    programId,
    fetcher,
    refresh
  );
  return swapQuoteWithParams(params);
}
function swapQuoteWithParams(params) {
  const quote = simulateSwap(params);
  const slippageAdjustedQuote = {
    ...quote,
    ...SwapUtils.calculateSwapAmountsFromQuote(quote.amount, quote.amountSpecifiedIsInput)
  };
  return slippageAdjustedQuote;
}
async function swapQuoteByToken(whirlpool, inputTokenMint, tokenAmount, amountSpecifiedTokenType, amountSpecifiedIsInput, programId, fetcher, refresh) {
  const whirlpoolData = whirlpool.getData();
  const swapMintKey = AddressUtil6.toPubKey(inputTokenMint);
  const swapTokenType = PoolUtil.getTokenType(whirlpoolData, swapMintKey);
  invariant7(!!swapTokenType, "swapTokenMint does not match any tokens on this pool");
  const aToB = swapTokenType === amountSpecifiedTokenType;
  const tickArrays = await SwapUtils.getTickArrays(
    whirlpoolData.tickCurrentIndex,
    whirlpoolData.tickSpacing,
    aToB,
    AddressUtil6.toPubKey(programId),
    whirlpool.getAddress(),
    fetcher,
    refresh
  );
  return {
    whirlpoolData,
    tokenAmount,
    aToB,
    amountSpecifiedIsInput,
    sqrtPriceLimit: SwapUtils.getDefaultSqrtPriceLimit(aToB),
    otherAmountThreshold: SwapUtils.getDefaultOtherAmountThreshold(amountSpecifiedIsInput),
    tickArrays
  };
}

// src/quotes/public/dev-fee-swap-quote.ts
async function swapQuoteByInputTokenWithDevFees(whirlpool, inputTokenMint, tokenAmount, slippageTolerance, programId, fetcher, devFeePercentage, refresh) {
  if (devFeePercentage.toDecimal().greaterThanOrEqualTo(1)) {
    throw new WhirlpoolsError(
      "Provided devFeePercentage must be less than 100%",
      "InvalidDevFeePercentage" /* InvalidDevFeePercentage */
    );
  }
  const devFeeAmount = tokenAmount.mul(devFeePercentage.numerator).div(devFeePercentage.denominator);
  const slippageAdjustedQuote = await swapQuoteByInputToken(
    whirlpool,
    inputTokenMint,
    tokenAmount.sub(devFeeAmount),
    slippageTolerance,
    programId,
    fetcher,
    refresh
  );
  const devFeeAdjustedQuote = {
    ...slippageAdjustedQuote,
    amountSpecifiedIsInput: true,
    estimatedAmountIn: slippageAdjustedQuote.estimatedAmountIn.add(devFeeAmount),
    estimatedFeeAmount: slippageAdjustedQuote.estimatedFeeAmount.add(devFeeAmount),
    estimatedSwapFeeAmount: slippageAdjustedQuote.estimatedFeeAmount,
    devFeeAmount
  };
  return devFeeAdjustedQuote;
}

// src/impl/whirlpool-client-impl.ts
import { AddressUtil as AddressUtil8, TransactionBuilder as TransactionBuilder5 } from "@orca-so/common-sdk";
import { Keypair as Keypair6, PublicKey as PublicKey12 } from "@solana/web3.js";
import invariant9 from "tiny-invariant";

// src/impl/util.ts
import BN13 from "bn.js";
async function getTokenMintInfos(fetcher, data, refresh) {
  const mintA = data.tokenMintA;
  const infoA = await fetcher.getMintInfo(mintA, refresh);
  if (!infoA) {
    throw new Error(`Unable to fetch MintInfo for mint - ${mintA}`);
  }
  const mintB = data.tokenMintB;
  const infoB = await fetcher.getMintInfo(mintB, refresh);
  if (!infoB) {
    throw new Error(`Unable to fetch MintInfo for mint - ${mintB}`);
  }
  return [
    { mint: mintA, ...infoA },
    { mint: mintB, ...infoB }
  ];
}
async function getRewardInfos(fetcher, data, refresh) {
  const rewardInfos = [];
  for (const rewardInfo of data.rewardInfos) {
    rewardInfos.push(await getRewardInfo(fetcher, rewardInfo, refresh));
  }
  return rewardInfos;
}
async function getRewardInfo(fetcher, data, refresh) {
  const rewardInfo = { ...data, initialized: false, vaultAmount: new BN13(0) };
  if (PoolUtil.isRewardInitialized(data)) {
    const vaultInfo = await fetcher.getTokenInfo(data.vault, refresh);
    if (!vaultInfo) {
      throw new Error(`Unable to fetch TokenAccountInfo for vault - ${data.vault}`);
    }
    rewardInfo.initialized = true;
    rewardInfo.vaultAmount = vaultInfo.amount;
  }
  return rewardInfo;
}
async function getTokenVaultAccountInfos(fetcher, data, refresh) {
  const vaultA = data.tokenVaultA;
  const vaultInfoA = await fetcher.getTokenInfo(vaultA, refresh);
  if (!vaultInfoA) {
    throw new Error(`Unable to fetch TokenAccountInfo for vault - ${vaultA}`);
  }
  const vaultB = data.tokenVaultB;
  const vaultInfoB = await fetcher.getTokenInfo(vaultB, refresh);
  if (!vaultInfoB) {
    throw new Error(`Unable to fetch TokenAccountInfo for vault - ${vaultB}`);
  }
  return [vaultInfoA, vaultInfoB];
}

// src/impl/whirlpool-impl.ts
import {
  AddressUtil as AddressUtil7,
  deriveATA as deriveATA2,
  resolveOrCreateATAs as resolveOrCreateATAs3,
  TokenUtil as TokenUtil4,
  TransactionBuilder as TransactionBuilder4,
  ZERO as ZERO10
} from "@orca-so/common-sdk";
import { BN as BN14, translateAddress } from "@project-serum/anchor";
import { NATIVE_MINT as NATIVE_MINT4 } from "@solana/spl-token";
import { Keypair as Keypair5 } from "@solana/web3.js";
import invariant8 from "tiny-invariant";
var WhirlpoolImpl = class {
  constructor(ctx, address, tokenAInfo, tokenBInfo, tokenVaultAInfo, tokenVaultBInfo, rewardInfos, data) {
    this.ctx = ctx;
    this.address = address;
    this.tokenAInfo = tokenAInfo;
    this.tokenBInfo = tokenBInfo;
    this.tokenVaultAInfo = tokenVaultAInfo;
    this.tokenVaultBInfo = tokenVaultBInfo;
    this.rewardInfos = rewardInfos;
    this.data = data;
  }
  getAddress() {
    return this.address;
  }
  getData() {
    return this.data;
  }
  getTokenAInfo() {
    return this.tokenAInfo;
  }
  getTokenBInfo() {
    return this.tokenBInfo;
  }
  getTokenVaultAInfo() {
    return this.tokenVaultAInfo;
  }
  getTokenVaultBInfo() {
    return this.tokenVaultBInfo;
  }
  getRewardInfos() {
    return this.rewardInfos;
  }
  async refreshData() {
    await this.refresh();
    return this.data;
  }
  async openPosition(tickLower, tickUpper, liquidityInput, wallet, funder) {
    await this.refresh();
    return this.getOpenPositionWithOptMetadataTx(
      tickLower,
      tickUpper,
      liquidityInput,
      !!wallet ? AddressUtil7.toPubKey(wallet) : this.ctx.wallet.publicKey,
      !!funder ? AddressUtil7.toPubKey(funder) : this.ctx.wallet.publicKey
    );
  }
  async openPositionWithMetadata(tickLower, tickUpper, liquidityInput, sourceWallet, positionWallet, funder) {
    await this.refresh();
    return this.getOpenPositionWithOptMetadataTx(
      tickLower,
      tickUpper,
      liquidityInput,
      !!sourceWallet ? AddressUtil7.toPubKey(sourceWallet) : this.ctx.wallet.publicKey,
      !!funder ? AddressUtil7.toPubKey(funder) : this.ctx.wallet.publicKey,
      true
    );
  }
  async initTickArrayForTicks(ticks, funder, refresh = true) {
    const initTickArrayStartPdas = await TickArrayUtil.getUninitializedArraysPDAs(
      ticks,
      this.ctx.program.programId,
      this.address,
      this.data.tickSpacing,
      this.ctx.fetcher,
      refresh
    );
    if (!initTickArrayStartPdas.length) {
      return null;
    }
    const txBuilder = new TransactionBuilder4(
      this.ctx.provider.connection,
      this.ctx.provider.wallet
    );
    initTickArrayStartPdas.forEach((initTickArrayInfo) => {
      txBuilder.addInstruction(
        initTickArrayIx(this.ctx.program, {
          startTick: initTickArrayInfo.startIndex,
          tickArrayPda: initTickArrayInfo.pda,
          whirlpool: this.address,
          funder: !!funder ? AddressUtil7.toPubKey(funder) : this.ctx.provider.wallet.publicKey
        })
      );
    });
    return txBuilder;
  }
  async closePosition(positionAddress, slippageTolerance, destinationWallet, positionWallet, payer) {
    await this.refresh();
    const positionWalletKey = positionWallet ? AddressUtil7.toPubKey(positionWallet) : this.ctx.wallet.publicKey;
    const destinationWalletKey = destinationWallet ? AddressUtil7.toPubKey(destinationWallet) : this.ctx.wallet.publicKey;
    const payerKey = payer ? AddressUtil7.toPubKey(payer) : this.ctx.wallet.publicKey;
    return this.getClosePositionIx(
      AddressUtil7.toPubKey(positionAddress),
      slippageTolerance,
      destinationWalletKey,
      positionWalletKey,
      payerKey
    );
  }
  async swap(quote, sourceWallet) {
    const sourceWalletKey = sourceWallet ? AddressUtil7.toPubKey(sourceWallet) : this.ctx.wallet.publicKey;
    return this.getSwapTx(quote, sourceWalletKey);
  }
  async swapWithDevFees(quote, devFeeWallet, wallet, payer) {
    const sourceWalletKey = wallet ? AddressUtil7.toPubKey(wallet) : this.ctx.wallet.publicKey;
    const payerKey = payer ? AddressUtil7.toPubKey(payer) : this.ctx.wallet.publicKey;
    const txBuilder = new TransactionBuilder4(
      this.ctx.provider.connection,
      this.ctx.provider.wallet
    );
    if (!quote.devFeeAmount.eq(ZERO10)) {
      const inputToken = quote.aToB === quote.amountSpecifiedIsInput ? this.getTokenAInfo() : this.getTokenBInfo();
      txBuilder.addInstruction(
        await TokenUtil4.createSendTokensToWalletInstruction(
          this.ctx.connection,
          sourceWalletKey,
          devFeeWallet,
          inputToken.mint,
          inputToken.decimals,
          quote.devFeeAmount,
          () => this.ctx.fetcher.getAccountRentExempt(),
          payerKey
        )
      );
    }
    return this.getSwapTx(quote, sourceWalletKey, txBuilder);
  }
  async getOpenPositionWithOptMetadataTx(tickLower, tickUpper, liquidityInput, wallet, funder, withMetadata = false) {
    invariant8(TickUtil.checkTickInBounds(tickLower), "tickLower is out of bounds.");
    invariant8(TickUtil.checkTickInBounds(tickUpper), "tickUpper is out of bounds.");
    const { liquidityAmount: liquidity, tokenMaxA, tokenMaxB } = liquidityInput;
    invariant8(liquidity.gt(new BN14(0)), "liquidity must be greater than zero");
    const whirlpool = await this.ctx.fetcher.getPool(this.address, false);
    if (!whirlpool) {
      throw new Error(`Whirlpool not found: ${translateAddress(this.address).toBase58()}`);
    }
    invariant8(
      TickUtil.isTickInitializable(tickLower, whirlpool.tickSpacing),
      `lower tick ${tickLower} is not an initializable tick for tick-spacing ${whirlpool.tickSpacing}`
    );
    invariant8(
      TickUtil.isTickInitializable(tickUpper, whirlpool.tickSpacing),
      `upper tick ${tickUpper} is not an initializable tick for tick-spacing ${whirlpool.tickSpacing}`
    );
    const positionMintKeypair = Keypair5.generate();
    const positionPda = PDAUtil.getPosition(
      this.ctx.program.programId,
      positionMintKeypair.publicKey
    );
    const metadataPda = PDAUtil.getPositionMetadata(positionMintKeypair.publicKey);
    const positionTokenAccountAddress = await deriveATA2(wallet, positionMintKeypair.publicKey);
    const txBuilder = new TransactionBuilder4(
      this.ctx.provider.connection,
      this.ctx.provider.wallet
    );
    const positionIx = (withMetadata ? openPositionWithMetadataIx : openPositionIx)(
      this.ctx.program,
      {
        funder,
        owner: wallet,
        positionPda,
        metadataPda,
        positionMintAddress: positionMintKeypair.publicKey,
        positionTokenAccount: positionTokenAccountAddress,
        whirlpool: this.address,
        tickLowerIndex: tickLower,
        tickUpperIndex: tickUpper
      }
    );
    txBuilder.addInstruction(positionIx).addSigner(positionMintKeypair);
    const [ataA, ataB] = await resolveOrCreateATAs3(
      this.ctx.connection,
      wallet,
      [
        { tokenMint: whirlpool.tokenMintA, wrappedSolAmountIn: tokenMaxA },
        { tokenMint: whirlpool.tokenMintB, wrappedSolAmountIn: tokenMaxB }
      ],
      () => this.ctx.fetcher.getAccountRentExempt(),
      funder
    );
    const { address: tokenOwnerAccountA, ...tokenOwnerAccountAIx } = ataA;
    const { address: tokenOwnerAccountB, ...tokenOwnerAccountBIx } = ataB;
    txBuilder.addInstruction(tokenOwnerAccountAIx);
    txBuilder.addInstruction(tokenOwnerAccountBIx);
    const tickArrayLowerPda = PDAUtil.getTickArrayFromTickIndex(
      tickLower,
      this.data.tickSpacing,
      this.address,
      this.ctx.program.programId
    );
    const tickArrayUpperPda = PDAUtil.getTickArrayFromTickIndex(
      tickUpper,
      this.data.tickSpacing,
      this.address,
      this.ctx.program.programId
    );
    const liquidityIx = increaseLiquidityIx(this.ctx.program, {
      liquidityAmount: liquidity,
      tokenMaxA,
      tokenMaxB,
      whirlpool: this.address,
      positionAuthority: wallet,
      position: positionPda.publicKey,
      positionTokenAccount: positionTokenAccountAddress,
      tokenOwnerAccountA,
      tokenOwnerAccountB,
      tokenVaultA: whirlpool.tokenVaultA,
      tokenVaultB: whirlpool.tokenVaultB,
      tickArrayLower: tickArrayLowerPda.publicKey,
      tickArrayUpper: tickArrayUpperPda.publicKey
    });
    txBuilder.addInstruction(liquidityIx);
    return {
      positionMint: positionMintKeypair.publicKey,
      tx: txBuilder
    };
  }
  async getClosePositionIx(positionAddress, slippageTolerance, destinationWallet, positionWallet, payerKey) {
    const positionData = await this.ctx.fetcher.getPosition(positionAddress, true);
    if (!positionData) {
      throw new Error(`Position not found: ${positionAddress.toBase58()}`);
    }
    const whirlpool = this.data;
    invariant8(
      positionData.whirlpool.equals(this.address),
      `Position ${positionAddress.toBase58()} is not a position for Whirlpool ${this.address.toBase58()}`
    );
    const positionTokenAccount = await deriveATA2(positionWallet, positionData.positionMint);
    const tokenAccountsTxBuilder = new TransactionBuilder4(
      this.ctx.provider.connection,
      this.ctx.provider.wallet
    );
    const accountExemption = await this.ctx.fetcher.getAccountRentExempt();
    const txBuilder = new TransactionBuilder4(
      this.ctx.provider.connection,
      this.ctx.provider.wallet
    );
    const tickArrayLower = PDAUtil.getTickArrayFromTickIndex(
      positionData.tickLowerIndex,
      whirlpool.tickSpacing,
      positionData.whirlpool,
      this.ctx.program.programId
    ).publicKey;
    const tickArrayUpper = PDAUtil.getTickArrayFromTickIndex(
      positionData.tickUpperIndex,
      whirlpool.tickSpacing,
      positionData.whirlpool,
      this.ctx.program.programId
    ).publicKey;
    const [tickArrayLowerData, tickArrayUpperData] = await getTickArrayDataForPosition(
      this.ctx,
      positionData,
      whirlpool,
      true
    );
    invariant8(
      !!tickArrayLowerData,
      `Tick array ${tickArrayLower} expected to be initialized for whirlpool ${this.address}`
    );
    invariant8(
      !!tickArrayUpperData,
      `Tick array ${tickArrayUpper} expected to be initialized for whirlpool ${this.address}`
    );
    const position = new PositionImpl(
      this.ctx,
      positionAddress,
      positionData,
      whirlpool,
      tickArrayLowerData,
      tickArrayUpperData
    );
    const tickLower = position.getLowerTickData();
    const tickUpper = position.getUpperTickData();
    const feesQuote = collectFeesQuote({
      position: positionData,
      whirlpool,
      tickLower,
      tickUpper
    });
    const rewardsQuote = collectRewardsQuote({
      position: positionData,
      whirlpool,
      tickLower,
      tickUpper
    });
    const shouldCollectFees = feesQuote.feeOwedA.gtn(0) || feesQuote.feeOwedB.gtn(0);
    invariant8(
      this.data.rewardInfos.length === rewardsQuote.length,
      "Rewards quote does not match reward infos length"
    );
    const shouldDecreaseLiquidity = positionData.liquidity.gtn(0);
    const rewardsToCollect = this.data.rewardInfos.filter((_, i) => (rewardsQuote[i] ?? ZERO10).gtn(0)).map((info) => info.mint);
    const shouldCollectRewards = rewardsToCollect.length > 0;
    let mintType = "ALL" /* ALL */;
    if ((shouldDecreaseLiquidity || shouldCollectFees) && !shouldCollectRewards) {
      mintType = "POOL_ONLY" /* POOL_ONLY */;
    } else if (!(shouldDecreaseLiquidity || shouldCollectFees) && shouldCollectRewards) {
      mintType = "REWARDS_ONLY" /* REWARD_ONLY */;
    }
    const affiliatedMints = getTokenMintsFromWhirlpools([whirlpool], mintType);
    const { ataTokenAddresses: walletTokenAccountsByMint, resolveAtaIxs } = await resolveAtaForMints(this.ctx, {
      mints: affiliatedMints.mintMap,
      accountExemption,
      receiver: destinationWallet,
      payer: payerKey
    });
    tokenAccountsTxBuilder.addInstructions(resolveAtaIxs);
    if (affiliatedMints.hasNativeMint) {
      let { address: wSOLAta, ...resolveWSolIx } = createWSOLAccountInstructions(
        destinationWallet,
        ZERO10,
        accountExemption,
        payerKey,
        destinationWallet
      );
      walletTokenAccountsByMint[NATIVE_MINT4.toBase58()] = wSOLAta;
      txBuilder.addInstruction(resolveWSolIx);
    }
    if (shouldDecreaseLiquidity) {
      const tokenOwnerAccountA = walletTokenAccountsByMint[whirlpool.tokenMintA.toBase58()];
      const tokenOwnerAccountB = walletTokenAccountsByMint[whirlpool.tokenMintB.toBase58()];
      const decreaseLiqQuote = decreaseLiquidityQuoteByLiquidityWithParams({
        liquidity: positionData.liquidity,
        slippageTolerance,
        sqrtPrice: whirlpool.sqrtPrice,
        tickCurrentIndex: whirlpool.tickCurrentIndex,
        tickLowerIndex: positionData.tickLowerIndex,
        tickUpperIndex: positionData.tickUpperIndex
      });
      const liquidityIx = decreaseLiquidityIx(this.ctx.program, {
        liquidityAmount: decreaseLiqQuote.liquidityAmount,
        tokenMinA: decreaseLiqQuote.tokenMinA,
        tokenMinB: decreaseLiqQuote.tokenMinB,
        whirlpool: positionData.whirlpool,
        positionAuthority: positionWallet,
        position: positionAddress,
        positionTokenAccount,
        tokenOwnerAccountA,
        tokenOwnerAccountB,
        tokenVaultA: whirlpool.tokenVaultA,
        tokenVaultB: whirlpool.tokenVaultB,
        tickArrayLower,
        tickArrayUpper
      });
      txBuilder.addInstruction(liquidityIx);
    }
    if (shouldCollectFees) {
      const collectFeexTx = await position.collectFees(
        false,
        walletTokenAccountsByMint,
        destinationWallet,
        positionWallet,
        payerKey,
        true
      );
      txBuilder.addInstruction(collectFeexTx.compressIx(false));
    }
    if (shouldCollectRewards) {
      const collectRewardsTx = await position.collectRewards(
        rewardsToCollect,
        false,
        walletTokenAccountsByMint,
        destinationWallet,
        positionWallet,
        payerKey
      );
      txBuilder.addInstruction(collectRewardsTx.compressIx(false));
    }
    const positionIx = closePositionIx(this.ctx.program, {
      positionAuthority: positionWallet,
      receiver: destinationWallet,
      positionTokenAccount,
      position: positionAddress,
      positionMint: positionData.positionMint
    });
    txBuilder.addInstruction(positionIx);
    const txBuilders = [];
    if (!tokenAccountsTxBuilder.isEmpty()) {
      txBuilders.push(tokenAccountsTxBuilder);
    }
    txBuilders.push(txBuilder);
    return txBuilders;
  }
  async getSwapTx(input, wallet, initTxBuilder) {
    invariant8(input.amount.gt(ZERO10), "swap amount must be more than zero.");
    const tickArrayAddresses = [input.tickArray0, input.tickArray1, input.tickArray2];
    const tickArrays = await this.ctx.fetcher.listTickArrays(tickArrayAddresses, true);
    const uninitializedIndices = TickArrayUtil.getUninitializedArrays(tickArrays);
    if (uninitializedIndices.length > 0) {
      const uninitializedArrays = uninitializedIndices.map((index) => tickArrayAddresses[index].toBase58()).join(", ");
      throw new Error(`TickArray addresses - [${uninitializedArrays}] need to be initialized.`);
    }
    const { amount, aToB } = input;
    const whirlpool = this.data;
    const txBuilder = initTxBuilder ?? new TransactionBuilder4(this.ctx.provider.connection, this.ctx.provider.wallet);
    const [ataA, ataB] = await resolveOrCreateATAs3(
      this.ctx.connection,
      wallet,
      [
        { tokenMint: whirlpool.tokenMintA, wrappedSolAmountIn: aToB ? amount : ZERO10 },
        { tokenMint: whirlpool.tokenMintB, wrappedSolAmountIn: !aToB ? amount : ZERO10 }
      ],
      () => this.ctx.fetcher.getAccountRentExempt()
    );
    const { address: tokenOwnerAccountA, ...tokenOwnerAccountAIx } = ataA;
    const { address: tokenOwnerAccountB, ...tokenOwnerAccountBIx } = ataB;
    txBuilder.addInstruction(tokenOwnerAccountAIx);
    txBuilder.addInstruction(tokenOwnerAccountBIx);
    const oraclePda = PDAUtil.getOracle(this.ctx.program.programId, this.address);
    txBuilder.addInstruction(
      swapIx(this.ctx.program, {
        ...input,
        whirlpool: this.address,
        tokenAuthority: wallet,
        tokenOwnerAccountA,
        tokenVaultA: whirlpool.tokenVaultA,
        tokenOwnerAccountB,
        tokenVaultB: whirlpool.tokenVaultB,
        oracle: oraclePda.publicKey
      })
    );
    return txBuilder;
  }
  async refresh() {
    const account = await this.ctx.fetcher.getPool(this.address, true);
    if (!!account) {
      const rewardInfos = await getRewardInfos(this.ctx.fetcher, account, true);
      const [tokenVaultAInfo, tokenVaultBInfo] = await getTokenVaultAccountInfos(
        this.ctx.fetcher,
        account,
        true
      );
      this.data = account;
      this.tokenVaultAInfo = tokenVaultAInfo;
      this.tokenVaultBInfo = tokenVaultBInfo;
      this.rewardInfos = rewardInfos;
    }
  }
};

// src/impl/whirlpool-client-impl.ts
var WhirlpoolClientImpl = class {
  constructor(ctx) {
    this.ctx = ctx;
  }
  getContext() {
    return this.ctx;
  }
  getFetcher() {
    return this.ctx.fetcher;
  }
  async getPool(poolAddress, refresh = false) {
    const account = await this.ctx.fetcher.getPool(poolAddress, refresh);
    if (!account) {
      throw new Error(`Unable to fetch Whirlpool at address at ${poolAddress}`);
    }
    const tokenInfos = await getTokenMintInfos(this.ctx.fetcher, account, refresh);
    const vaultInfos = await getTokenVaultAccountInfos(this.ctx.fetcher, account, refresh);
    const rewardInfos = await getRewardInfos(this.ctx.fetcher, account, refresh);
    return new WhirlpoolImpl(
      this.ctx,
      AddressUtil8.toPubKey(poolAddress),
      tokenInfos[0],
      tokenInfos[1],
      vaultInfos[0],
      vaultInfos[1],
      rewardInfos,
      account
    );
  }
  async getPools(poolAddresses, refresh = false) {
    const accounts2 = (await this.ctx.fetcher.listPools(poolAddresses, refresh)).filter(
      (account) => !!account
    );
    if (accounts2.length !== poolAddresses.length) {
      throw new Error(`Unable to fetch all Whirlpools at addresses ${poolAddresses}`);
    }
    const tokenMints = /* @__PURE__ */ new Set();
    const tokenAccounts = /* @__PURE__ */ new Set();
    accounts2.forEach((account) => {
      tokenMints.add(account.tokenMintA.toBase58());
      tokenMints.add(account.tokenMintB.toBase58());
      tokenAccounts.add(account.tokenVaultA.toBase58());
      tokenAccounts.add(account.tokenVaultB.toBase58());
      account.rewardInfos.forEach((rewardInfo) => {
        if (PoolUtil.isRewardInitialized(rewardInfo)) {
          tokenAccounts.add(rewardInfo.vault.toBase58());
        }
      });
    });
    await this.ctx.fetcher.listMintInfos(Array.from(tokenMints), refresh);
    await this.ctx.fetcher.listTokenInfos(Array.from(tokenAccounts), refresh);
    const whirlpools = [];
    for (let i = 0; i < accounts2.length; i++) {
      const account = accounts2[i];
      const poolAddress = poolAddresses[i];
      const tokenInfos = await getTokenMintInfos(this.ctx.fetcher, account, false);
      const vaultInfos = await getTokenVaultAccountInfos(this.ctx.fetcher, account, false);
      const rewardInfos = await getRewardInfos(this.ctx.fetcher, account, false);
      whirlpools.push(
        new WhirlpoolImpl(
          this.ctx,
          AddressUtil8.toPubKey(poolAddress),
          tokenInfos[0],
          tokenInfos[1],
          vaultInfos[0],
          vaultInfos[1],
          rewardInfos,
          account
        )
      );
    }
    return whirlpools;
  }
  async getPosition(positionAddress, refresh = false) {
    const account = await this.ctx.fetcher.getPosition(positionAddress, refresh);
    if (!account) {
      throw new Error(`Unable to fetch Position at address at ${positionAddress}`);
    }
    const whirlAccount = await this.ctx.fetcher.getPool(account.whirlpool, refresh);
    if (!whirlAccount) {
      throw new Error(`Unable to fetch Whirlpool for Position at address at ${positionAddress}`);
    }
    const [lowerTickArray, upperTickArray] = await getTickArrayDataForPosition(
      this.ctx,
      account,
      whirlAccount,
      refresh
    );
    if (!lowerTickArray || !upperTickArray) {
      throw new Error(`Unable to fetch TickArrays for Position at address at ${positionAddress}`);
    }
    return new PositionImpl(
      this.ctx,
      AddressUtil8.toPubKey(positionAddress),
      account,
      whirlAccount,
      lowerTickArray,
      upperTickArray
    );
  }
  async getPositions(positionAddresses, refresh = false) {
    const positions = await this.ctx.fetcher.listPositions(positionAddresses, refresh);
    const whirlpoolAddrs = positions.map((position) => position == null ? void 0 : position.whirlpool.toBase58()).flatMap((x) => !!x ? x : []);
    await this.ctx.fetcher.listPools(whirlpoolAddrs, refresh);
    const tickArrayAddresses = /* @__PURE__ */ new Set();
    await Promise.all(
      positions.map(async (pos) => {
        if (pos) {
          const pool = await this.ctx.fetcher.getPool(pos.whirlpool, false);
          if (pool) {
            const lowerTickArrayPda = PDAUtil.getTickArrayFromTickIndex(
              pos.tickLowerIndex,
              pool.tickSpacing,
              pos.whirlpool,
              this.ctx.program.programId
            ).publicKey;
            const upperTickArrayPda = PDAUtil.getTickArrayFromTickIndex(
              pos.tickUpperIndex,
              pool.tickSpacing,
              pos.whirlpool,
              this.ctx.program.programId
            ).publicKey;
            tickArrayAddresses.add(lowerTickArrayPda);
            tickArrayAddresses.add(upperTickArrayPda);
          }
        }
      })
    );
    await this.ctx.fetcher.listTickArrays(Array.from(tickArrayAddresses), true);
    const results = await Promise.all(
      positionAddresses.map(async (pos) => {
        try {
          const position = await this.getPosition(pos, false);
          return [pos, position];
        } catch {
          return [pos, null];
        }
      })
    );
    return Object.fromEntries(results);
  }
  async createPool(whirlpoolsConfig, tokenMintA, tokenMintB, tickSpacing, initialTick, funder, refresh = false) {
    invariant9(TickUtil.checkTickInBounds(initialTick), "initialTick is out of bounds.");
    invariant9(
      TickUtil.isTickInitializable(initialTick, tickSpacing),
      `initial tick ${initialTick} is not an initializable tick for tick-spacing ${tickSpacing}`
    );
    const correctTokenOrder = PoolUtil.orderMints(tokenMintA, tokenMintB).map(
      (addr) => addr.toString()
    );
    invariant9(
      correctTokenOrder[0] === tokenMintA.toString(),
      "Token order needs to be flipped to match the canonical ordering (i.e. sorted on the byte repr. of the mint pubkeys)"
    );
    whirlpoolsConfig = AddressUtil8.toPubKey(whirlpoolsConfig);
    const feeTierKey = PDAUtil.getFeeTier(
      this.ctx.program.programId,
      whirlpoolsConfig,
      tickSpacing
    ).publicKey;
    const initSqrtPrice = PriceMath.tickIndexToSqrtPriceX64(initialTick);
    const tokenVaultAKeypair = Keypair6.generate();
    const tokenVaultBKeypair = Keypair6.generate();
    const whirlpoolPda = PDAUtil.getWhirlpool(
      this.ctx.program.programId,
      whirlpoolsConfig,
      new PublicKey12(tokenMintA),
      new PublicKey12(tokenMintB),
      tickSpacing
    );
    const feeTier = await this.ctx.fetcher.getFeeTier(feeTierKey, refresh);
    invariant9(!!feeTier, `Fee tier for ${tickSpacing} doesn't exist`);
    const txBuilder = new TransactionBuilder5(
      this.ctx.provider.connection,
      this.ctx.provider.wallet
    );
    const initPoolIx = WhirlpoolIx.initializePoolIx(this.ctx.program, {
      initSqrtPrice,
      whirlpoolsConfig,
      whirlpoolPda,
      tokenMintA: new PublicKey12(tokenMintA),
      tokenMintB: new PublicKey12(tokenMintB),
      tokenVaultAKeypair,
      tokenVaultBKeypair,
      feeTierKey,
      tickSpacing,
      funder: new PublicKey12(funder)
    });
    const initialTickArrayStartTick = TickUtil.getStartTickIndex(initialTick, tickSpacing);
    const initialTickArrayPda = PDAUtil.getTickArray(
      this.ctx.program.programId,
      whirlpoolPda.publicKey,
      initialTickArrayStartTick
    );
    txBuilder.addInstruction(initPoolIx);
    txBuilder.addInstruction(
      initTickArrayIx(this.ctx.program, {
        startTick: initialTickArrayStartTick,
        tickArrayPda: initialTickArrayPda,
        whirlpool: whirlpoolPda.publicKey,
        funder: AddressUtil8.toPubKey(funder)
      })
    );
    return {
      poolKey: whirlpoolPda.publicKey,
      tx: txBuilder
    };
  }
  async collectFeesAndRewardsForPositions(positionAddresses, refresh) {
    const walletKey = this.ctx.wallet.publicKey;
    return collectAllForPositionAddressesTxns(
      this.ctx,
      {
        positions: positionAddresses,
        receiver: walletKey,
        positionAuthority: walletKey,
        positionOwner: walletKey,
        payer: walletKey
      },
      refresh
    );
  }
};

// src/whirlpool-client.ts
function buildWhirlpoolClient(ctx) {
  return new WhirlpoolClientImpl(ctx);
}

// src/index.ts
import { Percentage as Percentage9 } from "@orca-so/common-sdk";
Decimal3.set({ precision: 40, toExpPos: 40, toExpNeg: -20, rounding: 1 });
export {
  AccountFetcher,
  AccountName,
  FEE_RATE_MUL_VALUE,
  MAX_SQRT_PRICE,
  MAX_SWAP_TICK_ARRAYS,
  MAX_TICK_INDEX,
  METADATA_PROGRAM_ADDRESS,
  MIN_SQRT_PRICE,
  MIN_TICK_INDEX,
  NUM_REWARDS,
  ORCA_WHIRLPOOLS_CONFIG,
  ORCA_WHIRLPOOL_PROGRAM_ID,
  PDAUtil,
  PROTOCOL_FEE_RATE_MUL_VALUE,
  ParsableFeeTier,
  ParsableMintInfo,
  ParsablePosition,
  ParsableTickArray,
  ParsableTokenInfo,
  ParsableWhirlpool,
  ParsableWhirlpoolsConfig,
  Percentage9 as Percentage,
  PoolUtil,
  PositionImpl,
  PriceMath,
  SwapDirection,
  SwapUtils,
  TICK_ARRAY_SIZE,
  TickArrayUtil,
  TickUtil,
  TokenType,
  WHIRLPOOL_ACCOUNT_SIZE,
  WHIRLPOOL_CODER,
  WhirlpoolContext2 as WhirlpoolContext,
  WhirlpoolIx,
  buildWhirlpoolClient,
  collectFeesQuote,
  collectRewardsQuote,
  decreaseLiquidityQuoteByLiquidity,
  decreaseLiquidityQuoteByLiquidityWithParams,
  increaseLiquidityQuoteByInputToken,
  increaseLiquidityQuoteByInputTokenWithParams,
  swapQuoteByInputToken,
  swapQuoteByInputTokenWithDevFees,
  swapQuoteByOutputToken,
  swapQuoteWithParams,
  toTokenAmount,
  toTx
};
//# sourceMappingURL=index.mjs.map