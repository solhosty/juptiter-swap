"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DexProgram = void 0;
const web3_js_1 = require("@solana/web3.js");
const spl_token_1 = require("@solana/spl-token");
const anchor_1 = require("@project-serum/anchor");
const idl_1 = require("@dradex/idl");
const market_1 = require("./market");
const core_1 = require("./core");
class DexProgram extends anchor_1.Program {
    constructor(options = {}) {
        var _a, _b;
        const dexMetadata = (_a = options.dexMetadata) !== null && _a !== void 0 ? _a : idl_1.dexIdl.metadata;
        super(idl_1.DexIDL, dexMetadata.address, options.provider);
        this.loggerProgramId = (0, anchor_1.translateAddress)((_b = options.loggerProgramId) !== null && _b !== void 0 ? _b : idl_1.loggerIdl.metadata.address);
        this.loadDexMetadata(dexMetadata);
    }
    loadDexMetadata(dexMetadata) {
        const [masterAddress, masterBump] = dexMetadata.master;
        if (!this.provider.publicKey) {
            throw new Error("provider public key is not set");
        }
        this.systemAccounts = {
            signer: this.provider.publicKey,
            master: (0, anchor_1.translateAddress)(masterAddress),
            rent: web3_js_1.SYSVAR_RENT_PUBKEY,
            clock: web3_js_1.SYSVAR_CLOCK_PUBKEY,
            systemProgram: web3_js_1.SystemProgram.programId,
            tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
            logger: this.loggerProgramId,
        };
        this.bumps = {
            master: masterBump,
        };
    }
    get connection() {
        return this.provider.connection;
    }
    get signer() {
        return this.systemAccounts.signer;
    }
    createInstructionSet(instructions) {
        return new core_1.InstructionSet(instructions, this.provider);
    }
    async getMarket(address) {
        const marketAccountInfo = await this.connection.getAccountInfo(address);
        if (!marketAccountInfo) {
            throw new Error(`market ${address} not found`);
        }
        return new market_1.DexMarket(address, marketAccountInfo);
    }
    async loadMarket(market) {
        const accountKeys = market.getAccountsForUpdate();
        const accounts = await this.connection.getMultipleAccountsInfo(accountKeys);
        const accountMap = this.toAccountInfoMap(accountKeys, accounts);
        market.update(accountMap);
    }
    toAccountInfoMap(keys, accounts) {
        const accountMap = new Map();
        accounts.forEach((account, index) => account && accountMap.set(keys[index].toString(), account));
        return accountMap;
    }
    async findProgramAddress(seeds, programId) {
        return await web3_js_1.PublicKey.findProgramAddress(seeds, programId !== null && programId !== void 0 ? programId : this.programId);
    }
    async getProgramAddress(seeds) {
        return (await this.findProgramAddress(seeds))[0];
    }
    async getMarketUserAddress(market, user) {
        return await this.getProgramAddress([Buffer.from("market_user_v2"), market.toBuffer(), (user !== null && user !== void 0 ? user : this.signer).toBuffer()]);
    }
    async getDexUserAddress(user) {
        return await this.getProgramAddress([Buffer.from("dex_user"), (user !== null && user !== void 0 ? user : this.signer).toBuffer()]);
    }
    async createOrder(market, input, options = {}) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const signer = this.systemAccounts.signer;
        const accounts = {
            ...this.systemAccounts,
            ...market.getAccounts(),
            t0User: (_b = (_a = options.accounts) === null || _a === void 0 ? void 0 : _a.t0User) !== null && _b !== void 0 ? _b : (await (0, spl_token_1.getAssociatedTokenAddress)(market.state.t0, signer)),
            t1User: (_d = (_c = options.accounts) === null || _c === void 0 ? void 0 : _c.t1User) !== null && _d !== void 0 ? _d : (await (0, spl_token_1.getAssociatedTokenAddress)(market.state.t1, signer)),
            marketUser: (_f = (_e = options.accounts) === null || _e === void 0 ? void 0 : _e.marketUser) !== null && _f !== void 0 ? _f : (await this.getMarketUserAddress(market.address, signer)),
            dexUser: (_h = (_g = options.accounts) === null || _g === void 0 ? void 0 : _g.dexUser) !== null && _h !== void 0 ? _h : (await this.getDexUserAddress(signer)),
        };
        return this.createInstructionSet([
            this.instruction.createOrder(input, {
                accounts,
                remainingAccounts: options.remainingAccounts || undefined,
            }),
        ]);
    }
    async createDexUser(user) {
        return this.createInstructionSet([
            this.instruction.createDexUser(null, {
                accounts: {
                    ...this.systemAccounts,
                    signer: user !== null && user !== void 0 ? user : this.signer,
                    dexUser: await this.getDexUserAddress(user),
                },
            }),
        ]);
    }
    async createMarketUser(market, user) {
        return this.createInstructionSet([
            this.instruction.createMarketUser({
                accounts: {
                    ...this.systemAccounts,
                    ...market.getAccounts(),
                    signer: user !== null && user !== void 0 ? user : this.signer,
                    marketUser: await this.getMarketUserAddress(market.address, user),
                },
            }),
        ]);
    }
}
exports.DexProgram = DexProgram;
