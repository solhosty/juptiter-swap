"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InstructionSet = exports.Side = exports.FEE_BPS_BASE = exports.dexCoder = void 0;
const web3_js_1 = require("@solana/web3.js");
const anchor_1 = require("@project-serum/anchor");
const idl_1 = require("@dradex/idl");
exports.dexCoder = new anchor_1.BorshCoder(idl_1.DexIDL);
exports.FEE_BPS_BASE = 10000;
var Side;
(function (Side) {
    Side[Side["BID"] = 0] = "BID";
    Side[Side["ASK"] = 1] = "ASK";
})(Side = exports.Side || (exports.Side = {}));
class InstructionSet {
    constructor(instructions, provider) {
        this.instructions = instructions;
        this.provider = provider;
    }
    tx() {
        return new web3_js_1.Transaction().add(...this.instructions);
    }
    add(...items) {
        items.forEach((item) => {
            if (item instanceof web3_js_1.TransactionInstruction) {
                this.instructions.push(item);
            }
            else {
                this.instructions.push(...item.instructions);
            }
        });
    }
    instruction() {
        if (this.instructions.length == 0) {
            throw new Error("no instruction available");
        }
        return this.instructions[0];
    }
    exec({ signers, ...options } = {}) {
        var _a, _b;
        if (!this.provider) {
            throw new Error("provider not available");
        }
        if (!signers) {
            throw new Error("signers not available");
        }
        return (_b = (_a = this.provider).send) === null || _b === void 0 ? void 0 : _b.call(_a, this.tx(), signers, options);
    }
}
exports.InstructionSet = InstructionSet;
