"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.QuoteCalculator = exports.ParsedOrder = exports.SwapMode = void 0;
const idl_1 = require("@dradex/idl");
const anchor_1 = require("@project-serum/anchor");
const decimal_js_1 = __importDefault(require("decimal.js"));
const jsbi_1 = __importDefault(require("jsbi"));
const core_1 = require("./core");
var SwapMode;
(function (SwapMode) {
    SwapMode["ExactIn"] = "ExactIn";
    SwapMode["ExactOut"] = "ExactOut";
})(SwapMode = exports.SwapMode || (exports.SwapMode = {}));
class ParsedOrder {
}
exports.ParsedOrder = ParsedOrder;
class QuoteCalculator {
    constructor(market, orderBook, tokens) {
        this.market = market;
        this.orderBook = orderBook;
        this.tokens = tokens;
        this.parseOrder = (order) => {
            return {
                quantity: this.toUiAmount(order.quantity, this.tokens[0]),
                price: this.toUiPrice(idl_1.OrderBook.getPriceFromKey(order.key)),
            };
        };
        this.formatting = this.getMarketFormatting(this.market.config.t0LotSize.toNumber(), this.market.config.t1LotSize.toNumber(), this.tokens[0].decimals, this.tokens[1].decimals);
        this.pool = this.market.pool.map((poolAmount, i) => this.toUiAmount(poolAmount, this.tokens[i]));
        this.orders = {
            bids: orderBook.bids.map(this.parseOrder),
            asks: orderBook.asks.map(this.parseOrder),
        };
        this.feeRates = {
            maker: this.market.config.feeRates.maker.toNumber(),
            taker: this.market.config.feeRates.taker.toNumber(),
        };
        this.basePrices = [this.evaluateOrder(core_1.Side.BID, 0).unitPrice, this.evaluateOrder(core_1.Side.ASK, 0).unitPrice];
    }
    getMarketFormatting(lot0, lot1, decimals0, decimals1) {
        const lotSize = 10 ** -decimals0 * lot0;
        const quoteSize = 10 ** -decimals1 * lot1;
        const tickSize = lot1 / (lotSize * 10 ** decimals1);
        const sizeDecimals = Math.max(Math.floor(-Math.log10(lotSize)), 0);
        const priceDecimals = Math.max(Math.floor(-Math.log10(tickSize)), 0);
        const quoteDecimals = priceDecimals;
        return {
            lotSize,
            tickSize,
            quoteSize,
            sizeDecimals,
            priceDecimals,
            quoteDecimals,
        };
    }
    toUiAmount(amount, token) {
        var _a;
        const power = new decimal_js_1.default(10).toPower((_a = token.decimals) !== null && _a !== void 0 ? _a : 9);
        return new decimal_js_1.default(amount.toString()).div(power).toNumber();
    }
    toProgramAmount(amount, token) {
        var _a;
        const power = new decimal_js_1.default(10).toPower((_a = token.decimals) !== null && _a !== void 0 ? _a : 9);
        return jsbi_1.default.BigInt(new decimal_js_1.default(amount).mul(power).floor().toString());
    }
    toUiPrice(lotPrice) {
        const p0 = new decimal_js_1.default(10).pow(this.tokens[0].decimals);
        const p1 = new decimal_js_1.default(10).pow(this.tokens[1].decimals);
        const lot0 = this.market.config.t0LotSize.toNumber();
        const lot1 = this.market.config.t1LotSize.toNumber();
        return new decimal_js_1.default(lotPrice.toString()).div(p1.div(lot1)).mul(p0.div(lot0)).toNumber();
    }
    isBetterOffer(side, a, b) {
        if (!a)
            return false;
        if (!b)
            return true;
        return !side ? a <= b : a >= b;
    }
    getBetterOffer(side, a, b) {
        if (!a)
            return b;
        if (!b)
            return a;
        return !side ? Math.min(a, b) : Math.max(a, b);
    }
    evaluateOrder(side, amount, limitPrice, limitTotal) {
        let pool = this.pool;
        const offers = !side ? this.orders.asks : this.orders.bids;
        const { lotSize, tickSize } = this.formatting;
        const hasVolume = Number(amount) > 0 || Number(limitTotal) > 0;
        amount = amount !== null && amount !== void 0 ? amount : Infinity;
        limitTotal = limitTotal !== null && limitTotal !== void 0 ? limitTotal : Infinity;
        limitPrice = limitPrice !== null && limitPrice !== void 0 ? limitPrice : 0;
        let remaining = amount;
        if (!remaining) {
            remaining = lotSize;
        }
        let remainingTotal = limitTotal;
        if (!remainingTotal) {
            remainingTotal = tickSize;
        }
        let offerIndex = 0;
        const totals = {
            filled: 0,
            cost: 0,
            lpFilled: 0,
            lpCost: 0,
            orderFilled: 0,
            orderCost: 0,
        };
        let lpPrice = pool[0] ? pool[1] / pool[0] : 0;
        const minimumLiquidityX = this.toUiAmount(new anchor_1.BN(100), this.tokens[0]);
        const minimumLiquidityY = this.toUiAmount(new anchor_1.BN(100), this.tokens[1]);
        const hasLp = pool[0] > minimumLiquidityX && pool[1] > minimumLiquidityY;
        let computeSteps = 0;
        let lastMatchPrice = 0;
        while (remaining > 0 && remainingTotal > 0) {
            const offer = offers[offerIndex++];
            const offerPrice = offer ? Number(offer.price) : 0;
            if (hasLp) {
                const x0 = Math.max(pool[0] - minimumLiquidityX, 0);
                const lpPrice = pool[1] / pool[0];
                const targetPrice = this.getBetterOffer(side, offerPrice, limitPrice);
                if (!targetPrice || this.isBetterOffer(side, lpPrice, targetPrice)) {
                    const c = new decimal_js_1.default(pool[0]).mul(pool[1]);
                    const m = targetPrice ? Math.sqrt(c.div(targetPrice).toNumber()) : 0;
                    const maxX = Math.min(c.div(minimumLiquidityY).toNumber(), x0);
                    let matchSize = targetPrice ? (side == 0 ? x0 - m : Math.min(m - x0, maxX)) : Infinity;
                    if (matchSize > 0) {
                        let maxFillable = Infinity;
                        if (remainingTotal != Infinity) {
                            const y = side == 0 ? pool[1] + remainingTotal : Math.max(pool[1] - remainingTotal, minimumLiquidityY);
                            const x = Math.max(c.div(y).toNumber(), minimumLiquidityX);
                            maxFillable = Math.abs(x - x0);
                        }
                        const filled = Math.min(matchSize, remaining, maxFillable, maxX);
                        const x = side == 0 ? pool[0] - filled : pool[0] + filled;
                        const y = c.div(x).toNumber();
                        const cost = Math.min(Math.abs(pool[1] - y), remainingTotal);
                        pool = [x, y];
                        remaining -= filled;
                        totals.filled += filled;
                        totals.cost += cost;
                        totals.lpFilled += filled;
                        totals.lpCost += cost;
                        if (remainingTotal != Infinity) {
                            remainingTotal -= cost;
                        }
                        if (lastMatchPrice != lpPrice) {
                            computeSteps++;
                            lastMatchPrice = cost / filled;
                        }
                    }
                }
            }
            if (remaining > 0 &&
                remainingTotal > 0 &&
                offer &&
                (limitPrice ? this.isBetterOffer(side, offerPrice, limitPrice) : true)) {
                const filled = Math.min(Number(offer.quantity), remaining, remainingTotal != Infinity ? remainingTotal / offerPrice : Infinity);
                const cost = filled * offerPrice;
                totals.filled += filled;
                totals.cost += cost;
                totals.orderFilled += filled;
                totals.orderCost += cost;
                if (remainingTotal != Infinity) {
                    remainingTotal -= cost;
                }
                remaining -= filled;
                computeSteps++;
                lastMatchPrice = offerPrice;
            }
            else {
                break;
            }
        }
        if (limitPrice) {
            remaining = Math.min(remaining, remainingTotal / limitPrice);
        }
        return {
            ...totals,
            lpPrice,
            unitPrice: totals.filled ? totals.cost / totals.filled : 0,
            lpUnitPrice: totals.lpFilled ? totals.lpCost / totals.lpFilled : 0,
            orderUnitPrice: totals.orderFilled ? totals.orderCost / totals.orderFilled : 0,
            quantity: hasVolume ? totals.filled + remaining : 0,
            remaining: limitPrice ? remaining : 0,
            remainingTotal: limitPrice ? limitPrice * remaining : 0,
            computeSteps,
            output: this.applyFees(totals, side),
        };
    }
    applyFees(totals, side) {
        const { maker, taker } = this.feeRates;
        const [lpAmount, orderAmount] = !side ? [totals.lpFilled, totals.orderFilled] : [totals.lpCost, totals.orderCost];
        const feeAmount = (lpAmount * (maker + taker) + orderAmount * taker) / core_1.FEE_BPS_BASE;
        const grossAmount = lpAmount + orderAmount;
        return {
            grossAmount,
            netAmount: grossAmount - feeAmount,
            feeAmount,
            feePct: (feeAmount / grossAmount) * 100,
        };
    }
    checkMinimumAmounts(side, inAmount, outAmount) {
        const lotSize = this.toProgramAmount(this.formatting.lotSize, this.tokens[0]);
        return !side
            ? {
                outAmount: jsbi_1.default.greaterThanOrEqual(outAmount, lotSize) ? outAmount : jsbi_1.default.BigInt(0),
                minOutAmount: lotSize,
            }
            : {
                outAmount: jsbi_1.default.greaterThanOrEqual(inAmount, lotSize) ? outAmount : jsbi_1.default.BigInt(0),
                minInAmount: lotSize,
            };
    }
    getQuote(params) {
        const side = params.destinationMint.equals(this.market.t0) ? core_1.Side.BID : core_1.Side.ASK;
        const inMode = params.swapMode == SwapMode.ExactIn;
        const inputSide = inMode ? side : 1 - side;
        const inputToken = this.tokens[1 - inputSide];
        const amountUi = this.toUiAmount(new anchor_1.BN(params.amount.toString()), inputToken);
        const outToken = this.tokens[side];
        const inToken = this.tokens[1 - side];
        const useTotal = inMode ? !side : side;
        const result = this.evaluateOrder(side, !useTotal ? amountUi : undefined, 0, useTotal ? amountUi : undefined);
        const basePrice = this.basePrices[side];
        const { feeAmount: feeAmountUi, feePct, grossAmount: grossAmountUi } = result.output;
        const feeAmount = this.toProgramAmount(feeAmountUi, outToken);
        const netOutAmount = jsbi_1.default.subtract(this.toProgramAmount(grossAmountUi, outToken), feeAmount);
        const resultInAmount = this.toProgramAmount(!side ? result.cost : result.filled, inToken);
        const [inAmount, outAmount] = inMode ? [params.amount, netOutAmount] : [resultInAmount, netOutAmount];
        return {
            feeMint: outToken.address.toString(),
            feeAmount,
            feePct,
            inAmount,
            notEnoughLiquidity: result.remaining > 0 && result.remainingTotal > 0,
            priceImpactPct: (Math.abs(basePrice - result.unitPrice) / result.unitPrice) * 100,
            ...this.checkMinimumAmounts(side, inAmount, outAmount),
        };
    }
}
exports.QuoteCalculator = QuoteCalculator;
