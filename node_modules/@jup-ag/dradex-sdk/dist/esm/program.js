import { PublicKey, SYSVAR_RENT_PUBKEY, SYSVAR_CLOCK_PUBKEY, SystemProgram, } from "@solana/web3.js";
import { TOKEN_PROGRAM_ID, getAssociatedTokenAddress } from "@solana/spl-token";
import { Program, translateAddress } from "@project-serum/anchor";
import { DexIDL, dexIdl, loggerIdl } from "@dradex/idl";
import { DexMarket } from "./market";
import { InstructionSet } from "./core";
export class DexProgram extends Program {
    constructor(options = {}) {
        var _a, _b;
        const dexMetadata = (_a = options.dexMetadata) !== null && _a !== void 0 ? _a : dexIdl.metadata;
        super(DexIDL, dexMetadata.address, options.provider);
        this.loggerProgramId = translateAddress((_b = options.loggerProgramId) !== null && _b !== void 0 ? _b : loggerIdl.metadata.address);
        this.loadDexMetadata(dexMetadata);
    }
    loadDexMetadata(dexMetadata) {
        const [masterAddress, masterBump] = dexMetadata.master;
        if (!this.provider.publicKey) {
            throw new Error("provider public key is not set");
        }
        this.systemAccounts = {
            signer: this.provider.publicKey,
            master: translateAddress(masterAddress),
            rent: SYSVAR_RENT_PUBKEY,
            clock: SYSVAR_CLOCK_PUBKEY,
            systemProgram: SystemProgram.programId,
            tokenProgram: TOKEN_PROGRAM_ID,
            logger: this.loggerProgramId,
        };
        this.bumps = {
            master: masterBump,
        };
    }
    get connection() {
        return this.provider.connection;
    }
    get signer() {
        return this.systemAccounts.signer;
    }
    createInstructionSet(instructions) {
        return new InstructionSet(instructions, this.provider);
    }
    async getMarket(address) {
        const marketAccountInfo = await this.connection.getAccountInfo(address);
        if (!marketAccountInfo) {
            throw new Error(`market ${address} not found`);
        }
        return new DexMarket(address, marketAccountInfo);
    }
    async loadMarket(market) {
        const accountKeys = market.getAccountsForUpdate();
        const accounts = await this.connection.getMultipleAccountsInfo(accountKeys);
        const accountMap = this.toAccountInfoMap(accountKeys, accounts);
        market.update(accountMap);
    }
    toAccountInfoMap(keys, accounts) {
        const accountMap = new Map();
        accounts.forEach((account, index) => account && accountMap.set(keys[index].toString(), account));
        return accountMap;
    }
    async findProgramAddress(seeds, programId) {
        return await PublicKey.findProgramAddress(seeds, programId !== null && programId !== void 0 ? programId : this.programId);
    }
    async getProgramAddress(seeds) {
        return (await this.findProgramAddress(seeds))[0];
    }
    async getMarketUserAddress(market, user) {
        return await this.getProgramAddress([Buffer.from("market_user_v2"), market.toBuffer(), (user !== null && user !== void 0 ? user : this.signer).toBuffer()]);
    }
    async getDexUserAddress(user) {
        return await this.getProgramAddress([Buffer.from("dex_user"), (user !== null && user !== void 0 ? user : this.signer).toBuffer()]);
    }
    async createOrder(market, input, options = {}) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const signer = this.systemAccounts.signer;
        const accounts = {
            ...this.systemAccounts,
            ...market.getAccounts(),
            t0User: (_b = (_a = options.accounts) === null || _a === void 0 ? void 0 : _a.t0User) !== null && _b !== void 0 ? _b : (await getAssociatedTokenAddress(market.state.t0, signer)),
            t1User: (_d = (_c = options.accounts) === null || _c === void 0 ? void 0 : _c.t1User) !== null && _d !== void 0 ? _d : (await getAssociatedTokenAddress(market.state.t1, signer)),
            marketUser: (_f = (_e = options.accounts) === null || _e === void 0 ? void 0 : _e.marketUser) !== null && _f !== void 0 ? _f : (await this.getMarketUserAddress(market.address, signer)),
            dexUser: (_h = (_g = options.accounts) === null || _g === void 0 ? void 0 : _g.dexUser) !== null && _h !== void 0 ? _h : (await this.getDexUserAddress(signer)),
        };
        return this.createInstructionSet([
            this.instruction.createOrder(input, {
                accounts,
                remainingAccounts: options.remainingAccounts || undefined,
            }),
        ]);
    }
    async createDexUser(user) {
        return this.createInstructionSet([
            this.instruction.createDexUser(null, {
                accounts: {
                    ...this.systemAccounts,
                    signer: user !== null && user !== void 0 ? user : this.signer,
                    dexUser: await this.getDexUserAddress(user),
                },
            }),
        ]);
    }
    async createMarketUser(market, user) {
        return this.createInstructionSet([
            this.instruction.createMarketUser({
                accounts: {
                    ...this.systemAccounts,
                    ...market.getAccounts(),
                    signer: user !== null && user !== void 0 ? user : this.signer,
                    marketUser: await this.getMarketUserAddress(market.address, user),
                },
            }),
        ]);
    }
}
