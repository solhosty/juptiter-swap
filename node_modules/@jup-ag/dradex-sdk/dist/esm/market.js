import { unpackMint } from "@solana/spl-token";
import { OrderBook } from "@dradex/idl";
import { dexCoder } from "./core";
import { QuoteCalculator } from "./quote";
export class DexMarket {
    constructor(address, accountInfo) {
        this.address = address;
        this.id = address.toString();
        this.decodeMarketState(accountInfo);
        this.reserveTokenMints = [this.state.t0, this.state.t1];
    }
    decodeMarketState(accountInfo) {
        this.state = dexCoder.accounts.decode("market", accountInfo.data);
    }
    getAccountsForUpdate() {
        return [this.address, ...this.reserveTokenMints, this.state.orderBook.bids, this.state.orderBook.asks];
    }
    update(accountInfoMap) {
        const market = accountInfoMap.get(this.id);
        const bids = accountInfoMap.get(this.state.orderBook.bids.toString());
        const asks = accountInfoMap.get(this.state.orderBook.asks.toString());
        const mints = this.reserveTokenMints.map((mint) => accountInfoMap.get(mint.toString()));
        if (!market || !bids || !asks || mints.find((mint) => !mint)) {
            throw new Error("one of the required accounts is missing");
        }
        this.decodeMarketState(market);
        this.mintInfos = this.reserveTokenMints.map((mint, index) => unpackMint(mint, mints[index]));
        this.orderBookState = {
            bids: OrderBook.decode(bids.data).items,
            asks: OrderBook.decode(asks.data).items,
        };
        this.quoteCalculator = new QuoteCalculator(this.state, this.orderBookState, this.mintInfos);
    }
    getQuote(quoteParams) {
        return this.quoteCalculator.getQuote(quoteParams);
    }
    getAccounts() {
        return {
            pair: this.state.pair,
            market: this.address,
            t0Vault: this.state.t0Vault,
            t1Vault: this.state.t1Vault,
            bids: this.state.orderBook.bids,
            asks: this.state.orderBook.asks,
            eventQueue: this.state.eventQueue,
        };
    }
}
