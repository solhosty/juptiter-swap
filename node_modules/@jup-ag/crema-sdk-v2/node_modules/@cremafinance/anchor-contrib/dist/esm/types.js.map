{"version":3,"file":"types.js","sourceRoot":"","sources":["../../src/types.ts"],"names":[],"mappings":"","sourcesContent":["import type {\n  AccountClient,\n  Address,\n  BN,\n  Context as AnchorContext,\n  Program as AProgram,\n  ProgramAccount,\n  StateClient,\n} from \"@project-serum/anchor\";\nimport type {\n  Idl,\n  IdlAccountItem,\n  IdlAccounts,\n  IdlEvent,\n  IdlEventField,\n  IdlField,\n  IdlInstruction,\n  IdlType,\n  IdlTypeDef,\n  IdlTypeDefTyStruct,\n} from \"@project-serum/anchor/dist/esm/idl.js\";\nimport type {\n  AccountMeta,\n  PublicKey,\n  Transaction,\n  TransactionInstruction,\n  TransactionSignature,\n} from \"@solana/web3.js\";\n\ntype InstructionsParsed = Record<\n  string,\n  {\n    accounts: IdlAccountItem[];\n    args: Array<unknown>;\n  }\n>;\n\nexport type ContextAccounts<A extends IdlAccountItem[]> = {\n  [K in A[number][\"name\"]]: A[number] & { name: K } extends IdlAccounts\n    ? ContextAccounts<\n        NonNullable<(A[number] & { name: K } & IdlAccounts)[\"accounts\"]>\n      >\n    : Address;\n};\n\ntype Context<A extends IdlAccountItem[]> = Omit<AnchorContext, \"accounts\"> & {\n  accounts: ContextAccounts<A>;\n};\n\ntype MakeInstructionsNamespace<\n  R extends InstructionsParsed,\n  Ret,\n  Mk extends { [M in keyof R]: unknown } = { [M in keyof R]: unknown }\n> = {\n  [M in keyof R]: ((\n    ...args: [...R[M][\"args\"], Context<R[M][\"accounts\"]>]\n  ) => Ret) &\n    Mk[M];\n};\n\ntype RpcNamespace<R extends InstructionsParsed> = MakeInstructionsNamespace<\n  R,\n  Promise<TransactionSignature>\n>;\n\ntype InstructionNamespace<R extends InstructionsParsed> =\n  MakeInstructionsNamespace<\n    R,\n    TransactionInstruction,\n    {\n      [M in keyof R]: {\n        accounts: (ctx: ContextAccounts<R[M][\"accounts\"]>) => AccountMeta[];\n      };\n    }\n  >;\n\ntype TransactionNamespace<R extends InstructionsParsed> =\n  MakeInstructionsNamespace<R, Transaction>;\n\ntype AccountsNamespace<A> = {\n  [K in keyof A]: Omit<\n    AccountClient,\n    \"fetch\" | \"fetchNullable\" | \"all\" | \"associated\"\n  > & {\n    /**\n     * Returns a deserialized account.\n     *\n     * @param address The address of the account to fetch.\n     */\n    fetch: (address: PublicKey) => Promise<A[K]>;\n    /**\n     * Returns a deserialized account, returning null if it doesn't exist.\n     *\n     * @param address The address of the account to fetch.\n     */\n    fetchNullable: (address: PublicKey) => Promise<A[K] | null>;\n    /**\n     * Returns all instances of this account type for the program.\n     */\n    all: (\n      ...args: Parameters<AccountClient[\"all\"]>\n    ) => Promise<ProgramAccount<A[K]>[]>;\n    /**\n     * @deprecated since version 14.0.\n     *\n     * Function returning the associated account. Args are keys to associate.\n     * Order matters.\n     */\n    associated: (...args: PublicKey[]) => Promise<A[K]>;\n  };\n};\n\ntype TypeMap = {\n  publicKey: PublicKey;\n  bool: boolean;\n  string: string;\n  bytes: Uint8Array;\n} & {\n  [K in \"u8\" | \"i8\" | \"u16\" | \"i16\" | \"u32\" | \"i32\"]: number;\n} & {\n  [K in \"u64\" | \"i64\" | \"u128\" | \"i128\"]: BN;\n};\n\ntype DecodeType<T extends IdlType, Defined> = T extends keyof TypeMap\n  ? TypeMap[T]\n  : T extends { defined: keyof Defined }\n  ? Defined[T[\"defined\"]]\n  : T extends { option: { defined: keyof Defined } }\n  ? Defined[T[\"option\"][\"defined\"]] | null\n  : T extends { option: keyof TypeMap }\n  ? TypeMap[T[\"option\"]] | null\n  : T extends { vec: { defined: keyof Defined } }\n  ? Defined[T[\"vec\"][\"defined\"]][]\n  : T extends { vec: keyof TypeMap }\n  ? TypeMap[T[\"vec\"]][]\n  : T extends { array: [idlType: keyof TypeMap, size: number] }\n  ? TypeMap[T[\"array\"][0]][]\n  : unknown;\n\ntype MakeArgs<A extends IdlField[], Defined> = {\n  [K in keyof A]: A[K] extends IdlField\n    ? DecodeType<A[K][\"type\"], Defined>\n    : unknown;\n};\n\ntype MakeNamedArgs<A extends IdlField, Defined> = {\n  [K in A[\"name\"]]: DecodeType<(A & { name: K })[\"type\"], Defined>;\n};\n\ntype MakeInstructions<I extends IdlInstruction[], Defined> = {\n  [K in I[number][\"name\"]]: {\n    accounts: (I[number] & { name: K })[\"accounts\"];\n    args: MakeArgs<(I[number] & { name: K })[\"args\"], Defined> & unknown[];\n    namedArgs: MakeNamedArgs<\n      (I[number] & { name: K })[\"args\"][number],\n      Defined\n    >;\n  };\n};\n\nexport type AnchorProgram<\n  IDL extends Idl,\n  A,\n  Defined = AnchorDefined<IDL>,\n  RPCInstructions extends MakeInstructions<\n    IDL[\"instructions\"],\n    Defined\n  > = MakeInstructions<IDL[\"instructions\"], Defined>,\n  Methods extends MakeInstructions<\n    NonNullable<IDL[\"state\"]>[\"methods\"],\n    Defined\n  > = MakeInstructions<NonNullable<IDL[\"state\"]>[\"methods\"], Defined>\n> = Omit<\n  AProgram,\n  \"rpc\" | \"state\" | \"account\" | \"transaction\" | \"instruction\"\n> & {\n  rpc: RpcNamespace<RPCInstructions>;\n  state: StateClient<IDL>;\n  account: AccountsNamespace<A>;\n  transaction: TransactionNamespace<RPCInstructions & Methods>;\n  instruction: InstructionNamespace<RPCInstructions & Methods>;\n};\n\nexport type AnchorError<T extends Idl> = NonNullable<T[\"errors\"]>[number];\n\ntype FieldsOfType<I extends IdlTypeDef> = I extends {\n  type: IdlTypeDefTyStruct;\n}\n  ? NonNullable<I[\"type\"][\"fields\"]>[number]\n  : never;\n\ntype AnchorTypeDef<I extends IdlTypeDef, Defined> = {\n  [F in FieldsOfType<I>[\"name\"]]: DecodeType<\n    (FieldsOfType<I> & { name: F })[\"type\"],\n    Defined\n  >;\n};\n\ntype AnchorTypeDefs<T extends IdlTypeDef[], Defined> = {\n  [K in T[number][\"name\"]]: AnchorTypeDef<T[number] & { name: K }, Defined>;\n};\n\nexport type AnchorDefined<\n  T extends Idl,\n  D = Record<string, never>\n> = AnchorTypeDefs<NonNullable<T[\"types\"]>, D>;\n\nexport type AnchorAccounts<T extends Idl, Defined> = AnchorTypeDefs<\n  NonNullable<T[\"accounts\"]>,\n  Defined\n>;\n\nexport type AnchorState<T extends Idl, Defined> = AnchorTypeDef<\n  NonNullable<T[\"state\"]>[\"struct\"],\n  Defined\n>;\n\nexport type AnchorTypes<\n  T extends Idl,\n  AccountMap = Record<string, never>,\n  D = Record<string, never>,\n  DEF = AnchorDefined<T, D>\n> = {\n  Defined: DEF;\n  Accounts: AnchorAccounts<T, DEF>;\n  State: AnchorState<T, DEF>;\n  Error: AnchorError<T>;\n  Program: AnchorProgram<T, AccountMap, DEF>;\n  Instructions: MakeInstructions<T[\"instructions\"], DEF>;\n  Methods: MakeInstructions<NonNullable<T[\"state\"]>[\"methods\"], DEF>;\n  Events: AnchorEvents<NonNullable<T[\"events\"]>[number], DEF>;\n  AccountMap: AccountMap;\n  IDL: T;\n};\n\ntype AnchorEvent<T extends IdlEventField, Defined> = {\n  [N in T[\"name\"]]: DecodeType<(T & { name: N })[\"type\"], Defined>;\n};\n\ntype AnchorEvents<T extends IdlEvent, Defined> = {\n  [K in T[\"name\"]]: {\n    name: K;\n    data: AnchorEvent<(T & { name: K })[\"fields\"][number], Defined>;\n  };\n};\n"]}