{"version":3,"file":"PendingTransaction.js","sourceRoot":"","sources":["../../../src/transaction/PendingTransaction.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  BlockhashWithExpiryBlockHeight,\n  Cluster,\n  Connection,\n  Finality,\n  SignatureResult,\n  TransactionSignature,\n} from \"@solana/web3.js\";\nimport promiseRetry from \"promise-retry\";\nimport type { WrapOptions } from \"retry\";\n\nimport { generateTXLink } from \"../utils/txLink.js\";\nimport { TransactionReceipt } from \"./TransactionReceipt.js\";\n\n/**\n * Options for awaiting a transaction confirmation.\n */\nexport interface TransactionWaitOptions\n  extends WrapOptions,\n    Partial<BlockhashWithExpiryBlockHeight> {\n  /**\n   * Commitment of the transaction. Defaults to `confirmed`.\n   */\n  readonly commitment?: Finality;\n  /**\n   * Whether or not to use websockets for awaiting confirmation. Defaults to `false`.\n   */\n  readonly useWebsocket?: boolean;\n  /**\n   * Max supported transaction version. Pass `undefined` to only support `legacy` transactions.\n   */\n  readonly maxSupportedTransactionVersion?: number;\n}\n\n/**\n * Transaction which may or may not be confirmed.\n */\nexport class PendingTransaction {\n  private _receipt: TransactionReceipt | null = null;\n\n  constructor(\n    readonly connection: Connection,\n    readonly signature: TransactionSignature\n  ) {}\n\n  /**\n   * Gets the transaction receipt, if it has already been fetched.\n   *\n   * You probably want the async version of this function, `wait`.\n   */\n  get receipt(): TransactionReceipt | null {\n    return this._receipt;\n  }\n\n  /**\n   * Waits for the confirmation of the transaction.\n   * @returns\n   */\n  async wait({\n    commitment = \"confirmed\",\n    maxSupportedTransactionVersion = 0,\n    useWebsocket = true,\n    ...retryOpts\n  }: TransactionWaitOptions = {}): Promise<TransactionReceipt> {\n    if (this._receipt) {\n      return this._receipt;\n    }\n    if (useWebsocket) {\n      await this.confirm({ commitment, ...retryOpts });\n      return await this.pollForReceipt({\n        commitment,\n        maxSupportedTransactionVersion,\n      });\n    }\n    return await this.pollForReceipt({\n      commitment,\n      maxSupportedTransactionVersion,\n      ...retryOpts,\n    });\n  }\n\n  /**\n   * Fetches the TransactionReceipt via polling.\n   * @returns\n   */\n  async pollForReceipt({\n    commitment = \"confirmed\",\n    maxSupportedTransactionVersion = 0,\n    ...retryOpts\n  }: Omit<\n    TransactionWaitOptions,\n    \"useWebsocket\"\n  > = {}): Promise<TransactionReceipt> {\n    const receipt = await promiseRetry(\n      async (retry) => {\n        const result = await this.connection.getTransaction(this.signature, {\n          commitment,\n          maxSupportedTransactionVersion,\n        });\n        if (!result) {\n          retry(new Error(\"Error fetching transaction\"));\n          return;\n        }\n        return new TransactionReceipt(this.signature, result);\n      },\n      {\n        retries: 5,\n        minTimeout: 500,\n        ...retryOpts,\n      }\n    );\n    if (!receipt) {\n      throw new Error(\"transaction could not be confirmed\");\n    }\n    this._receipt = receipt;\n    return receipt;\n  }\n\n  /**\n   * Awaits the confirmation of the transaction, via onSignature subscription.\n   *\n   * @deprecated use {@link PendingTransaction#confirm}\n   * @returns\n   */\n  async awaitSignatureConfirmation(\n    commitment: Finality = \"confirmed\"\n  ): Promise<TransactionSignature> {\n    const { value } = await this.connection.confirmTransaction(\n      this.signature,\n      commitment\n    );\n    if (value.err) {\n      throw value.err;\n    }\n    return this.signature;\n  }\n\n  /**\n   * Awaits the confirmation of the transaction, via onSignature subscription.\n   * @returns\n   */\n  async confirm({\n    commitment = \"confirmed\",\n    blockhash,\n    lastValidBlockHeight,\n  }: Pick<\n    TransactionWaitOptions,\n    \"commitment\" | \"blockhash\" | \"lastValidBlockHeight\"\n  >): Promise<TransactionSignature> {\n    let value: SignatureResult;\n    if (blockhash && lastValidBlockHeight) {\n      value = (\n        await this.connection.confirmTransaction(\n          {\n            signature: this.signature,\n            blockhash,\n            lastValidBlockHeight,\n          },\n          commitment\n        )\n      ).value;\n    } else {\n      value = (\n        await this.connection.confirmTransaction(this.signature, commitment)\n      ).value;\n    }\n\n    if (value.err) {\n      throw new Error(\n        `Transaction ${this.signature} failed (${JSON.stringify(value)})`\n      );\n    }\n\n    return this.signature;\n  }\n\n  /**\n   * Generates a link to view this {@link PendingTransaction} on the official Solana explorer.\n   * @param network\n   * @returns\n   */\n  generateSolanaExplorerLink(cluster: Cluster = \"mainnet-beta\"): string {\n    return generateTXLink(this.signature, cluster);\n  }\n}\n"]}