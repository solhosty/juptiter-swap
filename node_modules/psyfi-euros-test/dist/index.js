'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var web3_js = require('@solana/web3.js');
var anchor = require('@project-serum/anchor');
var splToken = require('@solana/spl-token');
var mplTokenMetadata = require('@metaplex-foundation/mpl-token-metadata');
var psystakeTest = require('psystake-test');

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

exports.StrategyType = void 0;
(function (StrategyType) {
    StrategyType[StrategyType["CALL"] = 0] = "CALL";
    StrategyType[StrategyType["PUT"] = 1] = "PUT";
})(exports.StrategyType || (exports.StrategyType = {}));

const deriveUnderlyingPoolKey = (underlyingMint) => web3_js.PublicKey.findProgramAddress([underlyingMint.toBuffer(), Buffer.from("underlyingPool")], euroPrimitiveProgramKey);
const deriveStablePoolKey = (stableMint) => web3_js.PublicKey.findProgramAddress([stableMint.toBuffer(), Buffer.from("stablePool")], euroPrimitiveProgramKey);
const deriveCallOptionMint = (euroMetaKey) => web3_js.PublicKey.findProgramAddress([euroMetaKey.toBuffer(), Buffer.from("callOptionMint")], euroPrimitiveProgramKey);
const deriveCallWriterMint = (euroMetaKey) => web3_js.PublicKey.findProgramAddress([euroMetaKey.toBuffer(), Buffer.from("callWriterMint")], euroPrimitiveProgramKey);
const derivePutOptionMint = (euroMetaKey) => web3_js.PublicKey.findProgramAddress([euroMetaKey.toBuffer(), Buffer.from("putOptionMint")], euroPrimitiveProgramKey);
const derivePutWriterMint = (euroMetaKey) => web3_js.PublicKey.findProgramAddress([euroMetaKey.toBuffer(), Buffer.from("putWriterMint")], euroPrimitiveProgramKey);
const derivePoolAuthority = () => __awaiter(void 0, void 0, void 0, function* () {
    return yield web3_js.PublicKey.findProgramAddress([Buffer.from("poolAuthority")], euroPrimitiveProgramKey);
});
const deriveVaultAccount = (program, collateralAssetMint, quoteAssetMint, uniqueSeed, strategyType) => __awaiter(void 0, void 0, void 0, function* () {
    return yield web3_js.PublicKey.findProgramAddress([
        collateralAssetMint.toBuffer(),
        quoteAssetMint.toBuffer(),
        new anchor.BN(strategyType).toArrayLike(Buffer, "le", 1),
        new anchor.BN(uniqueSeed).toArrayLike(Buffer, "le", 2),
    ], program.programId);
});
const deriveEpochHistory = (program, vaultAccount, epoch) => __awaiter(void 0, void 0, void 0, function* () {
    return yield web3_js.PublicKey.findProgramAddress([
        vaultAccount.toBuffer(),
        Buffer.from(epoch.toString()),
        Buffer.from("EpochHistory"),
    ], program.programId);
});
const deriveVaultAuthority = (program, vaultAccount) => __awaiter(void 0, void 0, void 0, function* () {
    return yield web3_js.PublicKey.findProgramAddress([vaultAccount.toBuffer(), Buffer.from("VaultAuthority")], program.programId);
});
const deriveVaultCollateralAccount = (program, vaultAccount) => __awaiter(void 0, void 0, void 0, function* () {
    return yield web3_js.PublicKey.findProgramAddress([vaultAccount.toBuffer(), Buffer.from("VaultCollateralAccount")], program.programId);
});
const deriveVaultTokenMint = (program, vaultAccount) => __awaiter(void 0, void 0, void 0, function* () {
    return yield web3_js.PublicKey.findProgramAddress([vaultAccount.toBuffer(), Buffer.from("VaultTokenMint")], program.programId);
});
const deriveVaultTokenAccount = (program, vaultAccount) => __awaiter(void 0, void 0, void 0, function* () {
    return yield web3_js.PublicKey.findProgramAddress([vaultAccount.toBuffer(), Buffer.from("VaultTokenAccount")], program.programId);
});
const deriveWithdrawalCollateralAccount = (program, vaultAccount) => __awaiter(void 0, void 0, void 0, function* () {
    return yield web3_js.PublicKey.findProgramAddress([vaultAccount.toBuffer(), Buffer.from("WithdrawalCollateralAccount")], program.programId);
});
const deriveDepositReceipt = (program, userAuthority, vaultAccount, epoch) => __awaiter(void 0, void 0, void 0, function* () {
    return yield web3_js.PublicKey.findProgramAddress([
        userAuthority.toBuffer(),
        vaultAccount.toBuffer(),
        Buffer.from(epoch.toString()),
        Buffer.from("DepositReceipt"),
    ], program.programId);
});
const deriveWithdrawalReceipt = (program, userAuthority, vaultAccount, epoch) => __awaiter(void 0, void 0, void 0, function* () {
    return yield web3_js.PublicKey.findProgramAddress([
        userAuthority.toBuffer(),
        vaultAccount.toBuffer(),
        Buffer.from(epoch.toString()),
        Buffer.from("WithdrawalReceipt"),
    ], program.programId);
});
const deriveOpenOrdersAddress = (serumMarket, authority, serumDexProgramKey) => __awaiter(void 0, void 0, void 0, function* () {
    return yield web3_js.PublicKey.findProgramAddress([
        Buffer.from("open-orders"),
        serumDexProgramKey.toBuffer(),
        serumMarket.toBuffer(),
        authority.toBuffer(),
    ], euroPrimitiveProgramKey);
});
const deriveMarketAuthority = (serumMarketKey, serumDexProgramKey) => __awaiter(void 0, void 0, void 0, function* () {
    return anchor.web3.PublicKey.findProgramAddress([
        Buffer.from("open-orders-init"),
        serumDexProgramKey.toBuffer(),
        serumMarketKey.toBuffer(),
    ], euroPrimitiveProgramKey);
});
const deriveRequestQueue = (optionMintKey, priceCurrencyKey) => web3_js.PublicKey.findProgramAddress([
    optionMintKey.toBuffer(),
    priceCurrencyKey.toBuffer(),
    Buffer.from("requestQueue"),
], euroPrimitiveProgramKey);
const deriveCoinVault = (optionMintKey, priceCurrencyKey) => web3_js.PublicKey.findProgramAddress([
    optionMintKey.toBuffer(),
    priceCurrencyKey.toBuffer(),
    Buffer.from("coinVault"),
], euroPrimitiveProgramKey);
const derivePCVault = (optionMintKey, priceCurrencyKey) => web3_js.PublicKey.findProgramAddress([
    optionMintKey.toBuffer(),
    priceCurrencyKey.toBuffer(),
    Buffer.from("pcVault"),
], euroPrimitiveProgramKey);
const deriveSerumMarketAddress = (optionMintKey, priceCurrencyKey) => web3_js.PublicKey.findProgramAddress([
    optionMintKey.toBuffer(),
    priceCurrencyKey.toBuffer(),
    Buffer.from("serumMarket"),
], euroPrimitiveProgramKey);
const deriveSerumVaultOwner = (serumMarket, serumDexProgramKey) => __awaiter(void 0, void 0, void 0, function* () {
    const nonce = new anchor.BN(0);
    while (nonce.toNumber() < 255) {
        try {
            const vaultOwner = yield web3_js.PublicKey.createProgramAddress([serumMarket.toBuffer(), nonce.toArrayLike(Buffer, "le", 8)], serumDexProgramKey);
            return [vaultOwner, nonce];
        }
        catch (e) {
            nonce.iaddn(1);
        }
    }
    throw new Error("Unable to find nonce");
});
const deriveStagingAccount = (auctionCurrencyMint, vaultAccount) => __awaiter(void 0, void 0, void 0, function* () {
    const stagingAccount = yield splToken.Token.getAssociatedTokenAddress(splToken.ASSOCIATED_TOKEN_PROGRAM_ID, splToken.TOKEN_PROGRAM_ID, auctionCurrencyMint, vaultAccount, true);
    return stagingAccount;
});
const deriveMetadataAccount = (mint) => __awaiter(void 0, void 0, void 0, function* () {
    const [metadataAccount] = yield web3_js.PublicKey.findProgramAddress([Buffer.from("metadata"), mplTokenMetadata.PROGRAM_ID.toBuffer(), mint.toBuffer()], mplTokenMetadata.PROGRAM_ID);
    return metadataAccount;
});

var pdas = /*#__PURE__*/Object.freeze({
    __proto__: null,
    deriveUnderlyingPoolKey: deriveUnderlyingPoolKey,
    deriveStablePoolKey: deriveStablePoolKey,
    deriveCallOptionMint: deriveCallOptionMint,
    deriveCallWriterMint: deriveCallWriterMint,
    derivePutOptionMint: derivePutOptionMint,
    derivePutWriterMint: derivePutWriterMint,
    derivePoolAuthority: derivePoolAuthority,
    deriveVaultAccount: deriveVaultAccount,
    deriveEpochHistory: deriveEpochHistory,
    deriveVaultAuthority: deriveVaultAuthority,
    deriveVaultCollateralAccount: deriveVaultCollateralAccount,
    deriveVaultTokenMint: deriveVaultTokenMint,
    deriveVaultTokenAccount: deriveVaultTokenAccount,
    deriveWithdrawalCollateralAccount: deriveWithdrawalCollateralAccount,
    deriveDepositReceipt: deriveDepositReceipt,
    deriveWithdrawalReceipt: deriveWithdrawalReceipt,
    deriveOpenOrdersAddress: deriveOpenOrdersAddress,
    deriveMarketAuthority: deriveMarketAuthority,
    deriveRequestQueue: deriveRequestQueue,
    deriveCoinVault: deriveCoinVault,
    derivePCVault: derivePCVault,
    deriveSerumMarketAddress: deriveSerumMarketAddress,
    deriveSerumVaultOwner: deriveSerumVaultOwner,
    deriveStagingAccount: deriveStagingAccount,
    deriveMetadataAccount: deriveMetadataAccount
});

const getMethodBuilder$q = (program, epochNumber, strategyType, vaultAccount, feeTokenAccount, collateralAssetMint, euroMeta, expirationData, writerTokenSrc) => __awaiter(void 0, void 0, void 0, function* () {
    const [poolAuthority] = yield derivePoolAuthority();
    const [vaultAuthority] = yield deriveVaultAuthority(program, vaultAccount);
    const [epochHistory] = yield deriveEpochHistory(program, vaultAccount, epochNumber);
    const [nextEpochHistory] = yield deriveEpochHistory(program, vaultAccount, epochNumber + 1);
    const [vaultCollateralAssetAccount] = yield deriveVaultCollateralAccount(program, vaultAccount);
    const [withdrawalCollateralAssetAccount] = yield deriveWithdrawalCollateralAccount(program, vaultAccount);
    const [vaultOwnershipTokenAccount] = yield deriveVaultTokenAccount(program, vaultAccount);
    const [vaultOwnershipTokenMint] = yield deriveVaultTokenMint(program, vaultAccount);
    let collateralPool, writerTokenMint;
    if (strategyType == exports.StrategyType.CALL) {
        [collateralPool] = yield deriveUnderlyingPoolKey(collateralAssetMint);
        [writerTokenMint] = yield deriveCallWriterMint(euroMeta);
    }
    else if (strategyType == exports.StrategyType.PUT) {
        [collateralPool] = yield deriveStablePoolKey(collateralAssetMint);
        [writerTokenMint] = yield derivePutWriterMint(euroMeta);
    }
    else {
        throw new Error("Strategy type not found.");
    }
    return program.methods.closePostExpiry().accounts({
        vaultAuthority,
        vaultAccount,
        epochHistory,
        nextEpochHistory,
        feeTokenAccount,
        vaultCollateralAssetAccount,
        withdrawalCollateralAssetAccount,
        vaultOwnershipTokenAccount,
        vaultOwnershipTokenMint,
        collateralAssetMint,
        euroMeta,
        expirationData,
        writerTokenMint,
        writerTokenSrc,
        collateralPool,
        poolAuthority,
        euroPrimitiveProgram: euroPrimitiveProgramKey,
    });
});
const closePostExpiryInstruction = (program, epochNumber, strategyType, vaultAccount, feeTokenAccount, collateralAssetMint, euroMeta, expirationData, writerTokenSrc) => __awaiter(void 0, void 0, void 0, function* () {
    const methodBuilder = yield getMethodBuilder$q(program, epochNumber, strategyType, vaultAccount, feeTokenAccount, collateralAssetMint, euroMeta, expirationData, writerTokenSrc);
    return methodBuilder.instruction();
});
const closePostExpiryRpc = (program, epochNumber, strategyType, vaultAccount, feeTokenAccount, collateralAssetMint, euroMeta, expirationData, writerTokenSrc, signers) => __awaiter(void 0, void 0, void 0, function* () {
    const methodBuilder = yield getMethodBuilder$q(program, epochNumber, strategyType, vaultAccount, feeTokenAccount, collateralAssetMint, euroMeta, expirationData, writerTokenSrc);
    return methodBuilder.signers(signers).rpc();
});

const getMethodBuilder$p = (program, depositAmount, userAuthority, vaultAccount, userCollateralAssetAccount, userVaultOwnershipTokenAccount) => __awaiter(void 0, void 0, void 0, function* () {
    const [vaultCollateralAssetAccount] = yield deriveVaultCollateralAccount(program, vaultAccount);
    const [vaultOwnershipTokenMint] = yield deriveVaultTokenMint(program, vaultAccount);
    return program.methods.deposit(depositAmount).accounts({
        userAuthority,
        vaultAccount,
        userCollateralAssetAccount,
        userVaultOwnershipTokenAccount,
        vaultCollateralAssetAccount,
        vaultOwnershipTokenMint,
    });
});
const depositInstruction = (program, depositAmount, userAuthority, vaultAccount, 
// TODO: Find these two accounts using ATA.
userCollateralAssetAccount, userVaultOwnershipTokenAccount) => __awaiter(void 0, void 0, void 0, function* () {
    const methodBuilder = yield getMethodBuilder$p(program, depositAmount, userAuthority, vaultAccount, userCollateralAssetAccount, userVaultOwnershipTokenAccount);
    return methodBuilder.instruction();
});
const depositRpc = (program, depositAmount, userAuthority, vaultAccount, 
// TODO: Find these two accounts using ATA.
userCollateralAssetAccount, userVaultOwnershipTokenAccount, signers) => __awaiter(void 0, void 0, void 0, function* () {
    const methodBuilder = yield getMethodBuilder$p(program, depositAmount, userAuthority, vaultAccount, userCollateralAssetAccount, userVaultOwnershipTokenAccount);
    return methodBuilder.signers(signers).rpc();
});

const getMethodBuilder$o = (program, withdrawAmount, userAuthority, vaultAccount, userCollateralAssetAccount, userVaultOwnershipTokenAccount, feeTokenAccount) => __awaiter(void 0, void 0, void 0, function* () {
    const [vaultCollateralAssetAccount] = yield deriveVaultCollateralAccount(program, vaultAccount);
    const [vaultOwnershipTokenMint] = yield deriveVaultTokenMint(program, vaultAccount);
    return program.methods.withdraw(withdrawAmount).accounts({
        userAuthority,
        vaultAccount,
        userCollateralAssetAccount,
        userVaultOwnershipTokenAccount,
        vaultCollateralAssetAccount,
        feeTokenAccount,
        vaultOwnershipTokenMint,
    });
});
const withdrawInstruction = (program, withdrawAmount, userAuthority, vaultAccount, 
// TODO: Find these two accounts using ATA.
userCollateralAssetAccount, userVaultOwnershipTokenAccount, feeTokenAccount) => __awaiter(void 0, void 0, void 0, function* () {
    const methodBuilder = yield getMethodBuilder$o(program, withdrawAmount, userAuthority, vaultAccount, userCollateralAssetAccount, userVaultOwnershipTokenAccount, feeTokenAccount);
    return methodBuilder.instruction();
});
const withdrawRpc = (program, withdrawAmount, userAuthority, vaultAccount, 
// TODO: Find these two accounts using ATA.
userCollateralAssetAccount, userVaultOwnershipTokenAccount, feeTokenAccount, signers) => __awaiter(void 0, void 0, void 0, function* () {
    const methodBuilder = yield getMethodBuilder$o(program, withdrawAmount, userAuthority, vaultAccount, userCollateralAssetAccount, userVaultOwnershipTokenAccount, feeTokenAccount);
    return methodBuilder.signers(signers).rpc();
});

const getMethodBuilder$n = (program, uniqueSeed, strategyType, vaultTokenDecimals, seedVaultTokenExchangeRate, endingExchangeRateDecimals, maxDeposit, fees, oracleProviderId, ownerAuthority, managerAuthority, taskerAuthority, feeTokenAccount, collateralAssetMint, quoteAssetMint, auctionCurrencyMint, oracle, payer) => __awaiter(void 0, void 0, void 0, function* () {
    const [vaultAccount] = yield deriveVaultAccount(program, collateralAssetMint, quoteAssetMint, uniqueSeed, strategyType);
    const [epochHistory] = yield deriveEpochHistory(program, vaultAccount, 1);
    const [vaultCollateralAssetAccount] = yield deriveVaultCollateralAccount(program, vaultAccount);
    const [withdrawalCollateralAssetAccount] = yield deriveWithdrawalCollateralAccount(program, vaultAccount);
    const [vaultOwnershipTokenAccount] = yield deriveVaultTokenAccount(program, vaultAccount);
    const [vaultOwnershipTokenMint] = yield deriveVaultTokenMint(program, vaultAccount);
    let accounts = {
        ownerAuthority,
        managerAuthority,
        taskerAuthority,
        feeTokenAccount,
        vaultAccount,
        vaultCollateralAssetAccount,
        withdrawalCollateralAssetAccount,
        collateralAssetMint,
        quoteAssetMint,
        auctionCurrencyMint,
        vaultOwnershipTokenMint,
        vaultOwnershipTokenAccount,
        currentEpochHistory: epochHistory,
        oracle,
    };
    if (payer)
        accounts.payer = payer;
    return program.methods
        .initializeVault(uniqueSeed, strategyType, vaultTokenDecimals, seedVaultTokenExchangeRate, endingExchangeRateDecimals, maxDeposit, fees, oracleProviderId)
        .accounts(accounts);
});
const initializeVaultInstruction = (program, uniqueSeed, strategyType, vaultTokenDecimals, seedVaultTokenExchangeRate, endingExchangeRateDecimals, maxDeposit, fees, oracleProviderId, ownerAuthority, managerAuthority, taskerAuthority, feeTokenAccount, collateralAssetMint, quoteAssetMint, auctionCurrencyMint, oracle, payer) => __awaiter(void 0, void 0, void 0, function* () {
    const methodBuilder = yield getMethodBuilder$n(program, uniqueSeed, strategyType, vaultTokenDecimals, seedVaultTokenExchangeRate, endingExchangeRateDecimals, maxDeposit, fees, oracleProviderId, ownerAuthority, managerAuthority, taskerAuthority, feeTokenAccount, collateralAssetMint, quoteAssetMint, auctionCurrencyMint, oracle, payer);
    return methodBuilder.instruction();
});
const initializeVaultRpc = (program, uniqueSeed, strategyType, vaultTokenDecimals, seedVaultTokenExchangeRate, endingExchangeRateDecimals, maxDeposit, fees, oracleProviderId, ownerAuthority, managerAuthority, taskerAuthority, feeTokenAccount, collateralAssetMint, quoteAssetMint, auctionCurrencyMint, oracle, signers, payer) => __awaiter(void 0, void 0, void 0, function* () {
    const methodBuilder = yield getMethodBuilder$n(program, uniqueSeed, strategyType, vaultTokenDecimals, seedVaultTokenExchangeRate, endingExchangeRateDecimals, maxDeposit, fees, oracleProviderId, ownerAuthority, managerAuthority, taskerAuthority, feeTokenAccount, collateralAssetMint, quoteAssetMint, auctionCurrencyMint, oracle, payer);
    return methodBuilder.signers(signers).rpc();
});

const getMethodBuilder$m = (program, tokensToMint, epochNumber, strategyType, managerAuthority, vaultAccount, euroMeta, collateralPool, mintedOptionDest, mintedWriterTokenDest) => __awaiter(void 0, void 0, void 0, function* () {
    const [vaultAuthority] = yield deriveVaultAuthority(program, vaultAccount);
    const [epochHistory] = yield deriveEpochHistory(program, vaultAccount, epochNumber);
    const [vaultCollateralAssetAccount] = yield deriveVaultCollateralAccount(program, vaultAccount);
    let optionMint, writerTokenMint;
    if (strategyType == exports.StrategyType.CALL) {
        [optionMint] = yield deriveCallOptionMint(euroMeta);
        [writerTokenMint] = yield deriveCallWriterMint(euroMeta);
    }
    else if (strategyType == exports.StrategyType.PUT) {
        [optionMint] = yield derivePutOptionMint(euroMeta);
        [writerTokenMint] = yield derivePutWriterMint(euroMeta);
    }
    else {
        throw new Error("Strategy type not found.");
    }
    return program.methods.mintOptions(tokensToMint).accounts({
        managerAuthority,
        vaultAuthority,
        vaultAccount,
        epochHistory,
        vaultCollateralAssetAccount,
        euroMeta,
        collateralPool,
        optionMint,
        writerTokenMint,
        mintedOptionDest,
        mintedWriterTokenDest,
        euroPrimitiveProgram: euroPrimitiveProgramKey,
    });
});
const mintOptionsInstruction = (program, tokensToMint, epochNumber, strategyType, managerAuthority, vaultAccount, euroMeta, collateralPool, mintedOptionDest, mintedWriterTokenDest) => __awaiter(void 0, void 0, void 0, function* () {
    const methodBuilder = yield getMethodBuilder$m(program, tokensToMint, epochNumber, strategyType, managerAuthority, vaultAccount, euroMeta, collateralPool, mintedOptionDest, mintedWriterTokenDest);
    return methodBuilder.instruction();
});
const mintOptionsRpc = (program, tokensToMint, epochNumber, strategyType, managerAuthority, vaultAccount, euroMeta, collateralPool, mintedOptionDest, mintedWriterTokenDest, signers) => __awaiter(void 0, void 0, void 0, function* () {
    const methodBuilder = yield getMethodBuilder$m(program, tokensToMint, epochNumber, strategyType, managerAuthority, vaultAccount, euroMeta, collateralPool, mintedOptionDest, mintedWriterTokenDest);
    return methodBuilder.signers(signers).rpc();
});

const getMethodBuilder$l = (program, epochNumber, userAuthority, vaultAccount) => __awaiter(void 0, void 0, void 0, function* () {
    const [depositReceipt] = yield deriveDepositReceipt(program, userAuthority, vaultAccount, epochNumber);
    return program.methods.initializeDepositReceipt().accounts({
        userAuthority,
        depositReceipt,
        vaultAccount,
    });
});
const initializeDepositReceiptInstruction = (program, epochNumber, userAuthority, vaultAccount) => __awaiter(void 0, void 0, void 0, function* () {
    const methodBuilder = yield getMethodBuilder$l(program, epochNumber, userAuthority, vaultAccount);
    return methodBuilder.instruction();
});
const initializeDepositReceiptRpc = (program, epochNumber, userAuthority, vaultAccount, signers) => __awaiter(void 0, void 0, void 0, function* () {
    const methodBuilder = yield getMethodBuilder$l(program, epochNumber, userAuthority, vaultAccount);
    return methodBuilder.signers(signers).rpc();
});

const getMethodBuilder$k = (program, epochNumber, feeReceiver, receiptOwner, vaultAccount, receivingVaultTokenAccount) => __awaiter(void 0, void 0, void 0, function* () {
    const [depositReceipt] = yield deriveDepositReceipt(program, receiptOwner, vaultAccount, epochNumber);
    const [epochHistory] = yield deriveEpochHistory(program, vaultAccount, epochNumber);
    const [vaultOwnershipTokenAccount] = yield deriveVaultTokenAccount(program, vaultAccount);
    return program.methods.payoutDepositReceipt().accounts({
        feeReceiver,
        depositReceipt,
        vaultAccount,
        receivingVaultTokenAccount,
        vaultOwnershipTokenAccount,
        epochHistory,
    });
});
const payoutDepositReceiptInstruction = (program, epochNumber, feeReceiver, receiptOwner, vaultAccount, receivingVaultTokenAccount) => __awaiter(void 0, void 0, void 0, function* () {
    const methodBuilder = yield getMethodBuilder$k(program, epochNumber, feeReceiver, receiptOwner, vaultAccount, receivingVaultTokenAccount);
    return methodBuilder.instruction();
});
const payoutDepositReceiptRpc = (program, epochNumber, feeReceiver, receiptOwner, vaultAccount, receivingVaultTokenAccount, signers) => __awaiter(void 0, void 0, void 0, function* () {
    const methodBuilder = yield getMethodBuilder$k(program, epochNumber, feeReceiver, receiptOwner, vaultAccount, receivingVaultTokenAccount);
    return methodBuilder.signers(signers).rpc();
});

const getMethodBuilder$j = (program, transferAmount, epochNumber, userAuthority, vaultAccount, userCollateralAssetAccount) => __awaiter(void 0, void 0, void 0, function* () {
    const [depositReceipt] = yield deriveDepositReceipt(program, userAuthority, vaultAccount, epochNumber);
    const [vaultCollateralAssetAccount] = yield deriveVaultCollateralAccount(program, vaultAccount);
    return program.methods.transferToDepositReceipt(transferAmount).accounts({
        userAuthority,
        depositReceipt,
        vaultAccount,
        userCollateralAssetAccount,
        vaultCollateralAssetAccount,
    });
});
const transferToDepositReceiptInstruction = (program, transferAmount, epochNumber, userAuthority, vaultAccount, userCollateralAssetAccount) => __awaiter(void 0, void 0, void 0, function* () {
    const methodBuilder = yield getMethodBuilder$j(program, transferAmount, epochNumber, userAuthority, vaultAccount, userCollateralAssetAccount);
    return methodBuilder.instruction();
});
const transferToDepositReceiptRpc = (program, transferAmount, epochNumber, userAuthority, vaultAccount, userCollateralAssetAccount, signers) => __awaiter(void 0, void 0, void 0, function* () {
    const methodBuilder = yield getMethodBuilder$j(program, transferAmount, epochNumber, userAuthority, vaultAccount, userCollateralAssetAccount);
    return methodBuilder.signers(signers).rpc();
});

const getMethodBuilder$i = (program, transferAmount, epochNumber, userAuthority, vaultAccount, userCollateralAssetAccount) => __awaiter(void 0, void 0, void 0, function* () {
    const [depositReceipt] = yield deriveDepositReceipt(program, userAuthority, vaultAccount, epochNumber);
    const [vaultCollateralAssetAccount] = yield deriveVaultCollateralAccount(program, vaultAccount);
    return program.methods.transferFromDepositReceipt(transferAmount).accounts({
        userAuthority,
        depositReceipt,
        vaultAccount,
        userCollateralAssetAccount,
        vaultCollateralAssetAccount,
    });
});
const transferFromDepositReceiptInstruction = (program, transferAmount, epochNumber, userAuthority, vaultAccount, userCollateralAssetAccount) => __awaiter(void 0, void 0, void 0, function* () {
    const methodBuilder = yield getMethodBuilder$i(program, transferAmount, epochNumber, userAuthority, vaultAccount, userCollateralAssetAccount);
    return methodBuilder.instruction();
});
const transferFromDepositReceiptRpc = (program, transferAmount, epochNumber, userAuthority, vaultAccount, userCollateralAssetAccount, signers) => __awaiter(void 0, void 0, void 0, function* () {
    const methodBuilder = yield getMethodBuilder$i(program, transferAmount, epochNumber, userAuthority, vaultAccount, userCollateralAssetAccount);
    return methodBuilder.signers(signers).rpc();
});

const getMethodBuilder$h = (program, epochNumber, userAuthority, vaultAccount) => __awaiter(void 0, void 0, void 0, function* () {
    const [withdrawalReceipt] = yield deriveWithdrawalReceipt(program, userAuthority, vaultAccount, epochNumber);
    return program.methods.initializeWithdrawalReceipt().accounts({
        userAuthority,
        withdrawalReceipt,
        vaultAccount,
    });
});
const initializeWithdrawalReceiptInstruction = (program, epochNumber, userAuthority, vaultAccount) => __awaiter(void 0, void 0, void 0, function* () {
    const methodBuilder = yield getMethodBuilder$h(program, epochNumber, userAuthority, vaultAccount);
    return methodBuilder.instruction();
});
const initializeWithdrawalReceiptRpc = (program, epochNumber, userAuthority, vaultAccount, signers) => __awaiter(void 0, void 0, void 0, function* () {
    const methodBuilder = yield getMethodBuilder$h(program, epochNumber, userAuthority, vaultAccount);
    return methodBuilder.signers(signers).rpc();
});

const getMethodBuilder$g = (program, epochNumber, feeReceiver, receiptOwner, vaultAccount, receiptOwnerCollateralAccount, feeTokenAccount, tempSolAccount) => __awaiter(void 0, void 0, void 0, function* () {
    const [withdrawalReceipt] = yield deriveWithdrawalReceipt(program, receiptOwner, vaultAccount, epochNumber);
    const [epochHistory] = yield deriveEpochHistory(program, vaultAccount, epochNumber);
    const [withdrawalCollateralAssetAccount] = yield deriveWithdrawalCollateralAccount(program, vaultAccount);
    return program.methods.payoutWithdrawalReceipt().accounts({
        feeReceiver,
        withdrawalReceipt,
        vaultAccount,
        receiptOwnerCollateralAccount,
        withdrawalCollateralAssetAccount,
        feeTokenAccount,
        receiptOwner,
        epochHistory,
        tempSolAccount,
        nativeMint: splToken.NATIVE_MINT,
    });
});
const payoutWithdrawalReceiptInstruction = (program, epochNumber, feeReceiver, receiptOwner, vaultAccount, receiptOwnerCollateralAccount, feeTokenAccount, tempSolAccount) => __awaiter(void 0, void 0, void 0, function* () {
    const methodBuilder = yield getMethodBuilder$g(program, epochNumber, feeReceiver, receiptOwner, vaultAccount, receiptOwnerCollateralAccount, feeTokenAccount, tempSolAccount);
    return methodBuilder.instruction();
});
const payoutWithdrawalReceiptRpc = (program, epochNumber, feeReceiver, receiptOwner, vaultAccount, receiptOwnerCollateralAccount, feeTokenAccount, signers) => __awaiter(void 0, void 0, void 0, function* () {
    const tempAccountKeypair = web3_js.Keypair.generate();
    const methodBuilder = yield getMethodBuilder$g(program, epochNumber, feeReceiver, receiptOwner, vaultAccount, receiptOwnerCollateralAccount, feeTokenAccount, tempAccountKeypair.publicKey);
    return methodBuilder.signers([...signers, tempAccountKeypair]).rpc();
});

const getMethodBuilder$f = (program, transferAmount, epochNumber, userAuthority, vaultAccount, userVaultOwnershipTokenAccount) => __awaiter(void 0, void 0, void 0, function* () {
    const [withdrawalReceipt] = yield deriveWithdrawalReceipt(program, userAuthority, vaultAccount, epochNumber);
    const [vaultOwnershipTokenAccount] = yield deriveVaultTokenAccount(program, vaultAccount);
    return program.methods.transferToWithdrawalReceipt(transferAmount).accounts({
        userAuthority,
        withdrawalReceipt,
        vaultAccount,
        userVaultOwnershipTokenAccount,
        vaultOwnershipTokenAccount,
    });
});
const transferToWithdrawalReceiptInstruction = (program, transferAmount, epochNumber, userAuthority, vaultAccount, userVaultOwnershipTokenAccount) => __awaiter(void 0, void 0, void 0, function* () {
    const methodBuilder = yield getMethodBuilder$f(program, transferAmount, epochNumber, userAuthority, vaultAccount, userVaultOwnershipTokenAccount);
    return methodBuilder.instruction();
});
const transferToWithdrawalReceiptRpc = (program, transferAmount, epochNumber, userAuthority, vaultAccount, userVaultOwnershipTokenAccount, signers) => __awaiter(void 0, void 0, void 0, function* () {
    const methodBuilder = yield getMethodBuilder$f(program, transferAmount, epochNumber, userAuthority, vaultAccount, userVaultOwnershipTokenAccount);
    return methodBuilder.signers(signers).rpc();
});

const getMethodBuilder$e = (program, transferAmount, epochNumber, userAuthority, vaultAccount, userVaultOwnershipTokenAccount) => __awaiter(void 0, void 0, void 0, function* () {
    const [withdrawalReceipt] = yield deriveWithdrawalReceipt(program, userAuthority, vaultAccount, epochNumber);
    const [vaultOwnershipTokenAccount] = yield deriveVaultTokenAccount(program, vaultAccount);
    return program.methods
        .transferFromWithdrawalReceipt(transferAmount)
        .accounts({
        userAuthority,
        withdrawalReceipt,
        vaultAccount,
        userVaultOwnershipTokenAccount,
        vaultOwnershipTokenAccount,
    });
});
const transferFromWithdrawalReceiptInstruction = (program, transferAmount, epochNumber, userAuthority, vaultAccount, userVaultOwnershipTokenAccount) => __awaiter(void 0, void 0, void 0, function* () {
    const methodBuilder = yield getMethodBuilder$e(program, transferAmount, epochNumber, userAuthority, vaultAccount, userVaultOwnershipTokenAccount);
    return methodBuilder.instruction();
});
const transferFromWithdrawalReceiptRpc = (program, transferAmount, epochNumber, userAuthority, vaultAccount, userVaultOwnershipTokenAccount, signers) => __awaiter(void 0, void 0, void 0, function* () {
    const methodBuilder = yield getMethodBuilder$e(program, transferAmount, epochNumber, userAuthority, vaultAccount, userVaultOwnershipTokenAccount);
    return methodBuilder.signers(signers).rpc();
});

const getMethodBuilder$d = (program, ownerAuthority, managerAuthority, taskerAuthority, vaultAccount) => __awaiter(void 0, void 0, void 0, function* () {
    return program.methods.updateVaultAuthorities().accounts({
        ownerAuthority,
        vaultAccount,
        managerAuthority,
        taskerAuthority,
    });
});
const updateVaultAuthoritiesInstruction = (program, ownerAuthority, managerAuthority, taskerAuthority, vaultAccount) => __awaiter(void 0, void 0, void 0, function* () {
    const methodBuilder = yield getMethodBuilder$d(program, ownerAuthority, managerAuthority, taskerAuthority, vaultAccount);
    return methodBuilder.instruction();
});
const updateVaultAuthoritiesRpc = (program, ownerAuthority, managerAuthority, taskerAuthority, vaultAccount, signers) => __awaiter(void 0, void 0, void 0, function* () {
    const methodBuilder = yield getMethodBuilder$d(program, ownerAuthority, managerAuthority, taskerAuthority, vaultAccount);
    return methodBuilder.signers(signers).rpc();
});

const getMethodBuilder$c = (program, maxDeposits, fees, oracleProviderId, ownerAuthority, vaultAccount, auctionCurrencyMint, oracle) => __awaiter(void 0, void 0, void 0, function* () {
    return program.methods
        .updateVaultParameters(maxDeposits, fees, oracleProviderId)
        .accounts({
        ownerAuthority,
        vaultAccount,
        auctionCurrencyMint,
        oracle,
    });
});
const updateVaultParametersInstruction = (program, maxDeposits, fees, oracleProviderId, ownerAuthority, vaultAccount, auctionCurrencyMint, oracle) => __awaiter(void 0, void 0, void 0, function* () {
    const methodBuilder = yield getMethodBuilder$c(program, maxDeposits, fees, oracleProviderId, ownerAuthority, vaultAccount, auctionCurrencyMint, oracle);
    return methodBuilder.instruction();
});
const updateVaultParametersRpc = (program, maxDeposits, fees, oracleProviderId, ownerAuthority, vaultAccount, auctionCurrencyMint, oracle, signers) => __awaiter(void 0, void 0, void 0, function* () {
    const methodBuilder = yield getMethodBuilder$c(program, maxDeposits, fees, oracleProviderId, ownerAuthority, vaultAccount, auctionCurrencyMint, oracle);
    return methodBuilder.signers(signers).rpc();
});

const getMethodBuilder$b = (program, ownerAuthority, vaultAccount, feeTokenAccount) => __awaiter(void 0, void 0, void 0, function* () {
    return program.methods.updateFeeAccount().accounts({
        ownerAuthority,
        vaultAccount,
        feeTokenAccount,
    });
});
const updateFeeAccountInstruction = (program, ownerAuthority, vaultAccount, feeTokenAccount) => __awaiter(void 0, void 0, void 0, function* () {
    const methodBuilder = yield getMethodBuilder$b(program, ownerAuthority, vaultAccount, feeTokenAccount);
    return methodBuilder.instruction();
});
const updateFeeAccountRpc = (program, ownerAuthority, vaultAccount, feeTokenAccount, signers) => __awaiter(void 0, void 0, void 0, function* () {
    const methodBuilder = yield getMethodBuilder$b(program, ownerAuthority, vaultAccount, feeTokenAccount);
    return methodBuilder.signers(signers).rpc();
});

const getMethodBuilder$a = (program, clientOrderId, epochNumber, taskerAuthority, vaultAccount, eventQueue, bids, asks, euroMeta, collateralAssetMint, optionMint, serumDexProgramKey, auctionCurrencyMint) => __awaiter(void 0, void 0, void 0, function* () {
    const [vaultAuthority] = yield deriveVaultAuthority(program, vaultAccount);
    const [epochHistory] = yield deriveEpochHistory(program, vaultAccount, epochNumber);
    const [serumMarket] = yield deriveSerumMarketAddress(optionMint, auctionCurrencyMint);
    const [openOrders] = yield deriveOpenOrdersAddress(serumMarket, vaultAuthority, serumDexProgramKey);
    return program.methods.cancelSerumOrder(clientOrderId).accounts({
        taskerAuthority,
        vaultAuthority,
        vaultAccount,
        epochHistory,
        euroMeta,
        optionMint,
        eventQueue,
        bids,
        asks,
        openOrders,
        serumMarket,
        euroPrimitiveProgram: euroPrimitiveProgramKey,
        dexProgram: serumDexProgramKey,
    });
});
const cancelSerumOrderInstruction = (program, clientOrderId, epochNumber, taskerAuthority, vaultAccount, eventQueue, bids, asks, euroMeta, collateralAssetMint, optionMint, serumDexProgramKey, auctionCurrencyMint) => __awaiter(void 0, void 0, void 0, function* () {
    const methodBuilder = yield getMethodBuilder$a(program, clientOrderId, epochNumber, taskerAuthority, vaultAccount, eventQueue, bids, asks, euroMeta, collateralAssetMint, optionMint, serumDexProgramKey, auctionCurrencyMint);
    return methodBuilder.instruction();
});
const cancelSerumOrderRpc = (program, clientOrderId, epochNumber, taskerAuthority, vaultAccount, eventQueue, bids, asks, euroMeta, collateralAssetMint, optionMint, serumDexProgramKey, auctionCurrencyMint, signers) => __awaiter(void 0, void 0, void 0, function* () {
    const methodBuilder = yield getMethodBuilder$a(program, clientOrderId, epochNumber, taskerAuthority, vaultAccount, eventQueue, bids, asks, euroMeta, collateralAssetMint, optionMint, serumDexProgramKey, auctionCurrencyMint);
    return methodBuilder.signers(signers).rpc();
});

const getMethodBuilder$9 = (program, limitPrice, clientOrderId, epochNumber, taskerAuthority, vaultAccount, optionTokenAccount, eventQueue, bids, asks, euroMeta, collateralAssetMint, optionMint, serumDexProgramKey, auctionCurrencyMint) => __awaiter(void 0, void 0, void 0, function* () {
    const [vaultAuthority] = yield deriveVaultAuthority(program, vaultAccount);
    const [epochHistory] = yield deriveEpochHistory(program, vaultAccount, epochNumber);
    const [serumMarket] = yield deriveSerumMarketAddress(optionMint, auctionCurrencyMint);
    const [openOrders] = yield deriveOpenOrdersAddress(serumMarket, vaultAuthority, serumDexProgramKey);
    const [requestQueue] = yield deriveRequestQueue(optionMint, auctionCurrencyMint);
    const [coinVault] = yield deriveCoinVault(optionMint, auctionCurrencyMint);
    const [priceCurrencyVault] = yield derivePCVault(optionMint, auctionCurrencyMint);
    return program.methods.placeSerumOrder(limitPrice, clientOrderId).accounts({
        taskerAuthority,
        vaultAuthority,
        vaultAccount,
        epochHistory,
        euroMeta,
        optionMint,
        optionTokenAccount,
        eventQueue,
        requestQueue,
        bids,
        asks,
        coinVault,
        priceCurrencyVault,
        openOrders,
        serumMarket,
        euroPrimitiveProgram: euroPrimitiveProgramKey,
        dexProgram: serumDexProgramKey,
    });
});
const placeSerumOrderInstruction = (program, limitPrice, clientOrderId, epochNumber, taskerAuthority, vaultAccount, optionTokenAccount, eventQueue, bids, asks, euroMeta, collateralAssetMint, optionMint, serumDexProgramKey, auctionCurrencyMint) => __awaiter(void 0, void 0, void 0, function* () {
    const methodBuilder = yield getMethodBuilder$9(program, limitPrice, clientOrderId, epochNumber, taskerAuthority, vaultAccount, optionTokenAccount, eventQueue, bids, asks, euroMeta, collateralAssetMint, optionMint, serumDexProgramKey, auctionCurrencyMint);
    return methodBuilder.instruction();
});
const placeSerumOrderRpc = (program, limitPrice, clientOrderId, epochNumber, taskerAuthority, vaultAccount, optionTokenAccount, eventQueue, bids, asks, euroMeta, collateralAssetMint, optionMint, serumDexProgramKey, auctionCurrencyMint, signers) => __awaiter(void 0, void 0, void 0, function* () {
    const methodBuilder = yield getMethodBuilder$9(program, limitPrice, clientOrderId, epochNumber, taskerAuthority, vaultAccount, optionTokenAccount, eventQueue, bids, asks, euroMeta, collateralAssetMint, optionMint, serumDexProgramKey, auctionCurrencyMint);
    return methodBuilder.signers(signers).rpc();
});

const getMethodBuilder$8 = (program, epochNumber, vaultAccount, optionTokenAccount, euroMeta, optionMint, referralAccount, auctionCurrencyMint, serumDexProgramKey) => __awaiter(void 0, void 0, void 0, function* () {
    const [vaultAuthority] = yield deriveVaultAuthority(program, vaultAccount);
    const [epochHistory] = yield deriveEpochHistory(program, vaultAccount, epochNumber);
    const [vaultCollateralAssetAccount] = yield deriveVaultCollateralAccount(program, vaultAccount);
    const [serumMarket] = yield deriveSerumMarketAddress(optionMint, auctionCurrencyMint);
    const [openOrders] = yield deriveOpenOrdersAddress(serumMarket, vaultAuthority, serumDexProgramKey);
    const [coinVault] = yield deriveCoinVault(optionMint, auctionCurrencyMint);
    const [priceCurrencyVault] = yield derivePCVault(optionMint, auctionCurrencyMint);
    const [serumVaultSigner] = yield deriveSerumVaultOwner(serumMarket, serumDexProgramKey);
    const stagingAccount = yield deriveStagingAccount(auctionCurrencyMint, vaultAccount);
    return program.methods.settleSerumOrder().accounts({
        vaultAuthority,
        vaultAccount,
        vaultCollateralAssetAccount,
        epochHistory,
        euroMeta,
        optionMint,
        optionTokenAccount,
        coinVault,
        priceCurrencyVault,
        openOrders,
        serumMarket,
        serumVaultSigner,
        referralAccount,
        stagingAccount,
        euroPrimitiveProgram: euroPrimitiveProgramKey,
        dexProgram: serumDexProgramKey,
    });
});
const settleSerumOrderInstruction = (program, epochNumber, vaultAccount, optionTokenAccount, euroMeta, optionMint, referralAccount, auctionCurrencyMint, serumDexProgramKey) => __awaiter(void 0, void 0, void 0, function* () {
    const methodBuilder = yield getMethodBuilder$8(program, epochNumber, vaultAccount, optionTokenAccount, euroMeta, optionMint, referralAccount, auctionCurrencyMint, serumDexProgramKey);
    return methodBuilder.instruction();
});
const settleSerumOrderRpc = (program, epochNumber, vaultAccount, optionTokenAccount, euroMeta, optionMint, referralAccount, auctionCurrencyMint, serumDexProgramKey, signers) => __awaiter(void 0, void 0, void 0, function* () {
    const stagingAccount = yield deriveStagingAccount(auctionCurrencyMint, vaultAccount);
    const tx = new web3_js.Transaction().add(splToken.Token.createAssociatedTokenAccountInstruction(splToken.ASSOCIATED_TOKEN_PROGRAM_ID, splToken.TOKEN_PROGRAM_ID, auctionCurrencyMint, stagingAccount, vaultAccount, program.provider.wallet.publicKey));
    try {
        yield program.provider.send(tx);
    }
    catch (err) {
        console.log("Staging ATA already exists for this auction currency");
    }
    const methodBuilder = yield getMethodBuilder$8(program, epochNumber, vaultAccount, optionTokenAccount, euroMeta, optionMint, referralAccount, auctionCurrencyMint, serumDexProgramKey);
    return methodBuilder.signers(signers).rpc();
});

const getMethodBuilder$7 = (program, epochNumber, payer, vaultAccount, euroMeta, optionMint, serumMarket, serumDexProgramKey) => __awaiter(void 0, void 0, void 0, function* () {
    const [vaultAuthority] = yield deriveVaultAuthority(program, vaultAccount);
    const [epochHistory] = yield deriveEpochHistory(program, vaultAccount, epochNumber);
    const [openOrders] = yield deriveOpenOrdersAddress(serumMarket, vaultAuthority, serumDexProgramKey);
    const [psyMarketAuthority] = yield deriveMarketAuthority(serumMarket, serumDexProgramKey);
    return program.methods.initializeSerumOpenOrders().accounts({
        payer,
        vaultAuthority,
        vaultAccount,
        epochHistory,
        euroMeta,
        optionMint,
        openOrders,
        serumMarket,
        psyMarketAuthority,
        euroPrimitiveProgram: euroPrimitiveProgramKey,
        dexProgram: serumDexProgramKey,
    });
});
const initializeSerumOpenOrdersInstruction = (program, epochNumber, payer, vaultAccount, euroMeta, optionMint, serumMarket, serumDexProgramKey) => __awaiter(void 0, void 0, void 0, function* () {
    const methodBuilder = yield getMethodBuilder$7(program, epochNumber, payer, vaultAccount, euroMeta, optionMint, serumMarket, serumDexProgramKey);
    return methodBuilder.instruction();
});
const initializeSerumOpenOrdersRpc = (program, epochNumber, payer, vaultAccount, euroMeta, optionMint, serumMarket, serumDexProgramKey, signers) => __awaiter(void 0, void 0, void 0, function* () {
    const methodBuilder = yield getMethodBuilder$7(program, epochNumber, payer, vaultAccount, euroMeta, optionMint, serumMarket, serumDexProgramKey);
    return methodBuilder.signers(signers).rpc();
});

const getMethodBuilder$6 = (program, stakingProgramKey, receiptEpoch, userAuthority, vaultAccount, stakePool, receivingTokenAccount, startRewardRecordEpoch, endRewardRecordEpoch, rewardPoolId) => __awaiter(void 0, void 0, void 0, function* () {
    const [depositReceipt] = yield deriveDepositReceipt(program, userAuthority, vaultAccount, receiptEpoch);
    const [epochHistory] = yield deriveEpochHistory(program, vaultAccount, receiptEpoch);
    const [vaultOwnershipTokenMint] = yield deriveVaultTokenMint(program, vaultAccount);
    const [stakingRecord] = yield psystakeTest.pdas.deriveStakingRecord(stakingProgramKey, userAuthority, stakePool);
    const [rewardPool] = yield psystakeTest.pdas.deriveRewardPool(stakingProgramKey, stakePool, rewardPoolId);
    const [startRewardRecord] = yield psystakeTest.pdas.deriveRewardRecord(stakingProgramKey, rewardPool, startRewardRecordEpoch);
    const [endRewardRecord] = yield psystakeTest.pdas.deriveRewardRecord(stakingProgramKey, rewardPool, endRewardRecordEpoch);
    const [allocatedTokenAccount] = yield psystakeTest.pdas.deriveAllocatedTokenAccount(stakingProgramKey, rewardPool);
    return program.methods.claimRewardForStaker().accounts({
        depositReceipt,
        vaultAccount,
        epochHistory,
        vaultOwnershipTokenMint,
        stakingRecord,
        stakePool,
        rewardPool,
        startRewardRecord,
        endRewardRecord,
        allocatedTokenAccount,
        receivingTokenAccount,
        stakingProgram: stakingProgramKey,
    });
});
const claimRewardForStakerInstruction = (program, stakingProgramKey, receiptEpoch, userAuthority, vaultAccount, stakePool, receivingTokenAccount, startRewardRecordEpoch, endRewardRecordEpoch, rewardPoolId) => __awaiter(void 0, void 0, void 0, function* () {
    const methodBuilder = yield getMethodBuilder$6(program, stakingProgramKey, receiptEpoch, userAuthority, vaultAccount, stakePool, receivingTokenAccount, startRewardRecordEpoch, endRewardRecordEpoch, rewardPoolId);
    return methodBuilder.instruction();
});
const claimRewardForStakerRpc = (program, stakingProgramKey, receiptEpoch, userAuthority, vaultAccount, stakePool, receivingTokenAccount, startRewardRecordEpoch, endRewardRecordEpoch, rewardPoolId, signers) => __awaiter(void 0, void 0, void 0, function* () {
    const methodBuilder = yield getMethodBuilder$6(program, stakingProgramKey, receiptEpoch, userAuthority, vaultAccount, stakePool, receivingTokenAccount, startRewardRecordEpoch, endRewardRecordEpoch, rewardPoolId);
    return methodBuilder.signers(signers).rpc();
});

const deriveAssociatedAddress = (mint, owner, allowOwnerOffCurve = true) => __awaiter(void 0, void 0, void 0, function* () {
    return splToken.Token.getAssociatedTokenAddress(splToken.ASSOCIATED_TOKEN_PROGRAM_ID, splToken.TOKEN_PROGRAM_ID, mint, owner, allowOwnerOffCurve);
});

const getMethodBuilder$5 = (program, stakingProgramKey, feeReceiver, receiptEpoch, userAuthority, vaultAccount, stakePool) => __awaiter(void 0, void 0, void 0, function* () {
    const [depositReceipt] = yield deriveDepositReceipt(program, userAuthority, vaultAccount, receiptEpoch);
    const [epochHistory] = yield deriveEpochHistory(program, vaultAccount, receiptEpoch);
    const [vaultOwnershipTokenAccount] = yield deriveVaultTokenAccount(program, vaultAccount);
    const [vaultOwnershipTokenMint] = yield deriveVaultTokenMint(program, vaultAccount);
    const [stakingRecord] = yield psystakeTest.pdas.deriveStakingRecord(stakingProgramKey, userAuthority, stakePool);
    const [stakingTokenAccount] = yield psystakeTest.pdas.deriveStakingTokenAccount(stakingProgramKey, stakePool);
    const receiptOwnerVaultTokenAccount = yield deriveAssociatedAddress(vaultOwnershipTokenMint, userAuthority);
    return program.methods.payoutDepositReceiptToStaking().accounts({
        feeReceiver,
        depositReceipt,
        vaultAccount,
        vaultOwnershipTokenAccount,
        vaultOwnershipTokenMint,
        epochHistory,
        receiptOwnerVaultTokenAccount,
        stakingRecord,
        stakePool,
        stakingTokenAccount,
        stakingProgram: stakingProgramKey,
    });
});
const payoutDepositReceiptToStakingInstruction = (program, stakingProgramKey, feeReceiver, receiptEpoch, userAuthority, vaultAccount, stakePool) => __awaiter(void 0, void 0, void 0, function* () {
    const methodBuilder = yield getMethodBuilder$5(program, stakingProgramKey, feeReceiver, receiptEpoch, userAuthority, vaultAccount, stakePool);
    return methodBuilder.instruction();
});
const payoutDepositReceiptToStakingRpc = (program, stakingProgramKey, feeReceiver, receiptEpoch, userAuthority, vaultAccount, stakePool, signers) => __awaiter(void 0, void 0, void 0, function* () {
    const methodBuilder = yield getMethodBuilder$5(program, stakingProgramKey, feeReceiver, receiptEpoch, userAuthority, vaultAccount, stakePool);
    return methodBuilder.signers(signers).rpc();
});

const getMethodBuilder$4 = (program, stakingProgramKey, transferAmount, lockupPeriod, forStaking, epochNumber, userAuthority, vaultAccount, userCollateralAssetAccount, stakePool) => __awaiter(void 0, void 0, void 0, function* () {
    const [depositReceipt] = yield deriveDepositReceipt(program, userAuthority, vaultAccount, epochNumber);
    const [vaultCollateralAssetAccount] = yield deriveVaultCollateralAccount(program, vaultAccount);
    const [stakingRecord] = yield psystakeTest.pdas.deriveStakingRecord(stakingProgramKey, userAuthority, stakePool);
    return program.methods
        .transferToDepositReceiptForStaking(transferAmount, lockupPeriod, forStaking)
        .accounts({
        userAuthority,
        depositReceipt,
        vaultAccount,
        userCollateralAssetAccount,
        vaultCollateralAssetAccount,
        stakingRecord,
        stakePool,
    });
});
const transferToDepositReceiptForStakingInstruction = (program, stakingProgramKey, transferAmount, lockupPeriod, forStaking, epochNumber, userAuthority, vaultAccount, userCollateralAssetAccount, stakePool) => __awaiter(void 0, void 0, void 0, function* () {
    const methodBuilder = yield getMethodBuilder$4(program, stakingProgramKey, transferAmount, lockupPeriod, forStaking, epochNumber, userAuthority, vaultAccount, userCollateralAssetAccount, stakePool);
    return methodBuilder.instruction();
});
const transferToDepositReceiptForStakingRpc = (program, stakingProgramKey, transferAmount, lockupPeriod, forStaking, epochNumber, userAuthority, vaultAccount, userCollateralAssetAccount, stakePool, signers) => __awaiter(void 0, void 0, void 0, function* () {
    const methodBuilder = yield getMethodBuilder$4(program, stakingProgramKey, transferAmount, lockupPeriod, forStaking, epochNumber, userAuthority, vaultAccount, userCollateralAssetAccount, stakePool);
    return methodBuilder.signers(signers).rpc();
});

const getMethodBuilder$3 = (program, epochNumber, strategyType, managerAuthority, vaultAccount, euroMeta, collateralPool, optionTokenSrc, writerTokenSrc) => __awaiter(void 0, void 0, void 0, function* () {
    const [poolAuthority] = yield derivePoolAuthority();
    const [vaultAuthority] = yield deriveVaultAuthority(program, vaultAccount);
    const [epochHistory] = yield deriveEpochHistory(program, vaultAccount, epochNumber);
    const [vaultCollateralAssetAccount] = yield deriveVaultCollateralAccount(program, vaultAccount);
    let optionMint, writerTokenMint;
    if (strategyType == exports.StrategyType.CALL) {
        [optionMint] = yield deriveCallOptionMint(euroMeta);
        [writerTokenMint] = yield deriveCallWriterMint(euroMeta);
    }
    else if (strategyType == exports.StrategyType.PUT) {
        [optionMint] = yield derivePutOptionMint(euroMeta);
        [writerTokenMint] = yield derivePutWriterMint(euroMeta);
    }
    else {
        throw new Error("Strategy type not found.");
    }
    return program.methods.cancelOptionsPosition().accounts({
        managerAuthority,
        vaultAuthority,
        vaultAccount,
        epochHistory,
        vaultCollateralAssetAccount,
        euroMeta,
        collateralPool,
        poolAuthority,
        optionMint,
        writerTokenMint,
        optionTokenSrc,
        writerTokenSrc,
        euroPrimitiveProgram: euroPrimitiveProgramKey,
    });
});
const cancelOptionsPositionInstruction = (program, epochNumber, strategyType, managerAuthority, vaultAccount, euroMeta, collateralPool, optionTokenSrc, writerTokenSrc) => __awaiter(void 0, void 0, void 0, function* () {
    const methodBuilder = yield getMethodBuilder$3(program, epochNumber, strategyType, managerAuthority, vaultAccount, euroMeta, collateralPool, optionTokenSrc, writerTokenSrc);
    return methodBuilder.instruction();
});
const cancelOptionsPositionRpc = (program, epochNumber, strategyType, managerAuthority, vaultAccount, euroMeta, collateralPool, optionTokenSrc, writerTokenSrc, signers) => __awaiter(void 0, void 0, void 0, function* () {
    const methodBuilder = yield getMethodBuilder$3(program, epochNumber, strategyType, managerAuthority, vaultAccount, euroMeta, collateralPool, optionTokenSrc, writerTokenSrc);
    return methodBuilder.signers(signers).rpc();
});

const getMethodBuilder$2 = (program, declaredPrice, stagingAmountToTrade, epochNumber, taskerAuthority, vaultAccount, collateralAssetMint, auctionCurrencyMint, taskerPaymentAccount, taskerDestinationAccount, oracle) => __awaiter(void 0, void 0, void 0, function* () {
    const [epochHistory] = yield deriveEpochHistory(program, vaultAccount, epochNumber);
    const [vaultCollateralAssetAccount] = yield deriveVaultCollateralAccount(program, vaultAccount);
    const stagingAccount = yield deriveStagingAccount(auctionCurrencyMint, vaultAccount);
    return program.methods
        .otcSwapBidAsset(declaredPrice, stagingAmountToTrade)
        .accounts({
        taskerAuthority,
        vaultAccount,
        vaultCollateralAssetAccount,
        collateralAssetMint,
        auctionCurrencyMint,
        stagingAccount,
        taskerPaymentAccount,
        taskerDestinationAccount,
        currentEpochHistory: epochHistory,
        oracle,
    });
});
const otcSwapBidAssetInstruction = (program, declaredPrice, stagingAmountToTrade, epochNumber, taskerAuthority, vaultAccount, collateralAssetMint, auctionCurrencyMint, taskerPaymentAccount, taskerDestinationAccount, oracle) => __awaiter(void 0, void 0, void 0, function* () {
    const methodBuilder = yield getMethodBuilder$2(program, declaredPrice, stagingAmountToTrade, epochNumber, taskerAuthority, vaultAccount, collateralAssetMint, auctionCurrencyMint, taskerPaymentAccount, taskerDestinationAccount, oracle);
    return methodBuilder.instruction();
});
const otcSwapBidAssetRpc = (program, declaredPrice, stagingAmountToTrade, epochNumber, taskerAuthority, vaultAccount, collateralAssetMint, auctionCurrencyMint, taskerPaymentAccount, taskerDestinationAccount, oracle, signers) => __awaiter(void 0, void 0, void 0, function* () {
    const methodBuilder = yield getMethodBuilder$2(program, declaredPrice, stagingAmountToTrade, epochNumber, taskerAuthority, vaultAccount, collateralAssetMint, auctionCurrencyMint, taskerPaymentAccount, taskerDestinationAccount, oracle);
    return methodBuilder.signers(signers).rpc();
});

const getMethodBuilder$1 = (program, title, symbol, uri, vaultAccount, payer, ownerAuthority) => __awaiter(void 0, void 0, void 0, function* () {
    const [mint] = yield deriveVaultTokenMint(program, vaultAccount);
    const metadataAccount = yield deriveMetadataAccount(mint);
    return program.methods.createMetaplexMetadata(title, symbol, uri).accounts({
        vaultOwnershipTokenMint: mint,
        vaultAccount: vaultAccount,
        payer: payer,
        tokenMetadataProgram: mplTokenMetadata.PROGRAM_ID,
        metadata: metadataAccount,
        ownerAuthority: ownerAuthority,
    });
});
//Checks the owner authority and sets it to the update authority
const createMetaplexMetadataRpc = (program, title, symbol, uri, vaultAccount, payer, ownerAuthority, signers) => __awaiter(void 0, void 0, void 0, function* () {
    return (yield getMethodBuilder$1(program, title, symbol, uri, vaultAccount, payer, ownerAuthority))
        .signers(signers)
        .rpc();
});
const createMetaplexMetadataInstruction = (program, title, symbol, uri, vaultAccount, mint, payer, ownerAuthority) => __awaiter(void 0, void 0, void 0, function* () {
    return (yield getMethodBuilder$1(program, title, symbol, uri, vaultAccount, payer, ownerAuthority)).instruction();
});

const getMethodBuilder = (program, epochNumber, strategyType, managerAuthority, vaultAccount, collateralAssetMint, euroMeta, expirationData, collateralPool, optionTokenSrc) => __awaiter(void 0, void 0, void 0, function* () {
    const [poolAuthority] = yield derivePoolAuthority();
    const [vaultAuthority] = yield deriveVaultAuthority(program, vaultAccount);
    const [epochHistory] = yield deriveEpochHistory(program, vaultAccount, epochNumber);
    const [vaultCollateralAssetAccount] = yield deriveVaultCollateralAccount(program, vaultAccount);
    let optionMint;
    if (strategyType == exports.StrategyType.CALL) {
        [optionMint] = yield deriveCallOptionMint(euroMeta);
    }
    else if (strategyType == exports.StrategyType.PUT) {
        [optionMint] = yield derivePutOptionMint(euroMeta);
    }
    else {
        throw new Error("Strategy type not found.");
    }
    return program.methods.settleExpiredOptions().accounts({
        managerAuthority,
        vaultAuthority,
        vaultAccount,
        epochHistory,
        vaultCollateralAssetAccount,
        collateralAssetMint,
        euroMeta,
        expirationData,
        collateralPool,
        poolAuthority,
        optionMint,
        optionTokenSrc,
        euroPrimitiveProgram: euroPrimitiveProgramKey,
    });
});
const settleExpiredOptionsInstruction = (program, epochNumber, strategyType, managerAuthority, vaultAccount, collateralAssetMint, euroMeta, expirationData, collateralPool, optionTokenSrc) => __awaiter(void 0, void 0, void 0, function* () {
    const methodBuilder = yield getMethodBuilder(program, epochNumber, strategyType, managerAuthority, vaultAccount, collateralAssetMint, euroMeta, expirationData, collateralPool, optionTokenSrc);
    return methodBuilder.instruction();
});
const settleExpiredOptionsRpc = (program, epochNumber, strategyType, managerAuthority, vaultAccount, collateralAssetMint, euroMeta, expirationData, collateralPool, optionTokenSrc, signers) => __awaiter(void 0, void 0, void 0, function* () {
    const methodBuilder = yield getMethodBuilder(program, epochNumber, strategyType, managerAuthority, vaultAccount, collateralAssetMint, euroMeta, expirationData, collateralPool, optionTokenSrc);
    return methodBuilder.signers(signers).rpc();
});

var index = /*#__PURE__*/Object.freeze({
    __proto__: null,
    closePostExpiryInstruction: closePostExpiryInstruction,
    closePostExpiryRpc: closePostExpiryRpc,
    depositInstruction: depositInstruction,
    depositRpc: depositRpc,
    withdrawInstruction: withdrawInstruction,
    withdrawRpc: withdrawRpc,
    initializeVaultInstruction: initializeVaultInstruction,
    initializeVaultRpc: initializeVaultRpc,
    mintOptionsInstruction: mintOptionsInstruction,
    mintOptionsRpc: mintOptionsRpc,
    initializeDepositReceiptInstruction: initializeDepositReceiptInstruction,
    initializeDepositReceiptRpc: initializeDepositReceiptRpc,
    payoutDepositReceiptInstruction: payoutDepositReceiptInstruction,
    payoutDepositReceiptRpc: payoutDepositReceiptRpc,
    transferToDepositReceiptInstruction: transferToDepositReceiptInstruction,
    transferToDepositReceiptRpc: transferToDepositReceiptRpc,
    transferFromDepositReceiptInstruction: transferFromDepositReceiptInstruction,
    transferFromDepositReceiptRpc: transferFromDepositReceiptRpc,
    initializeWithdrawalReceiptInstruction: initializeWithdrawalReceiptInstruction,
    initializeWithdrawalReceiptRpc: initializeWithdrawalReceiptRpc,
    payoutWithdrawalReceiptInstruction: payoutWithdrawalReceiptInstruction,
    payoutWithdrawalReceiptRpc: payoutWithdrawalReceiptRpc,
    transferToWithdrawalReceiptInstruction: transferToWithdrawalReceiptInstruction,
    transferToWithdrawalReceiptRpc: transferToWithdrawalReceiptRpc,
    transferFromWithdrawalReceiptInstruction: transferFromWithdrawalReceiptInstruction,
    transferFromWithdrawalReceiptRpc: transferFromWithdrawalReceiptRpc,
    updateVaultAuthoritiesInstruction: updateVaultAuthoritiesInstruction,
    updateVaultAuthoritiesRpc: updateVaultAuthoritiesRpc,
    updateVaultParametersInstruction: updateVaultParametersInstruction,
    updateVaultParametersRpc: updateVaultParametersRpc,
    updateFeeAccountInstruction: updateFeeAccountInstruction,
    updateFeeAccountRpc: updateFeeAccountRpc,
    cancelSerumOrderInstruction: cancelSerumOrderInstruction,
    cancelSerumOrderRpc: cancelSerumOrderRpc,
    placeSerumOrderInstruction: placeSerumOrderInstruction,
    placeSerumOrderRpc: placeSerumOrderRpc,
    settleSerumOrderInstruction: settleSerumOrderInstruction,
    settleSerumOrderRpc: settleSerumOrderRpc,
    initializeSerumOpenOrdersInstruction: initializeSerumOpenOrdersInstruction,
    initializeSerumOpenOrdersRpc: initializeSerumOpenOrdersRpc,
    claimRewardForStakerInstruction: claimRewardForStakerInstruction,
    claimRewardForStakerRpc: claimRewardForStakerRpc,
    payoutDepositReceiptToStakingInstruction: payoutDepositReceiptToStakingInstruction,
    payoutDepositReceiptToStakingRpc: payoutDepositReceiptToStakingRpc,
    transferToDepositReceiptForStakingInstruction: transferToDepositReceiptForStakingInstruction,
    transferToDepositReceiptForStakingRpc: transferToDepositReceiptForStakingRpc,
    cancelOptionsPositionInstruction: cancelOptionsPositionInstruction,
    cancelOptionsPositionRpc: cancelOptionsPositionRpc,
    otcSwapBidAssetInstruction: otcSwapBidAssetInstruction,
    otcSwapBidAssetRpc: otcSwapBidAssetRpc,
    createMetaplexMetadataRpc: createMetaplexMetadataRpc,
    createMetaplexMetadataInstruction: createMetaplexMetadataInstruction,
    settleExpiredOptionsInstruction: settleExpiredOptionsInstruction,
    settleExpiredOptionsRpc: settleExpiredOptionsRpc
});

const PsyFiIdl = {
    version: "0.1.5",
    name: "psyfi_euros",
    instructions: [
        {
            name: "initializeVault",
            accounts: [
                {
                    name: "ownerAuthority",
                    isMut: false,
                    isSigner: true,
                },
                {
                    name: "managerAuthority",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "taskerAuthority",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "vaultAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "feeTokenAccount",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "vaultCollateralAssetAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "withdrawalCollateralAssetAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "collateralAssetMint",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "quoteAssetMint",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "auctionCurrencyMint",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "vaultOwnershipTokenMint",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "vaultOwnershipTokenAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "currentEpochHistory",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "oracle",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "payer",
                    isMut: true,
                    isSigner: true,
                },
                {
                    name: "rent",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "tokenProgram",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "systemProgram",
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: "uniqueSeed",
                    type: "u16",
                },
                {
                    name: "strategyType",
                    type: "u8",
                },
                {
                    name: "vaultTokenDecimals",
                    type: "u8",
                },
                {
                    name: "seedVaultTokenPerCollateral",
                    type: {
                        defined: "ExchangeRate",
                    },
                },
                {
                    name: "endingExchangeRateDecimals",
                    type: "u8",
                },
                {
                    name: "maxDeposits",
                    type: "u64",
                },
                {
                    name: "fees",
                    type: {
                        defined: "VaultFees",
                    },
                },
                {
                    name: "oracleProviderId",
                    type: "u8",
                },
            ],
        },
        {
            name: "updateVaultParameters",
            accounts: [
                {
                    name: "ownerAuthority",
                    isMut: false,
                    isSigner: true,
                },
                {
                    name: "vaultAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "auctionCurrencyMint",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "oracle",
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: "maxDeposits",
                    type: "u64",
                },
                {
                    name: "fees",
                    type: {
                        defined: "VaultFees",
                    },
                },
                {
                    name: "oracleProviderId",
                    type: "u8",
                },
            ],
        },
        {
            name: "updateVaultAuthorities",
            accounts: [
                {
                    name: "ownerAuthority",
                    isMut: false,
                    isSigner: true,
                },
                {
                    name: "vaultAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "managerAuthority",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "taskerAuthority",
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [],
        },
        {
            name: "updateFeeAccount",
            accounts: [
                {
                    name: "ownerAuthority",
                    isMut: false,
                    isSigner: true,
                },
                {
                    name: "vaultAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "feeTokenAccount",
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [],
        },
        {
            name: "mintOptions",
            accounts: [
                {
                    name: "managerAuthority",
                    isMut: false,
                    isSigner: true,
                },
                {
                    name: "vaultAuthority",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "vaultAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "epochHistory",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "vaultCollateralAssetAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "euroMeta",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "collateralPool",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "optionMint",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "writerTokenMint",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "mintedOptionDest",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "mintedWriterTokenDest",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "euroPrimitiveProgram",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "tokenProgram",
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: "tokensToMint",
                    type: "u64",
                },
            ],
        },
        {
            name: "cancelOptionsPosition",
            accounts: [
                {
                    name: "managerAuthority",
                    isMut: false,
                    isSigner: true,
                },
                {
                    name: "vaultAuthority",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "vaultAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "epochHistory",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "vaultCollateralAssetAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "euroMeta",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "collateralPool",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "poolAuthority",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "optionMint",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "writerTokenMint",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "optionTokenSrc",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "writerTokenSrc",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "euroPrimitiveProgram",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "tokenProgram",
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [],
        },
        {
            name: "closePostExpiry",
            accounts: [
                {
                    name: "vaultAuthority",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "vaultAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "epochHistory",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "nextEpochHistory",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "feeTokenAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "vaultCollateralAssetAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "withdrawalCollateralAssetAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "vaultOwnershipTokenAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "vaultOwnershipTokenMint",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "collateralAssetMint",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "euroMeta",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "expirationData",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "writerTokenMint",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "writerTokenSrc",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "collateralPool",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "poolAuthority",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "payer",
                    isMut: true,
                    isSigner: true,
                },
                {
                    name: "euroPrimitiveProgram",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "tokenProgram",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "systemProgram",
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [],
        },
        {
            name: "settleExpiredOptions",
            accounts: [
                {
                    name: "managerAuthority",
                    isMut: false,
                    isSigner: true,
                },
                {
                    name: "vaultAuthority",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "vaultAccount",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "epochHistory",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "vaultCollateralAssetAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "collateralAssetMint",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "euroMeta",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "expirationData",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "collateralPool",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "poolAuthority",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "optionMint",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "optionTokenSrc",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "euroPrimitiveProgram",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "tokenProgram",
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [],
        },
        {
            name: "initializeDepositReceipt",
            accounts: [
                {
                    name: "userAuthority",
                    isMut: true,
                    isSigner: true,
                },
                {
                    name: "depositReceipt",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "vaultAccount",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "systemProgram",
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [],
        },
        {
            name: "transferToDepositReceipt",
            accounts: [
                {
                    name: "userAuthority",
                    isMut: false,
                    isSigner: true,
                },
                {
                    name: "depositReceipt",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "vaultAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "userCollateralAssetAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "vaultCollateralAssetAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "tokenProgram",
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: "transferAmount",
                    type: "u64",
                },
            ],
        },
        {
            name: "transferFromDepositReceipt",
            accounts: [
                {
                    name: "userAuthority",
                    isMut: false,
                    isSigner: true,
                },
                {
                    name: "depositReceipt",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "vaultAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "userCollateralAssetAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "vaultCollateralAssetAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "tokenProgram",
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: "transferAmount",
                    type: "u64",
                },
            ],
        },
        {
            name: "payoutDepositReceipt",
            accounts: [
                {
                    name: "feeReceiver",
                    isMut: true,
                    isSigner: true,
                },
                {
                    name: "depositReceipt",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "vaultAccount",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "receivingVaultTokenAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "vaultOwnershipTokenAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "epochHistory",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "tokenProgram",
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [],
        },
        {
            name: "initializeWithdrawalReceipt",
            accounts: [
                {
                    name: "userAuthority",
                    isMut: true,
                    isSigner: true,
                },
                {
                    name: "withdrawalReceipt",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "vaultAccount",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "systemProgram",
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [],
        },
        {
            name: "transferToWithdrawalReceipt",
            accounts: [
                {
                    name: "userAuthority",
                    isMut: false,
                    isSigner: true,
                },
                {
                    name: "withdrawalReceipt",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "vaultAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "userVaultOwnershipTokenAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "vaultOwnershipTokenAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "tokenProgram",
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: "vaultTokenAmount",
                    type: "u64",
                },
            ],
        },
        {
            name: "transferFromWithdrawalReceipt",
            accounts: [
                {
                    name: "userAuthority",
                    isMut: false,
                    isSigner: true,
                },
                {
                    name: "withdrawalReceipt",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "vaultAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "userVaultOwnershipTokenAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "vaultOwnershipTokenAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "tokenProgram",
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: "vaultTokenAmount",
                    type: "u64",
                },
            ],
        },
        {
            name: "payoutWithdrawalReceipt",
            accounts: [
                {
                    name: "feeReceiver",
                    isMut: true,
                    isSigner: true,
                },
                {
                    name: "withdrawalReceipt",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "vaultAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "receiptOwnerCollateralAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "withdrawalCollateralAssetAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "feeTokenAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "epochHistory",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "receiptOwner",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "tempSolAccount",
                    isMut: true,
                    isSigner: true,
                },
                {
                    name: "nativeMint",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "tokenProgram",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "systemProgram",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "rent",
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [],
        },
        {
            name: "deposit",
            accounts: [
                {
                    name: "userAuthority",
                    isMut: false,
                    isSigner: true,
                },
                {
                    name: "vaultAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "userCollateralAssetAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "userVaultOwnershipTokenAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "vaultCollateralAssetAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "vaultOwnershipTokenMint",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "tokenProgram",
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: "collateralAmount",
                    type: "u64",
                },
            ],
        },
        {
            name: "withdraw",
            accounts: [
                {
                    name: "userAuthority",
                    isMut: false,
                    isSigner: true,
                },
                {
                    name: "vaultAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "userCollateralAssetAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "userVaultOwnershipTokenAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "vaultCollateralAssetAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "feeTokenAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "vaultOwnershipTokenMint",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "tokenProgram",
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: "vaultTokenAmount",
                    type: "u64",
                },
            ],
        },
        {
            name: "initializeSerumOpenOrders",
            accounts: [
                {
                    name: "payer",
                    isMut: true,
                    isSigner: true,
                },
                {
                    name: "vaultAuthority",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "vaultAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "epochHistory",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "euroMeta",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "optionMint",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "openOrders",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "serumMarket",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "psyMarketAuthority",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "euroPrimitiveProgram",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "dexProgram",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "rent",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "systemProgram",
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [],
        },
        {
            name: "placeSerumOrder",
            accounts: [
                {
                    name: "taskerAuthority",
                    isMut: false,
                    isSigner: true,
                },
                {
                    name: "vaultAuthority",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "vaultAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "epochHistory",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "euroMeta",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "optionMint",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "optionTokenAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "eventQueue",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "requestQueue",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "bids",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "asks",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "coinVault",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "priceCurrencyVault",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "openOrders",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "serumMarket",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "euroPrimitiveProgram",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "dexProgram",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "rent",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "tokenProgram",
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: "limitPrice",
                    type: "u64",
                },
                {
                    name: "clientOrderId",
                    type: "u64",
                },
            ],
        },
        {
            name: "settleSerumOrder",
            accounts: [
                {
                    name: "vaultAuthority",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "vaultAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "vaultCollateralAssetAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "epochHistory",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "euroMeta",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "optionMint",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "optionTokenAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "coinVault",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "priceCurrencyVault",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "openOrders",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "serumMarket",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "serumVaultSigner",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "referralAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "stagingAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "euroPrimitiveProgram",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "dexProgram",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "tokenProgram",
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [],
        },
        {
            name: "cancelSerumOrder",
            accounts: [
                {
                    name: "taskerAuthority",
                    isMut: false,
                    isSigner: true,
                },
                {
                    name: "vaultAuthority",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "vaultAccount",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "epochHistory",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "euroMeta",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "optionMint",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "eventQueue",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "bids",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "asks",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "openOrders",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "serumMarket",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "euroPrimitiveProgram",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "dexProgram",
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: "clientOrderId",
                    type: "u64",
                },
            ],
        },
        {
            name: "otcSwapBidAsset",
            accounts: [
                {
                    name: "taskerAuthority",
                    isMut: false,
                    isSigner: true,
                },
                {
                    name: "vaultAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "vaultCollateralAssetAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "collateralAssetMint",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "auctionCurrencyMint",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "stagingAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "taskerPaymentAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "taskerDestinationAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "currentEpochHistory",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "oracle",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "tokenProgram",
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: "declaredPrice",
                    type: "u64",
                },
                {
                    name: "stagingAmountToTrade",
                    type: "u64",
                },
            ],
        },
        {
            name: "transferToDepositReceiptForStaking",
            accounts: [
                {
                    name: "userAuthority",
                    isMut: false,
                    isSigner: true,
                },
                {
                    name: "depositReceipt",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "vaultAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "userCollateralAssetAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "vaultCollateralAssetAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "stakingRecord",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "stakePool",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "tokenProgram",
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: "transferAmount",
                    type: "u64",
                },
                {
                    name: "lockupPeriod",
                    type: "u8",
                },
                {
                    name: "forStaking",
                    type: "bool",
                },
            ],
        },
        {
            name: "claimRewardForStaker",
            accounts: [
                {
                    name: "depositReceipt",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "vaultAccount",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "epochHistory",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "vaultOwnershipTokenMint",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "stakingRecord",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "stakePool",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "rewardPool",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "startRewardRecord",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "endRewardRecord",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "allocatedTokenAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "receivingTokenAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "stakingProgram",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "tokenProgram",
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [],
        },
        {
            name: "payoutDepositReceiptToStaking",
            accounts: [
                {
                    name: "feeReceiver",
                    isMut: true,
                    isSigner: true,
                },
                {
                    name: "depositReceipt",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "vaultAccount",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "vaultOwnershipTokenAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "vaultOwnershipTokenMint",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "epochHistory",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "receiptOwnerVaultTokenAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "stakingRecord",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "stakePool",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "stakingTokenAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "stakingProgram",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "tokenProgram",
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [],
        },
        {
            name: "createMetaplexMetadata",
            accounts: [
                {
                    name: "vaultOwnershipTokenMint",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "payer",
                    isMut: true,
                    isSigner: true,
                },
                {
                    name: "ownerAuthority",
                    isMut: false,
                    isSigner: true,
                },
                {
                    name: "vaultAccount",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "tokenMetadataProgram",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "metadata",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "systemProgram",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "tokenProgram",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "rent",
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: "title",
                    type: "string",
                },
                {
                    name: "symbol",
                    type: "string",
                },
                {
                    name: "uri",
                    type: "string",
                },
            ],
        },
    ],
    accounts: [
        {
            name: "VaultAccount",
            type: {
                kind: "struct",
                fields: [
                    {
                        name: "ownerAuthority",
                        type: "publicKey",
                    },
                    {
                        name: "managerAuthority",
                        type: "publicKey",
                    },
                    {
                        name: "taskerAuthority",
                        type: "publicKey",
                    },
                    {
                        name: "vaultCollateralAssetAccount",
                        type: "publicKey",
                    },
                    {
                        name: "withdrawalCollateralAssetAccount",
                        type: "publicKey",
                    },
                    {
                        name: "vaultOwnershipTokenAccount",
                        type: "publicKey",
                    },
                    {
                        name: "feeTokenAccount",
                        type: "publicKey",
                    },
                    {
                        name: "collateralAssetMint",
                        type: "publicKey",
                    },
                    {
                        name: "quoteAssetMint",
                        type: "publicKey",
                    },
                    {
                        name: "vaultOwnershipTokenMint",
                        type: "publicKey",
                    },
                    {
                        name: "oracle",
                        type: "publicKey",
                    },
                    {
                        name: "seedVaultTokenPerCollateral",
                        type: {
                            defined: "ExchangeRate",
                        },
                    },
                    {
                        name: "endingExchangeRateDecimals",
                        type: "u8",
                    },
                    {
                        name: "strategyType",
                        type: "u8",
                    },
                    {
                        name: "vaultAccountBump",
                        type: "u8",
                    },
                    {
                        name: "uniqueSeed",
                        type: "u16",
                    },
                    {
                        name: "maxDeposits",
                        type: "u64",
                    },
                    {
                        name: "fees",
                        type: {
                            defined: "VaultFees",
                        },
                    },
                    {
                        name: "currentEpoch",
                        type: "u64",
                    },
                    {
                        name: "currentEpochHistory",
                        type: "publicKey",
                    },
                    {
                        name: "pendingCollateralAssetDeposits",
                        type: "u64",
                    },
                    {
                        name: "pendingWithdrawalTokens",
                        type: "u64",
                    },
                    {
                        name: "optionsCollateralHeld",
                        type: "u64",
                    },
                    {
                        name: "optionsActive",
                        type: "bool",
                    },
                    {
                        name: "auctionCurrencyMint",
                        type: "publicKey",
                    },
                    {
                        name: "oracleProviderId",
                        type: "u8",
                    },
                    {
                        name: "vaultOwnershipTokenSupply",
                        type: "u64",
                    },
                    {
                        name: "vaultCollateralAssetAccountAmount",
                        type: "u64",
                    },
                    {
                        name: "currentOptionSaleAmount",
                        type: "u64",
                    },
                    {
                        name: "reserved1",
                        type: "u64",
                    },
                    {
                        name: "reserved2",
                        type: "u64",
                    },
                    {
                        name: "euroMetaCache",
                        type: {
                            array: [
                                {
                                    defined: "EuroMetaCache",
                                },
                                4,
                            ],
                        },
                    },
                ],
            },
        },
        {
            name: "EpochHistory",
            type: {
                kind: "struct",
                fields: [
                    {
                        name: "vaultAccount",
                        type: "publicKey",
                    },
                    {
                        name: "epoch",
                        type: "u64",
                    },
                    {
                        name: "epochHistoryBump",
                        type: "u8",
                    },
                    {
                        name: "optionMarketMetaVec",
                        type: {
                            vec: {
                                defined: "OptionMarketMeta",
                            },
                        },
                    },
                    {
                        name: "optionSaleAmount",
                        type: "u64",
                    },
                    {
                        name: "endingCollateralPerVaultToken",
                        type: {
                            defined: "ExchangeRate",
                        },
                    },
                ],
            },
        },
        {
            name: "DepositReceipt",
            type: {
                kind: "struct",
                fields: [
                    {
                        name: "vaultAccount",
                        type: "publicKey",
                    },
                    {
                        name: "epochHistory",
                        type: "publicKey",
                    },
                    {
                        name: "receiptOwner",
                        type: "publicKey",
                    },
                    {
                        name: "depositAmount",
                        type: "u64",
                    },
                    {
                        name: "bump",
                        type: "u8",
                    },
                    {
                        name: "lockupPeriod",
                        type: "u8",
                    },
                    {
                        name: "forStaking",
                        type: "bool",
                    },
                    {
                        name: "stakingRecord",
                        type: "publicKey",
                    },
                ],
            },
        },
        {
            name: "WithdrawalReceipt",
            type: {
                kind: "struct",
                fields: [
                    {
                        name: "vaultAccount",
                        type: "publicKey",
                    },
                    {
                        name: "epochHistory",
                        type: "publicKey",
                    },
                    {
                        name: "receiptOwner",
                        type: "publicKey",
                    },
                    {
                        name: "withdrawalAmount",
                        type: "u64",
                    },
                    {
                        name: "bump",
                        type: "u8",
                    },
                ],
            },
        },
        {
            name: "AccountAllowlist",
            type: {
                kind: "struct",
                fields: [
                    {
                        name: "allowlistType",
                        type: "u8",
                    },
                    {
                        name: "enforceAllowlist",
                        type: "bool",
                    },
                    {
                        name: "managerAuthority",
                        type: "publicKey",
                    },
                    {
                        name: "vaultAccount",
                        type: "publicKey",
                    },
                    {
                        name: "accounts",
                        type: {
                            vec: "publicKey",
                        },
                    },
                ],
            },
        },
    ],
    types: [
        {
            name: "EuroMetaCache",
            type: {
                kind: "struct",
                fields: [
                    {
                        name: "strikePrice",
                        type: "u64",
                    },
                    {
                        name: "strikePriceDecimals",
                        type: "u8",
                    },
                    {
                        name: "writerTokenAmount",
                        type: "u64",
                    },
                    {
                        name: "writerTokenDecimals",
                        type: "u8",
                    },
                    {
                        name: "optionTokenAmount",
                        type: "u64",
                    },
                    {
                        name: "optionTokenDecimals",
                        type: "u8",
                    },
                    {
                        name: "reserved1",
                        type: "u64",
                    },
                    {
                        name: "reserved2",
                        type: "u64",
                    },
                ],
            },
        },
        {
            name: "OptionMarketMeta",
            type: {
                kind: "struct",
                fields: [
                    {
                        name: "euroMeta",
                        type: "publicKey",
                    },
                    {
                        name: "optionSaleMarket",
                        type: {
                            defined: "OptionTokenSaleMarket",
                        },
                    },
                    {
                        name: "writerTokenAccount",
                        type: "publicKey",
                    },
                    {
                        name: "optionTokenAccount",
                        type: "publicKey",
                    },
                ],
            },
        },
        {
            name: "OptionTokenSaleMarket",
            type: {
                kind: "struct",
                fields: [
                    {
                        name: "isSaleEnabled",
                        type: "bool",
                    },
                    {
                        name: "collateralAssetPerOptionToken",
                        type: "u64",
                    },
                ],
            },
        },
        {
            name: "ExchangeRate",
            type: {
                kind: "struct",
                fields: [
                    {
                        name: "rate",
                        type: "u128",
                    },
                    {
                        name: "decimals",
                        type: "u8",
                    },
                ],
            },
        },
        {
            name: "VaultFees",
            type: {
                kind: "struct",
                fields: [
                    {
                        name: "managementFeeBps",
                        type: "u64",
                    },
                    {
                        name: "performanceFeeBps",
                        type: "u64",
                    },
                    {
                        name: "withdrawalFeeBps",
                        type: "u64",
                    },
                ],
            },
        },
    ],
    errors: [
        {
            code: 6000,
            name: "ReceiptAlreadyExchanged",
            msg: "This receipt has already been exchanged.",
        },
        {
            code: 6001,
            name: "LowUserBalance",
            msg: "Insufficient balance in user account for the collateral asset.",
        },
        {
            code: 6002,
            name: "LowVaultToken",
            msg: "Insufficient Vault Ownership Token",
        },
        {
            code: 6003,
            name: "MaxVaultCapacity",
            msg: "Maximum Vault Capacity has been reached",
        },
        {
            code: 6004,
            name: "DepositingNotSupported",
            msg: "Depositing when options are active is not supported.",
        },
        {
            code: 6005,
            name: "WithdrawingNotSupported",
            msg: "Withdrawing when options are active is not supported.",
        },
        {
            code: 6006,
            name: "DepositReceiptNotSupported",
            msg: "Please deposit directly into vault when options are not active.",
        },
        {
            code: 6007,
            name: "WithdrawalReceiptNotSupported",
            msg: "Please withdraw directly from vault when options are not active.",
        },
        {
            code: 6008,
            name: "SaleNotEnabled",
            msg: "The sale is currently not enabled. Please contact the administrators if you think that this is wrong.",
        },
        {
            code: 6009,
            name: "InsufficientAmountForSale",
            msg: "There is insufficient amount for sale to meet the order size.",
        },
        {
            code: 6010,
            name: "IncorrectOptionSalePrice",
            msg: "Price to pay per option token does not match the price set.",
        },
        {
            code: 6011,
            name: "MaximumPriceExceeded",
            msg: "Cost of quote asset exceeds max paying price set.",
        },
        {
            code: 6012,
            name: "MaximumSlippageExceeded",
            msg: "Maximum slippage exceeded.",
        },
        {
            code: 6013,
            name: "MaximumFeesExceeded",
            msg: "Maximum configurable fees exceeded.",
        },
        {
            code: 6014,
            name: "InvalidTokenBalance",
            msg: "Final token balance does not match expected.",
        },
        {
            code: 6015,
            name: "AccountIsNotInAllowList",
            msg: "Purchase is not allowed as account is not in the allowlist.",
        },
        {
            code: 6016,
            name: "OptionsHaveNotExpire",
            msg: "Closing market is not allowed yet as options have not expire.",
        },
        {
            code: 6017,
            name: "InsufficientAmountInDepositReceipt",
            msg: "Insufficient amount in Deposit Receipt for instruction.",
        },
        {
            code: 6018,
            name: "InsufficientAmountInWithdrawalReceipt",
            msg: "Insufficient amount in Withdrawal Receipt for instruction.",
        },
        {
            code: 6019,
            name: "OptionsNotActive",
            msg: "Option Market has not yet started.",
        },
        {
            code: 6020,
            name: "WriterAndOptionTokenNotMatch",
            msg: "Writer and Option Tokens amount do not match.",
        },
        {
            code: 6021,
            name: "OptionMarketInvalid",
            msg: "Option Market violates account constraints.",
        },
        {
            code: 6022,
            name: "OptionMarketMetaInvalidLength",
            msg: "Invalid vector length for OptionMarketMeta.",
        },
        {
            code: 6023,
            name: "IndexOutOfRange",
            msg: "Index out of range error.",
        },
        {
            code: 6024,
            name: "InsufficientCollateral",
            msg: "Insufficient collateral for options mint.",
        },
        {
            code: 6025,
            name: "PnlCalculationError",
            msg: "PNL Calculation Error.",
        },
        {
            code: 6026,
            name: "PayoutPendingEpochEnd",
            msg: "Receipt can only be paid out after the epoch has ended.",
        },
        {
            code: 6027,
            name: "EpochHistoryConstraint",
            msg: "EpochHistory constraint error.",
        },
        {
            code: 6028,
            name: "UserCollateralConstraint",
            msg: "User collateral asset account constraint error.",
        },
        {
            code: 6029,
            name: "UserVaultTokenConstraint",
            msg: "User vault token account constraint error.",
        },
        {
            code: 6030,
            name: "WithdrawalCollateralConstraint",
            msg: "Withdrawal collateral asset account constraint error.",
        },
        {
            code: 6031,
            name: "VaultCollateralConstraint",
            msg: "Vault collateral asset account constraint error.",
        },
        {
            code: 6032,
            name: "VaultTokenAccountConstraint",
            msg: "Vault's vault token account constraint error.",
        },
        {
            code: 6033,
            name: "OptionTokenConstraint",
            msg: "Option token account constraint error.",
        },
        {
            code: 6034,
            name: "WriterTokenConstraint",
            msg: "Writer token account constraint error.",
        },
        {
            code: 6035,
            name: "DepositReceiptConstraint",
            msg: "Deposit receipt constraint error.",
        },
        {
            code: 6036,
            name: "WithdrawalReceiptConstraint",
            msg: "Withdrawal receipt constraint error.",
        },
        {
            code: 6037,
            name: "FeeTokenAccountConstraint",
            msg: "Fee token account constraint error.",
        },
        {
            code: 6038,
            name: "EuroMetaConstraint",
            msg: "EuroMeta constraint error.",
        },
        {
            code: 6039,
            name: "UnsupportedStrategy",
            msg: "Unsuported Strategy.",
        },
        {
            code: 6040,
            name: "EuroProgramMismatch",
            msg: "Euro Primitive Program Id mismatch.",
        },
        {
            code: 6041,
            name: "DexMismatch",
            msg: "Serum DEX Program Id mismatch.",
        },
        {
            code: 6042,
            name: "OptionsAlreadyMinted",
            msg: "Options are already minted.",
        },
        {
            code: 6043,
            name: "AmountMustBeGreaterThanZero",
            msg: "Amount must be greater than 0.",
        },
        {
            code: 6044,
            name: "BpsLimitExceeded",
            msg: "Bps cannot exceed 10000",
        },
        {
            code: 6045,
            name: "PayoutForStaking",
            msg: "Cannot payout receipt that is set for staking.",
        },
        {
            code: 6046,
            name: "ReceiptNotForStaking",
            msg: "Cannot stake or claim reward for receipt, when receipt is not for staking.",
        },
        {
            code: 6047,
            name: "OwnerMismatch",
            msg: "Owner of staking record and receipt does not match.",
        },
        {
            code: 6048,
            name: "StakePoolMismatch",
            msg: "StakePool does not match.",
        },
        {
            code: 6049,
            name: "StakingRecordMismatch",
            msg: "StakingRecord does not match.",
        },
        {
            code: 6050,
            name: "InvalidLockupPeriod",
            msg: "Invalid lockup period selected.",
        },
        {
            code: 6051,
            name: "UnclaimedRewardPool",
            msg: "Some RewardPool is unclaimed.",
        },
        {
            code: 6052,
            name: "ClaimRewardPendingEpochEnd",
            msg: "Reward can only be claimed for DepositReceipt after epoch ends.",
        },
        {
            code: 6053,
            name: "MarketStateError",
            msg: "Error loading Serum market state.",
        },
        {
            code: 6054,
            name: "AuctionMintMismatch",
            msg: "The mint specified for the auction currency doesn't match the vault.",
        },
        {
            code: 6055,
            name: "TaskerSignerError",
            msg: "Tasker did not sign this transaction.",
        },
        {
            code: 6056,
            name: "TaskerValidationError",
            msg: "Account specified as tasker is not the authorized tasker on this vault.",
        },
        {
            code: 6057,
            name: "TaskerCollateralAccountValidationError",
            msg: "Collateral destination does not match vault's collateral account.",
        },
        {
            code: 6058,
            name: "EpochHistoryValidationError",
            msg: "Account specified as epoch history is not the epoch history on this vault.",
        },
        {
            code: 6059,
            name: "OracleConfidenceError",
            msg: "Pyth Oracle confidence too low to price accurately, try again later.",
        },
        {
            code: 6060,
            name: "OracleResponseIssue",
            msg: "Pyth Oracle responding with zero or negative price.",
        },
        {
            code: 6061,
            name: "OracleExponentIssue",
            msg: "Pyth Oracle esponding with non-negative exponent.",
        },
        {
            code: 6062,
            name: "OracleValidationError",
            msg: "Oracle doesn't match vault Oracle.",
        },
        {
            code: 6063,
            name: "TaskerMintMismatch",
            msg: "The mint used for tasker's payment doesn't match the collateral pool.",
        },
        {
            code: 6064,
            name: "TokenOwnerMismatch",
            msg: "Invalid owner of token account.",
        },
        {
            code: 6065,
            name: "TaskerNotEnoughAssets",
            msg: "Tasker is not bringing enough underlying assets, offer more assets.",
        },
        {
            code: 6066,
            name: "TaskerDeclaredPriceTooLow",
            msg: "Tasker's declared price is too low: offer a better exchange rate.",
        },
        {
            code: 6067,
            name: "TaskerDeclaredPriceTooHigh",
            msg: "Tasker's declared price is too high: check for typo.",
        },
        {
            code: 6068,
            name: "StagingAccountEmpty",
            msg: "The staging account has no assets: perhaps the auction has not ended?",
        },
        {
            code: 6069,
            name: "NumericalOverflow",
            msg: "Numerical Overflow",
        },
        {
            code: 6070,
            name: "OptionWriterMismatchError",
            msg: "Option and Writer token size mismatch.",
        },
        {
            code: 6071,
            name: "InvalidNativeMint",
            msg: "Invalid native mint provided",
        },
        {
            code: 6072,
            name: "InvalidReceiptOwner",
            msg: "Receipt owner provided does not match owner recorded",
        },
        {
            code: 6073,
            name: "OracleNotSupported",
            msg: "Instruction is not supported by oracle type.",
        },
    ],
};

const dexDevnetProgramKey = new web3_js.PublicKey("DESVgJVGajEgKGXhb6XmqDHGz3VjdgP7rEVESBgxmroY");
const dexMainnetProgramKey = new web3_js.PublicKey("9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin");
const euroPrimitiveProgramKey = new web3_js.PublicKey("FASQhaZQT53W9eT9wWnPoBFw8xzZDey9TbMmJj6jCQTs");

exports.PsyFiIdl = PsyFiIdl;
exports.dexDevnetProgramKey = dexDevnetProgramKey;
exports.dexMainnetProgramKey = dexMainnetProgramKey;
exports.euroPrimitiveProgramKey = euroPrimitiveProgramKey;
exports.instructions = index;
exports.pdas = pdas;
