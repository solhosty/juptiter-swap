"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenUtil = void 0;
const spl_token_1 = require("@solana/spl-token");
const web3_js_1 = require("@solana/web3.js");
const tiny_invariant_1 = __importDefault(require("tiny-invariant"));
const math_1 = require("../math");
const web3_1 = require("../web3");
/**
 * @category Util
 */
class TokenUtil {
    static isNativeMint(mint) {
        return mint.equals(spl_token_1.NATIVE_MINT);
    }
    /**
     * Create an ix to send a spl-token / native-mint to another wallet.
     * This function will handle the associated token accounts internally for spl-token.
     * SOL is sent directly to the user's wallet.
     *
     * @param connection - Connection object
     * @param sourceWallet - PublicKey for the sender's wallet
     * @param destinationWallet - PublicKey for the receiver's wallet
     * @param tokenMint - Mint for the token that is being sent.
     * @param tokenDecimals - Decimal for the token that is being sent.
     * @param amount - Amount of token to send
     * @param getAccountRentExempt - Fn to fetch the account rent exempt value
     * @param payer - PublicKey for the payer that would fund the possibly new token-accounts. (must sign the txn)
     * @returns
     */
    static createSendTokensToWalletInstruction(connection, sourceWallet, destinationWallet, tokenMint, tokenDecimals, amount, getAccountRentExempt, payer) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, tiny_invariant_1.default)(!amount.eq(math_1.ZERO), "SendToken transaction must send more than 0 tokens.");
            // Specifically handle SOL, which is not a spl-token.
            if (tokenMint.equals(spl_token_1.NATIVE_MINT)) {
                const sendSolTxn = web3_js_1.SystemProgram.transfer({
                    fromPubkey: sourceWallet,
                    toPubkey: destinationWallet,
                    lamports: BigInt(amount.toString()),
                });
                return {
                    instructions: [sendSolTxn],
                    cleanupInstructions: [],
                    signers: [],
                };
            }
            const sourceTokenAccount = yield (0, web3_1.deriveATA)(sourceWallet, tokenMint);
            const _a = yield (0, web3_1.resolveOrCreateATA)(connection, destinationWallet, tokenMint, getAccountRentExempt, amount, payer), { address: destinationTokenAccount } = _a, destinationAtaIx = __rest(_a, ["address"]);
            const transferIx = spl_token_1.Token.createTransferCheckedInstruction(spl_token_1.TOKEN_PROGRAM_ID, sourceTokenAccount, tokenMint, destinationTokenAccount, sourceWallet, [], new spl_token_1.u64(amount.toString()), tokenDecimals);
            return {
                instructions: destinationAtaIx.instructions.concat(transferIx),
                cleanupInstructions: destinationAtaIx.cleanupInstructions,
                signers: destinationAtaIx.signers,
            };
        });
    }
}
exports.TokenUtil = TokenUtil;
TokenUtil.deserializeTokenAccount = (data) => {
    if (!data) {
        return null;
    }
    if (data.byteLength !== spl_token_1.AccountLayout.span) {
        throw new Error("Invalid data length for TokenAccount");
    }
    const accountInfo = spl_token_1.AccountLayout.decode(data);
    accountInfo.mint = new web3_js_1.PublicKey(accountInfo.mint);
    accountInfo.owner = new web3_js_1.PublicKey(accountInfo.owner);
    accountInfo.amount = spl_token_1.u64.fromBuffer(accountInfo.amount);
    if (accountInfo.delegateOption === 0) {
        accountInfo.delegate = null;
        accountInfo.delegatedAmount = new spl_token_1.u64(0);
    }
    else {
        accountInfo.delegate = new web3_js_1.PublicKey(accountInfo.delegate);
        accountInfo.delegatedAmount = spl_token_1.u64.fromBuffer(accountInfo.delegatedAmount);
    }
    accountInfo.isInitialized = accountInfo.state !== 0;
    accountInfo.isFrozen = accountInfo.state === 2;
    if (accountInfo.isNativeOption === 1) {
        accountInfo.rentExemptReserve = spl_token_1.u64.fromBuffer(accountInfo.isNative);
        accountInfo.isNative = true;
    }
    else {
        accountInfo.rentExemptReserve = null;
        accountInfo.isNative = false;
    }
    if (accountInfo.closeAuthorityOption === 0) {
        accountInfo.closeAuthority = null;
    }
    else {
        accountInfo.closeAuthority = new web3_js_1.PublicKey(accountInfo.closeAuthority);
    }
    return accountInfo;
};
