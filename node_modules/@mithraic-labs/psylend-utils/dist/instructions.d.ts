import { Program, BN } from "@project-serum/anchor";
import { PublicKey } from "@solana/web3.js";
import { reserveBumpSeeds, reserveAccounts } from "./pdas";
import { Amount, DepositCollateralBumpSeeds, ReserveConfig, WithdrawCollateralBumpSeeds } from "./types";
import { Psylend as PsyLend } from "./idl";
/**
 * Accrues interest for a reserve. Updates the NOTE cache and DATA cache
 * Has to be updated within `TTL` slots from other instructions reading from `cached_note`
 * or cached `ReserveData`
 *
 * As of Aug 2022, TTL is 100 in devnet/localnet, 5 for mainnet
 * @param program
 * @param market - market the reserve is under
 * @param marketAuthority
 * @param reserve
 * @param feeNoteVault - can be extracted from `reserve`
 * @param depositNoteMint - can be extracted from `reserve`
 * @returns
 */
export declare const accrueInterestIx: (program: Program<PsyLend>, market: PublicKey, marketAuthority: PublicKey, reserve: PublicKey, feeNoteVault: PublicKey, depositNoteMint: PublicKey) => Promise<import("@solana/web3.js").TransactionInstruction>;
/**
 * Borrows funds against a user's collateral. Requires a general refresh of all reserves the user
 * has borrowed or used as collateral (use: {@link refreshEitherReserveIx}).
 *
 * Loan account must be initialized (see {@link initLoanIx} or {@link getOrInitLoanAccount})
 * @param program
 * @param bump - bump for loan account
 * @param amount - to borrow,
 * @param market - market for the given reserve
 * @param marketAuthority
 * @param reserve - reserve to be borrowed from
 * @param obligation - derived with `deriveUserObligation`, initialized with `initObligationIx`
 * @param vault - can be extracted from `reserve`
 * @param loanNoteMint - can be extracted from `reserve`
 * @param userAddress - typically the user's wallet
 * @param loanAccount - derived with `deriveClientReserveAccounts`, initialized with `initLoanIx`
 * @param receiver - receiver account: borrowed tokens will be transferred here.
 * @returns
 */
export declare const borrowIx: (program: Program<PsyLend>, bump: number, amount: Amount, market: PublicKey, marketAuthority: PublicKey, reserve: PublicKey, obligation: PublicKey, vault: PublicKey, loanNoteMint: PublicKey, userAddress: PublicKey, loanAccount: PublicKey, receiver: PublicKey) => Promise<import("@solana/web3.js").TransactionInstruction>;
/**
 * Deposits a user's tokens into a reserve.
 *
 * Only the reserve being deposited into needs to be
 * refreshed, a general refresh of all reserves is NOT needed to deposit. Only the NOTE cache needs
 * to be up-to-date (updated with {@link accrueInterestIx})
 * @param program
 * @param bump - bump for the deposit account
 * @param amount - Specifies units and amount to transfer
 * @param market - market this reserve will be under
 * @param marketAuthority
 * @param depositSource - tokens come from this account
 * @param depositAccount - deposit account, a PDA that can be derived with
 * `deriveClientReserveAccounts`. Deposit notes will transfer here
 * @param userAddress - owns the deposit source, typically users's wallet
 * @param reserve - Deposit target, must be same currency as depositSource
 * @param vault - can be extracted from `reserve`
 * @param depositNoteMint - can be extracted from `reserve`
 * @returns
 */
export declare const depositIx: (program: Program<PsyLend>, bump: number, amount: Amount, market: PublicKey, marketAuthority: PublicKey, depositSource: PublicKey, depositAccount: PublicKey, userAddress: PublicKey, reserve: PublicKey, vault: PublicKey, depositNoteMint: PublicKey) => Promise<import("@solana/web3.js").TransactionInstruction>;
/**
 * Works exactly the same as {@link deposit}, except that the `depositAccount` may be any account,
 * and does not have to be a PDA owned by this program.
 *
 * Use this IX only when the user wants to transfer deposit notes outside of the program. A user may
 * wish to do this in order to stake these notes or trade them externally.
 * @param program
 * @param amount
 * @param market
 * @param marketAuthority
 * @param depositSource
 * @param depositAccount - typically an ATA created `createAssociatedTokenAccountInstruction`, using
 * the reserve's depositNoteMint. Any account that can hold deposit notes is acceptable.
 * @param userAddress
 * @param reserve
 * @param vault
 * @param depositNoteMint
 * @returns
 */
export declare const depositTokensIx: (program: Program<PsyLend>, amount: Amount, market: PublicKey, marketAuthority: PublicKey, depositSource: PublicKey, depositAccount: PublicKey, userAddress: PublicKey, reserve: PublicKey, vault: PublicKey, depositNoteMint: PublicKey) => Promise<import("@solana/web3.js").TransactionInstruction>;
/**
 * Used to transfer funds from the deposit account to the collateral account, where are they able to
 * used for borrowing. Deposit, Collateral and Obligation accounts should have been initalized.
 *
 * Only the reserve being deposited into needs to be
 * refreshed, a general refresh of all reserves is NOT needed to deposit. Only the NOTE cache needs
 * to be up-to-date (updated with {@link accrueInterestIx})
 * @param program
 * @param bumps - derived with `deriveClientReserveAccounts`
 * @param amount - to transfer from deposit to collateral
 * @param market - market for this reserve
 * @param marketAuthority
 * @param obligation - derived with `deriveUserObligation`, initialized with `initObligationIx`
 * @param depositAccount - derived with `deriveClientReserveAccounts`, initialized with `initDepositAccountIx`
 * @param collateralAccount - derived with `deriveClientReserveAccounts`, initialized with `initCollateralIx`
 * @param userAddress - typically the user's wallet
 * @param reserve - collateral accounts are reserve-specific
 * @returns
 */
export declare const depositCollateralIx: (program: Program<PsyLend>, bumps: DepositCollateralBumpSeeds, amount: Amount, market: PublicKey, marketAuthority: PublicKey, obligation: PublicKey, depositAccount: PublicKey, collateralAccount: PublicKey, userAddress: PublicKey, reserve: PublicKey) => Promise<import("@solana/web3.js").TransactionInstruction>;
/**
 * How many rates the Discounts account holds.
 *
 * Mirrors value in discounts.rs
 */
export declare const MAX_DISCOUNT_RATES = 20;
/**
 * Initializes the discounts account, which tracks which tokens are valued at less than their face
 * value for collateral and liquidation purposes.
 *
 * Generally, you should run {@link syncDiscountRates} for any reserve that uses the tokens for
 * which rates were changed.
 * @param program
 * @param authority - signs any future updates to this account
 * @param payer
 * @param discounts
 * @param mintAddresses - addresses of token mints that will be discounted. Array must be of
 * size `MAX_DISCOUNT_RATES`, unused slots can be filled with default key.
 * @param discountRates - for each mint, discount, expressed as a % multiplied by the common
 * rates/bps denominator of 10,000, e.g. 5% = .05 * 10,000 = 500. Array must be of
 * size `MAX_DISCOUNT_RATES`, unused slots can be filled with 0
 * @returns
 */
export declare const initDiscountsIx: (program: Program<PsyLend>, authority: PublicKey, payer: PublicKey, discounts: PublicKey, mintAddresses: PublicKey[], discountRates: number[]) => Promise<import("@solana/web3.js").TransactionInstruction>;
/**
 * Updates the discounts account, which tracks which tokens are valued at less than their face
 * value for collateral and liquidation purposes.
 *
 * Generally, you should run {@link syncDiscountRates} for any reserve that uses the tokens for
 * which rates were changed.
 * @param program
 * @param authority - whoever created the account with `initDiscountsIx` and is authorized to update.
 * @param discounts
 * @param mintAddresses - addresses of token mints that will be discounted. Array must be of
 * size `MAX_DISCOUNT_RATES`, unused slots can be filled with default key.
 * @param discountRates - for each mint, discount, expressed as a % multiplied by the common
 * rates/bps denominator of 10,000, e.g. 5% = .05 * 10,000 = 500. Array must be of
 * size `MAX_DISCOUNT_RATES`, unused slots can be filled with 0
 * @returns
 */
export declare const updateDiscountsIx: (program: Program<PsyLend>, authority: PublicKey, discounts: PublicKey, mintAddresses: PublicKey[], discountRates: number[]) => Promise<import("@solana/web3.js").TransactionInstruction>;
/**
 * Iniitalizes a market. You may wish to initialize the market
 * by creating the account (with the System program)
 * @param program
 * @param owner
 * @param quoteCurrencyName
 * @param quoteCurrencyMint
 * @param market - also is the signer of the IX
 * @returns
 */
export declare const initMarketIx: (program: Program<PsyLend>, owner: PublicKey, quoteCurrencyMint: PublicKey, quoteCurrencyName: string, market: PublicKey) => Promise<import("@solana/web3.js").TransactionInstruction>;
/**
 * Iniitalizes a reserve for some currency. Add optional psyfi vault arguments to intialize a
 * psyfi reserve that trades on vault tokens, or use {@link initPsyfiReserveIx}.
 *
 * You may wish to initialize the reserve by creating the account (with the System program)
 *
 * Note: for usdc, the quotetokenmint and tokenmint are probably the same (usdc)
 * @param program
 * @param bumpSeeds - for derived pdas in `reserveAccounts`
 * @param reserveConfig
 * @param market - market this reserve will be under
 * @param marketAuthority - market authority
 * @param owner
 * @param payer
 * @param pythOracleProduct - product quote currency must match quote currency of market
 * @param pythOraclePrice
 * @param reserve - should be initialized to the correct size
 * @param reserveAccounts - derive these pdas, but do not initialize them
 * @param dexMarket
 * @param quoteTokenMint - quote token of the market, generally usdc
 * @param tokenMint - mint for the currency this reserve tracks
 * @param isDevnet - true if testing on devnet, false for mainnet, used to pick the dex id
 * @param optional - { psyfiVaultAccount, collateralAssetMint}
 *
 * @returns
 */
export declare const initReserveIx: (program: Program<PsyLend>, bumpSeeds: reserveBumpSeeds, reserveConfig: ReserveConfig, market: PublicKey, marketAuthority: PublicKey, owner: PublicKey, payer: PublicKey, pythOracleProduct: PublicKey, pythOraclePrice: PublicKey, reserve: PublicKey, reserveAccounts: reserveAccounts, dexMarket: PublicKey, quoteTokenMint: PublicKey, tokenMint: PublicKey, isDevnet: boolean, optional?: {
    psyfiVaultAccount: PublicKey;
    collateralAssetMint: PublicKey;
}) => Promise<import("@solana/web3.js").TransactionInstruction>;
/**
 * Iniitalizes a reserve that tracks a Psyfi vault token.
 * See {@link initReserveIx} for assets that are not vault tokens.
 * You may wish to initialize the reserve by creating the account (with the System program)
 *
 * Note: for usdc, the quotetokenmint and tokenmint are probably the same (usdc)
 * @param program
 * @param bumpSeeds - for derived pdas in `reserveAccounts`
 * @param reserveConfig
 * @param market - market this reserve will be under
 * @param marketAuthority - market authority
 * @param owner
 * @param payer
 * @param pythOracleProduct - product quote currency must match quote currency of market
 * @param pythOraclePrice
 * @param reserve - should be initialized to the correct size
 * @param reserveAccounts - derive these pdas, but do not initialize them
 * @param dexMarket
 * @param quoteTokenMint - quote token of the market, generally usdc
 * @param tokenMint - mint for the currency this reserve tracks
 * @param psyfiVault - vault that issues ownership tokens this reserve tracks
 * @param psyfiCollateralMint - collateral mint used by vault
 * @param isDevnet - true if testing on devnet, false for local, used to get the dex id
 * @returns
 */
export declare const initPsyfiReserveIx: (program: Program<PsyLend>, bumpSeeds: reserveBumpSeeds, reserveConfig: ReserveConfig, market: PublicKey, marketAuthority: PublicKey, owner: PublicKey, payer: PublicKey, pythOracleProduct: PublicKey, pythOraclePrice: PublicKey, reserve: PublicKey, reserveAccounts: reserveAccounts, dexMarket: PublicKey, quoteTokenMint: PublicKey, tokenMint: PublicKey, psyfiVault: PublicKey, psyfiCollateralMint: PublicKey, isDevnet: boolean) => Promise<import("@solana/web3.js").TransactionInstruction>;
/**
 * Creates a deposit account for the given user
 * @param program
 * @param bump
 * @param market - market the reserve is under
 * @param marketAuthority
 * @param reserve - a deposit account is reserve-specific: make a new account per reserve
 * @param depositNoteMint - can be extracted from `reserve`
 * @param userAddress - generally the user's wallet
 * @param depositAccount - the account to be created: a PDA that can be derived with `deriveClientReserveAccounts`
 * @returns
 */
export declare const initDepositAccountIx: (program: Program<PsyLend>, bump: number, market: PublicKey, marketAuthority: PublicKey, reserve: PublicKey, depositNoteMint: PublicKey, userAddress: PublicKey, depositAccount: PublicKey) => Promise<import("@solana/web3.js").TransactionInstruction>;
/**
 * Initializes the obligation account for a user on the given market. This must be done before any
 * collateral can be deposited with `deposit_collateral`.
 * @param program
 * @param bump - derived with `deriveUserObligation`
 * @param market - market for this obligation
 * @param marketAuthority
 * @param obligation - derived with `deriveUserObligation`
 * @param userAddress - the borrower's address, typically the user's wallet
 * @returns
 */
export declare const initObligationIx: (program: Program<PsyLend>, bump: number, market: PublicKey, marketAuthority: PublicKey, obligation: PublicKey, userAddress: PublicKey) => Promise<import("@solana/web3.js").TransactionInstruction>;
/**
 * Initiailizes a collateral account for a user. Collateral accounts are specific to a single
 * reserve. The obligation for this user should have been initialized already with {@link initObligationIx}
 * @param program
 * @param bump - derived with `deriveClientReserveAccounts`.
 * @param market - market for the reserve and obligation
 * @param marketAuthority
 * @param reserve - collateral accounts are reserve-specific
 * @param depositNoteMint - can be extracted from `reserve`
 * @param userAddress - typically the user's wallet
 * @param obligation - derived with `deriveUserObligation`
 * @param collateralAccount - derived with `deriveClientReserveAccounts`. Deposit notes used as
 * collateral will be held here
 * @returns
 */
export declare const initCollateralIx: (program: Program<PsyLend>, bump: number, market: PublicKey, marketAuthority: PublicKey, reserve: PublicKey, depositNoteMint: PublicKey, userAddress: PublicKey, obligation: PublicKey, collateralAccount: PublicKey) => Promise<import("@solana/web3.js").TransactionInstruction>;
/**
 * Initiailizes a loan account for a user. Loan accounts are specific to a single
 * reserve. The obligation for this user should have been initialized already with {@link initObligationIx}
 * @param program
 * @param bump - derived with `deriveClientReserveAccounts`.
 * @param market - market for the reserve and obligation
 * @param marketAuthority
 * @param reserve - loan accounts are reserve-specific
 * @param loanNoteMint - can be extracted from `reserve`
 * @param userAddress - typically the user's wallet
 * @param obligation - derived with `deriveUserObligation`
 * @param loanAccount - derived with `deriveClientReserveAccounts`.
 * @returns
 */
export declare const initLoanIx: (program: Program<PsyLend>, bump: number, market: PublicKey, marketAuthority: PublicKey, reserve: PublicKey, loanNoteMint: PublicKey, userAddress: PublicKey, obligation: PublicKey, loanAccount: PublicKey) => Promise<import("@solana/web3.js").TransactionInstruction>;
/**
 * A liquidator calls this instruction on a user whose obligation is underwater to seize a portion of
 * their collateral and repay a portion of their loan.
 * @param program
 * @param amount - amount being repaid (in tokens or loan notes)
 * @param minCollateral - min collateral to accept (in deposit notes)
 * @param market - market for all reserves involved
 * @param marketAuthority - market authority
 * @param userObligation - user's obligation whose loan is repaid for. Must be unhealthy
 * @param reserve - the reserve with the DEBT borrowed (hereafter called `reserve`)
 * @param collateralReserve - the reserve with collateral to seize (hereafter called `collateralReserve`)
 * @param vault - `reserve` vault (TODO does nothing?)
 * @param loanNoteMint - mint for debt/loan notes on `reserve`
 * @param loanAccount - users's loan account on `reserve`
 * @param collateralAccount - user's collateral acc on `collateralReserve`
 * @param payerAccount - The liquidator's token account for the asset being repaid
 * @param receiverAccount -- Account receiving liquidated collateral. Typically owned by the liquidator.
 * Note that this must be a collateral account on the same reserve. The collateral being liquidated is
 * stored as *deposit notes* in the collateral account, not the actual collateral token
 * @param payer - signs tx, owns the payer account
 * @param receiverObligation - receiver's obligation
 * @returns
 */
export declare const liquidateIx: (program: Program<PsyLend>, amount: Amount, minCollateral: BN, market: PublicKey, marketAuthority: PublicKey, userObligation: PublicKey, reserve: PublicKey, collateralReserve: PublicKey, vault: PublicKey, loanNoteMint: PublicKey, loanAccount: PublicKey, collateralAccount: PublicKey, payerAccount: PublicKey, receiverAccount: PublicKey, payer: PublicKey, receiverObligation: PublicKey) => Promise<import("@solana/web3.js").TransactionInstruction>;
/**
 * Updates various reserve properties. Updates the INFO cache.
 * Must be invoked first, in the same tx, as most transactions that read the status of a reserve.
 *
 * For reserves backed by a vault, use {@link refreshPsyfiReserveIx} instead
 * @param program
 * @param market - market the reserve is under
 * @param reserve
 * @param pythOraclePrice - can be extracted from `reserve`
 * @returns
 */
export declare const refreshReserveIx: (program: Program<PsyLend>, market: PublicKey, reserve: PublicKey, pythOraclePrice: PublicKey) => Promise<import("@solana/web3.js").TransactionInstruction>;
/**
 * Updates various reserve properties. Updates the INFO cache.
 * Must be invoked first, in the same tx, as most transactions that read the status of a reserve.
 *
 * For reserves backed by currency that is not a vault token, use {@link refreshReserveIx} instead
 * @param program
 * @param market - market the reserve is under
 * @param reserve
 * @param vaultAccount - the vault that the ownership tokens for this reserve come from
 * @param pythOraclePrice - can be extracted from `reserve`
 * @returns
 */
export declare const refreshPsyfiReserveIx: (program: Program<PsyLend>, market: PublicKey, reserve: PublicKey, vaultAccount: PublicKey, pythOraclePrice: PublicKey) => Promise<import("@solana/web3.js").TransactionInstruction>;
/**
 * Updates various reserve properties. Updates the INFO cache.
 * Must be invoked first, in the same tx, as most transactions that read the status of a reserve.
 *
 * Executes {@link refreshReserveIx} or {@link refreshPsyfiReserveIx} instead if a
 * `psyfiVaultAccount` is provided
 * @param program
 * @param market - market the reserve is under
 * @param reserve
 * @param pythOraclePrice - can be extracted from `reserve`
 * @param psyfiVaultAccount - optional. If provided, uses `refreshPsyfiReserve` Ix.
 * @returns
 */
export declare const refreshEitherReserveIx: (program: Program<PsyLend>, market: PublicKey, reserve: PublicKey, pythOraclePrice: PublicKey, psyfiVaultAccount?: PublicKey) => Promise<import("@solana/web3.js").TransactionInstruction>;
/**
 * Repays a borrowed debt. Requires a general refresh of all reserves the user
 * has borrowed or used as collateral (use: {@link refreshEitherReserveIx}).
 * @param program
 * @param amount - to repay (deducts balance from loan account)
 * @param market - market the reserve is under
 * @param marketAuthority
 * @param userAddress - typically the user's wallet, owns the payer account
 * @param reserve
 * @param vault - can be extracted from `reserve`
 * @param obligation - derived with `deriveUserObligation`
 * @param loanNoteMint - can be extracted from `reserve`
 * @param loanAccount - derived with `deriveClientReserveAccounts`
 * @param payerAccount - user's payment account, tokens will be transferred from here
 * @returns
 */
export declare const repayIx: (program: Program<PsyLend>, amount: Amount, market: PublicKey, marketAuthority: PublicKey, userAddress: PublicKey, reserve: PublicKey, vault: PublicKey, obligation: PublicKey, loanNoteMint: PublicKey, loanAccount: PublicKey, payerAccount: PublicKey) => Promise<import("@solana/web3.js").TransactionInstruction>;
/**
 * Modifies a market to halt borrows, repays, or deposits
 * @param program
 * @param flags - use `MarketFlags` to generate
 * @param market - market to modify
 * @param owner - market owner, should sign
 * @returns
 */
export declare const setMarketFlagsIx: (program: Program<PsyLend>, flags: BN, market: PublicKey, owner: PublicKey) => Promise<import("@solana/web3.js").TransactionInstruction>;
/**
 * Orders a reserve to update its discount rate from the common discounts account that all rates are
 * stored in. Should run after {@link updateDiscountsIx} for each reserve that uses a token that had
 * its rate updated.
 *
 * If the reserve's `discount_rate_version` is less than or equal to the current
 * `discounts.version`, does nothing. If the discounts account no longer features a rate for the
 * token the reserve tracks, resets the rate to the default and resets the version to 0.
 *
 * This is a permissionless instruction.
 * @param program
 * @param reserve
 * @returns
 */
export declare const syncDiscountRates: (program: Program<PsyLend>, reserve: PublicKey) => Promise<import("@solana/web3.js").TransactionInstruction>;
/**
 * Modifies the reserve to use the specified configuration settings. Can update borrow rates,
 * interest, origination fees, etc.
 * @param program
 * @param config - a `ReserveConfig` struct
 * @param market - market the reserve is under
 * @param reserve
 * @param owner - market owner
 * @returns
 */
export declare const updateReserveConfigIx: (program: Program<PsyLend>, config: ReserveConfig, market: PublicKey, reserve: PublicKey, owner: PublicKey) => Promise<import("@solana/web3.js").TransactionInstruction>;
/**
 * Halts or resumes borrows, repays, deposits, or withdraws on this reserve.
 * @param program
 * @param halts - 0 = resume all, 1 = halt deposits, 2 = halt borrows, 4 = halt repays, 8 = halt
 * withdraws. Can add to halt multiple, e.g. 1 + 4 = 5, to halt deposits and repays only
 * @param market - market the reserve is under
 * @param reserve
 * @param owner - market owner
 * @returns
 */
export declare const updateReserveHaltsIx: (program: Program<PsyLend>, halts: number, market: PublicKey, reserve: PublicKey, owner: PublicKey) => Promise<import("@solana/web3.js").TransactionInstruction>;
/**
 * Transfers funds from the deposits account to the user's destination of choice.
 *
 * Requires the reserve being withdrawn from to have an updated NOTE cache (updated with
 * {@link accrueInterestIx}).
 * @param program
 * @param depositBump - derived with `deriveClientReserveAccounts`
 * @param amount - to transfer from deposits account to receiver account
 * @param market - market the reserve is under
 * @param marketAuthority
 * @param receiver - account where the funds will be sent
 * @param depositAccount - derived with `deriveClientReserveAccounts`
 * @param userAddress - typically the user's wallet
 * @param reserve
 * @param vault - can be extracted from `reserve`
 * @param depositNoteMint - can be extracted from `reserve`
 * @param isDevnet - true if devnet, false if mainnet. Determines which PsyLend IDL is used.
 * @returns
 */
export declare const withdrawIX: (program: Program<PsyLend>, depositBump: number, amount: Amount, market: PublicKey, marketAuthority: PublicKey, receiver: PublicKey, depositAccount: PublicKey, userAddress: PublicKey, reserve: PublicKey, vault: PublicKey, depositNoteMint: PublicKey, isDevnet?: boolean) => Promise<import("@solana/web3.js").TransactionInstruction>;
/**
 * Same as {@link withdrawIX}, except that the depositAccount can be any external account, not just a
 * deposit account owned by this program.
 *
 * Typically, use this ix after depositing some funds with {@link depositTokensIx}
 * @param program
 * @param amount - to transfer from deposits account to receiver account
 * @param market - market the reserve is under
 * @param marketAuthority
 * @param receiver - account where the funds will be sent
 * @param depositAccount - typically an ATA with some deposit notes to be redeemed. Any account that
 * can hold deposit notes is acceptable.
 * @param userAddress - typically the user's wallet
 * @param reserve
 * @param vault - can be extracted from `reserve`
 * @param depositNoteMint - can be extracted from `reserve`
 * @returns
 */
export declare const withdrawTokensIX: (program: Program<PsyLend>, amount: Amount, market: PublicKey, marketAuthority: PublicKey, receiver: PublicKey, depositAccount: PublicKey, userAddress: PublicKey, reserve: PublicKey, vault: PublicKey, depositNoteMint: PublicKey) => Promise<import("@solana/web3.js").TransactionInstruction>;
/**
 * Transfers funds from the collateral account to the deposit account, if obligation allows. A
 * refresh of all reserves that apply to the user is required
 *
 * Requires the reserve being withdrawn from to have an updated NOTE cache (updated with
 * {@link accrueInterestIx}).
 *
 * Requires a general refresh of all reserves the user
 * has borrowed or used as collateral (use: {@link refreshEitherReserveIx}).
 * @param program
 * @param bumps - derived with `deriveClientReserveAccounts`, packaged as `WithdrawCollateralBumpSeeds`
 * @param amount - to withdraw into deposits account
 * @param market - market the reserve is under
 * @param marketAuthority
 * @param userAddress - typically the user's wallet
 * @param obligation - derived with `deriveUserObligation`
 * @param reserve
 * @param collateralAccount - derived with `deriveClientReserveAccounts`
 * @param depositAccount - derived with `deriveClientReserveAccounts`
 * @returns
 */
export declare const withdrawCollateralIx: (program: Program<PsyLend>, bumps: WithdrawCollateralBumpSeeds, amount: Amount, market: PublicKey, marketAuthority: PublicKey, userAddress: PublicKey, obligation: PublicKey, reserve: PublicKey, collateralAccount: PublicKey, depositAccount: PublicKey) => Promise<import("@solana/web3.js").TransactionInstruction>;
/**
 * Initializes the MarketRewardState struct stored in Market account that contains
 * market-level config and MarketReward account that stores the reward tokens claimable.
 *
 * This should be invoked after initialization of Market and before the lending activies start used.
 * MarketReward account has to be created and assigned to the program as owner before this is called.
 *
 * Note: Account needs to be created before running this ix, or use `createAndInitMarketReward` to
 * create the account and run this ix.
 *
 * @param program
 * @param market - market the reserve is under
 * @param owner - owner of market
 * @param marketReward - public key of the MarketReward account.
 * @param initialRewardIndexTimestamp - timestamp when rewards will start to be distributed
 * @param distributionPeriod - duration of each distribution period in seconds
 * @param rewardPointsPerPeriod - reward points to be distributed across whole market per period
 * @param rewardUnitDecimals - number of decimals to store reward points in
 * @param minWithdrawalDuration - min duration from start of period, after which rewards claim is allowed
 * @returns TransactionInstruction
 */
export declare const initMarketRewardIx: (program: Program<PsyLend>, market: PublicKey, owner: PublicKey, marketReward: PublicKey, initialRewardIndexTimestamp: BN, distributionPeriod: BN, rewardPointsPerPeriod: BN, rewardUnitDecimals: number, minWithdrawalDuration: BN) => Promise<import("@solana/web3.js").TransactionInstruction>;
/**
 * Updates `MarketReward` to set the reward token mint and initialize the reward token
 * account for a particular RewardState (aka period).
 *
 * @param program
 * @param market - market the reserve is under
 * @param owner - owner of market
 * @param payer - payer for token account init
 * @param marketReward - public key of the MarketReward account.
 * @param marketAuthority - PDA for market
 * @param stateIndex - index of RewardState/period to modify
 * @param infoIndex - index of RewardInfo to modify within that RewardState
 * @param rewardTokenMint - reward token mint to issue
 * @returns TransactionInstruction
 */
export declare const updateMarketRewardIx: (program: Program<PsyLend>, market: PublicKey, owner: PublicKey, payer: PublicKey, marketReward: PublicKey, marketAuthority: PublicKey, stateIndex: number, infoIndex: number, rewardTokenMint: PublicKey) => Promise<import("@solana/web3.js").TransactionInstruction>;
/**
 * Updates `MarketRewardState` in Market to change config.
 *
 * @param program
 * @param market - market the reserve is under
 * @param owner - owner of market
 * @param minWithdrawalDuration - min duration from start of period, after which rewards claim is allowed
 * @returns TransactionInstruction
 */
export declare const updateMarketRewardConfigIx: (program: Program, market: PublicKey, owner: PublicKey, minWithdrawalDuration: BN) => Promise<import("@solana/web3.js").TransactionInstruction>;
/**
 * Updates `Reserve` to the deposit and borrow reward multipliers that
 * will determine the fractional allocation of reward points to this
 * reserve on supply and borrow side.
 *
 * @param program
 * @param market - market the reserve is under
 * @param reserve
 * @param owner - owner of market
 * @param depositRewardMultiplier - value between 0 to 255
 * @param borrowRewardMultiplier - value between 0 to 255
 * @returns TransactionInstruction
 */
export declare const updateReserveRewardIx: (program: Program<PsyLend>, market: PublicKey, reserve: PublicKey, owner: PublicKey, depositRewardMultiplier: number, borrowRewardMultiplier: number) => Promise<import("@solana/web3.js").TransactionInstruction>;
/**
 * Used for claiming reward tokens in exchange for reward units
 * stored in an `Obligation`.
 *
 * Each reward token account has to correspond in the same order
 * as RewardInfo in MarketReward for the period. Receiving token
 * accounts has to match the same sequence as reward token accounts.
 *
 * @param program
 * @param market - market the reserve is under
 * @param owner - owner of obligation
 * @param marketReward - MarketReward account
 * @param marketAuthority - PDA of market's authority
 * @param obligation
 * @param periodToClaim - the period to claim rewards for
 * @param rewardTokenAccounts - Array of reward token accounts, matching RewardInfo
 * @param receivingTokenAccounts - Array of token accounts, owned by owner
 * @returns TransactionInstruction
 */
export declare const claimRewardsIx: (program: Program<PsyLend>, market: PublicKey, owner: PublicKey, marketReward: PublicKey, marketAuthority: PublicKey, obligation: PublicKey, periodToClaim: number, rewardTokenAccounts: PublicKey[], receivingTokenAccounts: PublicKey[]) => Promise<import("@solana/web3.js").TransactionInstruction>;
/**
 * Used for accruing rewards for a user's `Position` in an `Obligation`.
 *
 * @param program
 * @param market - market the reserve is under
 * @param reserve
 * @param obligation
 * @param obligationOwner - owner of obligation
 * @param positionAccount - the collateral or loan account to accrue for
 * @param side - 0 for collateral, 1 for loan.
 * @returns TransactionInstruction
 */
export declare const accruePositionRewardIx: (program: Program<PsyLend>, market: PublicKey, reserve: PublicKey, obligation: PublicKey, obligationOwner: PublicKey, positionAccount: PublicKey, side: number) => Promise<import("@solana/web3.js").TransactionInstruction>;
export declare const closeDepositAccountIx: (program: Program<PsyLend>, market: PublicKey, reserve: PublicKey, tokenMint: PublicKey, depositor: PublicKey, receiverAccount: PublicKey) => Promise<import("@solana/web3.js").TransactionInstruction>;
export declare const closeCollateralAccountIx: (program: Program<PsyLend>, market: PublicKey, reserve: PublicKey, obligation: PublicKey, owner: PublicKey) => Promise<import("@solana/web3.js").TransactionInstruction>;
export declare const closeLoanAccountIx: (program: Program<PsyLend>, market: PublicKey, reserve: PublicKey, obligation: PublicKey, owner: PublicKey) => Promise<import("@solana/web3.js").TransactionInstruction>;
/**
 * Currently does nothing. If the response is ok, the obligation account can be safely closed.
 * @param program
 * @param market
 * @param obligation
 * @param owner
 * @returns
 */
export declare const closeObligationAccountIx: (program: Program<PsyLend>, market: PublicKey, obligation: PublicKey, owner: PublicKey) => Promise<import("@solana/web3.js").TransactionInstruction>;
/**
 * Returns the active dex id (local or devnet)
 * @param isDevnet - true if testing on devnet
 * @returns
 */
export declare const getDexId: (isDevnet: boolean) => PublicKey;
/**
 * DEPRECATED: Older versions of PsyLend passed the protocol's own id to certain ixes. This is no
 * longer used.
 *
 * Returns the active PysLend Protocol ID (local or devnet).
 * Note that this is also sometimes called the Jet ID or Jet program in legacy documentation
 * @param isDevnet - true if testing on devnet
 * @returns
 */
export declare const getPsyLendId: (isDevnet: boolean) => PublicKey;
//# sourceMappingURL=instructions.d.ts.map