import { Program } from "@project-serum/anchor";
import { PublicKey } from "@solana/web3.js";
import { EcosystemHelper } from "./ecosystem_helper";
import { Psylend as PsyLend } from "./idl";
import { LiquidationEstimate, MarketAccount, Obligation, ObligationPriceInfo, Position, PositionValue } from "./types";
/**
 * Accounts are eligible for liquidation when they drop below this threshold, defined as (sum of
 * collateral) / (sum of debts). Liquidators try to seize assets until an account meets this threshold
 */
export declare const MIN_C_RATIO = 1.25;
/**
 * Liquidators get to keep this portion of the debt they repay. For example, if a liquidator repays
 * a debt of $100 with a premium of 1%, the liquidator takes an extra $1 (for a total of $101)
 */
export declare const LIQUIDATION_PREMIUM = 0.01;
/**
 * "Blank" entries for collateral/loan reserves in a user's obligation use this default key.
 */
export declare const DEFAULT_OBLIGATION_ENTRY = "11111111111111111111111111111111";
/**
 * Size of a collateral or loan position saved on the obligation. See `Position` in obligation.rs
 * for more details.
 */
export declare const POSITION_SIZE = 160;
/**
 * DEPRECATED, USE `getLiquidationOptions`, which supports obligations with multiple positions
 *
 * Given a user with one collateral asset and one borrowed asset, returns the amount the liquidator
 * should attempt to repay and how much collateral should be claimed for this liquidation.
 *
 * Generally, some slippage should be subtracted from the expected collateral.
 *
 * @param program
 * @param userCollateralAssetAccount - users's collateral account for the Jet reserve where
 * collateral is deposited.
 * @param userLoanAccount - users's loan account for the Jet reserve where the user borrowed funds
 * @param collateralPrice - price of 1 collateral token in USD, before discount rate applied
 * @param discountRate - discount rate for the collateral, as float (e.g. 95% = .95)
 * @param cRatioTarget - typically the largest C Ratio among all loan accounts, as float (e.g. 125% = 1.25)
 * @param liquidationPrem - bonus earned for liquidated this loan, as float (e.g. 2% = .02)
 * @param collateralDecimals - decimals used for collateral asset (can be derived from the asset mint)
 * @param debtPrice - price of 1 borrowed token in USD
 * @param debtDecimals - decimals used for loan asset (can be derived from the asset mint)
 * @returns amount to repay in native decimals, amount to repay in USD, amount to seize in native decimals,
 * amount to seize in USD, expected profit or loss in USD
 */
export declare const getIdealLiquidationAmountSingleAsset: (program: Program<PsyLend>, userCollateralAssetAccount: PublicKey, userLoanAccount: PublicKey, collateralPrice: number, discountRate: number, liquidationPrem: number, cRatioTarget: number, collateralDecimals: number, debtPrice: number, debtDecimals: number) => Promise<{
    repaid: number;
    repaidUSD: number;
    seized: number;
    seizedUSD: number;
    expectedPnL: number;
}>;
/**
 * DEPRECATED, USE `getLiquidationOptions`, which supports obligations with multiple positions
 *
 * Given a user with one collateral asset and one borrowed asset, returns the amount the liquidator
 * should attempt to repay and how much collateral should be claimed for this liquidation.
 *
 * Generally, some slippage should be subtracted from the expected collateral.
 *
 * @param collateral - token balance of user's collateral acc
 * @param debt - token balance of user's loan acc
 * @param collateralPrice - price of 1 collateral token in USD, before discount rate applied
 * @param discountRate - discount rate for the collateral, as float (e.g. 95% = .95)
 * @param cRatioTarget - typically the largest C Ratio among all loan accounts, as float (e.g. 125% = 1.25)
 * @param liquidationPrem - bonus earned for liquidated this loan, as float (e.g. 2% = .02)
 * @param collateralDecimals - decimals used for collateral asset (can be derived from the asset mint)
 * @param debtPrice - price of 1 borrowed token in USD
 * @param debtDecimals - decimals used for loan asset (can be derived from the asset mint)
 * @returns amount to repay in native decimals, amount to repay in USD, amount to seize in native decimals,
 * amount to seize in USD, expected profit or loss in USD
 */
export declare const getIdealLiquidationAmountSingleAssetNoFetch: (collateral: number, debt: number, collateralPrice: number, discountRate: number, liquidationPrem: number, cRatioTarget: number, collateralDecimals: number, debtPrice: number, debtDecimals: number) => Promise<{
    repaid: number;
    repaidUSD: number;
    seized: number;
    seizedUSD: number;
    expectedPnL: number;
}>;
/**
 * Fetches the obligation, then calls {@link obligationLoaderNoFetch}
 * @param program - psylend program
 * @param obligation - pubkey of obligation. Must exist.
 */
export declare const obligationLoader: (program: Program, obligation: PublicKey) => Promise<ObligationInfo>;
/**
 * Reads data from an already fetched Obligation. Executes no network calls.
 *
 * Loads information about a user's obligation, returns:
 *
 * -the addresses of all reserves used as collateral or borrowed against as loans,
 *
 * -the amount/balance for each collateral/loan reserve,
 *
 * -the net value of all collateral and loans, in USD
 *
 * Notes:
 *
 * Currency balances are NOT in native decimals, but in regular JS numbers, e.g. 1 BTC will be
 * expressed as "1", not in Satoshis with the appropriate decimals. This is because they are stored
 * on the obligation as U192 Numbers, which always have the same decimals (15). To recover the correct
 * decimals, use the oracle decimals or read decimals from the currency's mint
 *
 * Likewise all account values are in USD, with no decimals. e.g. 1.1 = $1 and ten cents
 *
 * Cached prices may be stale if the olbigation has not updated its calculation cache recently (this
 * typically occurs on a borrow, withdraw, or liquidation event, trigger a new liquidation event to
 * refresh the user's obligation cache))
 * @param userObligation
 * @returns
 */
export declare const obligationLoaderNoFetch: (userObligation: Obligation) => ObligationInfo;
/**
 * {@link obligationLoader} returns information about the user's obligation in this format
 */
export type ObligationInfo = {
    collateralAccountKeys: PublicKey[];
    collateralAmounts: number[];
    netCollateralValue: number;
    netDiscountedCollateralValue: number;
    loanAccountKeys: PublicKey[];
    loanAmounts: number[];
    netLoanValue: number;
};
/**
 * Prints information about an obligation to console.
 * @param info
 */
export declare const printObligationInfo: (info: ObligationInfo) => void;
/**
 * Given a reserve, returns the value of a vault token in USD. The helper must be fully refreshed,
 * including the vaults
 *
 * Mirrors `compute_vault_token_price` on the Rust side.
 *
 * Use `getVaultTokenPrice` from the PsyFi package to get a price that doesn't incorporate
 * `optionTokenRemaining` or `pendingCollateralAssetDeposits`
 *
 * TODO: BN to number conversions can go out of bounds, need a version without precision loss
 * @param reserveKey
 * @param helper
 */
export declare const getVaultTokenPricing: (reserveKey: PublicKey, helper: EcosystemHelper) => number;
/**
 * Given a position that has been decoded from an Obligation (see `decodePositionsList`), and an
 * EcosystemHelper that has been initialized and refreshed, returns information about the value of
 * that position.
 *
 * A loan will return a negative value
 *
 * @param decoded - a Position on an Obligation
 * @param reserveKey - If the reserveKey is not known, it can be extracted using the reserveIndex on the
 * decoded Position if the market is known using `getReserveFromIndexInReserveInfo`
 * @param helper - an up-to-date EcosystemHelper
 * @param isCollateral - true for a collateral position, false for a loan. Can be extracted from
 * decoded Position's side if not known.
 * @returns
 */
export declare const getValueOfDecodedPosition: (decoded: Position, reserveKey: PublicKey, helper: EcosystemHelper, isCollateral: boolean) => PositionValue;
/**
 * Placeholder value used when the user has no loans to represent a C-Ratio of "infinity"
 */
export declare const INFINITE_C_RATIO = 99999999;
/**
 * Processes an Obligation into all relevant price information. See `ObligationPriceInfo` for a full
 * description of values returned.
 *
 * Performs no RPC calls!
 * @param obligationKey - not validated, make sure this matches the `obligation`.
 * @param obligation - A loaded Obligation account
 * @param marketKey - not validated, make sure this matches the 'market'
 * @param market - A loaded market account
 * @param helper - An up-to-date and refreshed ecosystem helper.
 * @returns
 */
export declare const getObligationPriceInfo: (obligationKey: PublicKey, obligation: Obligation, marketKey: PublicKey, market: MarketAccount, helper: EcosystemHelper) => ObligationPriceInfo;
/**
 * Examines all positions on the user's obligation and provides options for which positions to repay
 * and which to seize.
 * @param obligationPriceInfo - use {@link getObligationPriceInfo} to generate
 * @returns - an array of possible LiquidationEstimate, which describe the max that can be
 * repaid/seized with every possible pair of positions
 */
export declare const getLiquidationOptions: (obligationPriceInfo: ObligationPriceInfo) => LiquidationEstimate[];
/**
 * Calculate the repay and seize amounts based on loanValue and collateralValue.
 * @param obligationPriceInfo
 * @param loanValue
 * @param collateralValue
 * @returns
 */
export declare const getLiquidationEstimateAmounts: (obligationPriceInfo: ObligationPriceInfo, loanValue: PositionValue, collateralValue: PositionValue) => {
    repaidUSD: number;
    repaidTokens: number;
    repaidNotes: number;
    seizedUSD: number;
    seizedTokens: number;
    seizedNotes: number;
    expectedPnL: number;
};
//# sourceMappingURL=liquidation_utils.d.ts.map