/// <reference types="node" />
/// <reference types="bn.js" />
import { BN, Program } from "@project-serum/anchor";
import { Connection, Keypair, PublicKey, TransactionInstruction } from "@solana/web3.js";
import { reserveBumpSeeds, reserveAccounts } from "./pdas";
import { MarketAccount, MarketReward, ReserveAccount, ReserveConfig } from "./types";
import { Psylend as PsyLend } from "./idl";
/**
 * Attempts to fetch a user deposit account, creates it if it doesn't exist.
 * Derive the deposit account with `{@link deriveClientReserveAccounts}`. Data required to create deposit
 * account is optional and be omitted if only attempting to fetch an account.
 * @param program
 * @param depositKey - derived with `{@link deriveClientReserveAccounts}`
 * @param bump - derived with `{@link deriveClientReserveAccounts}`
 * @param toCreate - required to create an accont if one is not found
 * @param market - Psy market for this reserve
 * @param marketAuthority
 * @param reserve
 * @param depositNoteMint - can be extracted from the reserve
 * @param userAddress - generally the user's wallet
 * @returns deposit account, or null if no account is found and data to create a new one is not provided.
 */
export declare const getOrInitUserDepositAccount: (program: Program<PsyLend>, depositKey: PublicKey, bump?: number, toCreate?: {
    market: PublicKey;
    marketAuthority: PublicKey;
    reserve: PublicKey;
    depositNoteMint: PublicKey;
    userAddress: PublicKey;
}) => Promise<PublicKey>;
/**
 * Attempts to fetch collateral account at this address, creates one if it doesn't exist.
 *
 * Derive accounts with {@link deriveClientReserveAccounts} first to get the address
 * @param program - typically the user's program, user must sign tx if creating account
 * @param accountKey
 * @param bump
 * @param toCreate - Psy market/authority, reserve address/deposit note mint, user wallet. Accrue ix is
 * required if rewards are enabled.
 * @returns
 */
export declare const getOrInitCollateralAccount: (program: Program<PsyLend>, accountKey: PublicKey, bump?: number, toCreate?: {
    market: PublicKey;
    marketAuthority: PublicKey;
    reserve: PublicKey;
    depositNoteMint: PublicKey;
    userAddress: PublicKey;
    obligationAccount: PublicKey;
    accrueIx?: TransactionInstruction;
}) => Promise<PublicKey>;
/**
 * Attempts to fetch loan account at this address, creates one if it doesn't exist.
 *
 * Derive accounts with {@link deriveClientReserveAccounts} first to get the address
 * @param program - typically the user's program, user must sign tx if creating account
 * @param accountKey
 * @param bump
 * @param toCreate - Psy market/authority, reserve address/loan note mint, user wallet. Accrue ix is
 * required if rewards are enabled.
 * @returns
 */
export declare const getOrInitLoanAccount: (program: Program<PsyLend>, accountKey: PublicKey, bump?: number, toCreate?: {
    market: PublicKey;
    marketAuthority: PublicKey;
    reserve: PublicKey;
    loanNoteMint: PublicKey;
    userAddress: PublicKey;
    obligationAccount: PublicKey;
    accrueIx?: TransactionInstruction;
}) => Promise<PublicKey>;
/**
 * Attempts to fetch obligation account at this address, creates one if it doesn't exist.
 *
 * Derive account with  {@link deriveUserObligation} first to get the address
 * @param program - typically the user's program, user must sign tx if creating account
 * @param accountKey
 * @param bump
 * @param toCreate - psy market, authority, user's wallet address
 * @returns
 */
export declare const getOrInitObligationAccount: (program: Program<PsyLend>, accountKey: PublicKey, bump?: number, toCreate?: {
    market: PublicKey;
    marketAuthority: PublicKey;
    userAddress: PublicKey;
}) => Promise<PublicKey>;
/**
 * Returns the balance of a token account, in whatever currency the account is in.
 *
 * Requires spl-token 2.0 or later
 * @param program
 * @param account
 * @returns
 */
export declare const getTokenAccountBalance: (program: Program<PsyLend>, account: PublicKey) => Promise<number>;
/**
 * Sends a tx that creates a zeroed out market, and {@link initMarketIx}
 * @param program
 * @param owner
 * @param quoteCurrencyMint
 * @param quoteCurrencyName
 * @param market
 * @param payer - pays the tx fee to create the market account
 * @returns the created PsyMarket
 */
export declare const createAndInitPsyMarket: (program: Program<PsyLend>, owner: PublicKey, quoteCurrencyMint: PublicKey, quoteCurrencyName: string, market: Keypair, payer: Keypair) => Promise<MarketAccount>;
/**
 * Sends a tx that creates a reserve, and {@link initReserveIx}
 * @param program
 * @param bumpSeeds
 * @param reserveConfig
 * @param market
 * @param marketAuthority
 * @param owner
 * @param pythOracleProduct
 * @param pythOraclePrice - pyth oracle for currency reserve trades in (oracle of underlying asset if a
 * psyfi reserve)
 * @param reserve
 * @param reserveAccounts
 * @param dexMarket - Serum market that should have been created earlier with {@link createSerumMarket}
 * @param quoteTokenMint - quote token for reserve, currency the Psy market is priced in, generally usdc
 * @param tokenMint - currency this reserve trades in
 * @param isDevnet
 * @param payer
 * @param optional -
 *  @param psyfiVaultAccount - (optional) - the vault address, if creating a psyfi reserve
 *  @param collateralAssetMint - (optional) - mint for underlying token vault trades in (NOT the
 * ownership token), if creating psyfi reserve. Matches asset of pythPrice
 *
 */
export declare const createAndInitReserve: (program: Program<PsyLend>, bumpSeeds: reserveBumpSeeds, reserveConfig: ReserveConfig, market: PublicKey, marketAuthority: PublicKey, owner: PublicKey, pythOracleProduct: PublicKey, pythOraclePrice: PublicKey, reserve: Keypair, reserveAccounts: reserveAccounts, dexMarket: PublicKey, quoteTokenMint: PublicKey, tokenMint: PublicKey, isDevnet: boolean, payer: Keypair, optional?: {
    psyfiVaultAccount: PublicKey;
    collateralAssetMint: PublicKey;
}) => Promise<ReserveAccount>;
/**
 * Sends a tx that creates a reserve, and {@link initPsyfiReserveIx}.
 *
 * Deprecated, {@link createAndInitReserve} can now handle psyFi reserves with optional arguments.
 * @param program
 * @param bumpSeeds
 * @param reserveConfig
 * @param market
 * @param marketAuthority
 * @param owner
 * @param pythOracleProduct
 * @param pythOraclePrice
 * @param reserve
 * @param reserveAccounts
 * @param dexMarket
 * @param quoteTokenMint
 * @param tokenMint
 * @param psyfiVault
 * @param psyfiCollateralMint
 * @param isDevnet
 * @param payer
 */
export declare const createAndInitPsyfiReserve: (program: Program<PsyLend>, bumpSeeds: reserveBumpSeeds, reserveConfig: ReserveConfig, market: PublicKey, marketAuthority: PublicKey, owner: PublicKey, pythOracleProduct: PublicKey, pythOraclePrice: PublicKey, reserve: Keypair, reserveAccounts: reserveAccounts, dexMarket: PublicKey, quoteTokenMint: PublicKey, tokenMint: PublicKey, psyfiVault: PublicKey, psyfiCollateralMint: PublicKey, isDevnet: boolean, payer: Keypair) => Promise<ReserveAccount>;
/**
 * Sends a tx that creates a MarketReward account and {@link initMarketRewardIx}
 *
 * @param program
 * @param marketRewardKeypair - keypair for creation of MarketReward account.
 * @param psyMarket - Psy market the reserve is under
 * @param psyMarketOwner - keypair for owner of Psy market
 * @param initialRewardIndexTimestamp - timestamp when rewards will start to be distributed
 * @param distributionPeriod - duration of each distribution period in seconds
 * @param rewardPointsPerPeriod - reward points to be distributed across whole market per period
 * @param rewardUnitDecimals - number of decimals to store reward points in
 * @param minWithdrawalDuration - min duration from start of period, after which rewards claim is allowed
 * @returns - created `MarketReward` account
 */
export declare const createAndInitMarketReward: (program: Program<PsyLend>, marketRewardKeypair: Keypair, psyMarket: PublicKey, psyMarketOwner: Keypair, initialRewardIndexTimestamp: BN, distributionPeriod: BN, rewardPointsPerPeriod: BN, rewardUnitDecimals: number, minWithdrawalDuration?: BN) => Promise<MarketReward>;
/**
 * Derives obligation, deposits, loans, and collateral accounts for user.
 * @param program
 * @param market
 * @param userAddress - Pubkey of user's wallet
 * @param reserveKey
 * @returns
 */
export declare const deriveUserAccounts: (program: Program<PsyLend>, market: PublicKey, userAddress: PublicKey, reserveKey: PublicKey) => Promise<{
    obligationAccount: PublicKey;
    obligationBump: number;
    clientReserveAccounts: import("./pdas").clientReserveAccounts;
    clientReserveBumpSeeds: import("./pdas").clientReserveBumpSeeds;
}>;
/**
 * Reads a U192 from some buffer and returns a BN with equivalent value
 * @param buff - some buffer containing a U192 `Number`
 * @param start - index to begin reading
 */
export declare const readU192FromBuffer: (buff: Buffer, start: number) => BN;
/**
 * Fetches several reserves, in one rpc call
 * @param program
 * @param reserves - an array of reserve keys to fetch
 * @returns
 */
export declare const fetchSeveralReserves: (program: Program<PsyLend>, reserves: PublicKey[]) => Promise<ReserveAccount[]>;
/**
 * Returns circulating supply of a mint
 * @param connection
 * @param mint
 * @returns
 */
export declare const getMintSupply: (connection: Connection, mint: PublicKey) => Promise<bigint>;
export type reserveExchangeRates = {
    /**
     * Value of 1 deposit note in tokens (floating point, no decimals)
     */
    depositNotesToTokens: number;
    /**
     * Value of 1 loan note in tokens (floating point, no decimals)
     */
    loanNotesToTokens: number;
    /**
     * Value of 1 token in deposit notes (floating point, no decimals)
     */
    tokensToDepositNotes: number;
    /**
     * Value of 1 token in loan notes (floating point, no decimals)
     */
    tokensToLoanNotes: number;
    /**
     * Deposit notes in circulation total (uses same decimals as tokens)
     */
    depositNoteSupply: BN;
    /**
     * Loan notes in circulation total (uses same decimals as tokens)
     */
    loanNoteSupply: BN;
    /**
     * Assets that can be used to redeem deposits (includes vault assets + oustanding debt,
     * excludes fees) (in tokens, in native token decimals)
     */
    depositTokenSupply: BN;
    /**
     * Assets that are currently loaned out (in tokens, in native token decimals)
     */
    loanTokenSupply: BN;
};
export declare const printExchangeRates: (rates: reserveExchangeRates) => void;
/**
 * Given a reserve account, determines the exchange rate of Notes to Tokens for deposit/loan notes.
 * Also returns the oustanding supply of notes/tokens and the exchange rate in reverse. See
 * {@link reserveExchangeRates} for all returned values.
 *
 * Note that deposit/loan note mints and the mint for this reserve's token always use the same
 * decimals, so a value in notes for this reserve can be natively divided by a token value.
 *
 * Note that the exchange rates do not account for unaccrued interest.
 * @param reserve
 * @returns
 */
export declare const getNoteExchangeRatesForReserve: (reserve: ReserveAccount) => reserveExchangeRates;
//# sourceMappingURL=tools.d.ts.map