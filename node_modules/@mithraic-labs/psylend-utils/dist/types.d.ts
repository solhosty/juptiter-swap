/// <reference types="bn.js" />
import { BN } from "@project-serum/anchor";
import { PublicKey } from "@solana/web3.js";
export * from "./decode";
export declare const DEFAULT_DISCOUNT_RATE = 10000;
export declare const NOTHING_HALTED = 0;
export declare const DEPOSITS_HALTED = 1;
export declare const BORROWS_HALTED = 2;
export declare const REPAYS_HALTED = 4;
export declare const WITHDRAWS_HALTED = 8;
/**
 * All interests and percentages, such as discount rates, fees, liquidation premium, etc are stored
 * under the hood multiplied by this amount, e.g. 5% is stored as .05 * 10,000 = 500
 */
export declare const COMMON_DENOM = 10000;
export declare const PSY_MARKET_SIZE = 16544;
export declare const RESERVE_SIZE = 5184;
export declare const MARKET_REWARD_SIZE = 39968;
export declare const POSITION_SIZE = 160;
export declare const OBLIGATION_SIZE = 7168;
export declare const TOKENS = 0;
export declare const DEPOSIT_NOTES = 1;
export declare const LOAN_NOTES = 2;
/**
 * A unit and u64 pair. Most instructions dealing with currency use this as input.
 *
 * Note: remember to convert values into the appropriate decimals!
 *
 * For units, possible values are TOKENS (0), DEPOSIT_NOTES (1), and LOAN_NOTES (2)
 */
export declare class Amount {
    units: number;
    value: BN;
    constructor(units: number, value: BN);
    static tokens(amount: BN): Amount;
    static depositNotes(amount: BN): Amount;
    static loanNotes(amount: BN): Amount;
}
/**
 * Used exclusively in the `deposit_collateral` ix, which expects bumps to be packaged in this way
 */
export type DepositCollateralBumpSeeds = {
    depositAccount: number;
    collateralAccount: number;
};
/**
 * Used exclusively in the `withdraw_collateral` ix, which expects bumps to be packaged in this way
 */
export type WithdrawCollateralBumpSeeds = {
    collateralAccount: number;
    depositAccount: number;
};
/**
 * A Psy reserve. Matches reserve.rs in program types.
 */
export type ReserveAccount = {
    version: number;
    index: number;
    /**
     * The native mint's decimals, loaded at account init. Always negative (to mirror Pyth exponent).
     * Generally (but not always) the same as Pyth exponent.
     */
    exponent: number;
    market: PublicKey;
    pythOraclePrice: PublicKey;
    pythOracleProduct: PublicKey;
    tokenMint: PublicKey;
    depositNoteMint: PublicKey;
    loanNoteMint: PublicKey;
    vault: PublicKey;
    feeNoteVault: PublicKey;
    dexSwapTokens: PublicKey;
    dexOpenOrders: PublicKey;
    dexMarket: PublicKey;
    reserved0: number | number[];
    config: ReserveConfig;
    psyfiVaultConfig: PsyFiVaultConfig;
    discountRate: number;
    discountRateVersion: number;
    haltState: number;
    reserved1: number[];
    reserved2: BN[];
    state: number[];
};
/**
 * The number array at the end of the Reserve struct, can be decoded with {@link decodeReserveStateStruct}
 */
export type ReserveStateStruct = CacheStruct & {
    accruedUntil: BN;
    /**
     * Amount of deposited tokens loaned out to borrowers, plus amount of tokens charged in fees (in
     * token).
     * Actually a U192 `Number` field
     */
    outstandingDebt: BN;
    /**
     * Amount of fees collected (in token). `Outstanding debt` includes this amount.
     * Actually a U192 `Number` field
     */
    uncollectedFees: BN;
    /**
     * Amount of deposited tokens that is not borrowed (in token)
     */
    totalDeposits: BN;
    /**
     * Amount of deposit notes issued and in circulation (i.e., matches mint's supply)
     */
    totalDepositNotes: BN;
    /**
     * Amount of loan notes issued and in circulation (i.e., matches mint's supply)
     */
    totalLoanNotes: BN;
    /**
     * Each index corresponds to cummulative sum of the reward points distributed per deposit note for the
     * distribution period. This value is denominated in reward_unit_decimals.
     */
    cummulativeDepositRewardUnits: BN[];
    /**
     * Each index corresponds to cummulative sum of the reward points distributed distributed per loan
     * note for the distribution period. This value is denominated in reward_unit_decimals.
     */
    cummulativeLoanRewardUnits: BN[];
    _reserved: number[];
};
export type CacheStruct = {
    /** The last slot that this information was updated in */
    lastUpdated: BN;
    /** Whether the value has been manually invalidated */
    invalidated: boolean;
    /** Unused space */
    _reservedCache: number[];
};
/**
 * Part of the reserve.rs struct, stores information that a reserve may need to interact with a
 * PsyFi vault.
 */
export type PsyFiVaultConfig = {
    vaultAccount: PublicKey;
    collateralTokenDecimals: number;
    reserved1: number[];
    reserved2: number[];
};
/**
 * A generic reserve config with:
 *
 * utilitzation rates 8500/9500 (85/95%)
 *
 * borrow rate 20,000 at all levels (200%)
 *
 * min c-ratio = 12500 (125%)
 *
 * liquidation premium = 100 (1%)
 *
 * manage fee = 50 (.5%)
 *
 * origination fee = 0 (0%)
 * @returns
 */
export declare const getGenericReserveConfig: () => ReserveConfig;
/**
 * The `config` field of a `ReserveAccount` deserializes into this struct
 */
export type ReserveConfig = {
    /** The utilization rate at which we switch from the first to second regime. */
    utilizationRate1: number;
    /** The utilization rate at which we switch from the second to third regime. */
    utilizationRate2: number;
    /** The lowest borrow rate in the first regime. Essentially the minimum
            borrow rate possible for the reserve. */
    borrowRate0: number;
    /** The borrow rate at the transition point from the first to second regime. */
    borrowRate1: number;
    /** The borrow rate at the transition point from the second to thirs regime. */
    borrowRate2: number;
    /** The highest borrow rate in the third regime. Essentially the maximum
            borrow rate possible for the reserve. */
    borrowRate3: number;
    /** The minimum allowable collateralization ratio for an obligation */
    minCollateralRatio: number;
    /** The amount given as a bonus to a liquidator */
    liquidationPremium: number;
    /** The threshold at which to collect the fees accumulated from interest into
            real deposit notes. */
    manageFeeCollectionThreshold: BN;
    /** The fee rate applied to the interest payments collected */
    manageFeeRate: number;
    /** The fee rate applied as interest owed on new loans */
    loanOriginationFee: number;
    /** Reserved for future use */
    reserved0: number;
    /** Confidence Threshold */
    confidenceThreshold: number;
    /** Maximum number of tokens to sell in a single DEX trade during liquidation */
    liquidationDexTradeMax: BN;
    /** Reward distribution multiplier for deposit. */
    depositRewardMultiplier: number;
    /** Reward distribution multiplier for borrow. */
    borrowRewardMultiplier: number;
    /** 22 bytes, reserved for future use. Fill with reserved1: new Uint8Array(22) as unknown as number[], */
    reserved1: number[];
};
/**
 * A Psy market. Matches market.rs in program types.
 */
export type MarketAccount = {
    version: number;
    /** The exponent used for quote prices */
    quoteExponent: number;
    /** The currency used for quote prices */
    quoteCurrency: number[];
    /** The bump seed value for generating the authority address. */
    authorityBumpSeed: number[];
    /** The address used as the seed for generating the market authority
        address. Typically this is the market account's own address. */
    authoritySeed: PublicKey;
    /** The account derived by the program, which has authority over all
        assets in the market. */
    marketAuthority: PublicKey;
    /** The account that has authority to make changes to the market */
    owner: PublicKey;
    /** The mint for the token in terms of which the reserve assets are quoted */
    quoteTokenMint: PublicKey;
    /** Flags for halting Market */
    flags: BN;
    /** State of rewards for the market.*/
    marketRewardState: MarketRewardState;
    /** Reserved space */
    reserved: number[];
    /** Tracks the current prices of the tokens in reserve accounts */
    reserves: number[];
};
export type MarketRewardState = {
    marketReward: PublicKey;
    initialRewardIndexTimestamp: BN;
    distributionPeriod: BN;
    rewardPointsPerPeriod: BN;
    totalRewardMultiplier: BN;
    minWithdrawalDuration: BN;
    rewardUnitDecimals: number;
    /** Reserved space */
    reserved0: number[];
    reserved1: number[];
};
/**
 * A MarketRewards. Matches market_reward.rs in program types
 *
 * States is an array of 96 `RewardState`
 */
export type MarketReward = {
    market: PublicKey;
    states: RewardState[];
};
export type RewardState = {
    withdrawalTime: BN;
    unclaimedRewardUnits: BN;
    period: number;
    /** Reserved space */
    _reserved0: number[];
    _reserved1: number[];
    info: RewardInfo[];
};
export type RewardInfo = {
    rewardTokenMint: PublicKey;
    rewardTokenAccount: PublicKey;
};
export declare enum MarketFlags {
    HaltNothing = 0,
    HaltBorrows = 1,
    HaltRepays = 2,
    HaltDeposits = 4,
    HaltAll = 7
}
export type PsyMarketReserveInfo = {
    reserve: PublicKey;
    price: BN;
    minCollateralRatio: BN;
    liquidationBonus: BN;
    discountRate: BN;
    reserveInfoLastUpdated: BN;
    reserveInfoInvalidated: number;
    depositNoteExchangeRate: BN;
    loanNoteExchangeRate: BN;
    noteInfoLastUpdated: BN;
    noteInfoInvalidated: number;
};
/**
 * A Psy obligation. Matches obligation.rs in program types.
 */
export type Obligation = {
    version: number;
    reserved0: number | number[];
    market: PublicKey;
    owner: PublicKey;
    reserved1: number[];
    /**
     * is actually CalculationCache, decodes as number[] in the idl
     */
    cached: number[];
    /**
     * is actually Position, decodes as number[] in the idl
     */
    collateral: number[];
    /**
     * is actually Position, decodes as number[] in the idl
     */
    loans: number[];
    accruedRewardUnits: BN[];
};
export type CalculationCache = CacheStruct & {
    collateral_value: BN;
    discounted_collateral_value: BN;
    loan_value: BN;
    _reserved: number[];
};
/**
 * Discount rates for various token mints. Matches discounts.rs
 */
export type Discounts = {
    reserved: number[];
    version: number;
    lastUpdated: BN;
    authority: PublicKey;
    mintAddresses: PublicKey[];
    discountRates: number[];
};
/**
 * Indicates the status of a `PriceInformation` fetched from Oracle. OK = fetched price without
 * issue, EMA = failed to get price, fell back to EMA, FAILED = couldn't fetch or decode the price,
 * fell back to placeholder of $1
 */
export declare enum priceStatus {
    PRICE_INFORMATION_OK = 0,
    PRICE_INFORMATION_EMA = 1,
    PRICE_INFORMATION_FAILED = 2
}
/**
 * Oracle prices are fetched in this format. For convienence, the discount rate and discounted price
 * are also loaded whenever the oracle price is fetched, using the most recent discount rate for
 * the reserve. Native mint decimals are also fetched: these are generally, but not always, the same
 * as Oracle decimals.
 */
export type PriceInformation = {
    /**
     * Price in USD, as float with no decimals (e.g. $56.87 = 56.87)
     */
    price: number;
    /**
     * As float, e.g. 95% = .95. The `discountPrice` = `price` * `discountRate`
     */
    discountRate: number;
    discountPrice: number;
    /**
     * Abs value of the Pyth exponent. Typically, the reserve also stores this value (exponent) as a
     * negative number. Useful to convert token balances back to "price" decimals. Typically the same
     * as `oracleDecimals`
     */
    oracleDecimals: number;
    /**
     * Decimals reported from the native mint. Useful to convert token balances back to native decimals.
     */
    nativeDecimals: number;
    /**
     * Flags various information related to pricing, such as a failure to get an accurate price.
     *
     * Current values:
     *
     * 0 (PRICE_INFORMATION_OK) = OK,
     *
     * 1 (PRICE_INFORMATION_EMA) = Failed to get price normally, fell back to ema price
     *
     * 2 (PRICE_INFORMATION_FAILED) = Failed to get price or ema price, using a placeholder of $1
     */
    status: priceStatus;
};
/**
 * Position record in an Obligation. Matches obligation.rs
 */
export type Position = {
    /**
     * The token account holding the bank notes
     */
    account: PublicKey;
    /**
     * Non-authoritative number of bank notes placed in the account
     */
    noteAmount: BN;
    lastUpdated: BN;
    cummulativeRewardUnits: BN;
    side: BN;
    reserveIndex: BN;
};
/**
 * Information about the token and usd value of a Position stored on an Obligation.
 */
export type PositionValue = {
    /**
     * The number of tokens this position represents. Note that positions are stored in deposit or
     * loan notes, and this value has already accounted for the exchange rate. (in token, as float
     * with no decimals, always positive)
     */
    tokenAmount: number;
    /**
     * The number of notes in this position, which is deposit notes if this is a collateral position,
     * or loan notes if this is a loan position. Notes always use the same decimals as the token.
     * (in notes, as float with no decimals, always positive)
     */
    noteAmount: number;
    /**
     * Abs value of exponent reported from Pyth oracle. In most cases, this is the same as `tokenNativeDecimals`
     */
    tokenOracleDecimals: number;
    /**
     * To convert back into native decimals, multiply tokenAmount by 10^tokenDecimals
     */
    tokenNativeDecimals: number;
    /**
     * In USD, as float with no decimals, negative if this position is a loan.
     */
    usdValue: number;
    /**
     * The discount rate for this position, as float (e.g. 95% = .95). The discounted usd value is
     * equal to this rate times the usd value.
     */
    discountRate: number;
    /**
     * In USD, as float with no decimals, negative if this position is a loan. Same as `usdValue` if
     * no discount applies to this Position. Loans are never discounted, but the discounted price is
     * still shown for reference.
     */
    usdValueDiscounted: number;
    /**
     * The liquidation premium for this position, as float (e.g. 2% = .02). The liquidation premium is
     * awarded when this position is repaid by a liquidator. It is not typically relevant for
     * collateral positions.
     */
    liquidationPremium: number;
};
/**
 * A possible liquidation scenario, including the position to be repaid, the position to be seized,
 * and amounts that can be taken as a MAXIMUM. Liquidators can always seize less than the maximum,
 * simply take the ratio.
 *
 * E.g. if the max than can be repaid is $10, and the max to seize is $15, a
 * liquidator can repay $1 to seize $1/$10 = .1 * $15 = $1.5
 */
export type LiquidationEstimate = {
    collateralAccount: PublicKey;
    collateralReserve: PublicKey;
    loanAccount: PublicKey;
    loanReserve: PublicKey;
    /**
     * MAXIMUM amount of the position to repay, in dollars, e.g. $14.67
     */
    repaidUSD: number;
    /**
     * MAXIMUM amount of the position to repay, in token, as float (e.g. 1.25 tokens). Multiply by
     * 10^`loanDecimals` to get native decimals.
     */
    repaidTokens: number;
    /**
     * MAXIMUM amount of the position to repay, in loan notes, as float (e.g. 1.25 tokens). Multiply by
     * 10^`loanDecimals` to get native decimals.
     */
    repaidNotes: number;
    /**
     * MAXIMUM amount of the position to seize, in dollars, e.g. $14.67
     */
    seizedUSD: number;
    /**
     * MAXIMUM amount of the position to seize, in token, as float (e.g. 1.25 tokens). Multiply by
     * 10^`collateralDecimals` to get native decimals.
     */
    seizedTokens: number;
    /**
     * MAXIMUM amount of the position to seize, in deposit notes, as float (e.g. 1.25 tokens). Multiply by
     * 10^`collateralDecimals` to get native decimals.
     */
    seizedNotes: number;
    /**
     * Expected PNL, in dollars, e.g. $14.67. A negative PNL should always be aborted, unless the
     * liquidator wants to take a loss.
     */
    expectedPnL: number;
    /**
     * Native decimals, read from the token mint. Note: The same decimals are used for the token and the
     * deposit or loan notes
     */
    collateralDecimals: number;
    /**
     * Decimals as read from the `exponent` on the Pyth oracle (abs value, always positive).
     * Generally same as as `collateralDecimals`
     */
    collateralOracleDecimals: number;
    /**
     * Native decimals, read from the token mint. Note: The same decimals are used for the token and the
     * deposit or loan notes
     */
    loanDecimals: number;
    /**
     * Decimals as read from the `exponent` on the Pyth oracle (abs value, always positive).
     * Generally same as as `loanOracleDecimals`
     */
    loanOracleDecimals: number;
};
/**
 * Everything about an Obligation's price status and health. Everything that is needed to decide if/how
 * to liquidate a Obligation, and everything that's needed to send the liquidate tx.
 */
export type ObligationPriceInfo = {
    /**
     * This obligation's pubkey
     */
    obligationKey: PublicKey;
    /**
     * The market this obligation is under
     */
    obligationMarket: PublicKey;
    /**
     * Key of the obligations's collateral accounts, in the same order as the PositionValues. For the
     * reserve that corresponds to each account, see `collateralReserves`
     */
    collateralAccounts: PublicKey[];
    /**
     * Key of reserves the collateral is under, in the same order as the PositionValues.
     */
    collateralReserves: PublicKey[];
    /**
     * Key of the obligations's loan accounts, in the same order as the PositionValues. For the
     * reserve that corresponds to each account, see `loanReserves`
     */
    loanAccounts: PublicKey[];
    /**
     * Key of reserves the loans are under, in the same order as the PositionValues.
     */
    loanReserves: PublicKey[];
    collateralPositionValues: PositionValue[];
    loanPositionValues: PositionValue[];
    /**
     * As percent, e.g. 150% = 1.5. The LARGEST C-Ratio of all loaned positions determines obligation health.
     */
    minCRatio: number;
    /**
     * As percent, e.g. 150% = 1.5
     */
    cRatioActual: number;
    /**
     * As percent, e.g. 150% = 1.5. Includes the discount rate applied to some collateral assets.
     */
    cRatioDiscounted: number;
    /**
     * If true, can initiate liquidation. Use other values to determine amount to seize and repay.
     */
    canLiquidate: boolean;
    /**
     * In USD, as float with no decimals. Collateral values are always positive.
     */
    collateralValue: number;
    /**
     * In USD, as float with no decimals. Includes the discount rate applied to some collateral assets.
     */
    collateralDiscountedValue: number;
    /**
     * In USD, as float with no decimals. Loan values are always negative.
     */
    loanValue: number;
    /**
     * In USD, as float with no decimals. Obligations with debts greater than their collateral value
     * may have negative value (this is rare, and very bad)
     */
    netValue: number;
    /**
     * In USD, as float with no decimals. Obligations with debts greater than their collateral value
     * may have negative value. This is particularly likely when an asset has a large discount
     * applied, which may occur when the asset depegs or experiences a similar black swan event.
     */
    netDiscountedValue: number;
};
//# sourceMappingURL=types.d.ts.map