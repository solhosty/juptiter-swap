'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var web3_js = require('@solana/web3.js');
var spl2 = require('spl2');
var anchor = require('@project-serum/anchor');
var client = require('@pythnetwork/client');

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

const dexDevnetProgramKey = new web3_js.PublicKey("DESVgJVGajEgKGXhb6XmqDHGz3VjdgP7rEVESBgxmroY");
const dexMainnetProgramKey = new web3_js.PublicKey("9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin");
const psyLendDevnetProgramKey = new web3_js.PublicKey("8bpiM4yhcLYMSeCBTVFWisneXPQQWPYSA5ZpMm4DKAgT");
const psyLendMainnetProgramKey = new web3_js.PublicKey("PLENDj46Y4hhqitNV2WqLqGLrWKAaH2xJHm2UyHgJLY");
const psyFiDevnetProgramKey = new web3_js.PublicKey("95q3X9ADJv5hWt93oSaPqABPnP1rqfmjgrnto9v83LPK");
const psyFiMainnetProgramKey = new web3_js.PublicKey("PSYFiYqguvMXwpDooGdYV6mju92YEbFobbvW617VNcq");
/**
 * On all networks (devnet, local, main)
 */
const euroPrimitiveProgramKey = new web3_js.PublicKey("FASQhaZQT53W9eT9wWnPoBFw8xzZDey9TbMmJj6jCQTs");

var keys = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dexDevnetProgramKey: dexDevnetProgramKey,
    dexMainnetProgramKey: dexMainnetProgramKey,
    psyLendDevnetProgramKey: psyLendDevnetProgramKey,
    psyLendMainnetProgramKey: psyLendMainnetProgramKey,
    psyFiDevnetProgramKey: psyFiDevnetProgramKey,
    psyFiMainnetProgramKey: psyFiMainnetProgramKey,
    euroPrimitiveProgramKey: euroPrimitiveProgramKey
});

/**
 * Derive all the associated accounts for a reserve. See {@link deriveReserveAccountsSync} for sync variant.
 * @param program
 * @param reserveAddress The reserve address to derive the accounts for.
 * @param tokenMint The address of the mint for the token stored in the reserve.
 * @returns - accounts and bump seeds needed to create a reserve
 */
const deriveReserveAccounts = (program, reserveAddress, tokenMint) => __awaiter(void 0, void 0, void 0, function* () {
    let accounts = {
        vault: web3_js.PublicKey.default,
        feeNoteVault: web3_js.PublicKey.default,
        dexOpenOrders: web3_js.PublicKey.default,
        dexSwapTokens: web3_js.PublicKey.default,
        loanNoteMint: web3_js.PublicKey.default,
        depositNoteMint: web3_js.PublicKey.default,
    };
    let bumpSeeds = {
        vault: 0,
        feeNoteVault: 0,
        dexOpenOrders: 0,
        dexSwapTokens: 0,
        loanNoteMint: 0,
        depositNoteMint: 0,
    };
    [accounts.vault, bumpSeeds.vault] = yield deriveReserveVault(program.programId, reserveAddress);
    [accounts.feeNoteVault, bumpSeeds.feeNoteVault] =
        yield web3_js.PublicKey.findProgramAddress([Buffer.from("fee-vault"), reserveAddress.toBytes()], program.programId);
    [accounts.dexSwapTokens, bumpSeeds.dexSwapTokens] =
        yield web3_js.PublicKey.findProgramAddress([Buffer.from("dex-swap-tokens"), reserveAddress.toBytes()], program.programId);
    [accounts.dexOpenOrders, bumpSeeds.dexOpenOrders] =
        yield web3_js.PublicKey.findProgramAddress([Buffer.from("dex-open-orders"), reserveAddress.toBytes()], program.programId);
    [accounts.loanNoteMint, bumpSeeds.loanNoteMint] =
        yield web3_js.PublicKey.findProgramAddress([Buffer.from("loans"), reserveAddress.toBytes(), tokenMint.toBytes()], program.programId);
    [accounts.depositNoteMint, bumpSeeds.depositNoteMint] =
        yield deriveDepositNoteMint(program.programId, reserveAddress, tokenMint);
    return { accounts, bumpSeeds };
});
/**
 * Derive all the associated accounts for a reserve.
 * @param programId
 * @param reserveAddress
 * @param tokenMint
 * @returns
 */
const deriveReserveAccountsSync = (programId, reserveAddress, tokenMint) => {
    let accounts = {
        vault: web3_js.PublicKey.default,
        feeNoteVault: web3_js.PublicKey.default,
        dexOpenOrders: web3_js.PublicKey.default,
        dexSwapTokens: web3_js.PublicKey.default,
        loanNoteMint: web3_js.PublicKey.default,
        depositNoteMint: web3_js.PublicKey.default,
    };
    let bumpSeeds = {
        vault: 0,
        feeNoteVault: 0,
        dexOpenOrders: 0,
        dexSwapTokens: 0,
        loanNoteMint: 0,
        depositNoteMint: 0,
    };
    [accounts.vault, bumpSeeds.vault] = deriveReserveVaultSync(programId, reserveAddress);
    [accounts.feeNoteVault, bumpSeeds.feeNoteVault] =
        web3_js.PublicKey.findProgramAddressSync([Buffer.from("fee-vault"), reserveAddress.toBytes()], programId);
    [accounts.dexSwapTokens, bumpSeeds.dexSwapTokens] =
        web3_js.PublicKey.findProgramAddressSync([Buffer.from("dex-swap-tokens"), reserveAddress.toBytes()], programId);
    [accounts.dexOpenOrders, bumpSeeds.dexOpenOrders] =
        web3_js.PublicKey.findProgramAddressSync([Buffer.from("dex-open-orders"), reserveAddress.toBytes()], programId);
    [accounts.loanNoteMint, bumpSeeds.loanNoteMint] =
        web3_js.PublicKey.findProgramAddressSync([Buffer.from("loans"), reserveAddress.toBytes(), tokenMint.toBytes()], programId);
    [accounts.depositNoteMint, bumpSeeds.depositNoteMint] =
        deriveDepositNoteMintSync(programId, reserveAddress, tokenMint);
    return { accounts, bumpSeeds };
};
const deriveDepositNoteMint = (programId, reserveAddress, tokenMint) => __awaiter(void 0, void 0, void 0, function* () {
    return yield web3_js.PublicKey.findProgramAddress([Buffer.from("deposits"), reserveAddress.toBytes(), tokenMint.toBytes()], programId);
});
const deriveDepositNoteMintSync = (programId, reserveAddress, tokenMint) => {
    return web3_js.PublicKey.findProgramAddressSync([Buffer.from("deposits"), reserveAddress.toBytes(), tokenMint.toBytes()], programId);
};
const deriveUserDeposits = (programId, reserveAddress, userAddress) => __awaiter(void 0, void 0, void 0, function* () {
    return yield web3_js.PublicKey.findProgramAddress([Buffer.from("deposits"), reserveAddress.toBytes(), userAddress.toBytes()], programId);
});
const deriveUserDepositsSync = (programId, reserveAddress, userAddress) => {
    return web3_js.PublicKey.findProgramAddressSync([Buffer.from("deposits"), reserveAddress.toBytes(), userAddress.toBytes()], programId);
};
const deriveUserLoan = (programId, reserveAddress, obligationAddress, userAddress) => __awaiter(void 0, void 0, void 0, function* () {
    return yield web3_js.PublicKey.findProgramAddress([
        Buffer.from("loan"),
        reserveAddress.toBytes(),
        obligationAddress.toBytes(),
        userAddress.toBytes(),
    ], programId);
});
const deriveUserLoanSync = (programId, reserveAddress, obligationAddress, userAddress) => {
    return web3_js.PublicKey.findProgramAddressSync([
        Buffer.from("loan"),
        reserveAddress.toBytes(),
        obligationAddress.toBytes(),
        userAddress.toBytes(),
    ], programId);
};
const deriveUserCollateral = (programId, reserveAddress, obligationAddress, userAddress) => __awaiter(void 0, void 0, void 0, function* () {
    return yield web3_js.PublicKey.findProgramAddress([
        Buffer.from("collateral"),
        reserveAddress.toBytes(),
        obligationAddress.toBytes(),
        userAddress.toBytes(),
    ], programId);
});
const deriveUserCollateralSync = (programId, reserveAddress, obligationAddress, userAddress) => {
    return web3_js.PublicKey.findProgramAddressSync([
        Buffer.from("collateral"),
        reserveAddress.toBytes(),
        obligationAddress.toBytes(),
        userAddress.toBytes(),
    ], programId);
};
/**
 * Derives the accounts used in generating a user deposit account on some reserve. See
 * {@link deriveClientReserveAccountsSync} for the sync version
 *
 * Use {@link deriveUserObligation} or {@link deriveUserObligationSync}
 * to get the user's obligation on this market first.
 * @param program
 * @param reserveAddress
 * @param obligationAddress - Derived with {@link deriveUserObligation}
 * @param userAddress
 * @returns
 */
const deriveClientReserveAccounts = (program, reserveAddress, obligationAddress, userAddress) => __awaiter(void 0, void 0, void 0, function* () {
    return yield deriveClientReserveAccountsAlt(program.programId, reserveAddress, obligationAddress, userAddress);
});
/**
 * Same as {@link deriveClientReserveAccounts}, but doesn't require a program, only the id
 * @param programId
 * @param reserveAddress
 * @param obligationAddress
 * @param userAddress
 * @returns
 */
const deriveClientReserveAccountsAlt = (programId, reserveAddress, obligationAddress, userAddress) => __awaiter(void 0, void 0, void 0, function* () {
    let accounts = {
        deposits: web3_js.PublicKey.default,
        loan: web3_js.PublicKey.default,
        collateral: web3_js.PublicKey.default,
    };
    let bumpSeeds = {
        deposits: 0,
        loan: 0,
        collateral: 0,
    };
    [accounts.deposits, bumpSeeds.deposits] = yield deriveUserDeposits(programId, reserveAddress, userAddress);
    [accounts.loan, bumpSeeds.loan] = yield deriveUserLoan(programId, reserveAddress, obligationAddress, userAddress);
    [accounts.collateral, bumpSeeds.collateral] = yield deriveUserCollateral(programId, reserveAddress, obligationAddress, userAddress);
    return { accounts, bumpSeeds };
});
/**
 * Derives the accounts used in generating a user deposit account on some reserve.
 *
 * Use {@link deriveUserObligationSync} to get the user's obligation on this market first.
 * @param programId
 * @param reserveAddress
 * @param obligationAddress
 * @param userAddress
 * @returns
 */
const deriveClientReserveAccountsSync = (programId, reserveAddress, obligationAddress, userAddress) => {
    let accounts = {
        deposits: web3_js.PublicKey.default,
        loan: web3_js.PublicKey.default,
        collateral: web3_js.PublicKey.default,
    };
    let bumpSeeds = {
        deposits: 0,
        loan: 0,
        collateral: 0,
    };
    [accounts.deposits, bumpSeeds.deposits] = deriveUserDepositsSync(programId, reserveAddress, userAddress);
    [accounts.loan, bumpSeeds.loan] = deriveUserLoanSync(programId, reserveAddress, obligationAddress, userAddress);
    [accounts.collateral, bumpSeeds.collateral] = deriveUserCollateralSync(programId, reserveAddress, obligationAddress, userAddress);
    return { accounts, bumpSeeds };
};
/**
 * Returns the user's obligation for a given market. A user has just one obligation for any
 * market, and this is a PDA. The obligation is used to derive loans and collateral for different
 * reserves for that user on that market.
 *
 * See {@link deriveUserObligationSync} for sync version
 * @param program
 * @param marketAddress
 * @param userAddress
 * @returns
 */
const deriveUserObligation = (program, marketAddress, userAddress) => __awaiter(void 0, void 0, void 0, function* () {
    return yield deriveUserObligationAlt(program.programId, marketAddress, userAddress);
});
/**
 * Same as {@link deriveUserObligation}, but doesn't require program, just the id
 * @param programId
 * @param marketAddress
 * @param userAddress
 * @returns
 */
const deriveUserObligationAlt = (programId, marketAddress, userAddress) => __awaiter(void 0, void 0, void 0, function* () {
    let [obligationAccount, obligationBump] = yield web3_js.PublicKey.findProgramAddress([
        Buffer.from("obligation"),
        marketAddress.toBytes(),
        userAddress.toBytes(),
    ], programId);
    return { obligationAccount, obligationBump };
});
/**
 * Returns the user's obligation for a given market. A user has just one obligation for any
 * market, and this is a PDA. The obligation is used to derive loans and collateral for different
 * reserves for that user on that market.
 * @param programId
 * @param marketAddress
 * @param userAddress
 * @returns
 */
const deriveUserObligationSync = (programId, marketAddress, userAddress) => __awaiter(void 0, void 0, void 0, function* () {
    let [obligationAccount, obligationBump] = web3_js.PublicKey.findProgramAddressSync([
        Buffer.from("obligation"),
        marketAddress.toBytes(),
        userAddress.toBytes(),
    ], programId);
    return { obligationAccount, obligationBump };
});
const deriveMarketAuthority = (program, market) => __awaiter(void 0, void 0, void 0, function* () {
    return yield web3_js.PublicKey.findProgramAddress([market.toBytes()], program.programId);
});
/**
 * Same as {@link deriveMarketAuthority}
 * @param programId
 * @param market
 * @returns
 */
const deriveMarketAuthorityAlt = (programId, market) => __awaiter(void 0, void 0, void 0, function* () {
    return yield web3_js.PublicKey.findProgramAddress([market.toBytes()], programId);
});
const deriveMarketAuthoritySync = (programId, market) => __awaiter(void 0, void 0, void 0, function* () {
    return web3_js.PublicKey.findProgramAddressSync([market.toBytes()], programId);
});
const deriveReserveVault = (programId, reserveAddress) => __awaiter(void 0, void 0, void 0, function* () {
    return yield web3_js.PublicKey.findProgramAddress([Buffer.from("vault"), reserveAddress.toBytes()], programId);
});
const deriveReserveVaultSync = (programId, reserveAddress) => {
    return web3_js.PublicKey.findProgramAddressSync([Buffer.from("vault"), reserveAddress.toBytes()], programId);
};
const deriveDiscounts = (program) => __awaiter(void 0, void 0, void 0, function* () {
    return yield web3_js.PublicKey.findProgramAddress([Buffer.from("discounts")], program.programId);
});
const deriveDiscountsAlt = (programId) => __awaiter(void 0, void 0, void 0, function* () {
    return yield web3_js.PublicKey.findProgramAddress([Buffer.from("discounts")], programId);
});
const deriveDiscountsSync = (programId) => {
    return web3_js.PublicKey.findProgramAddressSync([Buffer.from("discounts")], programId);
};
const deriveRewardTokenAccount = (program, marketRewardAddress, stateIndex, rewardTokenMint) => __awaiter(void 0, void 0, void 0, function* () {
    return yield web3_js.PublicKey.findProgramAddress([
        marketRewardAddress.toBytes(),
        new anchor.BN(stateIndex).toArrayLike(Buffer, "le", 1),
        rewardTokenMint.toBytes(),
    ], program.programId);
});
const deriveRewardTokenAccountAlt = (programId, marketRewardAddress, stateIndex, rewardTokenMint) => __awaiter(void 0, void 0, void 0, function* () {
    return yield web3_js.PublicKey.findProgramAddress([
        marketRewardAddress.toBytes(),
        new anchor.BN(stateIndex).toArrayLike(Buffer, "le", 1),
        rewardTokenMint.toBytes(),
    ], programId);
});
const deriveRewardTokenAccountSync = (programId, marketRewardAddress, stateIndex, rewardTokenMint) => {
    return web3_js.PublicKey.findProgramAddressSync([
        marketRewardAddress.toBytes(),
        new anchor.BN(stateIndex).toArrayLike(Buffer, "le", 1),
        rewardTokenMint.toBytes(),
    ], programId);
};

var pdas = /*#__PURE__*/Object.freeze({
    __proto__: null,
    deriveReserveAccounts: deriveReserveAccounts,
    deriveReserveAccountsSync: deriveReserveAccountsSync,
    deriveDepositNoteMint: deriveDepositNoteMint,
    deriveDepositNoteMintSync: deriveDepositNoteMintSync,
    deriveUserDeposits: deriveUserDeposits,
    deriveUserDepositsSync: deriveUserDepositsSync,
    deriveUserLoan: deriveUserLoan,
    deriveUserLoanSync: deriveUserLoanSync,
    deriveUserCollateral: deriveUserCollateral,
    deriveUserCollateralSync: deriveUserCollateralSync,
    deriveClientReserveAccounts: deriveClientReserveAccounts,
    deriveClientReserveAccountsAlt: deriveClientReserveAccountsAlt,
    deriveClientReserveAccountsSync: deriveClientReserveAccountsSync,
    deriveUserObligation: deriveUserObligation,
    deriveUserObligationAlt: deriveUserObligationAlt,
    deriveUserObligationSync: deriveUserObligationSync,
    deriveMarketAuthority: deriveMarketAuthority,
    deriveMarketAuthorityAlt: deriveMarketAuthorityAlt,
    deriveMarketAuthoritySync: deriveMarketAuthoritySync,
    deriveReserveVault: deriveReserveVault,
    deriveReserveVaultSync: deriveReserveVaultSync,
    deriveDiscounts: deriveDiscounts,
    deriveDiscountsAlt: deriveDiscountsAlt,
    deriveDiscountsSync: deriveDiscountsSync,
    deriveRewardTokenAccount: deriveRewardTokenAccount,
    deriveRewardTokenAccountAlt: deriveRewardTokenAccountAlt,
    deriveRewardTokenAccountSync: deriveRewardTokenAccountSync
});

/**
 * Accrues interest for a reserve. Updates the NOTE cache and DATA cache
 * Has to be updated within `TTL` slots from other instructions reading from `cached_note`
 * or cached `ReserveData`
 *
 * As of Aug 2022, TTL is 100 in devnet/localnet, 5 for mainnet
 * @param program
 * @param market - market the reserve is under
 * @param marketAuthority
 * @param reserve
 * @param feeNoteVault - can be extracted from `reserve`
 * @param depositNoteMint - can be extracted from `reserve`
 * @returns
 */
const accrueInterestIx = (program, market, marketAuthority, reserve, feeNoteVault, depositNoteMint) => {
    const ix = program.methods
        .accrueInterest()
        .accounts({
        market,
        marketAuthority,
        reserve,
        feeNoteVault,
        depositNoteMint,
    })
        .instruction();
    return ix;
};
/**
 * Borrows funds against a user's collateral. Requires a general refresh of all reserves the user
 * has borrowed or used as collateral (use: {@link refreshEitherReserveIx}).
 *
 * Loan account must be initialized (see {@link initLoanIx} or {@link getOrInitLoanAccount})
 * @param program
 * @param bump - bump for loan account
 * @param amount - to borrow,
 * @param market - market for the given reserve
 * @param marketAuthority
 * @param reserve - reserve to be borrowed from
 * @param obligation - derived with `deriveUserObligation`, initialized with `initObligationIx`
 * @param vault - can be extracted from `reserve`
 * @param loanNoteMint - can be extracted from `reserve`
 * @param userAddress - typically the user's wallet
 * @param loanAccount - derived with `deriveClientReserveAccounts`, initialized with `initLoanIx`
 * @param receiver - receiver account: borrowed tokens will be transferred here.
 * @returns
 */
const borrowIx = (program, bump, amount, market, marketAuthority, reserve, obligation, vault, loanNoteMint, userAddress, loanAccount, receiver) => {
    const ix = program.methods
        .borrow(bump, amount)
        .accounts({
        market: market,
        marketAuthority: marketAuthority,
        reserve: reserve,
        obligation: obligation,
        vault: vault,
        loanNoteMint: loanNoteMint,
        borrower: userAddress,
        loanAccount: loanAccount,
        receiverAccount: receiver,
        tokenProgram: spl2.TOKEN_PROGRAM_ID,
    })
        .instruction();
    return ix;
};
/**
 * Deposits a user's tokens into a reserve.
 *
 * Only the reserve being deposited into needs to be
 * refreshed, a general refresh of all reserves is NOT needed to deposit. Only the NOTE cache needs
 * to be up-to-date (updated with {@link accrueInterestIx})
 * @param program
 * @param bump - bump for the deposit account
 * @param amount - Specifies units and amount to transfer
 * @param market - market this reserve will be under
 * @param marketAuthority
 * @param depositSource - tokens come from this account
 * @param depositAccount - deposit account, a PDA that can be derived with
 * `deriveClientReserveAccounts`. Deposit notes will transfer here
 * @param userAddress - owns the deposit source, typically users's wallet
 * @param reserve - Deposit target, must be same currency as depositSource
 * @param vault - can be extracted from `reserve`
 * @param depositNoteMint - can be extracted from `reserve`
 * @returns
 */
const depositIx = (program, bump, amount, market, marketAuthority, depositSource, depositAccount, userAddress, reserve, vault, depositNoteMint) => {
    const ix = program.methods
        .deposit(bump, amount)
        .accounts({
        market: market,
        marketAuthority: marketAuthority,
        depositSource: depositSource,
        depositAccount: depositAccount,
        depositor: userAddress,
        reserve: reserve,
        vault: vault,
        depositNoteMint: depositNoteMint,
        tokenProgram: spl2.TOKEN_PROGRAM_ID,
    })
        .instruction();
    return ix;
};
/**
 * Works exactly the same as {@link deposit}, except that the `depositAccount` may be any account,
 * and does not have to be a PDA owned by this program.
 *
 * Use this IX only when the user wants to transfer deposit notes outside of the program. A user may
 * wish to do this in order to stake these notes or trade them externally.
 * @param program
 * @param amount
 * @param market
 * @param marketAuthority
 * @param depositSource
 * @param depositAccount - typically an ATA created `createAssociatedTokenAccountInstruction`, using
 * the reserve's depositNoteMint. Any account that can hold deposit notes is acceptable.
 * @param userAddress
 * @param reserve
 * @param vault
 * @param depositNoteMint
 * @returns
 */
const depositTokensIx = (program, 
// bump: number,
amount, market, marketAuthority, depositSource, depositAccount, userAddress, reserve, vault, depositNoteMint) => {
    const ix = program.methods
        .depositTokens(amount)
        .accounts({
        market: market,
        marketAuthority: marketAuthority,
        depositSource: depositSource,
        depositAccount: depositAccount,
        depositor: userAddress,
        reserve: reserve,
        vault: vault,
        depositNoteMint: depositNoteMint,
        tokenProgram: spl2.TOKEN_PROGRAM_ID,
    })
        .instruction();
    return ix;
};
/**
 * Used to transfer funds from the deposit account to the collateral account, where are they able to
 * used for borrowing. Deposit, Collateral and Obligation accounts should have been initalized.
 *
 * Only the reserve being deposited into needs to be
 * refreshed, a general refresh of all reserves is NOT needed to deposit. Only the NOTE cache needs
 * to be up-to-date (updated with {@link accrueInterestIx})
 * @param program
 * @param bumps - derived with `deriveClientReserveAccounts`
 * @param amount - to transfer from deposit to collateral
 * @param market - market for this reserve
 * @param marketAuthority
 * @param obligation - derived with `deriveUserObligation`, initialized with `initObligationIx`
 * @param depositAccount - derived with `deriveClientReserveAccounts`, initialized with `initDepositAccountIx`
 * @param collateralAccount - derived with `deriveClientReserveAccounts`, initialized with `initCollateralIx`
 * @param userAddress - typically the user's wallet
 * @param reserve - collateral accounts are reserve-specific
 * @returns
 */
const depositCollateralIx = (program, bumps, amount, market, marketAuthority, obligation, depositAccount, collateralAccount, userAddress, reserve) => {
    const ix = program.methods
        .depositCollateral(bumps, amount)
        .accounts({
        market: market,
        marketAuthority,
        reserve,
        obligation,
        owner: userAddress,
        depositAccount,
        collateralAccount,
        tokenProgram: spl2.TOKEN_PROGRAM_ID,
    })
        .instruction();
    return ix;
};
/**
 * How many rates the Discounts account holds.
 *
 * Mirrors value in discounts.rs
 */
const MAX_DISCOUNT_RATES = 20;
/**
 * Initializes the discounts account, which tracks which tokens are valued at less than their face
 * value for collateral and liquidation purposes.
 *
 * Generally, you should run {@link syncDiscountRates} for any reserve that uses the tokens for
 * which rates were changed.
 * @param program
 * @param authority - signs any future updates to this account
 * @param payer
 * @param discounts
 * @param mintAddresses - addresses of token mints that will be discounted. Array must be of
 * size `MAX_DISCOUNT_RATES`, unused slots can be filled with default key.
 * @param discountRates - for each mint, discount, expressed as a % multiplied by the common
 * rates/bps denominator of 10,000, e.g. 5% = .05 * 10,000 = 500. Array must be of
 * size `MAX_DISCOUNT_RATES`, unused slots can be filled with 0
 * @returns
 */
const initDiscountsIx = (program, authority, payer, discounts, mintAddresses, discountRates) => {
    const ix = program.methods
        .initDiscounts(mintAddresses, discountRates)
        .accounts({
        signer: authority,
        payer,
        discounts: discounts,
    })
        .instruction();
    return ix;
};
/**
 * Updates the discounts account, which tracks which tokens are valued at less than their face
 * value for collateral and liquidation purposes.
 *
 * Generally, you should run {@link syncDiscountRates} for any reserve that uses the tokens for
 * which rates were changed.
 * @param program
 * @param authority - whoever created the account with `initDiscountsIx` and is authorized to update.
 * @param discounts
 * @param mintAddresses - addresses of token mints that will be discounted. Array must be of
 * size `MAX_DISCOUNT_RATES`, unused slots can be filled with default key.
 * @param discountRates - for each mint, discount, expressed as a % multiplied by the common
 * rates/bps denominator of 10,000, e.g. 5% = .05 * 10,000 = 500. Array must be of
 * size `MAX_DISCOUNT_RATES`, unused slots can be filled with 0
 * @returns
 */
const updateDiscountsIx = (program, authority, discounts, mintAddresses, discountRates) => {
    const ix = program.methods
        .updateDiscounts(mintAddresses, discountRates)
        .accounts({
        authority: authority,
        discounts: discounts,
    })
        .instruction();
    return ix;
};
/**
 * Iniitalizes a market. You may wish to initialize the market
 * by creating the account (with the System program)
 * @param program
 * @param owner
 * @param quoteCurrencyName
 * @param quoteCurrencyMint
 * @param market - also is the signer of the IX
 * @returns
 */
const initMarketIx = (program, owner, quoteCurrencyMint, quoteCurrencyName, market) => {
    const ix = program.methods
        .initMarket(owner, quoteCurrencyName, quoteCurrencyMint)
        .accounts({
        market,
    })
        .instruction();
    return ix;
};
/**
 * Iniitalizes a reserve for some currency. Add optional psyfi vault arguments to intialize a
 * psyfi reserve that trades on vault tokens, or use {@link initPsyfiReserveIx}.
 *
 * You may wish to initialize the reserve by creating the account (with the System program)
 *
 * Note: for usdc, the quotetokenmint and tokenmint are probably the same (usdc)
 * @param program
 * @param bumpSeeds - for derived pdas in `reserveAccounts`
 * @param reserveConfig
 * @param market - market this reserve will be under
 * @param marketAuthority - market authority
 * @param owner
 * @param payer
 * @param pythOracleProduct - product quote currency must match quote currency of market
 * @param pythOraclePrice
 * @param reserve - should be initialized to the correct size
 * @param reserveAccounts - derive these pdas, but do not initialize them
 * @param dexMarket
 * @param quoteTokenMint - quote token of the market, generally usdc
 * @param tokenMint - mint for the currency this reserve tracks
 * @param isDevnet - true if testing on devnet, false for mainnet, used to pick the dex id
 * @param optional - { psyfiVaultAccount, collateralAssetMint}
 *
 * @returns
 */
const initReserveIx = (program, bumpSeeds, reserveConfig, market, marketAuthority, owner, payer, pythOracleProduct, pythOraclePrice, reserve, reserveAccounts, dexMarket, quoteTokenMint, tokenMint, isDevnet, optional) => {
    //type InitReserveBumpSeeds = IdlTypes<PsyLend>["InitReserveBumpSeeds"];
    let context = {
        market: market,
        marketAuthority: marketAuthority,
        reserve: reserve,
        vault: reserveAccounts.vault,
        dexSwapTokens: reserveAccounts.dexSwapTokens,
        dexOpenOrders: reserveAccounts.dexOpenOrders,
        dexMarket: dexMarket,
        tokenMint: tokenMint,
        tokenProgram: spl2.TOKEN_PROGRAM_ID,
        dexProgram: getDexId(isDevnet),
        oraclePrice: pythOraclePrice,
        oracleProduct: pythOracleProduct,
        depositNoteMint: reserveAccounts.depositNoteMint,
        loanNoteMint: reserveAccounts.loanNoteMint,
        quoteTokenMint: quoteTokenMint,
        feeNoteVault: reserveAccounts.feeNoteVault,
        owner: owner,
        payer: payer,
        systemProgram: web3_js.SystemProgram.programId,
        rent: web3_js.SYSVAR_RENT_PUBKEY,
    };
    if ((optional === null || optional === void 0 ? void 0 : optional.psyfiVaultAccount) && (optional === null || optional === void 0 ? void 0 : optional.collateralAssetMint)) {
        context.psyfiVaultAccount = optional.psyfiVaultAccount;
        context.collateralAssetMint = optional.collateralAssetMint;
        return program.methods
            .initPsyfiReserve(bumpSeeds, reserveConfig)
            .accounts(context)
            .instruction();
    }
    return program.methods
        .initReserve(bumpSeeds, reserveConfig)
        .accounts(context)
        .instruction();
};
/**
 * Iniitalizes a reserve that tracks a Psyfi vault token.
 * See {@link initReserveIx} for assets that are not vault tokens.
 * You may wish to initialize the reserve by creating the account (with the System program)
 *
 * Note: for usdc, the quotetokenmint and tokenmint are probably the same (usdc)
 * @param program
 * @param bumpSeeds - for derived pdas in `reserveAccounts`
 * @param reserveConfig
 * @param market - market this reserve will be under
 * @param marketAuthority - market authority
 * @param owner
 * @param payer
 * @param pythOracleProduct - product quote currency must match quote currency of market
 * @param pythOraclePrice
 * @param reserve - should be initialized to the correct size
 * @param reserveAccounts - derive these pdas, but do not initialize them
 * @param dexMarket
 * @param quoteTokenMint - quote token of the market, generally usdc
 * @param tokenMint - mint for the currency this reserve tracks
 * @param psyfiVault - vault that issues ownership tokens this reserve tracks
 * @param psyfiCollateralMint - collateral mint used by vault
 * @param isDevnet - true if testing on devnet, false for local, used to get the dex id
 * @returns
 */
const initPsyfiReserveIx = (program, bumpSeeds, reserveConfig, market, marketAuthority, owner, payer, pythOracleProduct, pythOraclePrice, reserve, reserveAccounts, dexMarket, quoteTokenMint, tokenMint, psyfiVault, psyfiCollateralMint, isDevnet) => {
    const ix = program.methods
        .initPsyfiReserve(bumpSeeds, reserveConfig)
        .accounts({
        market: market,
        marketAuthority: marketAuthority,
        owner: owner,
        payer,
        oracleProduct: pythOracleProduct,
        oraclePrice: pythOraclePrice,
        reserve: reserve,
        vault: reserveAccounts.vault,
        feeNoteVault: reserveAccounts.feeNoteVault,
        dexSwapTokens: reserveAccounts.dexSwapTokens,
        dexOpenOrders: reserveAccounts.dexOpenOrders,
        loanNoteMint: reserveAccounts.loanNoteMint,
        depositNoteMint: reserveAccounts.depositNoteMint,
        dexMarket: dexMarket,
        quoteTokenMint: quoteTokenMint,
        tokenMint: tokenMint,
        psyfiVaultAccount: psyfiVault,
        collateralAssetMint: psyfiCollateralMint,
        tokenProgram: spl2.TOKEN_PROGRAM_ID,
        dexProgram: getDexId(isDevnet),
        rent: web3_js.SYSVAR_RENT_PUBKEY,
        systemProgram: web3_js.SystemProgram.programId,
    })
        .instruction();
    return ix;
};
/**
 * Creates a deposit account for the given user
 * @param program
 * @param bump
 * @param market - market the reserve is under
 * @param marketAuthority
 * @param reserve - a deposit account is reserve-specific: make a new account per reserve
 * @param depositNoteMint - can be extracted from `reserve`
 * @param userAddress - generally the user's wallet
 * @param depositAccount - the account to be created: a PDA that can be derived with `deriveClientReserveAccounts`
 * @returns
 */
const initDepositAccountIx = (program, bump, market, marketAuthority, reserve, depositNoteMint, userAddress, depositAccount) => {
    const ix = program.methods
        .initDepositAccount(bump)
        .accounts({
        market: market,
        marketAuthority: marketAuthority,
        reserve: reserve,
        depositNoteMint: depositNoteMint,
        depositor: userAddress,
        depositAccount: depositAccount,
        tokenProgram: spl2.TOKEN_PROGRAM_ID,
        systemProgram: web3_js.SystemProgram.programId,
        rent: web3_js.SYSVAR_RENT_PUBKEY,
    })
        .instruction();
    return ix;
};
/**
 * Initializes the obligation account for a user on the given market. This must be done before any
 * collateral can be deposited with `deposit_collateral`.
 * @param program
 * @param bump - derived with `deriveUserObligation`
 * @param market - market for this obligation
 * @param marketAuthority
 * @param obligation - derived with `deriveUserObligation`
 * @param userAddress - the borrower's address, typically the user's wallet
 * @returns
 */
const initObligationIx = (program, bump, market, marketAuthority, obligation, userAddress) => {
    const ix = program.methods
        .initObligation(bump)
        .accounts({
        market: market,
        marketAuthority: marketAuthority,
        obligation: obligation,
        borrower: userAddress,
        tokenProgram: spl2.TOKEN_PROGRAM_ID,
        systemProgram: web3_js.SystemProgram.programId,
    })
        .instruction();
    return ix;
};
/**
 * Initiailizes a collateral account for a user. Collateral accounts are specific to a single
 * reserve. The obligation for this user should have been initialized already with {@link initObligationIx}
 * @param program
 * @param bump - derived with `deriveClientReserveAccounts`.
 * @param market - market for the reserve and obligation
 * @param marketAuthority
 * @param reserve - collateral accounts are reserve-specific
 * @param depositNoteMint - can be extracted from `reserve`
 * @param userAddress - typically the user's wallet
 * @param obligation - derived with `deriveUserObligation`
 * @param collateralAccount - derived with `deriveClientReserveAccounts`. Deposit notes used as
 * collateral will be held here
 * @returns
 */
const initCollateralIx = (program, bump, market, marketAuthority, reserve, depositNoteMint, userAddress, obligation, collateralAccount) => {
    const ix = program.methods
        .initCollateralAccount(bump)
        .accounts({
        market: market,
        marketAuthority: marketAuthority,
        obligation: obligation,
        reserve: reserve,
        depositNoteMint: depositNoteMint,
        owner: userAddress,
        collateralAccount: collateralAccount,
        tokenProgram: spl2.TOKEN_PROGRAM_ID,
        systemProgram: web3_js.SystemProgram.programId,
        rent: web3_js.SYSVAR_RENT_PUBKEY,
    })
        .instruction();
    return ix;
};
/**
 * Initiailizes a loan account for a user. Loan accounts are specific to a single
 * reserve. The obligation for this user should have been initialized already with {@link initObligationIx}
 * @param program
 * @param bump - derived with `deriveClientReserveAccounts`.
 * @param market - market for the reserve and obligation
 * @param marketAuthority
 * @param reserve - loan accounts are reserve-specific
 * @param loanNoteMint - can be extracted from `reserve`
 * @param userAddress - typically the user's wallet
 * @param obligation - derived with `deriveUserObligation`
 * @param loanAccount - derived with `deriveClientReserveAccounts`.
 * @returns
 */
const initLoanIx = (program, bump, market, marketAuthority, reserve, loanNoteMint, userAddress, obligation, loanAccount) => {
    const ix = program.methods
        .initLoanAccount(bump)
        .accounts({
        market: market,
        marketAuthority: marketAuthority,
        reserve: reserve,
        loanNoteMint: loanNoteMint,
        owner: userAddress,
        obligation: obligation,
        loanAccount: loanAccount,
        tokenProgram: spl2.TOKEN_PROGRAM_ID,
        systemProgram: web3_js.SystemProgram.programId,
        rent: web3_js.SYSVAR_RENT_PUBKEY,
    })
        .instruction();
    return ix;
};
/**
 * A liquidator calls this instruction on a user whose obligation is underwater to seize a portion of
 * their collateral and repay a portion of their loan.
 * @param program
 * @param amount - amount being repaid (in tokens or loan notes)
 * @param minCollateral - min collateral to accept (in deposit notes)
 * @param market - market for all reserves involved
 * @param marketAuthority - market authority
 * @param userObligation - user's obligation whose loan is repaid for. Must be unhealthy
 * @param reserve - the reserve with the DEBT borrowed (hereafter called `reserve`)
 * @param collateralReserve - the reserve with collateral to seize (hereafter called `collateralReserve`)
 * @param vault - `reserve` vault (TODO does nothing?)
 * @param loanNoteMint - mint for debt/loan notes on `reserve`
 * @param loanAccount - users's loan account on `reserve`
 * @param collateralAccount - user's collateral acc on `collateralReserve`
 * @param payerAccount - The liquidator's token account for the asset being repaid
 * @param receiverAccount -- Account receiving liquidated collateral. Typically owned by the liquidator.
 * Note that this must be a collateral account on the same reserve. The collateral being liquidated is
 * stored as *deposit notes* in the collateral account, not the actual collateral token
 * @param payer - signs tx, owns the payer account
 * @param receiverObligation - receiver's obligation
 * @returns
 */
const liquidateIx = (program, amount, minCollateral, market, marketAuthority, userObligation, reserve, collateralReserve, vault, loanNoteMint, loanAccount, collateralAccount, payerAccount, receiverAccount, payer, receiverObligation) => {
    const ix = program.methods
        .liquidate(amount, minCollateral)
        .accounts({
        market: market,
        marketAuthority: marketAuthority,
        obligation: userObligation,
        reserve: reserve,
        collateralReserve: collateralReserve,
        vault: vault,
        loanNoteMint: loanNoteMint,
        loanAccount: loanAccount,
        collateralAccount: collateralAccount,
        payerAccount: payerAccount,
        receiverAccount: receiverAccount,
        receiverObligation,
        payer: payer,
    })
        .instruction();
    return ix;
};
/**
 * Updates various reserve properties. Updates the INFO cache.
 * Must be invoked first, in the same tx, as most transactions that read the status of a reserve.
 *
 * For reserves backed by a vault, use {@link refreshPsyfiReserveIx} instead
 * @param program
 * @param market - market the reserve is under
 * @param reserve
 * @param pythOraclePrice - can be extracted from `reserve`
 * @returns
 */
const refreshReserveIx = (program, market, reserve, pythOraclePrice) => {
    const ix = program.methods
        .refreshReserve()
        .accounts({
        market: market,
        reserve: reserve,
        pythOraclePrice: pythOraclePrice,
    })
        .instruction();
    return ix;
};
/**
 * Updates various reserve properties. Updates the INFO cache.
 * Must be invoked first, in the same tx, as most transactions that read the status of a reserve.
 *
 * For reserves backed by currency that is not a vault token, use {@link refreshReserveIx} instead
 * @param program
 * @param market - market the reserve is under
 * @param reserve
 * @param vaultAccount - the vault that the ownership tokens for this reserve come from
 * @param pythOraclePrice - can be extracted from `reserve`
 * @returns
 */
const refreshPsyfiReserveIx = (program, market, reserve, vaultAccount, pythOraclePrice) => {
    const ix = program.methods
        .refreshPsyfiReserve()
        .accounts({
        market: market,
        reserve: reserve,
        psyfiVaultAccount: vaultAccount,
        pythOraclePrice: pythOraclePrice,
    })
        .instruction();
    return ix;
};
/**
 * Updates various reserve properties. Updates the INFO cache.
 * Must be invoked first, in the same tx, as most transactions that read the status of a reserve.
 *
 * Executes {@link refreshReserveIx} or {@link refreshPsyfiReserveIx} instead if a
 * `psyfiVaultAccount` is provided
 * @param program
 * @param market - market the reserve is under
 * @param reserve
 * @param pythOraclePrice - can be extracted from `reserve`
 * @param psyfiVaultAccount - optional. If provided, uses `refreshPsyfiReserve` Ix.
 * @returns
 */
const refreshEitherReserveIx = (program, market, reserve, pythOraclePrice, psyfiVaultAccount) => {
    if (psyfiVaultAccount && psyfiVaultAccount != undefined) {
        return program.methods
            .refreshPsyfiReserve()
            .accounts({
            market: market,
            reserve: reserve,
            pythOraclePrice: pythOraclePrice,
            psyfiVaultAccount: psyfiVaultAccount,
        })
            .instruction();
    }
    else {
        return program.methods
            .refreshReserve()
            .accounts({
            market: market,
            reserve: reserve,
            pythOraclePrice: pythOraclePrice,
        })
            .instruction();
    }
};
/**
 * Repays a borrowed debt. Requires a general refresh of all reserves the user
 * has borrowed or used as collateral (use: {@link refreshEitherReserveIx}).
 * @param program
 * @param amount - to repay (deducts balance from loan account)
 * @param market - market the reserve is under
 * @param marketAuthority
 * @param userAddress - typically the user's wallet, owns the payer account
 * @param reserve
 * @param vault - can be extracted from `reserve`
 * @param obligation - derived with `deriveUserObligation`
 * @param loanNoteMint - can be extracted from `reserve`
 * @param loanAccount - derived with `deriveClientReserveAccounts`
 * @param payerAccount - user's payment account, tokens will be transferred from here
 * @returns
 */
const repayIx = (program, amount, market, marketAuthority, userAddress, reserve, vault, obligation, loanNoteMint, loanAccount, payerAccount) => {
    const ix = program.methods
        .repay(amount)
        .accounts({
        market: market,
        marketAuthority: marketAuthority,
        payer: userAddress,
        reserve: reserve,
        vault: vault,
        obligation: obligation,
        loanNoteMint: loanNoteMint,
        loanAccount: loanAccount,
        payerAccount: payerAccount,
        tokenProgram: spl2.TOKEN_PROGRAM_ID,
    })
        .instruction();
    return ix;
};
/**
 * Modifies a market to halt borrows, repays, or deposits
 * @param program
 * @param flags - use `MarketFlags` to generate
 * @param market - market to modify
 * @param owner - market owner, should sign
 * @returns
 */
const setMarketFlagsIx = (program, flags, market, owner) => __awaiter(void 0, void 0, void 0, function* () {
    const ix = program.methods
        .setMarketFlags(flags)
        .accounts({
        market: market,
        owner: owner,
    })
        .instruction();
    return ix;
});
/**
 * Orders a reserve to update its discount rate from the common discounts account that all rates are
 * stored in. Should run after {@link updateDiscountsIx} for each reserve that uses a token that had
 * its rate updated.
 *
 * If the reserve's `discount_rate_version` is less than or equal to the current
 * `discounts.version`, does nothing. If the discounts account no longer features a rate for the
 * token the reserve tracks, resets the rate to the default and resets the version to 0.
 *
 * This is a permissionless instruction.
 * @param program
 * @param reserve
 * @returns
 */
const syncDiscountRates = (program, reserve) => __awaiter(void 0, void 0, void 0, function* () {
    let [discountsKey] = web3_js.PublicKey.findProgramAddressSync([Buffer.from("discounts")], program.programId);
    const ix = program.methods
        .syncDiscountRates()
        .accounts({
        reserve: reserve,
        discounts: discountsKey,
    })
        .instruction();
    return ix;
});
/**
 * Modifies the reserve to use the specified configuration settings. Can update borrow rates,
 * interest, origination fees, etc.
 * @param program
 * @param config - a `ReserveConfig` struct
 * @param market - market the reserve is under
 * @param reserve
 * @param owner - market owner
 * @returns
 */
const updateReserveConfigIx = (program, config, market, reserve, owner) => __awaiter(void 0, void 0, void 0, function* () {
    const ix = program.methods
        .updateReserveConfig(config)
        .accounts({
        market: market,
        reserve: reserve,
        owner: owner,
    })
        .instruction();
    return ix;
});
/**
 * Halts or resumes borrows, repays, deposits, or withdraws on this reserve.
 * @param program
 * @param halts - 0 = resume all, 1 = halt deposits, 2 = halt borrows, 4 = halt repays, 8 = halt
 * withdraws. Can add to halt multiple, e.g. 1 + 4 = 5, to halt deposits and repays only
 * @param market - market the reserve is under
 * @param reserve
 * @param owner - market owner
 * @returns
 */
const updateReserveHaltsIx = (program, halts, market, reserve, owner) => __awaiter(void 0, void 0, void 0, function* () {
    const ix = program.methods
        .updateReserveHalts(halts)
        .accounts({
        market: market,
        reserve: reserve,
        owner: owner,
    })
        .instruction();
    return ix;
});
/**
 * Transfers funds from the deposits account to the user's destination of choice.
 *
 * Requires the reserve being withdrawn from to have an updated NOTE cache (updated with
 * {@link accrueInterestIx}).
 * @param program
 * @param depositBump - derived with `deriveClientReserveAccounts`
 * @param amount - to transfer from deposits account to receiver account
 * @param market - market the reserve is under
 * @param marketAuthority
 * @param receiver - account where the funds will be sent
 * @param depositAccount - derived with `deriveClientReserveAccounts`
 * @param userAddress - typically the user's wallet
 * @param reserve
 * @param vault - can be extracted from `reserve`
 * @param depositNoteMint - can be extracted from `reserve`
 * @param isDevnet - true if devnet, false if mainnet. Determines which PsyLend IDL is used.
 * @returns
 */
const withdrawIX = (program, depositBump, amount, market, marketAuthority, receiver, depositAccount, userAddress, reserve, vault, depositNoteMint, isDevnet = false) => {
    const ix = program.methods
        .withdraw(depositBump, amount)
        .accounts({
        market: market,
        marketAuthority: marketAuthority,
        withdrawAccount: receiver,
        depositAccount: depositAccount,
        depositor: userAddress,
        reserve: reserve,
        vault: vault,
        depositNoteMint: depositNoteMint,
        psyProgram: getPsyLendId(isDevnet),
        tokenProgram: spl2.TOKEN_PROGRAM_ID,
    })
        .instruction();
    return ix;
};
/**
 * Same as {@link withdrawIX}, except that the depositAccount can be any external account, not just a
 * deposit account owned by this program.
 *
 * Typically, use this ix after depositing some funds with {@link depositTokensIx}
 * @param program
 * @param amount - to transfer from deposits account to receiver account
 * @param market - market the reserve is under
 * @param marketAuthority
 * @param receiver - account where the funds will be sent
 * @param depositAccount - typically an ATA with some deposit notes to be redeemed. Any account that
 * can hold deposit notes is acceptable.
 * @param userAddress - typically the user's wallet
 * @param reserve
 * @param vault - can be extracted from `reserve`
 * @param depositNoteMint - can be extracted from `reserve`
 * @returns
 */
const withdrawTokensIX = (program, amount, market, marketAuthority, receiver, depositAccount, userAddress, reserve, vault, depositNoteMint) => {
    const ix = program.methods
        .withdrawTokens(amount)
        .accounts({
        market: market,
        marketAuthority: marketAuthority,
        withdrawAccount: receiver,
        depositAccount: depositAccount,
        depositor: userAddress,
        reserve: reserve,
        vault: vault,
        depositNoteMint: depositNoteMint,
        tokenProgram: spl2.TOKEN_PROGRAM_ID,
    })
        .instruction();
    return ix;
};
/**
 * Transfers funds from the collateral account to the deposit account, if obligation allows. A
 * refresh of all reserves that apply to the user is required
 *
 * Requires the reserve being withdrawn from to have an updated NOTE cache (updated with
 * {@link accrueInterestIx}).
 *
 * Requires a general refresh of all reserves the user
 * has borrowed or used as collateral (use: {@link refreshEitherReserveIx}).
 * @param program
 * @param bumps - derived with `deriveClientReserveAccounts`, packaged as `WithdrawCollateralBumpSeeds`
 * @param amount - to withdraw into deposits account
 * @param market - market the reserve is under
 * @param marketAuthority
 * @param userAddress - typically the user's wallet
 * @param obligation - derived with `deriveUserObligation`
 * @param reserve
 * @param collateralAccount - derived with `deriveClientReserveAccounts`
 * @param depositAccount - derived with `deriveClientReserveAccounts`
 * @returns
 */
const withdrawCollateralIx = (program, bumps, amount, market, marketAuthority, userAddress, obligation, reserve, collateralAccount, depositAccount) => {
    const ix = program.methods
        .withdrawCollateral(bumps, amount)
        .accounts({
        market: market,
        marketAuthority: marketAuthority,
        owner: userAddress,
        obligation: obligation,
        reserve: reserve,
        collateralAccount: collateralAccount,
        depositAccount: depositAccount,
        tokenProgram: spl2.TOKEN_PROGRAM_ID,
    })
        .instruction();
    return ix;
};
/**
 * Initializes the MarketRewardState struct stored in Market account that contains
 * market-level config and MarketReward account that stores the reward tokens claimable.
 *
 * This should be invoked after initialization of Market and before the lending activies start used.
 * MarketReward account has to be created and assigned to the program as owner before this is called.
 *
 * Note: Account needs to be created before running this ix, or use `createAndInitMarketReward` to
 * create the account and run this ix.
 *
 * @param program
 * @param market - market the reserve is under
 * @param owner - owner of market
 * @param marketReward - public key of the MarketReward account.
 * @param initialRewardIndexTimestamp - timestamp when rewards will start to be distributed
 * @param distributionPeriod - duration of each distribution period in seconds
 * @param rewardPointsPerPeriod - reward points to be distributed across whole market per period
 * @param rewardUnitDecimals - number of decimals to store reward points in
 * @param minWithdrawalDuration - min duration from start of period, after which rewards claim is allowed
 * @returns TransactionInstruction
 */
const initMarketRewardIx = (program, market, owner, marketReward, initialRewardIndexTimestamp, distributionPeriod, rewardPointsPerPeriod, rewardUnitDecimals, minWithdrawalDuration) => __awaiter(void 0, void 0, void 0, function* () {
    const ix = yield program.methods
        .initMarketReward(initialRewardIndexTimestamp, distributionPeriod, rewardPointsPerPeriod, rewardUnitDecimals, minWithdrawalDuration)
        .accounts({
        market,
        owner,
        marketReward,
        systemProgram: web3_js.SystemProgram.programId,
    })
        .instruction();
    return ix;
});
/**
 * Updates `MarketReward` to set the reward token mint and initialize the reward token
 * account for a particular RewardState (aka period).
 *
 * @param program
 * @param market - market the reserve is under
 * @param owner - owner of market
 * @param payer - payer for token account init
 * @param marketReward - public key of the MarketReward account.
 * @param marketAuthority - PDA for market
 * @param stateIndex - index of RewardState/period to modify
 * @param infoIndex - index of RewardInfo to modify within that RewardState
 * @param rewardTokenMint - reward token mint to issue
 * @returns TransactionInstruction
 */
const updateMarketRewardIx = (program, market, owner, payer, marketReward, marketAuthority, stateIndex, infoIndex, rewardTokenMint) => __awaiter(void 0, void 0, void 0, function* () {
    const [rewardTokenAccount] = yield deriveRewardTokenAccount(program, marketReward, stateIndex, rewardTokenMint);
    const ix = yield program.methods
        .updateMarketReward(stateIndex, infoIndex)
        .accounts({
        market,
        marketAuthority,
        marketReward,
        owner,
        payer,
        rewardTokenMint,
        rewardTokenAccount,
        rent: web3_js.SYSVAR_RENT_PUBKEY,
        systemProgram: web3_js.SystemProgram.programId,
        tokenProgram: spl2.TOKEN_PROGRAM_ID,
    })
        .instruction();
    return ix;
});
/**
 * Updates `MarketRewardState` in Market to change config.
 *
 * @param program
 * @param market - market the reserve is under
 * @param owner - owner of market
 * @param minWithdrawalDuration - min duration from start of period, after which rewards claim is allowed
 * @returns TransactionInstruction
 */
const updateMarketRewardConfigIx = (program, market, owner, minWithdrawalDuration) => __awaiter(void 0, void 0, void 0, function* () {
    const ix = yield program.methods
        .updateMarketRewardConfig(minWithdrawalDuration)
        .accounts({
        market,
        owner,
    })
        .instruction();
    return ix;
});
/**
 * Updates `Reserve` to the deposit and borrow reward multipliers that
 * will determine the fractional allocation of reward points to this
 * reserve on supply and borrow side.
 *
 * @param program
 * @param market - market the reserve is under
 * @param reserve
 * @param owner - owner of market
 * @param depositRewardMultiplier - value between 0 to 255
 * @param borrowRewardMultiplier - value between 0 to 255
 * @returns TransactionInstruction
 */
const updateReserveRewardIx = (program, market, reserve, owner, depositRewardMultiplier, borrowRewardMultiplier) => __awaiter(void 0, void 0, void 0, function* () {
    return yield program.methods
        .updateReserveReward(depositRewardMultiplier, borrowRewardMultiplier)
        .accounts({
        market,
        reserve,
        owner,
    })
        .instruction();
});
/**
 * Used for claiming reward tokens in exchange for reward units
 * stored in an `Obligation`.
 *
 * Each reward token account has to correspond in the same order
 * as RewardInfo in MarketReward for the period. Receiving token
 * accounts has to match the same sequence as reward token accounts.
 *
 * @param program
 * @param market - market the reserve is under
 * @param owner - owner of obligation
 * @param marketReward - MarketReward account
 * @param marketAuthority - PDA of market's authority
 * @param obligation
 * @param periodToClaim - the period to claim rewards for
 * @param rewardTokenAccounts - Array of reward token accounts, matching RewardInfo
 * @param receivingTokenAccounts - Array of token accounts, owned by owner
 * @returns TransactionInstruction
 */
const claimRewardsIx = (program, market, owner, marketReward, marketAuthority, obligation, periodToClaim, rewardTokenAccounts, receivingTokenAccounts) => __awaiter(void 0, void 0, void 0, function* () {
    let remainingAccounts = [];
    for (let i = 0; i < rewardTokenAccounts.length; i++) {
        remainingAccounts.push({
            pubkey: rewardTokenAccounts[i],
            isSigner: false,
            isWritable: true,
        });
        remainingAccounts.push({
            pubkey: receivingTokenAccounts[i],
            isSigner: false,
            isWritable: true,
        });
    }
    const ix = yield program.methods
        .claimRewards(periodToClaim)
        .accounts({
        market,
        marketAuthority,
        marketReward,
        owner,
        obligation,
        tokenProgram: spl2.TOKEN_PROGRAM_ID,
    })
        .remainingAccounts(remainingAccounts)
        .instruction();
    return ix;
});
/**
 * Used for accruing rewards for a user's `Position` in an `Obligation`.
 *
 * @param program
 * @param market - market the reserve is under
 * @param reserve
 * @param obligation
 * @param obligationOwner - owner of obligation
 * @param positionAccount - the collateral or loan account to accrue for
 * @param side - 0 for collateral, 1 for loan.
 * @returns TransactionInstruction
 */
const accruePositionRewardIx = (program, market, reserve, obligation, obligationOwner, positionAccount, side) => __awaiter(void 0, void 0, void 0, function* () {
    const ix = yield program.methods
        .accruePositionReward(side)
        .accounts({
        market,
        reserve,
        obligation,
        owner: obligationOwner,
        positionAccount,
    })
        .instruction();
    return ix;
});
const closeDepositAccountIx = (program, market, reserve, tokenMint, depositor, receiverAccount) => __awaiter(void 0, void 0, void 0, function* () {
    const [marketAuthority] = yield deriveMarketAuthority(program, market);
    const [depositAccount] = yield deriveUserDeposits(program.programId, reserve, depositor);
    const [depositNoteMint] = yield deriveDepositNoteMint(program.programId, reserve, tokenMint);
    const [vault] = yield deriveReserveVault(program.programId, reserve);
    const ix = yield program.methods
        .closeDepositAccount()
        .accounts({
        market,
        marketAuthority,
        reserve,
        vault,
        depositNoteMint,
        depositor,
        depositAccount,
        receiverAccount,
    })
        .instruction();
    return ix;
});
const closeCollateralAccountIx = (program, market, reserve, obligation, owner) => __awaiter(void 0, void 0, void 0, function* () {
    const [marketAuthority] = yield deriveMarketAuthority(program, market);
    const [depositAccount] = yield deriveUserDeposits(program.programId, reserve, owner);
    const [collateralAccount] = yield deriveUserCollateral(program.programId, reserve, obligation, owner);
    const ix = yield program.methods
        .closeCollateralAccount()
        .accounts({
        market,
        marketAuthority,
        obligation,
        owner,
        collateralAccount,
        depositAccount,
    })
        .instruction();
    return ix;
});
const closeLoanAccountIx = (program, market, reserve, obligation, owner) => __awaiter(void 0, void 0, void 0, function* () {
    const [marketAuthority] = yield deriveMarketAuthority(program, market);
    const [loanAccount] = yield deriveUserLoan(program.programId, reserve, obligation, owner);
    const ix = yield program.methods
        .closeLoanAccount()
        .accounts({
        market,
        marketAuthority,
        obligation,
        owner,
        loanAccount,
        tokenProgram: spl2.TOKEN_PROGRAM_ID,
    })
        .instruction();
    return ix;
});
/**
 * Currently does nothing. If the response is ok, the obligation account can be safely closed.
 * @param program
 * @param market
 * @param obligation
 * @param owner
 * @returns
 */
const closeObligationAccountIx = (program, market, obligation, owner) => __awaiter(void 0, void 0, void 0, function* () {
    const [marketAuthority] = yield deriveMarketAuthority(program, market);
    const ix = yield program.methods
        .closeObligation()
        .accounts({
        market,
        marketAuthority,
        owner,
        obligation,
    })
        .instruction();
    return ix;
});
/**
 * Returns the active dex id (local or devnet)
 * @param isDevnet - true if testing on devnet
 * @returns
 */
const getDexId = (isDevnet) => {
    return isDevnet ? dexDevnetProgramKey : dexMainnetProgramKey;
};
/**
 * DEPRECATED: Older versions of PsyLend passed the protocol's own id to certain ixes. This is no
 * longer used.
 *
 * Returns the active PysLend Protocol ID (local or devnet).
 * Note that this is also sometimes called the Jet ID or Jet program in legacy documentation
 * @param isDevnet - true if testing on devnet
 * @returns
 */
const getPsyLendId = (isDevnet) => {
    return isDevnet ? psyLendDevnetProgramKey : psyLendMainnetProgramKey;
};

var instructions = /*#__PURE__*/Object.freeze({
    __proto__: null,
    accrueInterestIx: accrueInterestIx,
    borrowIx: borrowIx,
    depositIx: depositIx,
    depositTokensIx: depositTokensIx,
    depositCollateralIx: depositCollateralIx,
    MAX_DISCOUNT_RATES: MAX_DISCOUNT_RATES,
    initDiscountsIx: initDiscountsIx,
    updateDiscountsIx: updateDiscountsIx,
    initMarketIx: initMarketIx,
    initReserveIx: initReserveIx,
    initPsyfiReserveIx: initPsyfiReserveIx,
    initDepositAccountIx: initDepositAccountIx,
    initObligationIx: initObligationIx,
    initCollateralIx: initCollateralIx,
    initLoanIx: initLoanIx,
    liquidateIx: liquidateIx,
    refreshReserveIx: refreshReserveIx,
    refreshPsyfiReserveIx: refreshPsyfiReserveIx,
    refreshEitherReserveIx: refreshEitherReserveIx,
    repayIx: repayIx,
    setMarketFlagsIx: setMarketFlagsIx,
    syncDiscountRates: syncDiscountRates,
    updateReserveConfigIx: updateReserveConfigIx,
    updateReserveHaltsIx: updateReserveHaltsIx,
    withdrawIX: withdrawIX,
    withdrawTokensIX: withdrawTokensIX,
    withdrawCollateralIx: withdrawCollateralIx,
    initMarketRewardIx: initMarketRewardIx,
    updateMarketRewardIx: updateMarketRewardIx,
    updateMarketRewardConfigIx: updateMarketRewardConfigIx,
    updateReserveRewardIx: updateReserveRewardIx,
    claimRewardsIx: claimRewardsIx,
    accruePositionRewardIx: accruePositionRewardIx,
    closeDepositAccountIx: closeDepositAccountIx,
    closeCollateralAccountIx: closeCollateralAccountIx,
    closeLoanAccountIx: closeLoanAccountIx,
    closeObligationAccountIx: closeObligationAccountIx,
    getDexId: getDexId,
    getPsyLendId: getPsyLendId
});

// Max number of ReserveInfo per Market.
const MAX_RESERVES = 32;
// Size of each ReserveInfo struct stored in Market.
const RESERVE_INFO_SIZE = 496;
// Max number of positions per deposit or borrow side.
const MAX_POSITION_PER_SIDE = 16;
const decodePositionStruct = (buff) => {
    let a = {
        account: new web3_js.PublicKey(buff.slice(0, 0 + 32)),
        noteAmount: new anchor.BN(buff.slice(32, 32 + 24), undefined, "le"),
        lastUpdated: new anchor.BN(buff.slice(56, 56 + 8), undefined, "le"),
        cummulativeRewardUnits: new anchor.BN(buff.slice(64, 64 + 16), undefined, "le"),
        // side: Number(buff.slice(80, 80 + 4)),
        // reserveIndex: Number(buff.slice(84, 84 + 2)),
        side: new anchor.BN(buff.slice(80, 80 + 4), undefined, "le"),
        reserveIndex: new anchor.BN(buff.slice(84, 84 + 2), undefined, "le"),
    };
    return a;
};
/**
 * Decodes buffer (typically from an Obligation's loan or collateral buffer) into an array of Position.
 *
 * @param buff - Buffer to decode
 * @param loadAll - Load all Positions, including uninitialized Positions, if true.
 */
const decodePositionsList = (buff, loadAll = true) => {
    let start = 0;
    let positionsList = [];
    while (start < MAX_POSITION_PER_SIDE * POSITION_SIZE$1) {
        const position = decodePositionStruct(buff.slice(start, start + POSITION_SIZE$1));
        if (loadAll || !position.account.equals(web3_js.PublicKey.default)) {
            positionsList.push(position);
        }
        start += POSITION_SIZE$1;
    }
    return positionsList;
};
/**
 * Same as {@link decodeCalculationCacheStruct}, except that reserved and CacheStruct fields
 * are not loaded. Can be used whenever only the collateral and loan values are needed, otherwise use
 * {@link decodeCalculationCacheStruct} to read the complete CalculationCache
 * @param buff
 * @returns
 */
const decodeCalculationCacheInner = (buff) => {
    let a = {
        collateralValue: new anchor.BN(buff.slice(0, 0 + 24), undefined, "le"),
        discountedCollateralValue: new anchor.BN(buff.slice(24, 24 + 24), undefined, "le"),
        loanValue: new anchor.BN(buff.slice(48, 48 + 24), undefined, "le"),
    };
    return a;
};
/**
 * When fetching an Obligation, the CalculationCache can be converted to a buffer and then read
 * using this function.
 *
 * Use `Buffer.from(obligation.cached as any as number[])` to convert cache to a buffer
 * @param buff
 * @returns
 */
const decodeCalculationCacheStruct = (buff) => {
    let a = {
        collateral_value: new anchor.BN(buff.slice(0, 0 + 24), undefined, "le"),
        discounted_collateral_value: new anchor.BN(buff.slice(24, 24 + 24), undefined, "le"),
        loan_value: new anchor.BN(buff.slice(48, 48 + 24), undefined, "le"),
        _reserved: [],
        //Reserved is 168 bytes...
        lastUpdated: new anchor.BN(buff.slice(24 + 168, 24 + 168 + 8), undefined, "le"),
        // 1 = true, 0 false
        invalidated: Number(buff.slice(32 + 168, 32 + 168 + 1)) == 1,
        _reservedCache: [],
    };
    return a;
};
const decodeU128Array = (buff, start, length) => {
    const decodedData = [];
    let sliceStart = start;
    for (let i = 0; i < length; i++) {
        decodedData.push(new anchor.BN(buff.slice(sliceStart, sliceStart + 16), undefined, "le"));
        sliceStart += 16;
    }
    return decodedData;
};
/**
 * When fetching a ReserveAccount, the ReserveStateStruct can be converted to a buffer and then read
 * using this function.
 *
 * Use `Buffer.from(reserve.state as any as number[])` to convert Reserve state to a buffer
 * @param buff
 * @returns
 */
const decodeReserveStateStruct = (buff) => {
    let a = {
        accruedUntil: new anchor.BN(buff.slice(0, 0 + 8), undefined, "le"),
        outstandingDebt: new anchor.BN(buff.slice(8, 8 + 24), undefined, "le"),
        uncollectedFees: new anchor.BN(buff.slice(32, 32 + 24), undefined, "le"),
        totalDeposits: new anchor.BN(buff.slice(56, 56 + 8), undefined, "le"),
        totalDepositNotes: new anchor.BN(buff.slice(64, 64 + 8), undefined, "le"),
        totalLoanNotes: new anchor.BN(buff.slice(72, 72 + 8), undefined, "le"),
        cummulativeDepositRewardUnits: decodeU128Array(buff, 80, 96),
        cummulativeLoanRewardUnits: decodeU128Array(buff, 1616, 96),
        //Reserved is 416 bytes...
        _reserved: [],
        lastUpdated: new anchor.BN(buff.slice(3568, 3568 + 8), undefined, "le"),
        invalidated: Boolean(buff.slice(3576, 3576 + 1).readInt8()),
        _reservedCache: [],
    };
    return a;
};
/**
 * Decode a single ReserveInfo from a buffer. Values returned are in the format stored, though U192
 * Amounts are converted into a BN.
 *
 * i.e. minCollateralRatio is stored as a U192 representation which has 15 decimal places,
 * which is returned as a BN with the same decimal places.
 *
 * This function can decode the first reserve, or use {@link decodeReserveInfoStructList} to decode
 * all reserves in the buffer.
 * @param buff
 * @returns
 */
const decodeReserveInfoStruct = (buff) => {
    let a = {
        reserve: new web3_js.PublicKey(buff.slice(0, 0 + 32)),
        price: new anchor.BN(buff.slice(112, 112 + 24), undefined, "le"),
        minCollateralRatio: new anchor.BN(buff.slice(136, 136 + 24), undefined, "le"),
        liquidationBonus: new anchor.BN(buff.slice(160, 160 + 2), undefined, "le"),
        discountRate: new anchor.BN(buff.slice(162, 162 + 2), undefined, "le"),
        reserveInfoLastUpdated: new anchor.BN(buff.slice(288, 288 + 8), undefined, "le"),
        reserveInfoInvalidated: Number(buff.slice(296, 296 + 1)),
        depositNoteExchangeRate: new anchor.BN(buff.slice(304, 304 + 24), undefined, "le"),
        loanNoteExchangeRate: new anchor.BN(buff.slice(328, 328 + 24), undefined, "le"),
        noteInfoLastUpdated: new anchor.BN(buff.slice(480, 480 + 8), undefined, "le"),
        noteInfoInvalidated: Number(buff.slice(488, 488 + 1)),
    };
    return a;
};
/**
 * Decode a list of 32 ReserveInfo from a buffer, including blanks. Every Market stores up to 32
 * reserves. Blank reserves are all zeros (including the default pubkey)
 *
 * You may need to use `Buffer.from(jetMarketAccount.reserves as any as number[])` to convert Market's reserves
 * to a buffer
 * @param buff
 * @returns
 */
const decodeReserveInfoStructList = (buff) => {
    let start = 0;
    let reserveInfoList = [];
    while (start < MAX_RESERVES * RESERVE_INFO_SIZE) {
        reserveInfoList.push(decodeReserveInfoStruct(buff.slice(start, start + RESERVE_INFO_SIZE)));
        start += RESERVE_INFO_SIZE;
    }
    return reserveInfoList;
};
/**
 * Given a reserveInfo list loaded with {@link decodeReserveInfoStructList} from a Market, returns
 * the reserve at some index in that market.
 *
 * Useful when presented with a reserveIndex and no reserve key (such as when loading an obligation)
 * to extract the original reserve data.
 * @param reserveIndex
 * @param info
 * @returns
 */
const getReserveFromIndexInReserveInfo = (reserveIndex, info) => {
    return info[reserveIndex].reserve;
};

const DEFAULT_DISCOUNT_RATE = 10000;
// Used in `updateReserveHaltsIx` to halt/restart various operations for a reserve.
// Matches variables of the same name in `reserve.rs`
const NOTHING_HALTED = 0;
const DEPOSITS_HALTED = 1;
const BORROWS_HALTED = 2;
const REPAYS_HALTED = 4;
const WITHDRAWS_HALTED = 8;
/**
 * All interests and percentages, such as discount rates, fees, liquidation premium, etc are stored
 * under the hood multiplied by this amount, e.g. 5% is stored as .05 * 10,000 = 500
 */
const COMMON_DENOM = 10000;
// Market is 16544 bytes, plus 8 bytes for discriminator.
const PSY_MARKET_SIZE = 16544;
// Reserve is 5184 bytes, plus 8 bytes for discriminator.
const RESERVE_SIZE = 5184;
// MarketReward is 39968 bytes, plus 8 bytes for discriminator.
const MARKET_REWARD_SIZE = 39968;
// Size of Position struct in bytes.
const POSITION_SIZE$1 = 160;
const OBLIGATION_SIZE = 7168;
const TOKENS = 0;
const DEPOSIT_NOTES = 1;
const LOAN_NOTES = 2;
//Sample usage:
// let amount: Amount = {
//   units: AmountUnits.DepositNotes,
//   value: new BN(50000)
// };
/**
 * A unit and u64 pair. Most instructions dealing with currency use this as input.
 *
 * Note: remember to convert values into the appropriate decimals!
 *
 * For units, possible values are TOKENS (0), DEPOSIT_NOTES (1), and LOAN_NOTES (2)
 */
class Amount {
    constructor(units, value) {
        this.units = units;
        this.value = value;
    }
    static tokens(amount) {
        return new Amount(TOKENS, new anchor.BN(amount));
    }
    static depositNotes(amount) {
        return new Amount(DEPOSIT_NOTES, new anchor.BN(amount));
    }
    static loanNotes(amount) {
        return new Amount(LOAN_NOTES, new anchor.BN(amount));
    }
}
/**
 * A generic reserve config with:
 *
 * utilitzation rates 8500/9500 (85/95%)
 *
 * borrow rate 20,000 at all levels (200%)
 *
 * min c-ratio = 12500 (125%)
 *
 * liquidation premium = 100 (1%)
 *
 * manage fee = 50 (.5%)
 *
 * origination fee = 0 (0%)
 * @returns
 */
const getGenericReserveConfig = () => {
    let reserveConfig = {
        utilizationRate1: 8500,
        utilizationRate2: 9500,
        borrowRate0: 20000,
        borrowRate1: 20000,
        borrowRate2: 20000,
        borrowRate3: 20000,
        minCollateralRatio: 12500,
        liquidationPremium: 100,
        manageFeeRate: 50,
        manageFeeCollectionThreshold: new anchor.BN(10),
        /**
         * Note: Loan origination fee set to zero for most tests to enable simpler math calculations when
         * borrowing and instantly repaying.
         */
        loanOriginationFee: 0,
        // liquidationSlippage: 300,
        liquidationDexTradeMax: new anchor.BN(100),
        reserved0: 0,
        confidenceThreshold: 200,
        depositRewardMultiplier: 0,
        borrowRewardMultiplier: 0,
        reserved1: new Uint8Array(22),
    };
    return reserveConfig;
};
var MarketFlags;
(function (MarketFlags) {
    MarketFlags[MarketFlags["HaltNothing"] = 0] = "HaltNothing";
    MarketFlags[MarketFlags["HaltBorrows"] = 1] = "HaltBorrows";
    MarketFlags[MarketFlags["HaltRepays"] = 2] = "HaltRepays";
    MarketFlags[MarketFlags["HaltDeposits"] = 4] = "HaltDeposits";
    MarketFlags[MarketFlags["HaltAll"] = 7] = "HaltAll";
})(MarketFlags || (MarketFlags = {}));
/**
 * Indicates the status of a `PriceInformation` fetched from Oracle. OK = fetched price without
 * issue, EMA = failed to get price, fell back to EMA, FAILED = couldn't fetch or decode the price,
 * fell back to placeholder of $1
 */
var priceStatus;
(function (priceStatus) {
    priceStatus[priceStatus["PRICE_INFORMATION_OK"] = 0] = "PRICE_INFORMATION_OK";
    priceStatus[priceStatus["PRICE_INFORMATION_EMA"] = 1] = "PRICE_INFORMATION_EMA";
    priceStatus[priceStatus["PRICE_INFORMATION_FAILED"] = 2] = "PRICE_INFORMATION_FAILED";
})(priceStatus || (priceStatus = {}));

var types = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DEFAULT_DISCOUNT_RATE: DEFAULT_DISCOUNT_RATE,
    NOTHING_HALTED: NOTHING_HALTED,
    DEPOSITS_HALTED: DEPOSITS_HALTED,
    BORROWS_HALTED: BORROWS_HALTED,
    REPAYS_HALTED: REPAYS_HALTED,
    WITHDRAWS_HALTED: WITHDRAWS_HALTED,
    COMMON_DENOM: COMMON_DENOM,
    PSY_MARKET_SIZE: PSY_MARKET_SIZE,
    RESERVE_SIZE: RESERVE_SIZE,
    MARKET_REWARD_SIZE: MARKET_REWARD_SIZE,
    POSITION_SIZE: POSITION_SIZE$1,
    OBLIGATION_SIZE: OBLIGATION_SIZE,
    TOKENS: TOKENS,
    DEPOSIT_NOTES: DEPOSIT_NOTES,
    LOAN_NOTES: LOAN_NOTES,
    Amount: Amount,
    getGenericReserveConfig: getGenericReserveConfig,
    get MarketFlags () { return MarketFlags; },
    get priceStatus () { return priceStatus; },
    MAX_RESERVES: MAX_RESERVES,
    RESERVE_INFO_SIZE: RESERVE_INFO_SIZE,
    decodePositionStruct: decodePositionStruct,
    decodePositionsList: decodePositionsList,
    decodeCalculationCacheInner: decodeCalculationCacheInner,
    decodeCalculationCacheStruct: decodeCalculationCacheStruct,
    decodeReserveStateStruct: decodeReserveStateStruct,
    decodeReserveInfoStruct: decodeReserveInfoStruct,
    decodeReserveInfoStructList: decodeReserveInfoStructList,
    getReserveFromIndexInReserveInfo: getReserveFromIndexInReserveInfo
});

// *************** ACCOUNT GETTERS *****************
/**
 * Attempts to fetch a user deposit account, creates it if it doesn't exist.
 * Derive the deposit account with `{@link deriveClientReserveAccounts}`. Data required to create deposit
 * account is optional and be omitted if only attempting to fetch an account.
 * @param program
 * @param depositKey - derived with `{@link deriveClientReserveAccounts}`
 * @param bump - derived with `{@link deriveClientReserveAccounts}`
 * @param toCreate - required to create an accont if one is not found
 * @param market - Psy market for this reserve
 * @param marketAuthority
 * @param reserve
 * @param depositNoteMint - can be extracted from the reserve
 * @param userAddress - generally the user's wallet
 * @returns deposit account, or null if no account is found and data to create a new one is not provided.
 */
const getOrInitUserDepositAccount = (program, depositKey, bump = 0, toCreate) => __awaiter(void 0, void 0, void 0, function* () {
    if (depositKey.equals(web3_js.PublicKey.default)) {
        console.error("Passed the default pubkey, must derive the correct deposit key before calling this function.");
    }
    let depositAccount = yield program.provider.connection.getAccountInfo(depositKey);
    //if already exists, return it
    if (depositAccount != null) {
        return depositKey;
    }
    //Doesn't exist, validate that creation args were provided
    if (!toCreate) {
        console.error("Failed to provide args to create the deposit account");
        return null;
    }
    let ix = yield initDepositAccountIx(program, bump, toCreate.market, toCreate.marketAuthority, toCreate.reserve, toCreate.depositNoteMint, toCreate.userAddress, depositKey);
    //console.log("init deposit acc " + depositKey);
    yield program.provider.sendAndConfirm(new web3_js.Transaction().add(ix));
    return depositKey;
});
/**
 * Attempts to fetch collateral account at this address, creates one if it doesn't exist.
 *
 * Derive accounts with {@link deriveClientReserveAccounts} first to get the address
 * @param program - typically the user's program, user must sign tx if creating account
 * @param accountKey
 * @param bump
 * @param toCreate - Psy market/authority, reserve address/deposit note mint, user wallet. Accrue ix is
 * required if rewards are enabled.
 * @returns
 */
const getOrInitCollateralAccount = (program, accountKey, bump = 0, toCreate) => __awaiter(void 0, void 0, void 0, function* () {
    if (accountKey.equals(web3_js.PublicKey.default)) {
        console.error("Passed the default pubkey, must derive the correct deposit key before calling this function.");
    }
    let collateralAccount = yield program.provider.connection.getAccountInfo(accountKey);
    //if already exists, return it
    if (collateralAccount != null) {
        return accountKey;
    }
    //Doesn't exist, validate that market was provided
    if (!toCreate) {
        console.error("Failed to provide args to create the collateral account");
        return null;
    }
    let ix = yield initCollateralIx(program, bump, toCreate.market, toCreate.marketAuthority, toCreate.reserve, toCreate.depositNoteMint, toCreate.userAddress, toCreate.obligationAccount, accountKey);
    let tx = new web3_js.Transaction();
    if (toCreate.accrueIx) {
        tx.add(toCreate.accrueIx);
    }
    tx.add(ix);
    yield program.provider.sendAndConfirm(tx);
    return accountKey;
});
/**
 * Attempts to fetch loan account at this address, creates one if it doesn't exist.
 *
 * Derive accounts with {@link deriveClientReserveAccounts} first to get the address
 * @param program - typically the user's program, user must sign tx if creating account
 * @param accountKey
 * @param bump
 * @param toCreate - Psy market/authority, reserve address/loan note mint, user wallet. Accrue ix is
 * required if rewards are enabled.
 * @returns
 */
const getOrInitLoanAccount = (program, accountKey, bump = 0, toCreate) => __awaiter(void 0, void 0, void 0, function* () {
    if (accountKey.equals(web3_js.PublicKey.default)) {
        console.error("Passed the default pubkey, must derive the correct deposit key before calling this function.");
    }
    let loanAccount = yield program.provider.connection.getAccountInfo(accountKey);
    //if already exists, return it
    if (loanAccount != null) {
        return accountKey;
    }
    //Doesn't exist, validate that market was provided
    if (!toCreate) {
        console.error("Failed to provide args to create the loan account");
        return null;
    }
    let ix = yield initLoanIx(program, bump, toCreate.market, toCreate.marketAuthority, toCreate.reserve, toCreate.loanNoteMint, toCreate.userAddress, toCreate.obligationAccount, accountKey);
    let tx = new web3_js.Transaction();
    if (toCreate.accrueIx) {
        tx.add(toCreate.accrueIx);
    }
    tx.add(ix);
    yield program.provider.sendAndConfirm(tx);
    return accountKey;
});
/**
 * Attempts to fetch obligation account at this address, creates one if it doesn't exist.
 *
 * Derive account with  {@link deriveUserObligation} first to get the address
 * @param program - typically the user's program, user must sign tx if creating account
 * @param accountKey
 * @param bump
 * @param toCreate - psy market, authority, user's wallet address
 * @returns
 */
const getOrInitObligationAccount = (program, accountKey, bump = 0, toCreate) => __awaiter(void 0, void 0, void 0, function* () {
    if (accountKey.equals(web3_js.PublicKey.default)) {
        console.error("Passed the default pubkey, must derive the correct deposit key before calling this function.");
    }
    let obligationAccount = yield program.provider.connection.getAccountInfo(accountKey);
    //if already exists, return it
    if (obligationAccount != null) {
        return accountKey;
    }
    //Doesn't exist, validate that market was provided
    if (!toCreate) {
        console.error("Failed to provide args to create the obligation account");
        return null;
    }
    let ix = yield initObligationIx(program, bump, toCreate.market, toCreate.marketAuthority, accountKey, toCreate.userAddress);
    yield program.provider.sendAndConfirm(new web3_js.Transaction().add(ix));
    return accountKey;
});
/**
 * Returns the balance of a token account, in whatever currency the account is in.
 *
 * Requires spl-token 2.0 or later
 * @param program
 * @param account
 * @returns
 */
const getTokenAccountBalance = (program, account) => __awaiter(void 0, void 0, void 0, function* () {
    let accountInfo = yield program.provider.connection.getAccountInfo(account);
    let data = spl2.AccountLayout.decode(accountInfo.data);
    if (data == undefined || data.amount == undefined) {
        return 0;
    }
    let amount = data.amount;
    return Number(amount);
});
// *************** INITIALIZATION HELPERS *****************
/**
 * Sends a tx that creates a zeroed out market, and {@link initMarketIx}
 * @param program
 * @param owner
 * @param quoteCurrencyMint
 * @param quoteCurrencyName
 * @param market
 * @param payer - pays the tx fee to create the market account
 * @returns the created PsyMarket
 */
const createAndInitPsyMarket = (program, owner, quoteCurrencyMint, quoteCurrencyName, market, //also signs the ix
payer) => __awaiter(void 0, void 0, void 0, function* () {
    let tx = new web3_js.Transaction();
    tx.add(web3_js.SystemProgram.createAccount({
        fromPubkey: payer.publicKey,
        newAccountPubkey: market.publicKey,
        lamports: yield program.provider.connection.getMinimumBalanceForRentExemption(PSY_MARKET_SIZE + 8),
        space: PSY_MARKET_SIZE + 8,
        programId: program.programId,
    }));
    tx.add(yield initMarketIx(program, owner, quoteCurrencyMint, quoteCurrencyName, market.publicKey));
    yield program.provider.sendAndConfirm(tx, [payer, market]);
    let psyMarketAccount = (yield program.account.market.fetch(market.publicKey));
    return psyMarketAccount;
});
/**
 * Sends a tx that creates a reserve, and {@link initReserveIx}
 * @param program
 * @param bumpSeeds
 * @param reserveConfig
 * @param market
 * @param marketAuthority
 * @param owner
 * @param pythOracleProduct
 * @param pythOraclePrice - pyth oracle for currency reserve trades in (oracle of underlying asset if a
 * psyfi reserve)
 * @param reserve
 * @param reserveAccounts
 * @param dexMarket - Serum market that should have been created earlier with {@link createSerumMarket}
 * @param quoteTokenMint - quote token for reserve, currency the Psy market is priced in, generally usdc
 * @param tokenMint - currency this reserve trades in
 * @param isDevnet
 * @param payer
 * @param optional -
 *  @param psyfiVaultAccount - (optional) - the vault address, if creating a psyfi reserve
 *  @param collateralAssetMint - (optional) - mint for underlying token vault trades in (NOT the
 * ownership token), if creating psyfi reserve. Matches asset of pythPrice
 *
 */
const createAndInitReserve = (program, bumpSeeds, reserveConfig, market, marketAuthority, owner, pythOracleProduct, pythOraclePrice, reserve, reserveAccounts, dexMarket, quoteTokenMint, tokenMint, isDevnet, payer, optional) => __awaiter(void 0, void 0, void 0, function* () {
    let tx = new web3_js.Transaction();
    tx.add(web3_js.SystemProgram.createAccount({
        fromPubkey: payer.publicKey,
        newAccountPubkey: reserve.publicKey,
        lamports: yield program.provider.connection.getMinimumBalanceForRentExemption(RESERVE_SIZE + 8),
        space: RESERVE_SIZE + 8,
        programId: program.programId,
    }));
    //Shorthand
    // tx.add (await program.account.reserve.createInstruction(reserve));
    tx.add(yield initReserveIx(program, bumpSeeds, reserveConfig, market, marketAuthority, owner, 
    /*payer=*/ owner, pythOracleProduct, pythOraclePrice, reserve.publicKey, reserveAccounts, dexMarket, quoteTokenMint, tokenMint, isDevnet, optional));
    try {
        yield program.provider.sendAndConfirm(tx, [payer, reserve]);
    }
    catch (err) {
        console.log(err);
    }
    let psyReserve = (yield program.account.reserve.fetch(reserve.publicKey));
    return psyReserve;
});
/**
 * Sends a tx that creates a reserve, and {@link initPsyfiReserveIx}.
 *
 * Deprecated, {@link createAndInitReserve} can now handle psyFi reserves with optional arguments.
 * @param program
 * @param bumpSeeds
 * @param reserveConfig
 * @param market
 * @param marketAuthority
 * @param owner
 * @param pythOracleProduct
 * @param pythOraclePrice
 * @param reserve
 * @param reserveAccounts
 * @param dexMarket
 * @param quoteTokenMint
 * @param tokenMint
 * @param psyfiVault
 * @param psyfiCollateralMint
 * @param isDevnet
 * @param payer
 */
const createAndInitPsyfiReserve = (program, bumpSeeds, reserveConfig, market, marketAuthority, owner, pythOracleProduct, pythOraclePrice, reserve, reserveAccounts, dexMarket, quoteTokenMint, tokenMint, psyfiVault, psyfiCollateralMint, isDevnet, payer) => __awaiter(void 0, void 0, void 0, function* () {
    let tx = new web3_js.Transaction();
    tx.add(web3_js.SystemProgram.createAccount({
        fromPubkey: payer.publicKey,
        newAccountPubkey: reserve.publicKey,
        lamports: yield program.provider.connection.getMinimumBalanceForRentExemption(RESERVE_SIZE + 8),
        space: RESERVE_SIZE + 8,
        programId: program.programId,
    }));
    //Shorthand
    // tx.add (await program.account.reserve.createInstruction(reserve));
    tx.add(yield initPsyfiReserveIx(program, bumpSeeds, reserveConfig, market, marketAuthority, owner, 
    /*payer=*/ owner, pythOracleProduct, pythOraclePrice, reserve.publicKey, reserveAccounts, dexMarket, quoteTokenMint, tokenMint, psyfiVault, psyfiCollateralMint, isDevnet));
    try {
        yield program.provider.sendAndConfirm(tx, [payer, reserve]);
    }
    catch (err) {
        console.log(err);
    }
    let psyReserve = (yield program.account.reserve.fetch(reserve.publicKey));
    return psyReserve;
});
/**
 * Sends a tx that creates a MarketReward account and {@link initMarketRewardIx}
 *
 * @param program
 * @param marketRewardKeypair - keypair for creation of MarketReward account.
 * @param psyMarket - Psy market the reserve is under
 * @param psyMarketOwner - keypair for owner of Psy market
 * @param initialRewardIndexTimestamp - timestamp when rewards will start to be distributed
 * @param distributionPeriod - duration of each distribution period in seconds
 * @param rewardPointsPerPeriod - reward points to be distributed across whole market per period
 * @param rewardUnitDecimals - number of decimals to store reward points in
 * @param minWithdrawalDuration - min duration from start of period, after which rewards claim is allowed
 * @returns - created `MarketReward` account
 */
const createAndInitMarketReward = (program, marketRewardKeypair, psyMarket, psyMarketOwner, initialRewardIndexTimestamp, distributionPeriod, rewardPointsPerPeriod, rewardUnitDecimals, minWithdrawalDuration = new anchor.BN(0)) => __awaiter(void 0, void 0, void 0, function* () {
    let tx = new web3_js.Transaction();
    tx.add(web3_js.SystemProgram.createAccount({
        fromPubkey: psyMarketOwner.publicKey,
        newAccountPubkey: marketRewardKeypair.publicKey,
        lamports: yield program.provider.connection.getMinimumBalanceForRentExemption(MARKET_REWARD_SIZE + 8),
        space: MARKET_REWARD_SIZE + 8,
        programId: program.programId,
    }));
    tx.add(yield initMarketRewardIx(program, psyMarket, psyMarketOwner.publicKey, marketRewardKeypair.publicKey, initialRewardIndexTimestamp, distributionPeriod, rewardPointsPerPeriod, rewardUnitDecimals, minWithdrawalDuration));
    try {
        yield program.provider.sendAndConfirm(tx, [
            marketRewardKeypair,
            psyMarketOwner,
        ]);
    }
    catch (err) {
        console.log(err);
    }
    let marketReward = (yield program.account.marketReward.fetch(marketRewardKeypair.publicKey));
    return marketReward;
});
/**
 * Derives obligation, deposits, loans, and collateral accounts for user.
 * @param program
 * @param market
 * @param userAddress - Pubkey of user's wallet
 * @param reserveKey
 * @returns
 */
const deriveUserAccounts = (program, market, userAddress, reserveKey) => __awaiter(void 0, void 0, void 0, function* () {
    let { obligationAccount, obligationBump } = yield deriveUserObligation(program, market, userAddress);
    let { accounts: clientReserveAccounts, bumpSeeds: clientReserveBumpSeeds } = yield deriveClientReserveAccounts(program, reserveKey, obligationAccount, userAddress);
    return {
        obligationAccount,
        obligationBump,
        clientReserveAccounts,
        clientReserveBumpSeeds,
    };
});
// *************** DATA PROCCESSING *********************
/**
 * Reads a U192 from some buffer and returns a BN with equivalent value
 * @param buff - some buffer containing a U192 `Number`
 * @param start - index to begin reading
 */
const readU192FromBuffer = (buff, start) => {
    return new anchor.BN(buff.slice(start, start + 24), undefined, "le");
};
/**
 * Fetches several reserves, in one rpc call
 * @param program
 * @param reserves - an array of reserve keys to fetch
 * @returns
 */
const fetchSeveralReserves = (program, reserves) => __awaiter(void 0, void 0, void 0, function* () {
    let accounts = (yield program.account.reserve.fetchMultiple(reserves));
    return accounts;
});
/**
 * Returns circulating supply of a mint
 * @param connection
 * @param mint
 * @returns
 */
const getMintSupply = (connection, mint) => __awaiter(void 0, void 0, void 0, function* () {
    return (yield spl2.getMint(connection, mint)).supply;
});
const printExchangeRates = (rates) => {
    console.log("----Current exchange rates---");
    console.log("Deposit Notes:        ");
    console.log("notes/token:         " + rates.depositNotesToTokens.toFixed(20).toString());
    console.log("tokens/note:         " + rates.tokensToDepositNotes.toFixed(20).toString());
    console.log("deposit note supply:  " +
        BigInt(rates.depositNoteSupply.toString()).toLocaleString());
    console.log("deposit token supply: " +
        BigInt(rates.depositTokenSupply.toString()).toLocaleString());
    console.log("Loan Notes: ");
    console.log("notes/token:         " + rates.loanNotesToTokens.toFixed(20).toString());
    console.log("tokens/note:         " + rates.tokensToLoanNotes.toFixed(20).toString());
    console.log("loan note supply:     " +
        BigInt(rates.loanNoteSupply.toString()).toLocaleString());
    console.log("loan token supply:    " +
        BigInt(rates.loanTokenSupply.toString()).toLocaleString());
    console.log("");
};
/**
 * Given a reserve account, determines the exchange rate of Notes to Tokens for deposit/loan notes.
 * Also returns the oustanding supply of notes/tokens and the exchange rate in reverse. See
 * {@link reserveExchangeRates} for all returned values.
 *
 * Note that deposit/loan note mints and the mint for this reserve's token always use the same
 * decimals, so a value in notes for this reserve can be natively divided by a token value.
 *
 * Note that the exchange rates do not account for unaccrued interest.
 * @param reserve
 * @returns
 */
const getNoteExchangeRatesForReserve = (reserve) => {
    let reserveState = decodeReserveStateStruct(Buffer.from(reserve.state));
    // Circulating note supplies
    let depositNoteSupply = reserveState.totalDepositNotes;
    let loanNoteSupply = reserveState.totalLoanNotes;
    // Amount on hand + amount loaned out (excluding fees)
    let depositTokenSupply = reserveState.totalDeposits.add(
    // Note that Outstanding Debt includes fees, which are part of the token supply that can be used
    // to redeem notes, and must be subtracted. E.g. deposit notes are not issued against fees until
    // they are actually collected (during an accrue)
    // Note that debt/fees are stored as Number for precision, divide by 10^15 to get token decimals.
    reserveState.outstandingDebt
        .sub(reserveState.uncollectedFees)
        .div(new anchor.BN(Math.pow(10, 15))));
    // Amount loaned out
    // Note that debt is stored as Number for precision, divide by 10^15 to get token decimals.
    let loanTokenSupply = reserveState.outstandingDebt.div(new anchor.BN(Math.pow(10, 15)));
    let depositNotesToTokens;
    let tokensToDepositNotes;
    if (depositNoteSupply.eqn(0) || depositNoteSupply.eqn(0)) {
        depositNotesToTokens = 1;
        tokensToDepositNotes = 1;
    }
    else {
        // TODO preserve float precision but handle numbers > 2^53?
        tokensToDepositNotes =
            depositNoteSupply.toNumber() / depositTokenSupply.toNumber();
        depositNotesToTokens =
            depositTokenSupply.toNumber() / depositNoteSupply.toNumber();
    }
    let loanNotesToTokens;
    let tokensToLoanNotes;
    if (loanNoteSupply.eqn(0) || loanTokenSupply.eqn(0)) {
        loanNotesToTokens = 1;
        tokensToLoanNotes = 1;
    }
    else {
        tokensToLoanNotes = loanNoteSupply.toNumber() / loanTokenSupply.toNumber();
        loanNotesToTokens = loanTokenSupply.toNumber() / loanNoteSupply.toNumber();
    }
    let exchangeRates = {
        depositNotesToTokens: depositNotesToTokens,
        loanNotesToTokens: loanNotesToTokens,
        tokensToDepositNotes: tokensToDepositNotes,
        tokensToLoanNotes: tokensToLoanNotes,
        depositNoteSupply: depositNoteSupply,
        loanNoteSupply: loanNoteSupply,
        depositTokenSupply: depositTokenSupply,
        loanTokenSupply: loanTokenSupply,
    };
    return exchangeRates;
};

var tools = /*#__PURE__*/Object.freeze({
    __proto__: null,
    getOrInitUserDepositAccount: getOrInitUserDepositAccount,
    getOrInitCollateralAccount: getOrInitCollateralAccount,
    getOrInitLoanAccount: getOrInitLoanAccount,
    getOrInitObligationAccount: getOrInitObligationAccount,
    getTokenAccountBalance: getTokenAccountBalance,
    createAndInitPsyMarket: createAndInitPsyMarket,
    createAndInitReserve: createAndInitReserve,
    createAndInitPsyfiReserve: createAndInitPsyfiReserve,
    createAndInitMarketReward: createAndInitMarketReward,
    deriveUserAccounts: deriveUserAccounts,
    readU192FromBuffer: readU192FromBuffer,
    fetchSeveralReserves: fetchSeveralReserves,
    getMintSupply: getMintSupply,
    printExchangeRates: printExchangeRates,
    getNoteExchangeRatesForReserve: getNoteExchangeRatesForReserve
});

/**
 * Converts a Psy U196 Number type, which is stored with a base of 10**15, to a Javascript floating point
 * number, with the max allowable precision.
 * @param psyNumber
 * @returns
 */
const psyBNToNumber = (psyNumber) => {
    const psyNumberBase = Math.pow(10, 15);
    const numberMax = Number.MAX_SAFE_INTEGER;
    if (psyNumber.lt(new anchor.BN(numberMax))) {
        return Number(psyNumber) / psyNumberBase;
    }
    const numberLen = psyNumber.toString().length;
    const baseToDivide = numberLen - 15;
    if (baseToDivide > 15) {
        console.log("Precision loss warning. Dividing by more than 15 decimals will result in non-floating point precision loss.");
    }
    const divisor = new anchor.BN(10).pow(new anchor.BN(baseToDivide));
    return Number(psyNumber.div(divisor)) / Math.pow(10, (15 - baseToDivide));
};

var math = /*#__PURE__*/Object.freeze({
    __proto__: null,
    psyBNToNumber: psyBNToNumber
});

/**
 * A tool for pulling information from various reserves in the PsyLend ecosystem
 */
class EcosystemHelper {
    /**
     * A tool for pulling information from various reserves in the PsyLend ecosystem
     * @param program - the Psylend program
     * @param psyfiProgram - the PsyFiEuros program, mandatory if any reserves are psyFi reserves
     */
    constructor(program, psyfiProgram) {
        this.program = program;
        if (psyfiProgram) {
            this.psyfiProgram = psyfiProgram;
        }
        this.reserveAccounts = new Map();
        this.exchangeRates = new Map();
        this.prices = new Map();
        this.psyfiVaultInfos = new Map();
    }
    /**
     * Refreshes information about reserves and loads into the {@link reserveAccounts}. Always call refresh
     * after first creating an EcosystemHelper.
     *
     * Note: GetMultiple can fetch a max of 100 accounts. In the event more than 100 reserves exist,
     * call refresh several times in chunks of 100 or fewer.
     */
    refresh(reserveKeys) {
        return __awaiter(this, void 0, void 0, function* () {
            let reserves = (yield this.program.account.reserve.fetchMultiple(reserveKeys));
            for (let i = 0; i < reserveKeys.length; i++) {
                this.reserveAccounts.set(reserveKeys[i].toString(), reserves[i]);
                this.exchangeRates.set(reserveKeys[i].toString(), getNoteExchangeRatesForReserve(reserves[i]));
            }
        });
    }
    /**
     * Refreshes information about reserves and loads into the {@link reserveAccounts}. Use if you
     * have already fetched all reserve data and wish to update the helper without invoking another
     * RPC call.
     *
     * Typically, reserve data is fetched with `program.account.reserve.fetchMultiple(reserveKeys)`
     * @param reserveKeys
     * @param reserves - the ReserveAccount for each key in `ReserveKeys`
     */
    refreshFromExistingFetch(reserveKeys, reserves) {
        for (let i = 0; i < reserveKeys.length; i++) {
            this.reserveAccounts.set(reserveKeys[i].toString(), reserves[i]);
            this.exchangeRates.set(reserveKeys[i].toString(), getNoteExchangeRatesForReserve(reserves[i]));
        }
    }
    /**
     * Refreshes only the given reserve, and loads info into the {@link reserveAccounts}.
     * @param reserveKey
     */
    refreshSingleReserve(reserveKey) {
        return __awaiter(this, void 0, void 0, function* () {
            let reserve = (yield this.program.account.reserve.fetch(reserveKey));
            this.reserveAccounts.set(reserveKey.toString(), reserve);
            this.exchangeRates.set(reserveKey.toString(), getNoteExchangeRatesForReserve(reserve));
        });
    }
    /**
     * Returns the ReserveAccount associated with the given key
     * @param key
     * @returns - ReserveAccount associated with the given key
     */
    getReserveInfo(key) {
        let acc = this.reserveAccounts.get(key);
        if (acc != undefined) {
            return acc;
        }
        else {
            console.error("Could not find reserve, did you forget to refresh?");
            return undefined;
        }
    }
    /**
     * Returns the Pyth Price Oracle address for this reserve
     * @param reserveKey
     * @returns - Pubkey of Pyth Oracle Price
     */
    getOracle(reserveKey) {
        var _a;
        return (_a = this.getReserveInfo(reserveKey)) === null || _a === void 0 ? void 0 : _a.pythOraclePrice;
    }
    /**
     * Fetches the current Pyth price (in oracle decimals), the price reflecting the currently applied
     * discount rate, and the exponent (for converting back to a standard decimal number if desired)
     *
     * The reserve itself must already be refreshed (use {@link refresh})
     * @param reserveKey
     * @returns a `PriceInformation`
     */
    refreshPrice(reserveKey) {
        return __awaiter(this, void 0, void 0, function* () {
            let oraclePriceKey = this.getOracle(reserveKey.toString());
            let priceDataInfo = yield this.program.provider.connection.getAccountInfo(oraclePriceKey);
            let decimals = Math.abs(this.getReserveInfo(reserveKey.toString()).exponent);
            let priceInfo = this.parsePriceDataIntoPriceInformation(reserveKey, priceDataInfo.data, decimals);
            this.prices.set(reserveKey.toString(), priceInfo);
            return priceInfo;
        });
    }
    /**
     * Fetches the current price (in oracle decimals) for all given reserves, and adds them to the
     * prices map. Attempts to bundle the request into a one rpc call
     *
     * The reserves themselves must already be refreshed (use {@link refresh})
     *
     * Note: GetMultiple can fetch a max of 100 accounts. In the event more than 100 reserves exist,
     * call refresh refreshPrices times in chunks of 100 or fewer.
     * @param reserveKeys
     */
    refreshPrices(reserveKeys) {
        return __awaiter(this, void 0, void 0, function* () {
            let oraclePriceKeys = reserveKeys.map((key) => this.getOracle(key.toString()));
            let priceDataInfos = yield this.program.provider.connection.getMultipleAccountsInfo(oraclePriceKeys);
            for (let i = 0; i < reserveKeys.length; i++) {
                let decimals = Math.abs(this.getReserveInfo(reserveKeys[i].toString()).exponent);
                let priceInfo = this.parsePriceDataIntoPriceInformation(reserveKeys[i], priceDataInfos[i].data, decimals);
                this.prices.set(reserveKeys[i].toString(), priceInfo);
            }
        });
    }
    /**
     * Override the oracle price for this helper with the value given.
     *
     * The real price must have already been refreshed (use {@link refreshPrice}
     * {@link refreshPrices}). The oracle decimals and price status will be inherited
     * from the real price. The discount rate will be inherited from the real price unless specified
     * in the optional arg
     * @param reserveKey
     * @param price - the price to set, in USD, as float, e.g. $1.25 = 1.25
     * @param discountRate - (optional) override discount rate. As float, e.g. 95% = .95
     * @returns a `PriceInformation`
     */
    forcePrice(reserveKey, price, discountRate) {
        return __awaiter(this, void 0, void 0, function* () {
            let priceInfo = this.prices.get(reserveKey.toString());
            priceInfo.price = price;
            if (discountRate) {
                priceInfo.discountRate = discountRate;
                priceInfo.discountPrice = price * discountRate;
            }
            else {
                priceInfo.discountPrice = price * priceInfo.discountRate;
            }
            this.prices.set(reserveKey.toString(), priceInfo);
            return priceInfo;
        });
    }
    /**
     * Loads information for a single PsyFi Vaults, which is needed to price the corresponding
     * vault token deposited into PsyFi Reserves.
     *
     * The reserve itself must already be refreshed (use {@link refresh})
     * @param reserveKey
     * @returns a `VaultInformation`
     */
    refreshVault(reserveKey) {
        return __awaiter(this, void 0, void 0, function* () {
            let vaultKey = this.getReserveInfo(reserveKey.toString())
                .psyfiVaultConfig.vaultAccount;
            if (vaultKey.equals(web3_js.PublicKey.default)) {
                console.log("Tried to load vault info for a non-Psyfi reserve, aborting");
                return;
            }
            let vaultAccountInfo = yield this.psyfiProgram.provider.connection.getAccountInfo(vaultKey);
            let vaultAcc = this.psyfiProgram.coder.accounts.decode("VaultAccount", vaultAccountInfo.data);
            this.psyfiVaultInfos.set(reserveKey.toString(), vaultAcc);
            return vaultAcc;
        });
    }
    /**
     * Loads information from PsyFi Vaults that is needed to price the corresponding vault token
     * deposited into PsyFi Reserves.
     *
     * Attempts to bundle the request into a single rpc call.
     *
     * The reserves themselves must already be refreshed (use {@link refresh})
     *
     * Note: GetMultiple can fetch a max of 100 accounts. In the event more than 100 reserves exist,
     * this function may fail to refresh vaults for all of them. Pass PsyFi reserves in chunks of less
     * than 100, but note that non-PsyFi reserves are skipped/ignored.
     * @param reserveKeys
     */
    refreshVaults(reserveKeys) {
        return __awaiter(this, void 0, void 0, function* () {
            // Get all the vault keys for valid PsyFi Reserves. All non-PsyFi Reserves will return the
            // default Pubkey.
            let reserveKeysWithVault = [];
            let vaultKeys = [];
            for (let i = 0; i < reserveKeys.length; i++) {
                let vault = this.getReserveInfo(reserveKeys[i].toString())
                    .psyfiVaultConfig.vaultAccount;
                if (!vault.equals(web3_js.PublicKey.default)) {
                    reserveKeysWithVault.push(reserveKeys[i]);
                    vaultKeys.push(vault);
                }
                else {
                    // Non-Psyfi reserves are skipped
                    continue;
                }
            }
            let vaultAccountInfos = yield this.psyfiProgram.provider.connection.getMultipleAccountsInfo(vaultKeys);
            let vaultAcc = vaultAccountInfos.map((acc) => {
                try {
                    return this.psyfiProgram.coder.accounts.decode("vaultAccount", acc.data);
                }
                catch (err) {
                    // Legacy IDL used an uppercase "V" (standard CamelCase)
                    return this.psyfiProgram.coder.accounts.decode("VaultAccount", acc.data);
                }
            });
            for (let i = 0; i < vaultAcc.length; i++) {
                this.psyfiVaultInfos.set(reserveKeysWithVault[i].toString(), vaultAcc[i]);
            }
        });
    }
    /**
     * Given Price Data loaded from an Oracle, parses `PriceInformation`. Requires the reserve to be
     * loaded into the helper (used to fetch the discount rate). If the Price Data doesn't have a
     * valid price, will fall back to EMA. If EMA isn't available, falls back to a placeholder of $1
     * @param reserveKey
     * @param buff - accInfo.data for a Pyth PriceData acc
     * @param nativeDecimals - typically read from reserve.exponent, or the native mint itself.
     * @returns
     */
    parsePriceDataIntoPriceInformation(reserveKey, buff, nativeDecimals) {
        var _a;
        let priceData = client.parsePriceData(buff);
        let discountRate = (_a = this.getReserveInfo(reserveKey.toString())) === null || _a === void 0 ? void 0 : _a.discountRate;
        // Default placeholder price is $1 if the oracle price fails to load.
        let priceInfo = {
            price: 1,
            discountRate: discountRate / COMMON_DENOM,
            discountPrice: (1 * discountRate) / COMMON_DENOM,
            oracleDecimals: Math.abs(priceData.exponent),
            nativeDecimals: nativeDecimals,
            status: priceStatus.PRICE_INFORMATION_FAILED,
        };
        // Price was able to load
        if (priceData.price) {
            // Consider: extract exponent from reserve instead? any difference?
            priceInfo.price = priceData.price;
            if (discountRate != DEFAULT_DISCOUNT_RATE) {
                priceInfo.discountPrice =
                    (priceData.price * discountRate) / COMMON_DENOM;
            }
            else {
                priceInfo.discountPrice = priceInfo.price;
            }
            priceInfo.status = priceStatus.PRICE_INFORMATION_OK;
            return priceInfo;
        }
        else {
            // Price failed the load, attempt to fall back to EMA
            // TODO determine if agg (altPrice = priceData.aggregate;) or ema is more reliable
            let altPrice = priceData.emaPrice;
            // EMA price was able to load
            if (altPrice) {
                console.log("Failed to parse a price price for: " +
                    reserveKey +
                    " using the ema price as a placeholder");
                priceInfo.price = altPrice.value;
                if (discountRate != DEFAULT_DISCOUNT_RATE) {
                    priceInfo.discountPrice =
                        (altPrice.value * discountRate) / COMMON_DENOM;
                }
                else {
                    priceInfo.discountPrice = altPrice.value;
                }
                priceInfo.status = priceStatus.PRICE_INFORMATION_EMA;
                return priceInfo;
            }
            else {
                // Both regular price and EMA failed to load, return the placeholder
                console.log("Failed to parse a price or ema price for: " +
                    reserveKey +
                    " using a placeholder of $1");
                return priceInfo;
            }
        }
    }
    /**
     * Fetches the mint that issues the token this reserve trades in
     * @param reserveKey
     * @returns
     */
    getTokenMint(reserveKey) {
        var _a;
        return (_a = this.getReserveInfo(reserveKey)) === null || _a === void 0 ? void 0 : _a.tokenMint;
    }
    /**
     * Returns true if the given reserve is a PsyFi reserve (a reserve that trades PsyFi vault
     * tokens), false if this is a conventional reserve that trades a simple token
     * @param reserveKey
     * @returns
     */
    isPsyfiReserve(reserveKey) {
        var _a;
        // A non-PsyFi reserve still has a Psy Vault Config, but it will use default values.
        // If the Psy Vault Config is default, it must be a normal reserve.
        return !((_a = this.getReserveInfo(reserveKey)) === null || _a === void 0 ? void 0 : _a.psyfiVaultConfig.vaultAccount.equals(web3_js.PublicKey.default));
    }
}
// TODO take an array of obligations and load the whole shebang in chunks.

var ecosystem_helper = /*#__PURE__*/Object.freeze({
    __proto__: null,
    EcosystemHelper: EcosystemHelper
});

// Some common utility functions and types that may be useful for constructing a liquidation bot
/**
 * Accounts are eligible for liquidation when they drop below this threshold, defined as (sum of
 * collateral) / (sum of debts). Liquidators try to seize assets until an account meets this threshold
 */
const MIN_C_RATIO = 1.25;
/**
 * Liquidators get to keep this portion of the debt they repay. For example, if a liquidator repays
 * a debt of $100 with a premium of 1%, the liquidator takes an extra $1 (for a total of $101)
 */
const LIQUIDATION_PREMIUM = 0.01;
/**
 * "Blank" entries for collateral/loan reserves in a user's obligation use this default key.
 */
const DEFAULT_OBLIGATION_ENTRY = "11111111111111111111111111111111";
/**
 * Size of a collateral or loan position saved on the obligation. See `Position` in obligation.rs
 * for more details.
 */
const POSITION_SIZE = 160;
/**
 * DEPRECATED, USE `getLiquidationOptions`, which supports obligations with multiple positions
 *
 * Given a user with one collateral asset and one borrowed asset, returns the amount the liquidator
 * should attempt to repay and how much collateral should be claimed for this liquidation.
 *
 * Generally, some slippage should be subtracted from the expected collateral.
 *
 * @param program
 * @param userCollateralAssetAccount - users's collateral account for the Jet reserve where
 * collateral is deposited.
 * @param userLoanAccount - users's loan account for the Jet reserve where the user borrowed funds
 * @param collateralPrice - price of 1 collateral token in USD, before discount rate applied
 * @param discountRate - discount rate for the collateral, as float (e.g. 95% = .95)
 * @param cRatioTarget - typically the largest C Ratio among all loan accounts, as float (e.g. 125% = 1.25)
 * @param liquidationPrem - bonus earned for liquidated this loan, as float (e.g. 2% = .02)
 * @param collateralDecimals - decimals used for collateral asset (can be derived from the asset mint)
 * @param debtPrice - price of 1 borrowed token in USD
 * @param debtDecimals - decimals used for loan asset (can be derived from the asset mint)
 * @returns amount to repay in native decimals, amount to repay in USD, amount to seize in native decimals,
 * amount to seize in USD, expected profit or loss in USD
 */
const getIdealLiquidationAmountSingleAsset = (program, userCollateralAssetAccount, userLoanAccount, collateralPrice, discountRate, liquidationPrem, cRatioTarget, collateralDecimals, debtPrice, debtDecimals) => __awaiter(void 0, void 0, void 0, function* () {
    let collateral = yield getTokenAccountBalance(program, userCollateralAssetAccount);
    let debt = yield getTokenAccountBalance(program, userLoanAccount);
    return getIdealLiquidationAmountSingleAssetNoFetch(collateral, debt, collateralPrice, discountRate, liquidationPrem, cRatioTarget, collateralDecimals, debtPrice, debtDecimals);
});
/**
 * DEPRECATED, USE `getLiquidationOptions`, which supports obligations with multiple positions
 *
 * Given a user with one collateral asset and one borrowed asset, returns the amount the liquidator
 * should attempt to repay and how much collateral should be claimed for this liquidation.
 *
 * Generally, some slippage should be subtracted from the expected collateral.
 *
 * @param collateral - token balance of user's collateral acc
 * @param debt - token balance of user's loan acc
 * @param collateralPrice - price of 1 collateral token in USD, before discount rate applied
 * @param discountRate - discount rate for the collateral, as float (e.g. 95% = .95)
 * @param cRatioTarget - typically the largest C Ratio among all loan accounts, as float (e.g. 125% = 1.25)
 * @param liquidationPrem - bonus earned for liquidated this loan, as float (e.g. 2% = .02)
 * @param collateralDecimals - decimals used for collateral asset (can be derived from the asset mint)
 * @param debtPrice - price of 1 borrowed token in USD
 * @param debtDecimals - decimals used for loan asset (can be derived from the asset mint)
 * @returns amount to repay in native decimals, amount to repay in USD, amount to seize in native decimals,
 * amount to seize in USD, expected profit or loss in USD
 */
const getIdealLiquidationAmountSingleAssetNoFetch = (collateral, debt, collateralPrice, discountRate, liquidationPrem, cRatioTarget, collateralDecimals, debtPrice, debtDecimals) => __awaiter(void 0, void 0, void 0, function* () {
    let collateralUSD = (collateral * collateralPrice) / Math.pow(10, collateralDecimals);
    let collateralUSD_disc = (collateral * collateralPrice * discountRate) /
        Math.pow(10, collateralDecimals);
    let debtUSD = (debt * debtPrice) / Math.pow(10, debtDecimals);
    let cRatio_disc = collateralUSD_disc / debtUSD;
    if (cRatio_disc > cRatioTarget) {
        console.error("Cannot liquidate a healthy target. Collateral (disc): + " +
            collateralUSD_disc +
            "debt: " +
            debtUSD +
            " C-ratio (disc): " +
            cRatio_disc +
            " but target C-ratio is: " +
            cRatioTarget);
        return;
    }
    let repaid, repaidUSD, seized, seizedUSD, expectedPnL;
    let limitFrac = ((debtUSD / collateralUSD) * cRatioTarget -
        collateralUSD_disc / collateralUSD) /
        (cRatioTarget / (1 + liquidationPrem) - discountRate);
    if (limitFrac <= 1) {
        let R_max = (collateralUSD * limitFrac) / (1 + liquidationPrem);
        let S_L = R_max * (1 + liquidationPrem);
        let S_R = (R_max / debtUSD) * collateralUSD;
        repaidUSD = R_max;
        seizedUSD = Math.min(S_L, S_R);
    }
    else {
        let R_max = debtUSD;
        let S_L = R_max * (1 + liquidationPrem);
        let S_R = (R_max / debtUSD) * collateralUSD;
        repaidUSD = R_max;
        seizedUSD = Math.min(S_L, S_R);
    }
    repaid = (repaidUSD / debtPrice) * Math.pow(10, debtDecimals);
    seized = (seizedUSD / collateralPrice) * Math.pow(10, collateralDecimals);
    expectedPnL = seizedUSD - repaidUSD;
    return { repaid, repaidUSD, seized, seizedUSD, expectedPnL };
});
/**
 * Fetches the obligation, then calls {@link obligationLoaderNoFetch}
 * @param program - psylend program
 * @param obligation - pubkey of obligation. Must exist.
 */
const obligationLoader = (program, obligation) => __awaiter(void 0, void 0, void 0, function* () {
    let userObligation = (yield program.account.obligation.fetch(obligation));
    return obligationLoaderNoFetch(userObligation);
});
/**
 * Reads data from an already fetched Obligation. Executes no network calls.
 *
 * Loads information about a user's obligation, returns:
 *
 * -the addresses of all reserves used as collateral or borrowed against as loans,
 *
 * -the amount/balance for each collateral/loan reserve,
 *
 * -the net value of all collateral and loans, in USD
 *
 * Notes:
 *
 * Currency balances are NOT in native decimals, but in regular JS numbers, e.g. 1 BTC will be
 * expressed as "1", not in Satoshis with the appropriate decimals. This is because they are stored
 * on the obligation as U192 Numbers, which always have the same decimals (15). To recover the correct
 * decimals, use the oracle decimals or read decimals from the currency's mint
 *
 * Likewise all account values are in USD, with no decimals. e.g. 1.1 = $1 and ten cents
 *
 * Cached prices may be stale if the olbigation has not updated its calculation cache recently (this
 * typically occurs on a borrow, withdraw, or liquidation event, trigger a new liquidation event to
 * refresh the user's obligation cache))
 * @param userObligation
 * @returns
 */
const obligationLoaderNoFetch = (userObligation) => {
    let collateralAccountKeys = [];
    let collateralAmounts = [];
    // Collateral/loan accounts are stored as `POSITION_SIZE` (160 as of 10/22) byte entries
    // <Publickey of Reserve as 32 bytes> <U192 quantity (24 bytes)> <reserved/misc info>
    let collateralBytes = Buffer.from(userObligation.collateral);
    for (let i = 0; i < collateralBytes.length; i += POSITION_SIZE) {
        let keyBytes = collateralBytes.slice(i, i + 32);
        let reserveKey = new web3_js.PublicKey(keyBytes);
        if (reserveKey.toString() == DEFAULT_OBLIGATION_ENTRY) {
            continue;
        }
        //For debugging key decoding issues:
        // console.log("bytes extracted: " + keyBytes);
        // for (let i = 0; i < keyBytes.length; i++) {
        //   console.log("key " + keyBytes[i]);
        // }
        // console.log("");
        let amount = psyBNToNumber(readU192FromBuffer(collateralBytes, i + 32));
        // let value = (await getPriceForReserve(program, reserveKey)) * amount;
        collateralAccountKeys.push(reserveKey);
        collateralAmounts.push(amount);
    }
    let loanAccountKeys = [];
    let loanAmounts = [];
    let loanBytes = Buffer.from(userObligation.loans);
    for (let i = 0; i < loanBytes.length; i += POSITION_SIZE) {
        let keyBytes = loanBytes.slice(i, i + 32);
        let reserveKey = new web3_js.PublicKey(keyBytes);
        if (reserveKey.toString() == DEFAULT_OBLIGATION_ENTRY) {
            continue;
        }
        let amount = psyBNToNumber(readU192FromBuffer(loanBytes, i + 32));
        loanAccountKeys.push(reserveKey);
        loanAmounts.push(amount);
    }
    let cache = decodeCalculationCacheStruct(Buffer.from(userObligation.cached));
    console.log("cached collateral val: " + cache.collateral_value.toString());
    let netCollateralValue = psyBNToNumber(cache.collateral_value);
    console.log("cached discounted collateral val: " +
        cache.discounted_collateral_value.toString());
    let netDiscountedCollateralValue = psyBNToNumber(cache.discounted_collateral_value);
    console.log("cached loan val: " + cache.loan_value.toString());
    let netLoanValue = psyBNToNumber(cache.loan_value);
    console.log("cached last updated: " + cache.lastUpdated.toString());
    let info = {
        collateralAccountKeys,
        collateralAmounts,
        netCollateralValue,
        netDiscountedCollateralValue,
        loanAccountKeys,
        loanAmounts,
        netLoanValue,
    };
    return info;
};
/**
 * Prints information about an obligation to console.
 * @param info
 */
const printObligationInfo = (info) => {
    console.log("obligation loaded: ");
    console.log("read " + info.collateralAmounts.length + " collateral accounts");
    for (let i = 0; i < info.collateralAmounts.length; i++) {
        console.log("collateral acc " + i + ": " + info.collateralAccountKeys[i]);
        console.log("collateral " + i + ": " + info.collateralAmounts[i]);
    }
    for (let i = 0; i < info.loanAmounts.length; i++) {
        console.log("loan acc " + i + ": " + info.loanAccountKeys[i]);
        console.log("borrow " + i + ": " + info.loanAmounts[i]);
    }
    console.log("net collateral val: " + info.netCollateralValue);
    console.log("net loan val: " + info.netLoanValue);
};
/**
 * Given a reserve, returns the value of a vault token in USD. The helper must be fully refreshed,
 * including the vaults
 *
 * Mirrors `compute_vault_token_price` on the Rust side.
 *
 * Use `getVaultTokenPrice` from the PsyFi package to get a price that doesn't incorporate
 * `optionTokenRemaining` or `pendingCollateralAssetDeposits`
 *
 * TODO: BN to number conversions can go out of bounds, need a version without precision loss
 * @param reserveKey
 * @param helper
 */
const getVaultTokenPricing = (reserveKey, helper) => {
    let reserveInfo = helper.getReserveInfo(reserveKey.toString());
    let vaultInfo = helper.psyfiVaultInfos.get(reserveKey.toString());
    let priceInfo = helper.prices.get(reserveKey.toString());
    if (!vaultInfo) {
        console.log("Failed to load PsyFi vault information for: " +
            reserveKey +
            " Try refreshing vaults.");
    }
    let meta = vaultInfo.euroMetaCache[0];
    let strikePrice = meta.strikePrice.toNumber() / Math.pow(10, meta.strikePriceDecimals);
    let collateralTokenFactor = Math.pow(10, reserveInfo.psyfiVaultConfig.collateralTokenDecimals);
    // Get option collateral values
    /**
     * In collateral decimals
     */
    let totalOptionCollateral = vaultInfo.optionsCollateralHeld.toNumber();
    /**
     * As float, no decimals
     */
    let writerTokenAmount = meta.writerTokenAmount.toNumber() / Math.pow(10, meta.writerTokenDecimals);
    /**
     * As float, no decimals
     */
    let optionTokenRemaining = meta.optionTokenAmount.toNumber() / Math.pow(10, meta.optionTokenDecimals);
    /**
     * In collateral decimals
     */
    let optionCollateralNotAtRisk = 0;
    if (optionTokenRemaining > 0) {
        optionCollateralNotAtRisk =
            (optionTokenRemaining / writerTokenAmount) * totalOptionCollateral;
    }
    /**
     * In collateral decimals
     */
    let optionCollateralAtRisk = totalOptionCollateral - optionCollateralNotAtRisk;
    /**
     * In token, as float, no decimals
     */
    let residualCollateral = (vaultInfo.vaultCollateralAssetAccountAmount.toNumber() -
        vaultInfo.pendingCollateralAssetDeposits.toNumber() +
        optionCollateralNotAtRisk) /
        collateralTokenFactor;
    let optionCollateralPrice = 0;
    let intrinsicOptionValueFactor = 0;
    let residualCollateralPrice = 0;
    // TODO replace with hardcoded CALL/PUT refs from PsyFi package when added.
    // 0 = CALL, 1 = PUT
    if (vaultInfo.strategyType == 0) {
        // Div by token factor to get in tokens as float
        optionCollateralPrice =
            (optionCollateralAtRisk * priceInfo.price) / collateralTokenFactor;
        // Already in tokens, as float
        residualCollateralPrice = residualCollateral * priceInfo.price;
        // In USD, as float
        intrinsicOptionValueFactor = Math.min(strikePrice / priceInfo.price, 1);
    }
    else {
        // Div by token factor to get in tokens as float
        optionCollateralPrice = optionCollateralAtRisk / collateralTokenFactor;
        // Already in tokens, as float
        residualCollateralPrice = residualCollateral;
        if (strikePrice > 0) {
            intrinsicOptionValueFactor = Math.min(priceInfo.price / strikePrice, 1);
        }
    }
    if (intrinsicOptionValueFactor > 1) {
        console.log("Something went wrong: the intrinsic option value is " +
            intrinsicOptionValueFactor +
            " but should be <1");
    }
    let vaultTokensTotalPrice = optionCollateralPrice * intrinsicOptionValueFactor +
        residualCollateralPrice;
    let vaultDecimals = Math.abs(reserveInfo.exponent);
    let vaultTokenPrice = (vaultTokensTotalPrice * Math.pow(10, vaultDecimals)) /
        vaultInfo.vaultOwnershipTokenSupply.toNumber();
    return vaultTokenPrice;
};
/**
 * Given a position that has been decoded from an Obligation (see `decodePositionsList`), and an
 * EcosystemHelper that has been initialized and refreshed, returns information about the value of
 * that position.
 *
 * A loan will return a negative value
 *
 * @param decoded - a Position on an Obligation
 * @param reserveKey - If the reserveKey is not known, it can be extracted using the reserveIndex on the
 * decoded Position if the market is known using `getReserveFromIndexInReserveInfo`
 * @param helper - an up-to-date EcosystemHelper
 * @param isCollateral - true for a collateral position, false for a loan. Can be extracted from
 * decoded Position's side if not known.
 * @returns
 */
const getValueOfDecodedPosition = (decoded, reserveKey, helper, isCollateral) => {
    let exchangeRates = helper.exchangeRates.get(reserveKey.toString());
    let rate = isCollateral
        ? exchangeRates.depositNotesToTokens
        : exchangeRates.loanNotesToTokens;
    let noteAmount = psyBNToNumber(decoded.noteAmount);
    let tokenAmount = noteAmount * rate;
    let priceInfo = helper.prices.get(reserveKey.toString());
    let usdValue;
    let usdValueDiscounted;
    if (helper.isPsyfiReserve(reserveKey.toString())) {
        // Note: reserve.exponent can be used if token decimals are needed.
        // priceInfo.decimals can be used if price decimals are needed.
        let actualTokenPrice = getVaultTokenPricing(reserveKey, helper);
        usdValue = tokenAmount * actualTokenPrice;
        usdValueDiscounted =
            tokenAmount * priceInfo.discountRate * actualTokenPrice;
    }
    else {
        usdValue = tokenAmount * priceInfo.price;
        usdValueDiscounted = tokenAmount * priceInfo.discountPrice;
    }
    let premium = helper.getReserveInfo(reserveKey.toString()).config.liquidationPremium /
        COMMON_DENOM;
    let value = {
        tokenAmount: tokenAmount,
        noteAmount: noteAmount,
        tokenOracleDecimals: priceInfo.oracleDecimals,
        tokenNativeDecimals: priceInfo.nativeDecimals,
        usdValue: isCollateral ? usdValue : -usdValue,
        discountRate: priceInfo.discountRate,
        // Note: Loans have no discount rate applied
        usdValueDiscounted: isCollateral ? usdValueDiscounted : -usdValue,
        liquidationPremium: premium,
    };
    return value;
};
/**
 * Placeholder value used when the user has no loans to represent a C-Ratio of "infinity"
 */
const INFINITE_C_RATIO = 99999999;
/**
 * Processes an Obligation into all relevant price information. See `ObligationPriceInfo` for a full
 * description of values returned.
 *
 * Performs no RPC calls!
 * @param obligationKey - not validated, make sure this matches the `obligation`.
 * @param obligation - A loaded Obligation account
 * @param marketKey - not validated, make sure this matches the 'market'
 * @param market - A loaded market account
 * @param helper - An up-to-date and refreshed ecosystem helper.
 * @returns
 */
const getObligationPriceInfo = (obligationKey, obligation, marketKey, market, helper) => {
    let marketReservesDecoded = decodeReserveInfoStructList(Buffer.from(market.reserves));
    let collateralDecoded = decodePositionsList(Buffer.from(obligation.collateral), false);
    let loansDecoded = decodePositionsList(Buffer.from(obligation.loans), false);
    let collateralAccounts = [];
    let loanAccounts = [];
    let collateralReserves = [];
    let loanReserves = [];
    let collateralPositionValues = [];
    let loanPositionValues = [];
    let minCRatio = 0;
    let cRatioActual;
    let cRatioDiscounted;
    let canLiquidate;
    let collateralValue = 0;
    let collateralDiscountedValue = 0;
    let netValue = 0;
    let netDiscountedValue = 0;
    let loanValue = 0;
    for (let i = 0; i < collateralDecoded.length; i++) {
        let reserveKey = getReserveFromIndexInReserveInfo(collateralDecoded[i].reserveIndex.toNumber(), marketReservesDecoded);
        let value = getValueOfDecodedPosition(collateralDecoded[i], reserveKey, helper, true);
        collateralAccounts.push(collateralDecoded[i].account);
        collateralReserves.push(reserveKey);
        collateralPositionValues.push(value);
        collateralValue += value.usdValue;
        collateralDiscountedValue += value.usdValueDiscounted;
        netValue += value.usdValue;
        netDiscountedValue += value.usdValueDiscounted;
    }
    for (let i = 0; i < loansDecoded.length; i++) {
        let reserveKey = getReserveFromIndexInReserveInfo(loansDecoded[i].reserveIndex.toNumber(), marketReservesDecoded);
        let value = getValueOfDecodedPosition(loansDecoded[i], reserveKey, helper, false);
        loanAccounts.push(loansDecoded[i].account);
        loanReserves.push(reserveKey);
        loanPositionValues.push(value);
        loanValue += value.usdValue;
        netValue += value.usdValue;
        netDiscountedValue += value.usdValue;
        let reserve = helper.getReserveInfo(reserveKey.toString());
        let cRatio = reserve.config.minCollateralRatio / COMMON_DENOM;
        if (cRatio > minCRatio) {
            minCRatio = cRatio;
        }
    }
    // If no loaned assets, C-Ratio is infinite, use a placeholder for sorting.
    if (loanValue == 0) {
        cRatioActual = INFINITE_C_RATIO;
        cRatioDiscounted = INFINITE_C_RATIO;
    }
    else {
        cRatioActual = collateralValue / -loanValue;
        cRatioDiscounted = collateralDiscountedValue / -loanValue;
    }
    canLiquidate = cRatioDiscounted < minCRatio ? true : false;
    let obligationPriceInfo = {
        obligationKey: obligationKey,
        obligationMarket: marketKey,
        collateralAccounts: collateralAccounts,
        collateralReserves: collateralReserves,
        loanAccounts: loanAccounts,
        loanReserves: loanReserves,
        collateralPositionValues: collateralPositionValues,
        loanPositionValues: loanPositionValues,
        minCRatio: minCRatio,
        cRatioActual: cRatioActual,
        cRatioDiscounted: cRatioDiscounted,
        canLiquidate: canLiquidate,
        collateralValue: collateralValue,
        collateralDiscountedValue: collateralDiscountedValue,
        loanValue: loanValue,
        netValue: netValue,
        netDiscountedValue: netDiscountedValue,
    };
    return obligationPriceInfo;
};
/**
 * Examines all positions on the user's obligation and provides options for which positions to repay
 * and which to seize.
 * @param obligationPriceInfo - use {@link getObligationPriceInfo} to generate
 * @returns - an array of possible LiquidationEstimate, which describe the max that can be
 * repaid/seized with every possible pair of positions
 */
const getLiquidationOptions = (obligationPriceInfo) => {
    const estimates = [];
    const collateralValues = obligationPriceInfo.collateralPositionValues;
    const loanValues = obligationPriceInfo.loanPositionValues;
    for (let i = 0; i < collateralValues.length; i++) {
        for (let k = 0; k < loanValues.length; k++) {
            const repaySeizeAmounts = getLiquidationEstimateAmounts(obligationPriceInfo, loanValues[k], collateralValues[i]);
            estimates.push(Object.assign({ collateralAccount: obligationPriceInfo.collateralAccounts[i], collateralReserve: obligationPriceInfo.collateralReserves[i], loanAccount: obligationPriceInfo.loanAccounts[k], loanReserve: obligationPriceInfo.loanReserves[k], collateralDecimals: obligationPriceInfo.collateralPositionValues[i].tokenNativeDecimals, collateralOracleDecimals: obligationPriceInfo.collateralPositionValues[i].tokenOracleDecimals, loanDecimals: obligationPriceInfo.loanPositionValues[k].tokenNativeDecimals, loanOracleDecimals: obligationPriceInfo.loanPositionValues[k].tokenOracleDecimals }, repaySeizeAmounts));
        }
    }
    return estimates;
};
/**
 * Calculate the repay and seize amounts based on loanValue and collateralValue.
 * @param obligationPriceInfo
 * @param loanValue
 * @param collateralValue
 * @returns
 */
const getLiquidationEstimateAmounts = (obligationPriceInfo, loanValue, collateralValue) => {
    const collateralUSD = obligationPriceInfo.collateralValue;
    const collateralUSD_disc = obligationPriceInfo.collateralDiscountedValue;
    const debtUSD = Math.abs(obligationPriceInfo.loanValue);
    const cRatio_disc = collateralUSD_disc / debtUSD;
    const cRatioTarget = obligationPriceInfo.minCRatio;
    if (cRatio_disc > cRatioTarget) {
        console.error("Cannot liquidate a healthy target. Collateral (disc): " +
            collateralUSD_disc +
            ", debt: " +
            debtUSD +
            ", C-ratio (disc): " +
            cRatio_disc +
            ", but target C-ratio is: " +
            cRatioTarget);
        return {
            repaidUSD: 0,
            repaidTokens: 0,
            repaidNotes: 0,
            seizedUSD: 0,
            seizedTokens: 0,
            seizedNotes: 0,
            expectedPnL: 0,
        };
    }
    let repaid, repaidNotes, repaidUSD, seized, seizedNotes, seizedUSD, expectedPnL;
    const limitFrac = ((debtUSD / collateralUSD) * cRatioTarget -
        collateralUSD_disc / collateralUSD) /
        (cRatioTarget / (1 + loanValue.liquidationPremium) -
            collateralValue.discountRate);
    if (limitFrac <= 1) {
        const R_max = (collateralUSD * limitFrac) / (1 + loanValue.liquidationPremium);
        const S_L = R_max * (1 + loanValue.liquidationPremium);
        const S_R = (R_max / debtUSD) * collateralUSD;
        repaidUSD = R_max;
        seizedUSD = Math.min(S_L, S_R);
    }
    else {
        const R_max = debtUSD;
        const S_L = R_max * (1 + loanValue.liquidationPremium);
        const S_R = (R_max / debtUSD) * collateralUSD;
        repaidUSD = R_max;
        seizedUSD = Math.min(S_L, S_R);
    }
    // TODO here we may break down further based on position limits, e.g. cap the repayment amount
    // to the actual value of the position, if applicable. These token estimates will be larger
    // than the actual token balance in many cases, but the liquidator can easily cap the values
    // as needed.
    const collateralTokensPerUSD = collateralValue.tokenAmount / collateralValue.usdValue;
    const loanTokensPerUSD = Math.abs(loanValue.tokenAmount / loanValue.usdValue);
    repaid = loanTokensPerUSD * repaidUSD;
    seized = collateralTokensPerUSD * seizedUSD;
    const collateralNotesPerUSD = collateralValue.noteAmount / collateralValue.usdValue;
    const loanNotesPerUSD = Math.abs(loanValue.noteAmount / loanValue.usdValue);
    repaidNotes = loanNotesPerUSD * repaidUSD;
    seizedNotes = collateralNotesPerUSD * seizedUSD;
    expectedPnL = seizedUSD - repaidUSD;
    return {
        repaidUSD,
        repaidTokens: repaid,
        repaidNotes,
        seizedUSD,
        seizedTokens: seized,
        seizedNotes,
        expectedPnL,
    };
};

var liquidation_utils = /*#__PURE__*/Object.freeze({
    __proto__: null,
    MIN_C_RATIO: MIN_C_RATIO,
    LIQUIDATION_PREMIUM: LIQUIDATION_PREMIUM,
    DEFAULT_OBLIGATION_ENTRY: DEFAULT_OBLIGATION_ENTRY,
    POSITION_SIZE: POSITION_SIZE,
    getIdealLiquidationAmountSingleAsset: getIdealLiquidationAmountSingleAsset,
    getIdealLiquidationAmountSingleAssetNoFetch: getIdealLiquidationAmountSingleAssetNoFetch,
    obligationLoader: obligationLoader,
    obligationLoaderNoFetch: obligationLoaderNoFetch,
    printObligationInfo: printObligationInfo,
    getVaultTokenPricing: getVaultTokenPricing,
    getValueOfDecodedPosition: getValueOfDecodedPosition,
    INFINITE_C_RATIO: INFINITE_C_RATIO,
    getObligationPriceInfo: getObligationPriceInfo,
    getLiquidationOptions: getLiquidationOptions,
    getLiquidationEstimateAmounts: getLiquidationEstimateAmounts
});

const IDL = {
    version: "0.1.0",
    name: "psylend",
    instructions: [
        {
            name: "initDiscounts",
            accounts: [
                {
                    name: "signer",
                    isMut: false,
                    isSigner: true,
                },
                {
                    name: "payer",
                    isMut: true,
                    isSigner: true,
                },
                {
                    name: "discounts",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "systemProgram",
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: "mintAddresses",
                    type: {
                        array: ["publicKey", 20],
                    },
                },
                {
                    name: "discountRates",
                    type: {
                        array: ["u16", 20],
                    },
                },
            ],
        },
        {
            name: "initMarket",
            accounts: [
                {
                    name: "market",
                    isMut: true,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: "owner",
                    type: "publicKey",
                },
                {
                    name: "quoteCurrency",
                    type: "string",
                },
                {
                    name: "quoteTokenMint",
                    type: "publicKey",
                },
            ],
        },
        {
            name: "initReserve",
            accounts: [
                {
                    name: "market",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "marketAuthority",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "reserve",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "vault",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "dexSwapTokens",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "dexOpenOrders",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "dexMarket",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "tokenMint",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "tokenProgram",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "dexProgram",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "oraclePrice",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "oracleProduct",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "depositNoteMint",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "loanNoteMint",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "quoteTokenMint",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "feeNoteVault",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "owner",
                    isMut: false,
                    isSigner: true,
                },
                {
                    name: "payer",
                    isMut: true,
                    isSigner: true,
                },
                {
                    name: "systemProgram",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "rent",
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: "bump",
                    type: {
                        defined: "InitReserveBumpSeeds",
                    },
                },
                {
                    name: "config",
                    type: {
                        defined: "ReserveConfig",
                    },
                },
            ],
        },
        {
            name: "initPsyfiReserve",
            accounts: [
                {
                    name: "market",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "marketAuthority",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "reserve",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "vault",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "dexSwapTokens",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "dexOpenOrders",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "dexMarket",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "tokenMint",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "tokenProgram",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "dexProgram",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "oraclePrice",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "oracleProduct",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "depositNoteMint",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "loanNoteMint",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "quoteTokenMint",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "feeNoteVault",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "owner",
                    isMut: false,
                    isSigner: true,
                },
                {
                    name: "payer",
                    isMut: true,
                    isSigner: true,
                },
                {
                    name: "psyfiVaultAccount",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "collateralAssetMint",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "systemProgram",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "rent",
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: "bump",
                    type: {
                        defined: "InitReserveBumpSeeds",
                    },
                },
                {
                    name: "config",
                    type: {
                        defined: "ReserveConfig",
                    },
                },
            ],
        },
        {
            name: "updateDiscounts",
            accounts: [
                {
                    name: "authority",
                    isMut: false,
                    isSigner: true,
                },
                {
                    name: "discounts",
                    isMut: true,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: "mintAddresses",
                    type: {
                        array: ["publicKey", 20],
                    },
                },
                {
                    name: "discountRates",
                    type: {
                        array: ["u16", 20],
                    },
                },
            ],
        },
        {
            name: "updateReserveConfig",
            accounts: [
                {
                    name: "market",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "reserve",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "owner",
                    isMut: false,
                    isSigner: true,
                },
            ],
            args: [
                {
                    name: "newConfig",
                    type: {
                        defined: "ReserveConfig",
                    },
                },
            ],
        },
        {
            name: "updateReserveHalts",
            accounts: [
                {
                    name: "market",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "reserve",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "owner",
                    isMut: false,
                    isSigner: true,
                },
            ],
            args: [
                {
                    name: "haltState",
                    type: "u8",
                },
            ],
        },
        {
            name: "initDepositAccount",
            accounts: [
                {
                    name: "market",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "marketAuthority",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "reserve",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "depositNoteMint",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "depositor",
                    isMut: true,
                    isSigner: true,
                },
                {
                    name: "depositAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "tokenProgram",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "systemProgram",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "rent",
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: "bump",
                    type: "u8",
                },
            ],
        },
        {
            name: "initCollateralAccount",
            accounts: [
                {
                    name: "market",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "marketAuthority",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "obligation",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "reserve",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "depositNoteMint",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "owner",
                    isMut: true,
                    isSigner: true,
                },
                {
                    name: "collateralAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "tokenProgram",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "systemProgram",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "rent",
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: "bump",
                    type: "u8",
                },
            ],
        },
        {
            name: "initLoanAccount",
            accounts: [
                {
                    name: "market",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "marketAuthority",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "obligation",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "reserve",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "loanNoteMint",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "owner",
                    isMut: true,
                    isSigner: true,
                },
                {
                    name: "loanAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "tokenProgram",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "systemProgram",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "rent",
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: "bump",
                    type: "u8",
                },
            ],
        },
        {
            name: "initObligation",
            accounts: [
                {
                    name: "market",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "marketAuthority",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "borrower",
                    isMut: true,
                    isSigner: true,
                },
                {
                    name: "obligation",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "tokenProgram",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "systemProgram",
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: "bump",
                    type: "u8",
                },
            ],
        },
        {
            name: "initMarketReward",
            accounts: [
                {
                    name: "market",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "owner",
                    isMut: false,
                    isSigner: true,
                },
                {
                    name: "marketReward",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "systemProgram",
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: "initialRewardIndexTimestamp",
                    type: "i64",
                },
                {
                    name: "distributionPeriod",
                    type: "u64",
                },
                {
                    name: "rewardPointsPerPeriod",
                    type: "u64",
                },
                {
                    name: "rewardUnitDecimals",
                    type: "u8",
                },
                {
                    name: "minWithdrawalDuration",
                    type: "u64",
                },
            ],
        },
        {
            name: "updateReserveReward",
            accounts: [
                {
                    name: "market",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "reserve",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "owner",
                    isMut: false,
                    isSigner: true,
                },
            ],
            args: [
                {
                    name: "depositRewardMultiplier",
                    type: "u8",
                },
                {
                    name: "borrowRewardMultiplier",
                    type: "u8",
                },
            ],
        },
        {
            name: "updateMarketReward",
            accounts: [
                {
                    name: "market",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "marketAuthority",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "marketReward",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "owner",
                    isMut: false,
                    isSigner: true,
                },
                {
                    name: "payer",
                    isMut: true,
                    isSigner: true,
                },
                {
                    name: "rewardTokenMint",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "rewardTokenAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "systemProgram",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "tokenProgram",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "rent",
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: "stateIndex",
                    type: "u8",
                },
                {
                    name: "infoIndex",
                    type: "u8",
                },
            ],
        },
        {
            name: "updateMarketRewardConfig",
            accounts: [
                {
                    name: "market",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "owner",
                    isMut: false,
                    isSigner: true,
                },
            ],
            args: [
                {
                    name: "minWithdrawalDuration",
                    type: "u64",
                },
            ],
        },
        {
            name: "accruePositionReward",
            accounts: [
                {
                    name: "market",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "reserve",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "obligation",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "owner",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "positionAccount",
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: "side",
                    type: "u8",
                },
            ],
        },
        {
            name: "claimRewards",
            accounts: [
                {
                    name: "market",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "marketAuthority",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "marketReward",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "owner",
                    isMut: false,
                    isSigner: true,
                },
                {
                    name: "obligation",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "tokenProgram",
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: "periodToClaim",
                    type: "u8",
                },
            ],
        },
        {
            name: "setMarketOwner",
            accounts: [
                {
                    name: "market",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "owner",
                    isMut: false,
                    isSigner: true,
                },
            ],
            args: [
                {
                    name: "newOwner",
                    type: "publicKey",
                },
            ],
        },
        {
            name: "setMarketFlags",
            accounts: [
                {
                    name: "market",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "owner",
                    isMut: false,
                    isSigner: true,
                },
            ],
            args: [
                {
                    name: "flags",
                    type: "u64",
                },
            ],
        },
        {
            name: "syncDiscountRates",
            accounts: [
                {
                    name: "reserve",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "discounts",
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [],
        },
        {
            name: "closeDepositAccount",
            accounts: [
                {
                    name: "market",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "marketAuthority",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "reserve",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "vault",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "depositNoteMint",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "depositor",
                    isMut: true,
                    isSigner: true,
                },
                {
                    name: "depositAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "receiverAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "tokenProgram",
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [],
        },
        {
            name: "closeCollateralAccount",
            accounts: [
                {
                    name: "market",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "marketAuthority",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "obligation",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "owner",
                    isMut: true,
                    isSigner: true,
                },
                {
                    name: "collateralAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "depositAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "tokenProgram",
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [],
        },
        {
            name: "closeLoanAccount",
            accounts: [
                {
                    name: "market",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "marketAuthority",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "obligation",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "owner",
                    isMut: true,
                    isSigner: true,
                },
                {
                    name: "loanAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "tokenProgram",
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [],
        },
        {
            name: "closeObligation",
            accounts: [
                {
                    name: "market",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "marketAuthority",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "owner",
                    isMut: true,
                    isSigner: true,
                },
                {
                    name: "obligation",
                    isMut: true,
                    isSigner: false,
                },
            ],
            args: [],
        },
        {
            name: "deposit",
            accounts: [
                {
                    name: "market",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "marketAuthority",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "reserve",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "vault",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "depositNoteMint",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "depositor",
                    isMut: false,
                    isSigner: true,
                },
                {
                    name: "depositAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "depositSource",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "tokenProgram",
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: "bump",
                    type: "u8",
                },
                {
                    name: "amount",
                    type: {
                        defined: "Amount",
                    },
                },
            ],
        },
        {
            name: "depositTokens",
            accounts: [
                {
                    name: "market",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "marketAuthority",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "reserve",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "vault",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "depositNoteMint",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "depositor",
                    isMut: false,
                    isSigner: true,
                },
                {
                    name: "depositAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "depositSource",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "tokenProgram",
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: "amount",
                    type: {
                        defined: "Amount",
                    },
                },
            ],
        },
        {
            name: "withdraw",
            accounts: [
                {
                    name: "market",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "marketAuthority",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "reserve",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "vault",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "depositNoteMint",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "depositor",
                    isMut: false,
                    isSigner: true,
                },
                {
                    name: "depositAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "withdrawAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "psyProgram",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "tokenProgram",
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: "bump",
                    type: "u8",
                },
                {
                    name: "amount",
                    type: {
                        defined: "Amount",
                    },
                },
            ],
        },
        {
            name: "withdrawTokens",
            accounts: [
                {
                    name: "market",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "marketAuthority",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "reserve",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "vault",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "depositNoteMint",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "depositor",
                    isMut: false,
                    isSigner: true,
                },
                {
                    name: "depositAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "withdrawAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "tokenProgram",
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: "amount",
                    type: {
                        defined: "Amount",
                    },
                },
            ],
        },
        {
            name: "depositCollateral",
            accounts: [
                {
                    name: "market",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "marketAuthority",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "reserve",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "obligation",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "owner",
                    isMut: false,
                    isSigner: true,
                },
                {
                    name: "depositAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "collateralAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "tokenProgram",
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: "bump",
                    type: {
                        defined: "DepositCollateralBumpSeeds",
                    },
                },
                {
                    name: "amount",
                    type: {
                        defined: "Amount",
                    },
                },
            ],
        },
        {
            name: "withdrawCollateral",
            accounts: [
                {
                    name: "market",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "marketAuthority",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "reserve",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "obligation",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "owner",
                    isMut: false,
                    isSigner: true,
                },
                {
                    name: "depositAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "collateralAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "tokenProgram",
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: "bump",
                    type: {
                        defined: "WithdrawCollateralBumpSeeds",
                    },
                },
                {
                    name: "amount",
                    type: {
                        defined: "Amount",
                    },
                },
            ],
        },
        {
            name: "borrow",
            accounts: [
                {
                    name: "market",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "marketAuthority",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "obligation",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "reserve",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "vault",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "loanNoteMint",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "borrower",
                    isMut: false,
                    isSigner: true,
                },
                {
                    name: "loanAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "receiverAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "tokenProgram",
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: "bump",
                    type: "u8",
                },
                {
                    name: "amount",
                    type: {
                        defined: "Amount",
                    },
                },
            ],
        },
        {
            name: "repay",
            accounts: [
                {
                    name: "market",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "marketAuthority",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "obligation",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "reserve",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "vault",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "loanNoteMint",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "loanAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "payerAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "payer",
                    isMut: false,
                    isSigner: true,
                },
                {
                    name: "tokenProgram",
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: "amount",
                    type: {
                        defined: "Amount",
                    },
                },
            ],
        },
        {
            name: "liquidate",
            accounts: [
                {
                    name: "market",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "marketAuthority",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "obligation",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "reserve",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "collateralReserve",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "vault",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "loanNoteMint",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "loanAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "collateralAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "payerAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "receiverObligation",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "receiverAccount",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "payer",
                    isMut: false,
                    isSigner: true,
                },
                {
                    name: "tokenProgram",
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: "amount",
                    type: {
                        defined: "Amount",
                    },
                },
                {
                    name: "minCollateral",
                    type: "u64",
                },
            ],
        },
        {
            name: "refreshReserve",
            accounts: [
                {
                    name: "market",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "reserve",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "pythOraclePrice",
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [],
        },
        {
            name: "accrueInterest",
            accounts: [
                {
                    name: "market",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "marketAuthority",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "reserve",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "feeNoteVault",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "depositNoteMint",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "tokenProgram",
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [],
        },
        {
            name: "refreshPsyfiReserve",
            accounts: [
                {
                    name: "market",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "reserve",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "psyfiVaultAccount",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "pythOraclePrice",
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [],
        },
    ],
    accounts: [
        {
            name: "discounts",
            type: {
                kind: "struct",
                fields: [
                    {
                        name: "reserved",
                        type: {
                            array: ["u8", 302],
                        },
                    },
                    {
                        name: "version",
                        type: "u16",
                    },
                    {
                        name: "lastUpdated",
                        type: "i64",
                    },
                    {
                        name: "authority",
                        type: "publicKey",
                    },
                    {
                        name: "mintAddresses",
                        type: {
                            array: ["publicKey", 20],
                        },
                    },
                    {
                        name: "discountRates",
                        type: {
                            array: ["u16", 20],
                        },
                    },
                ],
            },
        },
        {
            name: "marketReward",
            type: {
                kind: "struct",
                fields: [
                    {
                        name: "market",
                        type: "publicKey",
                    },
                    {
                        name: "states",
                        type: {
                            array: [
                                {
                                    defined: "RewardState",
                                },
                                96,
                            ],
                        },
                    },
                ],
            },
        },
        {
            name: "market",
            type: {
                kind: "struct",
                fields: [
                    {
                        name: "version",
                        type: "u32",
                    },
                    {
                        name: "quoteExponent",
                        type: "i32",
                    },
                    {
                        name: "quoteCurrency",
                        type: {
                            array: ["u8", 15],
                        },
                    },
                    {
                        name: "authorityBumpSeed",
                        type: {
                            array: ["u8", 1],
                        },
                    },
                    {
                        name: "authoritySeed",
                        type: "publicKey",
                    },
                    {
                        name: "marketAuthority",
                        type: "publicKey",
                    },
                    {
                        name: "owner",
                        type: "publicKey",
                    },
                    {
                        name: "quoteTokenMint",
                        type: "publicKey",
                    },
                    {
                        name: "flags",
                        type: "u64",
                    },
                    {
                        name: "marketRewardState",
                        type: {
                            defined: "MarketRewardState",
                        },
                    },
                    {
                        name: "reserved",
                        type: {
                            array: ["u8", 352],
                        },
                    },
                    {
                        name: "reserves",
                        type: {
                            array: ["u8", 15872],
                        },
                    },
                ],
            },
        },
        {
            name: "obligation",
            type: {
                kind: "struct",
                fields: [
                    {
                        name: "version",
                        type: "u32",
                    },
                    {
                        name: "reserved0",
                        type: "u32",
                    },
                    {
                        name: "market",
                        type: "publicKey",
                    },
                    {
                        name: "owner",
                        type: "publicKey",
                    },
                    {
                        name: "reserved1",
                        type: {
                            array: ["u8", 184],
                        },
                    },
                    {
                        name: "cached",
                        type: {
                            array: ["u8", 256],
                        },
                    },
                    {
                        name: "collateral",
                        type: {
                            array: ["u8", 2560],
                        },
                    },
                    {
                        name: "loans",
                        type: {
                            array: ["u8", 2560],
                        },
                    },
                    {
                        name: "accruedRewardUnits",
                        type: {
                            array: ["u128", 96],
                        },
                    },
                ],
            },
        },
        {
            name: "reserve",
            type: {
                kind: "struct",
                fields: [
                    {
                        name: "version",
                        type: "u16",
                    },
                    {
                        name: "index",
                        type: "u16",
                    },
                    {
                        name: "exponent",
                        type: "i32",
                    },
                    {
                        name: "market",
                        type: "publicKey",
                    },
                    {
                        name: "pythOraclePrice",
                        type: "publicKey",
                    },
                    {
                        name: "pythOracleProduct",
                        type: "publicKey",
                    },
                    {
                        name: "tokenMint",
                        type: "publicKey",
                    },
                    {
                        name: "depositNoteMint",
                        type: "publicKey",
                    },
                    {
                        name: "loanNoteMint",
                        type: "publicKey",
                    },
                    {
                        name: "vault",
                        type: "publicKey",
                    },
                    {
                        name: "feeNoteVault",
                        type: "publicKey",
                    },
                    {
                        name: "dexSwapTokens",
                        type: "publicKey",
                    },
                    {
                        name: "dexOpenOrders",
                        type: "publicKey",
                    },
                    {
                        name: "dexMarket",
                        type: "publicKey",
                    },
                    {
                        name: "reserved0",
                        type: {
                            array: ["u8", 408],
                        },
                    },
                    {
                        name: "config",
                        type: {
                            defined: "ReserveConfig",
                        },
                    },
                    {
                        name: "psyfiVaultConfig",
                        type: {
                            defined: "PsyFiVaultConfig",
                        },
                    },
                    {
                        name: "discountRate",
                        type: "u16",
                    },
                    {
                        name: "discountRateVersion",
                        type: "u16",
                    },
                    {
                        name: "haltState",
                        type: "u8",
                    },
                    {
                        name: "reserved1",
                        type: {
                            array: ["u8", 123],
                        },
                    },
                    {
                        name: "reserved2",
                        type: {
                            array: ["u128", 32],
                        },
                    },
                    {
                        name: "state",
                        type: {
                            array: ["u8", 3584],
                        },
                    },
                ],
            },
        },
    ],
    types: [
        {
            name: "DepositCollateralBumpSeeds",
            type: {
                kind: "struct",
                fields: [
                    {
                        name: "collateralAccount",
                        type: "u8",
                    },
                    {
                        name: "depositAccount",
                        type: "u8",
                    },
                ],
            },
        },
        {
            name: "InitReserveBumpSeeds",
            type: {
                kind: "struct",
                fields: [
                    {
                        name: "vault",
                        type: "u8",
                    },
                    {
                        name: "feeNoteVault",
                        type: "u8",
                    },
                    {
                        name: "dexOpenOrders",
                        type: "u8",
                    },
                    {
                        name: "dexSwapTokens",
                        type: "u8",
                    },
                    {
                        name: "depositNoteMint",
                        type: "u8",
                    },
                    {
                        name: "loanNoteMint",
                        type: "u8",
                    },
                ],
            },
        },
        {
            name: "WithdrawCollateralBumpSeeds",
            type: {
                kind: "struct",
                fields: [
                    {
                        name: "collateralAccount",
                        type: "u8",
                    },
                    {
                        name: "depositAccount",
                        type: "u8",
                    },
                ],
            },
        },
        {
            name: "RewardState",
            type: {
                kind: "struct",
                fields: [
                    {
                        name: "withdrawalTime",
                        type: "i64",
                    },
                    {
                        name: "unclaimedRewardUnits",
                        type: "u128",
                    },
                    {
                        name: "period",
                        type: "u8",
                    },
                    {
                        name: "reserved0",
                        type: {
                            array: ["u8", 7],
                        },
                    },
                    {
                        name: "reserved1",
                        type: {
                            array: ["u8", 32],
                        },
                    },
                    {
                        name: "reserved2",
                        type: {
                            array: ["u8", 32],
                        },
                    },
                    {
                        name: "info",
                        type: {
                            array: [
                                {
                                    defined: "RewardInfo",
                                },
                                5,
                            ],
                        },
                    },
                ],
            },
        },
        {
            name: "RewardInfo",
            type: {
                kind: "struct",
                fields: [
                    {
                        name: "rewardTokenMint",
                        type: "publicKey",
                    },
                    {
                        name: "rewardTokenAccount",
                        type: "publicKey",
                    },
                ],
            },
        },
        {
            name: "MarketRewardState",
            type: {
                kind: "struct",
                fields: [
                    {
                        name: "marketReward",
                        type: "publicKey",
                    },
                    {
                        name: "initialRewardIndexTimestamp",
                        type: "i64",
                    },
                    {
                        name: "distributionPeriod",
                        type: "u64",
                    },
                    {
                        name: "rewardPointsPerPeriod",
                        type: "u64",
                    },
                    {
                        name: "totalRewardMultiplier",
                        type: "u64",
                    },
                    {
                        name: "minWithdrawalDuration",
                        type: "u64",
                    },
                    {
                        name: "rewardUnitDecimals",
                        type: "u8",
                    },
                    {
                        name: "reserved0",
                        type: {
                            array: ["u8", 23],
                        },
                    },
                    {
                        name: "reserved1",
                        type: {
                            array: ["u8", 64],
                        },
                    },
                ],
            },
        },
        {
            name: "PsyFiVaultConfig",
            type: {
                kind: "struct",
                fields: [
                    {
                        name: "vaultAccount",
                        type: "publicKey",
                    },
                    {
                        name: "collateralTokenDecimals",
                        type: "u8",
                    },
                    {
                        name: "reserved1",
                        type: {
                            array: ["u8", 31],
                        },
                    },
                    {
                        name: "reserved2",
                        type: {
                            array: ["u8", 64],
                        },
                    },
                ],
            },
        },
        {
            name: "ReserveConfig",
            type: {
                kind: "struct",
                fields: [
                    {
                        name: "utilizationRate1",
                        type: "u16",
                    },
                    {
                        name: "utilizationRate2",
                        type: "u16",
                    },
                    {
                        name: "borrowRate0",
                        type: "u16",
                    },
                    {
                        name: "borrowRate1",
                        type: "u16",
                    },
                    {
                        name: "borrowRate2",
                        type: "u16",
                    },
                    {
                        name: "borrowRate3",
                        type: "u16",
                    },
                    {
                        name: "minCollateralRatio",
                        type: "u16",
                    },
                    {
                        name: "liquidationPremium",
                        type: "u16",
                    },
                    {
                        name: "manageFeeCollectionThreshold",
                        type: "u64",
                    },
                    {
                        name: "manageFeeRate",
                        type: "u16",
                    },
                    {
                        name: "loanOriginationFee",
                        type: "u16",
                    },
                    {
                        name: "reserved0",
                        type: "u16",
                    },
                    {
                        name: "confidenceThreshold",
                        type: "u16",
                    },
                    {
                        name: "liquidationDexTradeMax",
                        type: "u64",
                    },
                    {
                        name: "depositRewardMultiplier",
                        type: "u8",
                    },
                    {
                        name: "borrowRewardMultiplier",
                        type: "u8",
                    },
                    {
                        name: "reserved1",
                        type: {
                            array: ["u8", 22],
                        },
                    },
                ],
            },
        },
        {
            name: "Amount",
            type: {
                kind: "struct",
                fields: [
                    {
                        name: "units",
                        type: "u8",
                    },
                    {
                        name: "value",
                        type: "u64",
                    },
                ],
            },
        },
        {
            name: "CacheInvalidError",
            type: {
                kind: "enum",
                variants: [
                    {
                        name: "Expired",
                        fields: [
                            {
                                name: "msg",
                                type: "string",
                            },
                        ],
                    },
                    {
                        name: "TooNew",
                        fields: [
                            {
                                name: "msg",
                                type: "string",
                            },
                        ],
                    },
                    {
                        name: "Invalidated",
                    },
                ],
            },
        },
        {
            name: "Side",
            type: {
                kind: "enum",
                variants: [
                    {
                        name: "Collateral",
                    },
                    {
                        name: "Loan",
                    },
                ],
            },
        },
        {
            name: "JobCompletion",
            type: {
                kind: "enum",
                variants: [
                    {
                        name: "Partial",
                    },
                    {
                        name: "Full",
                    },
                ],
            },
        },
        {
            name: "Rounding",
            type: {
                kind: "enum",
                variants: [
                    {
                        name: "Up",
                    },
                    {
                        name: "Down",
                    },
                ],
            },
        },
    ],
    events: [
        {
            name: "BorrowEvent",
            fields: [
                {
                    name: "borrower",
                    type: "publicKey",
                    index: false,
                },
                {
                    name: "reserve",
                    type: "publicKey",
                    index: false,
                },
                {
                    name: "debt",
                    type: "u64",
                    index: false,
                },
            ],
        },
        {
            name: "DepositCollateralEvent",
            fields: [
                {
                    name: "depositor",
                    type: "publicKey",
                    index: false,
                },
                {
                    name: "reserve",
                    type: "publicKey",
                    index: false,
                },
                {
                    name: "amount",
                    type: {
                        defined: "Amount",
                    },
                    index: false,
                },
            ],
        },
        {
            name: "LiquidateEvent",
            fields: [
                {
                    name: "borrower",
                    type: "publicKey",
                    index: false,
                },
                {
                    name: "debtReserve",
                    type: "publicKey",
                    index: false,
                },
                {
                    name: "collateralReserve",
                    type: "publicKey",
                    index: false,
                },
                {
                    name: "paidAmount",
                    type: {
                        defined: "Amount",
                    },
                    index: false,
                },
                {
                    name: "collateralAmount",
                    type: "u64",
                    index: false,
                },
            ],
        },
        {
            name: "RepayEvent",
            fields: [
                {
                    name: "borrower",
                    type: "publicKey",
                    index: false,
                },
                {
                    name: "reserve",
                    type: "publicKey",
                    index: false,
                },
                {
                    name: "amount",
                    type: {
                        defined: "Amount",
                    },
                    index: false,
                },
            ],
        },
        {
            name: "WithdrawCollateralEvent",
            fields: [
                {
                    name: "depositor",
                    type: "publicKey",
                    index: false,
                },
                {
                    name: "reserve",
                    type: "publicKey",
                    index: false,
                },
                {
                    name: "amount",
                    type: {
                        defined: "Amount",
                    },
                    index: false,
                },
            ],
        },
    ],
    errors: [
        {
            code: 6000,
            name: "ArithmeticError",
            msg: "failed to perform some math operation safely",
        },
        {
            code: 6001,
            name: "InvalidOracle",
            msg: "oracle account provided is not valid",
        },
        {
            code: 6002,
            name: "NoFreeReserves",
            msg: "no free space left to add a new reserve in the market",
        },
        {
            code: 6003,
            name: "NoFreeObligation",
            msg: "no free space left to add the new loan or collateral in an obligation",
        },
        {
            code: 6004,
            name: "UnregisteredPosition",
            msg: "the obligation account doesn't have any record of the loan or collateral account",
        },
        {
            code: 6005,
            name: "InvalidOraclePrice",
            msg: "the oracle price is negative or does not meet confidence threshold.",
        },
        {
            code: 6006,
            name: "InvalidOracleExpo",
            msg: "the oracle exponent is positive, expected a negative exponent",
        },
        {
            code: 6007,
            name: "OraclePriceExpired",
            msg: "the oracle price is outdated, expected a more recent price",
        },
        {
            code: 6008,
            name: "InsufficientCollateral",
            msg: "there is not enough collateral deposited to borrow against",
        },
        {
            code: 6009,
            name: "InsufficientCollateralInVault",
            msg: "there is not enough collateral in the vault to borrow against",
        },
        {
            code: 6010,
            name: "SimultaneousDepositAndBorrow",
            msg: "cannot both deposit collateral to and borrow from the same reserve",
        },
        {
            code: 6011,
            name: "ObligationHealthy",
            msg: "cannot liquidate a healthy position",
        },
        {
            code: 6012,
            name: "ObligationUnhealthy",
            msg: "cannot perform an action that would leave the obligation unhealthy",
        },
        {
            code: 6013,
            name: "ExceptionalReserveState",
            msg: "reserve requires special action; call refresh_reserve until up to date",
        },
        {
            code: 6014,
            name: "InvalidAmountUnits",
            msg: "the units provided in the amount are not valid for the instruction",
        },
        {
            code: 6015,
            name: "InvalidDexMarketMints",
            msg: "the tokens in the DEX market don't match the reserve and lending market quote token",
        },
        {
            code: 6016,
            name: "InvalidMarketAuthority",
            msg: "the market authority provided doesn't match the market account",
        },
        {
            code: 6017,
            name: "InvalidLiquidationQuoteTokenAccount",
            msg: "the quote token account provided cannot be used for liquidations",
        },
        {
            code: 6018,
            name: "ObligationAccountMismatch",
            msg: "the obligation account doesn't have the collateral/loan registered",
        },
        {
            code: 6019,
            name: "UnknownInstruction",
            msg: "unknown instruction",
        },
        {
            code: 6020,
            name: "Disallowed",
            msg: "current conditions prevent an action from being performed",
        },
        {
            code: 6021,
            name: "LiquidationSwapSlipped",
            msg: "the actual slipped amount on the DEX trade exceeded the threshold configured",
        },
        {
            code: 6022,
            name: "CollateralValueTooSmall",
            msg: "the collateral value is too small for a DEX trade",
        },
        {
            code: 6023,
            name: "LiquidationLowCollateral",
            msg: "the collateral returned by the liquidation is smaller than requested",
        },
        {
            code: 6024,
            name: "NotSupported",
            msg: "this action is currently not supported by this version of the program",
        },
        {
            code: 6025,
            name: "MarketHalted",
            msg: "the market has currently halted this kind of operation",
        },
        {
            code: 6026,
            name: "ReserveHaltedDeposits",
            msg: "the reserve has currently halted new deposits",
        },
        {
            code: 6027,
            name: "ReserveHaltedBorrows",
            msg: "the reserve has currently halted new borrows",
        },
        {
            code: 6028,
            name: "ReserveHaltedRepays",
            msg: "the reserve has currently halted repayments",
        },
        {
            code: 6029,
            name: "ReserveHaltedWithdraws",
            msg: "the reserve has currently halted withdraws",
        },
        {
            code: 6030,
            name: "InvalidParameter",
            msg: "a given parameter is not valid",
        },
        {
            code: 6031,
            name: "PositionNotEmpty",
            msg: "the obligation account still holds position in the loan or collateral account",
        },
        {
            code: 6032,
            name: "ObligationPositionNotFound",
            msg: "position not found in an obligation",
        },
        {
            code: 6033,
            name: "AccountNotEmptyError",
            msg: "the collateral/loan account is not empty",
        },
        {
            code: 6034,
            name: "PsyFiVaultMismatch",
            msg: "PsyFi vault account does not match",
        },
        {
            code: 6035,
            name: "InvalidVaultAccountState",
            msg: "VaultAccount in invalid state",
        },
        {
            code: 6036,
            name: "InvalidOptionType",
            msg: "Option type is not supported",
        },
        {
            code: 6037,
            name: "DiscountsBadSigner",
            msg: "This Signer is not authorized to update the discounts",
        },
        {
            code: 6038,
            name: "ReserveHaltBadSigner",
            msg: "This Signer is not authorized to update the reserves halted operations",
        },
        {
            code: 6039,
            name: "ReserveInfoStale",
            msg: "Reserve info is stale: run the refresh ix",
        },
        {
            code: 6040,
            name: "ReserveNoteStale",
            msg: "Reserve note is stale: run the accrue interest ix",
        },
        {
            code: 6041,
            name: "MaxAllowedPositions",
            msg: "Account exceeds max allowed positions: close existing collateral or borrowed position",
        },
        {
            code: 6042,
            name: "TimestampTooSmall",
            msg: "Timestamp cannot be smaller than initial reward timestamp",
        },
        {
            code: 6043,
            name: "PeriodTooShort",
            msg: "Distribution period is too short",
        },
        {
            code: 6044,
            name: "UnitDecimalsLimit",
            msg: "Reward unit decimals exeeds limit",
        },
        {
            code: 6045,
            name: "IndexExceedBounds",
            msg: "Out of bounds error in accessing index of an array",
        },
        {
            code: 6046,
            name: "PastPeriodUpdateError",
            msg: "Cannot update past periods",
        },
        {
            code: 6047,
            name: "RewardInfoAlreadyExists",
            msg: "Reward info is already initialized",
        },
        {
            code: 6048,
            name: "RewardInfoEmptyIndex",
            msg: "An empty reward info index exists before current index",
        },
        {
            code: 6049,
            name: "NoRecentRewardAccrual",
            msg: "No reward has been accrued recently. Please accrue rewards with accrue_interest ix.",
        },
        {
            code: 6050,
            name: "PeriodInFuture",
            msg: "Cannot claim reward from a period that has not started",
        },
        {
            code: 6051,
            name: "NoPointsAvailable",
            msg: "No points available for claiming",
        },
        {
            code: 6052,
            name: "WithdrawalNotAllowed",
            msg: "Cannot claim points yet as withdrawal is not allowed",
        },
        {
            code: 6053,
            name: "TokenMintMismatch",
            msg: "Token account mint mismatch",
        },
        {
            code: 6054,
            name: "TokenOwnerMismatch",
            msg: "Token account owner mismatch",
        },
        {
            code: 6055,
            name: "TokenAccountMismatch",
            msg: "Token account key mismatch",
        },
        {
            code: 6056,
            name: "InvalidMarketReward",
            msg: "Invalid market reward",
        },
        {
            code: 6057,
            name: "MustAccrualInterest",
            msg: "Interest must be accrued for reserve in the same block before initializing a new position",
        },
        {
            code: 6058,
            name: "RewardsEnded",
            msg: "Rewards have ended permanently and can no longer be altered",
        },
    ],
};

exports.IDL = IDL;
exports.PsyLendIdl = IDL;
exports.ecosystemHelper = ecosystem_helper;
exports.instructions = instructions;
exports.keys = keys;
exports.liquidationUtils = liquidation_utils;
exports.math = math;
exports.pdas = pdas;
exports.tools = tools;
exports.types = types;
