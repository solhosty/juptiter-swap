import { Program } from "@project-serum/anchor";
import { PublicKey } from "@solana/web3.js";
import { PriceInformation, ReserveAccount } from "./types";
import { reserveExchangeRates } from "./tools";
import { Psylend as PsyLend } from "./idl";
import { PsyFiEuros, VaultAccount } from "psyfi-euros-test";
/**
 * A tool for pulling information from various reserves in the PsyLend ecosystem
 */
export declare class EcosystemHelper {
    program: Program<PsyLend>;
    psyfiProgram: Program<PsyFiEuros>;
    /**
     * Given the public key for a reserve, maps information available in the on-chain reserve account,
     * such as price oracle, token mint address, etc.
     */
    reserveAccounts: Map<string, ReserveAccount>;
    /**
     * Given the public key for a reserve, maps a variety of information about exchange rates and
     * the total outstanding supply of tokens/notes. Exchange rates are loaded at the same time
     * `reserveAccounts` are loaded, as they are stored on the reserve struct, and may be out of date
     * if the accrue ix has not run for some time.
     */
    exchangeRates: Map<string, reserveExchangeRates>;
    /**
     * Given the public key for a reserve, maps the most recent pyth oracle price, and some useful
     * secondary values like the discounted price and price exponents.
     *
     * Refreshes independently, use `refreshPrice` or `refreshPrices`
     */
    prices: Map<string, PriceInformation>;
    /**
     * Given the public key for a reserve, maps information about the corresponding PsyFi vault
     * account, such as cached values for various vault balances. These are required to correctly
     * price reserves using vault tokens.
     *
     * Note that if a key to a non-PsyFi reserve is supplied, will return undefined. Always check if
     * the reserve is a PsyFi reserve ({@link this.isPsyfiReserve}) before attempting to read the vault info.
     *
     * Refreshes independently, use `refreshVaults`
     */
    psyfiVaultInfos: Map<string, VaultAccount>;
    /**
     * A tool for pulling information from various reserves in the PsyLend ecosystem
     * @param program - the Psylend program
     * @param psyfiProgram - the PsyFiEuros program, mandatory if any reserves are psyFi reserves
     */
    constructor(program: Program<PsyLend>, psyfiProgram?: Program<PsyFiEuros>);
    /**
     * Refreshes information about reserves and loads into the {@link reserveAccounts}. Always call refresh
     * after first creating an EcosystemHelper.
     *
     * Note: GetMultiple can fetch a max of 100 accounts. In the event more than 100 reserves exist,
     * call refresh several times in chunks of 100 or fewer.
     */
    refresh(reserveKeys: PublicKey[]): Promise<void>;
    /**
     * Refreshes information about reserves and loads into the {@link reserveAccounts}. Use if you
     * have already fetched all reserve data and wish to update the helper without invoking another
     * RPC call.
     *
     * Typically, reserve data is fetched with `program.account.reserve.fetchMultiple(reserveKeys)`
     * @param reserveKeys
     * @param reserves - the ReserveAccount for each key in `ReserveKeys`
     */
    refreshFromExistingFetch(reserveKeys: PublicKey[], reserves: ReserveAccount[]): void;
    /**
     * Refreshes only the given reserve, and loads info into the {@link reserveAccounts}.
     * @param reserveKey
     */
    refreshSingleReserve(reserveKey: PublicKey): Promise<void>;
    /**
     * Returns the ReserveAccount associated with the given key
     * @param key
     * @returns - ReserveAccount associated with the given key
     */
    getReserveInfo(key: string): ReserveAccount;
    /**
     * Returns the Pyth Price Oracle address for this reserve
     * @param reserveKey
     * @returns - Pubkey of Pyth Oracle Price
     */
    getOracle(reserveKey: string): PublicKey;
    /**
     * Fetches the current Pyth price (in oracle decimals), the price reflecting the currently applied
     * discount rate, and the exponent (for converting back to a standard decimal number if desired)
     *
     * The reserve itself must already be refreshed (use {@link refresh})
     * @param reserveKey
     * @returns a `PriceInformation`
     */
    refreshPrice(reserveKey: PublicKey): Promise<PriceInformation>;
    /**
     * Fetches the current price (in oracle decimals) for all given reserves, and adds them to the
     * prices map. Attempts to bundle the request into a one rpc call
     *
     * The reserves themselves must already be refreshed (use {@link refresh})
     *
     * Note: GetMultiple can fetch a max of 100 accounts. In the event more than 100 reserves exist,
     * call refresh refreshPrices times in chunks of 100 or fewer.
     * @param reserveKeys
     */
    refreshPrices(reserveKeys: PublicKey[]): Promise<void>;
    /**
     * Override the oracle price for this helper with the value given.
     *
     * The real price must have already been refreshed (use {@link refreshPrice}
     * {@link refreshPrices}). The oracle decimals and price status will be inherited
     * from the real price. The discount rate will be inherited from the real price unless specified
     * in the optional arg
     * @param reserveKey
     * @param price - the price to set, in USD, as float, e.g. $1.25 = 1.25
     * @param discountRate - (optional) override discount rate. As float, e.g. 95% = .95
     * @returns a `PriceInformation`
     */
    forcePrice(reserveKey: PublicKey, price: number, discountRate?: number): Promise<PriceInformation>;
    /**
     * Loads information for a single PsyFi Vaults, which is needed to price the corresponding
     * vault token deposited into PsyFi Reserves.
     *
     * The reserve itself must already be refreshed (use {@link refresh})
     * @param reserveKey
     * @returns a `VaultInformation`
     */
    refreshVault(reserveKey: PublicKey): Promise<VaultAccount>;
    /**
     * Loads information from PsyFi Vaults that is needed to price the corresponding vault token
     * deposited into PsyFi Reserves.
     *
     * Attempts to bundle the request into a single rpc call.
     *
     * The reserves themselves must already be refreshed (use {@link refresh})
     *
     * Note: GetMultiple can fetch a max of 100 accounts. In the event more than 100 reserves exist,
     * this function may fail to refresh vaults for all of them. Pass PsyFi reserves in chunks of less
     * than 100, but note that non-PsyFi reserves are skipped/ignored.
     * @param reserveKeys
     */
    refreshVaults(reserveKeys: PublicKey[]): Promise<void>;
    /**
     * Given Price Data loaded from an Oracle, parses `PriceInformation`. Requires the reserve to be
     * loaded into the helper (used to fetch the discount rate). If the Price Data doesn't have a
     * valid price, will fall back to EMA. If EMA isn't available, falls back to a placeholder of $1
     * @param reserveKey
     * @param buff - accInfo.data for a Pyth PriceData acc
     * @param nativeDecimals - typically read from reserve.exponent, or the native mint itself.
     * @returns
     */
    private parsePriceDataIntoPriceInformation;
    /**
     * Fetches the mint that issues the token this reserve trades in
     * @param reserveKey
     * @returns
     */
    getTokenMint(reserveKey: string): PublicKey;
    /**
     * Returns true if the given reserve is a PsyFi reserve (a reserve that trades PsyFi vault
     * tokens), false if this is a conventional reserve that trades a simple token
     * @param reserveKey
     * @returns
     */
    isPsyfiReserve(reserveKey: string): boolean;
}
//# sourceMappingURL=ecosystem_helper.d.ts.map