{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../src/broadcaster/index.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  Blockhash,\n  BlockhashWithExpiryBlockHeight,\n  Commitment,\n  ConfirmOptions,\n  Connection,\n  RpcResponseAndContext,\n  SendOptions,\n  SimulatedTransactionResponse,\n  Transaction,\n} from \"@solana/web3.js\";\n\nimport { firstAggregateError } from \"../error.js\";\nimport type { Broadcaster } from \"../interfaces.js\";\nimport { DEFAULT_PROVIDER_OPTIONS } from \"../provider.js\";\nimport { PendingTransaction } from \"../transaction/index.js\";\nimport { suppressConsoleErrorAsync } from \"../utils/index.js\";\nimport { simulateTransactionWithCommitment } from \"../utils/simulateTransactionWithCommitment.js\";\nimport { sendAndSpamRawTx } from \"./sendAndSpamRawTx.js\";\n\nexport * from \"./tiered.js\";\n\n/**\n * Options for retrying sending of transactions periodically.\n */\nexport interface TransactionRetryOptions {\n  /**\n   * Number of times to retry the transaction being sent.\n   */\n  retryTimes?: number;\n  /**\n   * Milliseconds elapsed between transaction retries.\n   */\n  retryInterval?: number;\n}\n\n/**\n * Default retry parameters.\n */\nexport const DEFAULT_RETRY_OPTIONS: Required<TransactionRetryOptions> = {\n  retryTimes: 3,\n  retryInterval: 1_000,\n};\n\n/**\n * Default retry parameters for fallbacks.\n */\nexport const DEFAULT_FALLBACK_RETRY_OPTIONS: Required<TransactionRetryOptions> =\n  {\n    retryTimes: 10,\n    retryInterval: 300,\n  };\n\nexport interface BroadcastOptions\n  extends ConfirmOptions,\n    TransactionRetryOptions {\n  /**\n   * Prints the transaction logs as emitted by @solana/web3.js. Defaults to true.\n   */\n  printLogs?: boolean;\n  /**\n   * Retry options to use for fallback send connections.\n   */\n  fallbackRetryOptions?: TransactionRetryOptions;\n}\n\n/**\n * Broadcasts transactions to a single connection.\n */\nexport class SingleConnectionBroadcaster implements Broadcaster {\n  constructor(\n    readonly sendConnection: Connection,\n    readonly opts: ConfirmOptions = DEFAULT_PROVIDER_OPTIONS\n  ) {}\n\n  /**\n   * @inheritdoc\n   */\n  async getLatestBlockhash(\n    commitment: Commitment = this.opts.commitment ?? \"confirmed\"\n  ): Promise<BlockhashWithExpiryBlockHeight> {\n    return await this.sendConnection.getLatestBlockhash(commitment);\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async getRecentBlockhash(\n    commitment: Commitment = this.opts.commitment ?? \"confirmed\"\n  ): Promise<Blockhash> {\n    const result = await this.sendConnection.getLatestBlockhash(commitment);\n    return result.blockhash;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async broadcast(\n    tx: Transaction,\n    { printLogs = true, ...opts }: BroadcastOptions = this.opts\n  ): Promise<PendingTransaction> {\n    if (tx.signatures.length === 0) {\n      throw new Error(\"Transaction must be signed before broadcasting.\");\n    }\n    const rawTx = tx.serialize();\n\n    if (printLogs) {\n      return new PendingTransaction(\n        this.sendConnection,\n        await sendAndSpamRawTx(this.sendConnection, rawTx, opts, opts)\n      );\n    }\n\n    return await suppressConsoleErrorAsync(async () => {\n      // hide the logs of TX errors if printLogs = false\n      return new PendingTransaction(\n        this.sendConnection,\n        await sendAndSpamRawTx(this.sendConnection, rawTx, opts, opts)\n      );\n    });\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async simulate(\n    tx: Transaction,\n    {\n      commitment = this.opts.preflightCommitment ?? \"confirmed\",\n      verifySigners = true,\n    }: {\n      commitment?: Commitment;\n      verifySigners?: boolean;\n    } = {\n      commitment: this.opts.preflightCommitment ?? \"confirmed\",\n      verifySigners: true,\n    }\n  ): Promise<RpcResponseAndContext<SimulatedTransactionResponse>> {\n    if (verifySigners && tx.signatures.length === 0) {\n      throw new Error(\"Transaction must be signed before simulating.\");\n    }\n    return await simulateTransactionWithCommitment(\n      this.sendConnection,\n      tx,\n      commitment\n    );\n  }\n}\n\n/**\n * Broadcasts transactions to multiple connections simultaneously.\n */\nexport class MultipleConnectionBroadcaster implements Broadcaster {\n  constructor(\n    readonly connections: readonly Connection[],\n    readonly opts: ConfirmOptions = DEFAULT_PROVIDER_OPTIONS\n  ) {}\n\n  async getLatestBlockhash(\n    commitment: Commitment = this.opts.preflightCommitment ?? \"confirmed\"\n  ): Promise<BlockhashWithExpiryBlockHeight> {\n    try {\n      const result = await Promise.any(\n        this.connections.map((conn) => conn.getLatestBlockhash(commitment))\n      );\n      return result;\n    } catch (e) {\n      if (e instanceof AggregateError) {\n        throw firstAggregateError(e);\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  async getRecentBlockhash(\n    commitment: Commitment = this.opts.preflightCommitment ?? \"confirmed\"\n  ): Promise<Blockhash> {\n    try {\n      const result = await Promise.any(\n        this.connections.map((conn) => conn.getLatestBlockhash(commitment))\n      );\n      return result.blockhash;\n    } catch (e) {\n      if (e instanceof AggregateError) {\n        throw firstAggregateError(e);\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  private async _sendRawTransaction(\n    encoded: Buffer,\n    options?: SendOptions & Pick<BroadcastOptions, \"retryTimes\">\n  ): Promise<PendingTransaction> {\n    try {\n      return await Promise.any(\n        this.connections.map(async (connection) => {\n          return new PendingTransaction(\n            connection,\n            await sendAndSpamRawTx(connection, encoded, options ?? this.opts)\n          );\n        })\n      );\n    } catch (e) {\n      if (e instanceof AggregateError) {\n        throw firstAggregateError(e);\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  /**\n   * Broadcasts a signed transaction.\n   *\n   * @param tx\n   * @param confirm\n   * @param opts\n   * @returns\n   */\n  async broadcast(\n    tx: Transaction,\n    { printLogs = true, ...opts }: BroadcastOptions = this.opts\n  ): Promise<PendingTransaction> {\n    if (tx.signatures.length === 0) {\n      throw new Error(\"Transaction must be signed before broadcasting.\");\n    }\n    const rawTx = tx.serialize();\n\n    if (printLogs) {\n      return await this._sendRawTransaction(rawTx, opts);\n    }\n\n    return await suppressConsoleErrorAsync(async () => {\n      // hide the logs of TX errors if printLogs = false\n      return await this._sendRawTransaction(rawTx, opts);\n    });\n  }\n\n  /**\n   * Simulates a transaction with a commitment.\n   * @param tx\n   * @param commitment\n   * @returns\n   */\n  async simulate(\n    tx: Transaction,\n    {\n      commitment = this.opts.preflightCommitment ??\n        this.opts.commitment ??\n        \"confirmed\",\n      verifySigners = true,\n    }: {\n      commitment?: Commitment;\n      verifySigners?: boolean;\n    } = {\n      commitment:\n        this.opts.preflightCommitment ?? this.opts.commitment ?? \"confirmed\",\n      verifySigners: true,\n    }\n  ): Promise<RpcResponseAndContext<SimulatedTransactionResponse>> {\n    if (verifySigners && tx.signatures.length === 0) {\n      throw new Error(\"Transaction must be signed before simulating.\");\n    }\n    try {\n      return await Promise.any(\n        this.connections.map(async (connection) => {\n          return await simulateTransactionWithCommitment(\n            connection,\n            tx,\n            commitment\n          );\n        })\n      );\n    } catch (e) {\n      if (e instanceof AggregateError) {\n        throw firstAggregateError(e);\n      } else {\n        throw e;\n      }\n    }\n  }\n}\n"]}