{"version":3,"file":"accounts.js","sourceRoot":"","sources":["../../../src/utils/accounts.ts"],"names":[],"mappings":";;;;AACA,kDAA2D;AAG3D,gFAAyC;AA8BzC;;;;GAIG;AACI,MAAM,sBAAsB,GAAG,CACpC,SAAoB,EACpB,QAAsB,EACtB,KAAoB,EACC,EAAE;IACvB,MAAM,OAAO,GAAiC,EAAE,CAAC;IACjD,QAAQ,CAAC,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE;QAC3B,OAAO,CAAC,IAAA,0BAAS,EAAC,OAAO,CAAC,IAAI,CAAY,CAAC,GAAG;YAC5C,SAAS;YACT,IAAI,EAAE,OAAO,CAAC,IAAI;YAClB,MAAM,EAAE,CAAC,KAAK,EAAE,EAAE,CAAC,KAAK,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,EAAE,KAAK,CAAC;YACpD,KAAK,EAAE,CAAC,IAAY,EAAE,EAAE,CAAC,KAAK,CAAC,MAAM,CAAa,OAAO,CAAC,IAAI,EAAE,IAAI,CAAC;YACrE,GAAG,EAAE,OAAO;YACZ,IAAI,EAAE,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC;YACzB,aAAa,EAAE,2BAAkB,CAAC,oBAAoB,CAAC,OAAO,CAAC,IAAI,CAAC;SACrE,CAAC;IACJ,CAAC,CAAC,CAAC;IACH,OAAO,OAA8B,CAAC;AACxC,CAAC,CAAC;AAlBW,QAAA,sBAAsB,0BAkBjC","sourcesContent":["import type { AccountsCoder } from \"@project-serum/anchor\";\nimport { BorshAccountsCoder } from \"@project-serum/anchor\";\nimport type { IdlTypeDef } from \"@project-serum/anchor/dist/esm/idl.js\";\nimport type { ProgramAccountParser, PublicKey } from \"@saberhq/solana-contrib\";\nimport camelCase from \"lodash.camelcase\";\n\n/**\n * Account information.\n */\nexport interface AnchorAccount<T> extends ProgramAccountParser<T> {\n  /**\n   * {@link IdlTypeDef}.\n   */\n  idl: IdlTypeDef;\n  /**\n   * Size of the account in bytes\n   */\n  size: number;\n  /**\n   * The discriminator.\n   */\n  discriminator: Buffer;\n  /**\n   * Encodes the value.\n   */\n  encode: (value: T) => Promise<Buffer>;\n}\n\n/**\n * {@link ProgramAccountParser}s associated with an IDL.\n */\nexport type AnchorAccountMap<M> = {\n  [K in keyof M]: AnchorAccount<M[K]>;\n};\n/**\n * Generates the metadata of accounts.\n *\n * This is intended to be called once at initialization.\n */\nexport const generateAnchorAccounts = <M>(\n  programID: PublicKey,\n  accounts: IdlTypeDef[],\n  coder: AccountsCoder\n): AnchorAccountMap<M> => {\n  const parsers: Partial<AnchorAccountMap<M>> = {};\n  accounts.forEach((account) => {\n    parsers[camelCase(account.name) as keyof M] = {\n      programID,\n      name: account.name,\n      encode: (value) => coder.encode(account.name, value),\n      parse: (data: Buffer) => coder.decode<M[keyof M]>(account.name, data),\n      idl: account,\n      size: coder.size(account),\n      discriminator: BorshAccountsCoder.accountDiscriminator(account.name),\n    };\n  });\n  return parsers as AnchorAccountMap<M>;\n};\n"]}