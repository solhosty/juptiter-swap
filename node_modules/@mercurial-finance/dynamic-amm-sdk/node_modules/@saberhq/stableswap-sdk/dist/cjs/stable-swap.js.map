{"version":3,"file":"stable-swap.js","sourceRoot":"","sources":["../../src/stable-swap.ts"],"names":[],"mappings":"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","sourcesContent":["import { getProgramAddress } from \"@saberhq/solana-contrib\";\nimport type { ProgramAccount } from \"@saberhq/token-utils\";\nimport { TOKEN_PROGRAM_ID } from \"@saberhq/token-utils\";\nimport type { Connection, TransactionInstruction } from \"@solana/web3.js\";\nimport { PublicKey } from \"@solana/web3.js\";\n\nimport { SWAP_PROGRAM_ID } from \"./constants.js\";\nimport type { IExchange } from \"./entities/exchange.js\";\nimport type { StableSwapConfig } from \"./instructions/index.js\";\nimport * as instructions from \"./instructions/index.js\";\nimport type { StableSwapState } from \"./state/index.js\";\nimport { decodeSwap } from \"./state/index.js\";\nimport { StableSwapLayout } from \"./state/layout.js\";\nimport { loadProgramAccount } from \"./util/account.js\";\n\nexport interface StableSwapInfo {\n  config: StableSwapConfig;\n  state: StableSwapState;\n}\n\n/**\n * Swap token A for token B\n * @param userSource\n * @param poolSource\n * @param poolDestination\n * @param userDestination\n * @param amountIn\n * @param minimumAmountOut\n */\nexport function createSaberSwapInstruction(\n  { config, state }: StableSwapInfo,\n  args: Pick<\n    instructions.SwapInstruction,\n    | \"userAuthority\"\n    | \"userSource\"\n    | \"userDestination\"\n    | \"poolSource\"\n    | \"poolDestination\"\n    | \"amountIn\"\n    | \"minimumAmountOut\"\n  >\n): TransactionInstruction {\n  const adminDestination = args.poolDestination.equals(state.tokenA.reserve)\n    ? state.tokenA.adminFeeAccount\n    : state.tokenB.adminFeeAccount;\n  return instructions.swapInstruction({\n    config: config,\n    ...args,\n    adminDestination,\n  });\n}\n\n/**\n * Deposit tokens into the pool.\n */\nexport function createSaberDepositInstruction(\n  { config, state }: StableSwapInfo,\n  args: Pick<\n    instructions.DepositInstruction,\n    | \"userAuthority\"\n    | \"sourceA\"\n    | \"sourceB\"\n    | \"poolTokenAccount\"\n    | \"tokenAmountA\"\n    | \"tokenAmountB\"\n    | \"minimumPoolTokenAmount\"\n  >\n): TransactionInstruction {\n  return instructions.depositInstruction({\n    config: config,\n    tokenAccountA: state.tokenA.reserve,\n    tokenAccountB: state.tokenB.reserve,\n    poolTokenMint: state.poolTokenMint,\n    ...args,\n  });\n}\n\n/**\n * Withdraw tokens from the pool\n */\nexport function createSaberWithdrawInstruction(\n  { config, state }: StableSwapInfo,\n  args: Pick<\n    instructions.WithdrawInstruction,\n    | \"userAuthority\"\n    | \"userAccountA\"\n    | \"userAccountB\"\n    | \"sourceAccount\"\n    | \"poolTokenAmount\"\n    | \"minimumTokenA\"\n    | \"minimumTokenB\"\n  >\n): TransactionInstruction {\n  return instructions.withdrawInstruction({\n    config: config,\n    poolMint: state.poolTokenMint,\n    tokenAccountA: state.tokenA.reserve,\n    tokenAccountB: state.tokenB.reserve,\n    adminFeeAccountA: state.tokenA.adminFeeAccount,\n    adminFeeAccountB: state.tokenB.adminFeeAccount,\n    ...args,\n  });\n}\n\n/**\n * Withdraw tokens from the pool\n */\nexport function createSaberWithdrawOneInstruction(\n  { config, state }: StableSwapInfo,\n  args: Pick<\n    instructions.WithdrawOneInstruction,\n    | \"userAuthority\"\n    | \"baseTokenAccount\"\n    | \"destinationAccount\"\n    | \"sourceAccount\"\n    | \"poolTokenAmount\"\n    | \"minimumTokenAmount\"\n  >\n): TransactionInstruction {\n  const [quoteTokenAccount, adminDestinationAccount] =\n    args.baseTokenAccount.equals(state.tokenA.reserve)\n      ? [state.tokenB.reserve, state.tokenA.adminFeeAccount]\n      : [state.tokenA.reserve, state.tokenB.adminFeeAccount];\n\n  return instructions.withdrawOneInstruction({\n    config: config,\n    poolMint: state.poolTokenMint,\n    quoteTokenAccount,\n    adminDestinationAccount,\n    ...args,\n  });\n}\n\nexport class StableSwap implements StableSwapInfo {\n  /**\n   * Constructor for new StableSwap client object.\n   * @param config\n   * @param state\n   */\n  constructor(\n    readonly config: StableSwapConfig,\n    readonly state: StableSwapState\n  ) {}\n\n  /**\n   * Get the minimum balance for the token swap account to be rent exempt\n   *\n   * @return Number of lamports required\n   */\n  static async getMinBalanceRentForExemptStableSwap(\n    connection: Connection\n  ): Promise<number> {\n    return await connection.getMinimumBalanceForRentExemption(\n      StableSwapLayout.span\n    );\n  }\n\n  /**\n   * Load an onchain StableSwap program.\n   *\n   * @param connection A {@link Connection} to use.\n   * @param swapAccount The {@link PublicKey} of the swap account to load. You can obtain this pubkey by visiting [app.saber.so](https://app.saber.so/], navigating to the pool you want to load, and getting the \"swap account\" key.\n   * @param programID Address of the onchain StableSwap program.\n   */\n  static async load(\n    connection: Connection,\n    swapAccount: PublicKey,\n    programID: PublicKey = SWAP_PROGRAM_ID\n  ): Promise<StableSwap> {\n    const data = await loadProgramAccount(connection, swapAccount, programID);\n    const authority = getSwapAuthorityKey(swapAccount, programID);\n    return StableSwap.loadWithData(swapAccount, data, authority, programID);\n  }\n\n  /**\n   * Loads an onchain StableSwap program from an {@link IExchange}.\n   *\n   * @param connection\n   * @param exchange\n   * @returns\n   */\n  static async loadFromExchange(\n    connection: Connection,\n    exchange: IExchange\n  ): Promise<StableSwap> {\n    return StableSwap.load(\n      connection,\n      exchange.swapAccount,\n      exchange.programID\n    );\n  }\n\n  /**\n   * Loads the swap object from a program account.\n   * @param data\n   * @returns\n   */\n  static async fromProgramAccount(\n    data: ProgramAccount<StableSwapState>\n  ): Promise<StableSwap> {\n    const [authority] = await findSwapAuthorityKey(data.publicKey);\n    return StableSwap.fromProgramAccountWithAuthority(data, authority);\n  }\n\n  /**\n   * Loads the swap object from a program account.\n   * @param data\n   * @returns\n   */\n  static fromData(data: ProgramAccount<StableSwapState>): StableSwap {\n    const authority = getSwapAuthorityKey(data.publicKey);\n    return StableSwap.fromProgramAccountWithAuthority(data, authority);\n  }\n\n  /**\n   * Loads the swap object from a program account, with the swap authority loaded.\n   * @param data\n   * @returns\n   */\n  static fromProgramAccountWithAuthority(\n    data: ProgramAccount<StableSwapState>,\n    authority: PublicKey\n  ): StableSwap {\n    return new StableSwap(\n      {\n        swapAccount: data.publicKey,\n        swapProgramID: SWAP_PROGRAM_ID,\n        tokenProgramID: TOKEN_PROGRAM_ID,\n        authority,\n      },\n      data.account\n    );\n  }\n\n  /**\n   * Loads a StableSwap instance with data.\n   *\n   * @param programID The program ID.\n   * @param swapAccount The address of the swap.\n   * @param swapAccountData The data of the swapAccount.\n   * @param authority The swap's authority.\n   * @returns\n   */\n  static loadWithData(\n    swapAccount: PublicKey,\n    swapAccountData: Buffer,\n    authority: PublicKey,\n    programID: PublicKey = SWAP_PROGRAM_ID\n  ): StableSwap {\n    try {\n      const state = decodeSwap(swapAccountData);\n      if (!state.isInitialized) {\n        throw new Error(`Invalid token swap state`);\n      }\n      return new StableSwap(\n        {\n          swapAccount: swapAccount,\n          swapProgramID: programID,\n          tokenProgramID: TOKEN_PROGRAM_ID,\n          authority,\n        },\n        state\n      );\n    } catch (e) {\n      throw Error(e as string);\n    }\n  }\n\n  /**\n   * Swap token A for token B\n   * @param userSource\n   * @param poolSource\n   * @param poolDestination\n   * @param userDestination\n   * @param amountIn\n   * @param minimumAmountOut\n   */\n  swap(\n    args: Pick<\n      instructions.SwapInstruction,\n      | \"userAuthority\"\n      | \"userSource\"\n      | \"userDestination\"\n      | \"poolSource\"\n      | \"poolDestination\"\n      | \"amountIn\"\n      | \"minimumAmountOut\"\n    >\n  ): TransactionInstruction {\n    return createSaberSwapInstruction(this, args);\n  }\n\n  /**\n   * Deposit tokens into the pool.\n   */\n  deposit(\n    args: Pick<\n      instructions.DepositInstruction,\n      | \"userAuthority\"\n      | \"sourceA\"\n      | \"sourceB\"\n      | \"poolTokenAccount\"\n      | \"tokenAmountA\"\n      | \"tokenAmountB\"\n      | \"minimumPoolTokenAmount\"\n    >\n  ): TransactionInstruction {\n    return createSaberDepositInstruction(this, args);\n  }\n\n  /**\n   * Withdraw tokens from the pool\n   */\n  withdraw(\n    args: Pick<\n      instructions.WithdrawInstruction,\n      | \"userAuthority\"\n      | \"userAccountA\"\n      | \"userAccountB\"\n      | \"sourceAccount\"\n      | \"poolTokenAmount\"\n      | \"minimumTokenA\"\n      | \"minimumTokenB\"\n    >\n  ): TransactionInstruction {\n    return createSaberWithdrawInstruction(this, args);\n  }\n\n  /**\n   * Withdraw tokens from the pool\n   */\n  withdrawOne(\n    args: Pick<\n      instructions.WithdrawOneInstruction,\n      | \"userAuthority\"\n      | \"baseTokenAccount\"\n      | \"destinationAccount\"\n      | \"sourceAccount\"\n      | \"poolTokenAmount\"\n      | \"minimumTokenAmount\"\n    >\n  ): TransactionInstruction {\n    return createSaberWithdrawOneInstruction(this, args);\n  }\n}\n\n/**\n * Finds the swap authority address that is used to sign transactions on behalf of the swap.\n *\n * @param swapAccount\n * @param swapProgramID\n * @returns\n */\nexport const findSwapAuthorityKey = (\n  swapAccount: PublicKey,\n  swapProgramID: PublicKey = SWAP_PROGRAM_ID\n): Promise<[PublicKey, number]> =>\n  PublicKey.findProgramAddress([swapAccount.toBuffer()], swapProgramID);\n\n/**\n * Finds the swap authority address that is used to sign transactions on behalf of the swap.\n *\n * @param swapAccount\n * @param swapProgramID\n * @returns\n */\nexport const findSwapAuthorityKeySync = (\n  swapAccount: PublicKey,\n  swapProgramID: PublicKey = SWAP_PROGRAM_ID\n): [PublicKey, number] =>\n  PublicKey.findProgramAddressSync([swapAccount.toBuffer()], swapProgramID);\n\n/**\n * Finds the swap authority address that is used to sign transactions on behalf of the swap.\n *\n * @param swapAccount\n * @param swapProgramID\n * @returns\n */\nexport const getSwapAuthorityKey = (\n  swapAccount: PublicKey,\n  swapProgramID: PublicKey = SWAP_PROGRAM_ID\n): PublicKey => getProgramAddress([swapAccount.toBuffer()], swapProgramID);\n"]}