"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StableSwap = void 0;
const _1 = require(".");
const anchor_1 = require("@project-serum/anchor");
const stableswap_sdk_1 = require("@saberhq/stableswap-sdk");
const jsbi_1 = __importDefault(require("jsbi"));
const token_utils_1 = require("@saberhq/token-utils");
const web3_js_1 = require("@solana/web3.js");
const marinade_finance_json_1 = __importDefault(require("../marinade-finance.json"));
const constants_1 = require("../constants");
const types_1 = require("../types");
// Precision for base pool virtual price
const PRECISION = new anchor_1.BN(1000000);
const BASE_CACHE_EXPIRE = new anchor_1.BN(60 * 10);
class StableSwap {
    constructor(amp, tokenMultiplier, depeg, extraAccounts, onChainTime, stakePoolPubkey) {
        this.amp = amp;
        this.tokenMultiplier = tokenMultiplier;
        this.depeg = depeg;
        this.extraAccounts = extraAccounts;
        this.onChainTime = onChainTime;
        this.stakePoolPubkey = stakePoolPubkey;
    }
    getBasePoolVirtualPrice(depegType) {
        if (depegType['marinade']) {
            const account = this.extraAccounts.get(constants_1.CURVE_TYPE_ACCOUNTS.marinade.toBase58());
            const coder = new anchor_1.BorshCoder(marinade_finance_json_1.default);
            const stake = coder.accounts.decode('State', account.data);
            const msolPrice = stake.msolPrice;
            return msolPrice.mul(PRECISION).div(new anchor_1.BN(4294967296));
        }
        if (depegType['lido']) {
            const account = this.extraAccounts.get(constants_1.CURVE_TYPE_ACCOUNTS.lido.toBase58());
            //https://github.com/mercurial-finance/mercurial-dynamic-amm/blob/main/programs/amm/tests/test_depeg_price.rs#L33
            const stSolSupply = new anchor_1.BN(account.data.readBigInt64LE(73).toString());
            const stSolBalance = new anchor_1.BN(account.data.readBigInt64LE(81).toString());
            return stSolBalance.mul(PRECISION).div(stSolSupply);
        }
        if (depegType['splStake']) {
            const account = this.extraAccounts.get(this.stakePoolPubkey.toBase58());
            const stakePool = types_1.StakePoolLayout.decode(account.data);
            return stakePool.totalLamports.mul(PRECISION).div(stakePool.poolTokenSupply);
        }
        throw new Error('UnsupportedBasePool');
    }
    updateDepegInfoIfExpired() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.depeg.depegType['none']) {
                const expired = this.onChainTime.toNumber() > this.depeg.baseCacheUpdated.add(BASE_CACHE_EXPIRE).toNumber();
                if (expired) {
                    this.depeg.baseVirtualPrice = this.getBasePoolVirtualPrice(this.depeg.depegType);
                    this.depeg.baseCacheUpdated = new anchor_1.BN(this.onChainTime);
                }
            }
        });
    }
    upscaleTokenA(tokenAAmount) {
        const { tokenAMultiplier } = this.tokenMultiplier;
        const normalizedTokenAAmount = tokenAAmount.mul(tokenAMultiplier);
        if (!this.depeg.depegType['none']) {
            return normalizedTokenAAmount.mul(PRECISION);
        }
        return normalizedTokenAAmount;
    }
    downscaleTokenA(tokenAAmount) {
        const { tokenAMultiplier } = this.tokenMultiplier;
        const denormalizedTokenAAmount = tokenAAmount.div(tokenAMultiplier);
        if (!this.depeg.depegType['none']) {
            return denormalizedTokenAAmount.div(PRECISION);
        }
        return denormalizedTokenAAmount;
    }
    upscaleTokenB(tokenBAmount) {
        const { tokenBMultiplier } = this.tokenMultiplier;
        const normalizedTokenBAmount = tokenBAmount.mul(tokenBMultiplier);
        if (!this.depeg.depegType['none']) {
            return normalizedTokenBAmount.mul(this.depeg.baseVirtualPrice);
        }
        return normalizedTokenBAmount;
    }
    downscaleTokenB(tokenBAmount) {
        const { tokenBMultiplier } = this.tokenMultiplier;
        const denormalizedTokenBAmount = tokenBAmount.div(tokenBMultiplier);
        if (!this.depeg.depegType['none']) {
            return denormalizedTokenBAmount.div(this.depeg.baseVirtualPrice);
        }
        return denormalizedTokenBAmount;
    }
    computeOutAmountWithoutSlippage(sourceAmount, swapSourceAmount, swapDestinationAmount, invariantD) {
        const SIXTEEN = new anchor_1.BN(16);
        const FOUR = new anchor_1.BN(4);
        const TWO = new anchor_1.BN(2);
        const amp = new anchor_1.BN(this.amp);
        const a = amp.mul(SIXTEEN);
        const b = a;
        const c = invariantD.mul(FOUR).sub(invariantD.mul(amp).mul(SIXTEEN));
        const numerator = TWO.mul(a)
            .mul(swapSourceAmount)
            .add(b.mul(swapDestinationAmount))
            .add(c)
            .mul(swapDestinationAmount);
        const denominator = a.mul(swapSourceAmount).add(TWO.mul(b).mul(swapDestinationAmount).add(c)).mul(swapSourceAmount);
        return sourceAmount.mul(numerator).div(denominator);
    }
    computeOutAmount(sourceAmount, swapSourceAmount, swapDestinationAmount, tradeDirection) {
        this.updateDepegInfoIfExpired();
        const [upscaledSourceAmount, upscaledSwapSourceAmount, upscaledSwapDestinationAmount] = tradeDirection == _1.TradeDirection.AToB
            ? [
                this.upscaleTokenA(sourceAmount),
                this.upscaleTokenA(swapSourceAmount),
                this.upscaleTokenB(swapDestinationAmount),
            ]
            : [
                this.upscaleTokenB(sourceAmount),
                this.upscaleTokenB(swapSourceAmount),
                this.upscaleTokenA(swapDestinationAmount),
            ];
        const invariantD = (0, stableswap_sdk_1.computeD)(jsbi_1.default.BigInt(this.amp), jsbi_1.default.BigInt(upscaledSwapSourceAmount.toString()), jsbi_1.default.BigInt(upscaledSwapDestinationAmount.toString()));
        const newSwapSourceAmount = jsbi_1.default.add(jsbi_1.default.BigInt(upscaledSwapSourceAmount.toString()), jsbi_1.default.BigInt(upscaledSourceAmount.toString()));
        const newSwapDestinationAmount = (0, stableswap_sdk_1.computeY)(jsbi_1.default.BigInt(this.amp), newSwapSourceAmount, invariantD);
        let outAmount = upscaledSwapDestinationAmount.sub(new anchor_1.BN(newSwapDestinationAmount.toString())).sub(new anchor_1.BN(1));
        let outAmountWithoutSlippage = this.computeOutAmountWithoutSlippage(upscaledSourceAmount, upscaledSwapSourceAmount, upscaledSwapDestinationAmount, new anchor_1.BN(invariantD.toString()));
        [outAmount, outAmountWithoutSlippage] =
            tradeDirection == _1.TradeDirection.AToB
                ? [this.downscaleTokenB(outAmount), this.downscaleTokenB(outAmountWithoutSlippage)]
                : [this.downscaleTokenA(outAmount), this.downscaleTokenA(outAmountWithoutSlippage)];
        return {
            outAmount,
            priceImpact: (0, _1.getPriceImpact)(outAmount, outAmountWithoutSlippage),
        };
    }
    computeD(tokenAAmount, tokenBAmount) {
        this.updateDepegInfoIfExpired();
        const upscaledTokenAAmount = this.upscaleTokenA(tokenAAmount);
        const upscaledTokenBAmount = this.upscaleTokenB(tokenBAmount);
        const invariantD = new anchor_1.BN((0, stableswap_sdk_1.computeD)(jsbi_1.default.BigInt(this.amp), jsbi_1.default.BigInt(upscaledTokenAAmount.toString()), jsbi_1.default.BigInt(upscaledTokenBAmount.toString())).toString());
        if (!this.depeg.depegType['none']) {
            return invariantD.div(PRECISION);
        }
        return invariantD;
    }
    computeInAmount(destAmount, swapSourceAmount, swapDestinationAmount, tradeDirection) {
        this.updateDepegInfoIfExpired();
        const [upscaledDestAmount, upscaledSwapSourceAmount, upscaledSwapDestinationAmount] = tradeDirection == _1.TradeDirection.AToB
            ? [
                this.upscaleTokenB(destAmount),
                this.upscaleTokenA(swapSourceAmount),
                this.upscaleTokenB(swapDestinationAmount),
            ]
            : [
                this.upscaleTokenA(destAmount),
                this.upscaleTokenB(swapSourceAmount),
                this.upscaleTokenA(swapDestinationAmount),
            ];
        const invariantD = (0, stableswap_sdk_1.computeD)(jsbi_1.default.BigInt(this.amp), jsbi_1.default.BigInt(upscaledSwapSourceAmount.toString()), jsbi_1.default.BigInt(upscaledSwapDestinationAmount.toString()));
        const newSwapDestAmount = jsbi_1.default.subtract(jsbi_1.default.BigInt(upscaledSwapDestinationAmount.toString()), jsbi_1.default.BigInt(upscaledDestAmount.toString()));
        const newSwapSourceAmount = (0, stableswap_sdk_1.computeY)(jsbi_1.default.BigInt(this.amp), newSwapDestAmount, invariantD);
        const inAmount = new anchor_1.BN(newSwapSourceAmount.toString()).sub(swapSourceAmount);
        return tradeDirection == _1.TradeDirection.AToB ? this.downscaleTokenA(inAmount) : this.downscaleTokenB(inAmount);
    }
    computeImbalanceDeposit(depositAAmount, depositBAmount, swapTokenAAmount, swapTokenBAmount, lpSupply, fees) {
        this.updateDepegInfoIfExpired();
        const [upscaledDepositAAmount, upscaledDepositBAmount, upscaledSwapTokenAAmount, upscaledSwapTokenBAmount] = [
            this.upscaleTokenA(depositAAmount),
            this.upscaleTokenB(depositBAmount),
            this.upscaleTokenA(swapTokenAAmount),
            this.upscaleTokenB(swapTokenBAmount),
        ];
        const { mintAmount } = (0, stableswap_sdk_1.calculateEstimatedMintAmount)(Helper.toExchange(this.amp, upscaledSwapTokenAAmount, upscaledSwapTokenBAmount, lpSupply, fees), jsbi_1.default.BigInt(upscaledDepositAAmount.toString()), jsbi_1.default.BigInt(upscaledDepositBAmount.toString()));
        return mintAmount.toU64();
    }
    computeWithdrawOne(lpAmount, lpSupply, swapTokenAAmount, swapTokenBAmount, fees, tradeDirection) {
        this.updateDepegInfoIfExpired();
        const [upscaledSwapTokenAAmount, upscaledSwapTokenBAmount] = [
            this.upscaleTokenA(swapTokenAAmount),
            this.upscaleTokenB(swapTokenBAmount),
        ];
        const exchange = Helper.toExchange(this.amp, upscaledSwapTokenAAmount, upscaledSwapTokenBAmount, lpSupply, fees);
        const withdrawToken = tradeDirection == _1.TradeDirection.BToA ? exchange.reserves[0].amount.token : exchange.reserves[1].amount.token;
        const { withdrawAmountBeforeFees } = (0, stableswap_sdk_1.calculateEstimatedWithdrawOneAmount)({
            exchange,
            poolTokenAmount: Helper.toTokenAmount(lpAmount),
            withdrawToken,
        });
        // Before withdrawal fee
        return tradeDirection == _1.TradeDirection.AToB
            ? this.downscaleTokenB(withdrawAmountBeforeFees.toU64())
            : this.downscaleTokenA(withdrawAmountBeforeFees.toU64());
    }
    getRemainingAccounts() {
        let accounts = [];
        if ('marinade' in this.depeg.depegType) {
            accounts.push({
                pubkey: constants_1.CURVE_TYPE_ACCOUNTS.marinade,
                isWritable: false,
                isSigner: false,
            });
        }
        if ('lido' in this.depeg.depegType) {
            accounts.push({
                pubkey: constants_1.CURVE_TYPE_ACCOUNTS.lido,
                isWritable: false,
                isSigner: false,
            });
        }
        if (!this.stakePoolPubkey.equals(web3_js_1.PublicKey.default)) {
            accounts.push({
                pubkey: this.stakePoolPubkey,
                isWritable: false,
                isSigner: false,
            });
        }
        return accounts;
    }
}
exports.StableSwap = StableSwap;
// Helper class to convert the type to the type from saber stable calculator
class Helper {
    static toExchange(amp, swapTokenAAmount, swapTokenBAmount, lpSupply, fees) {
        return {
            ampFactor: jsbi_1.default.BigInt(amp),
            fees: this.toFees(fees),
            lpTotalSupply: this.toTokenAmount(lpSupply),
            reserves: [this.toReserve(swapTokenAAmount), this.toReserve(swapTokenBAmount)],
        };
    }
    static toFees(fees) {
        return {
            adminTrade: new token_utils_1.Percent(fees.ownerTradeFeeNumerator, fees.ownerTradeFeeDenominator),
            trade: new token_utils_1.Percent(fees.tradeFeeNumerator, fees.tradeFeeDenominator),
            adminWithdraw: new token_utils_1.Percent(0, 100),
            withdraw: new token_utils_1.Percent(0, 100),
        };
    }
    static toTokenAmount(amount) {
        return new token_utils_1.TokenAmount(
        // Only amount, address, and chainId are necessary for the calculation
        new token_utils_1.Token({
            address: web3_js_1.Keypair.generate().publicKey.toBase58(),
            chainId: token_utils_1.ChainId.MainnetBeta,
            decimals: 0,
            name: '',
            symbol: '',
        }), amount.toString());
    }
    static toReserve(amount) {
        // Only amount is necessary for the calculation
        return {
            adminFeeAccount: web3_js_1.PublicKey.default,
            amount: this.toTokenAmount(amount),
            reserveAccount: web3_js_1.PublicKey.default,
        };
    }
}
//# sourceMappingURL=stable-swap.js.map