var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { getPriceImpact, TradeDirection } from '.';
import { BN, BorshCoder } from '@project-serum/anchor';
import { computeY, computeD, calculateEstimatedMintAmount, calculateEstimatedWithdrawOneAmount, } from '@saberhq/stableswap-sdk';
import JSBI from 'jsbi';
import { Token, TokenAmount, Percent, ChainId } from '@saberhq/token-utils';
import { Keypair, PublicKey } from '@solana/web3.js';
import MarinadeIDL from '../marinade-finance.json';
import { CURVE_TYPE_ACCOUNTS } from '../constants';
import { StakePoolLayout } from '../types';
// Precision for base pool virtual price
const PRECISION = new BN(1000000);
const BASE_CACHE_EXPIRE = new BN(60 * 10);
export class StableSwap {
    constructor(amp, tokenMultiplier, depeg, extraAccounts, onChainTime, stakePoolPubkey) {
        this.amp = amp;
        this.tokenMultiplier = tokenMultiplier;
        this.depeg = depeg;
        this.extraAccounts = extraAccounts;
        this.onChainTime = onChainTime;
        this.stakePoolPubkey = stakePoolPubkey;
    }
    getBasePoolVirtualPrice(depegType) {
        if (depegType['marinade']) {
            const account = this.extraAccounts.get(CURVE_TYPE_ACCOUNTS.marinade.toBase58());
            const coder = new BorshCoder(MarinadeIDL);
            const stake = coder.accounts.decode('State', account.data);
            const msolPrice = stake.msolPrice;
            return msolPrice.mul(PRECISION).div(new BN(4294967296));
        }
        if (depegType['lido']) {
            const account = this.extraAccounts.get(CURVE_TYPE_ACCOUNTS.lido.toBase58());
            //https://github.com/mercurial-finance/mercurial-dynamic-amm/blob/main/programs/amm/tests/test_depeg_price.rs#L33
            const stSolSupply = new BN(account.data.readBigInt64LE(73).toString());
            const stSolBalance = new BN(account.data.readBigInt64LE(81).toString());
            return stSolBalance.mul(PRECISION).div(stSolSupply);
        }
        if (depegType['splStake']) {
            const account = this.extraAccounts.get(this.stakePoolPubkey.toBase58());
            const stakePool = StakePoolLayout.decode(account.data);
            return stakePool.totalLamports.mul(PRECISION).div(stakePool.poolTokenSupply);
        }
        throw new Error('UnsupportedBasePool');
    }
    updateDepegInfoIfExpired() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.depeg.depegType['none']) {
                const expired = this.onChainTime.toNumber() > this.depeg.baseCacheUpdated.add(BASE_CACHE_EXPIRE).toNumber();
                if (expired) {
                    this.depeg.baseVirtualPrice = this.getBasePoolVirtualPrice(this.depeg.depegType);
                    this.depeg.baseCacheUpdated = new BN(this.onChainTime);
                }
            }
        });
    }
    upscaleTokenA(tokenAAmount) {
        const { tokenAMultiplier } = this.tokenMultiplier;
        const normalizedTokenAAmount = tokenAAmount.mul(tokenAMultiplier);
        if (!this.depeg.depegType['none']) {
            return normalizedTokenAAmount.mul(PRECISION);
        }
        return normalizedTokenAAmount;
    }
    downscaleTokenA(tokenAAmount) {
        const { tokenAMultiplier } = this.tokenMultiplier;
        const denormalizedTokenAAmount = tokenAAmount.div(tokenAMultiplier);
        if (!this.depeg.depegType['none']) {
            return denormalizedTokenAAmount.div(PRECISION);
        }
        return denormalizedTokenAAmount;
    }
    upscaleTokenB(tokenBAmount) {
        const { tokenBMultiplier } = this.tokenMultiplier;
        const normalizedTokenBAmount = tokenBAmount.mul(tokenBMultiplier);
        if (!this.depeg.depegType['none']) {
            return normalizedTokenBAmount.mul(this.depeg.baseVirtualPrice);
        }
        return normalizedTokenBAmount;
    }
    downscaleTokenB(tokenBAmount) {
        const { tokenBMultiplier } = this.tokenMultiplier;
        const denormalizedTokenBAmount = tokenBAmount.div(tokenBMultiplier);
        if (!this.depeg.depegType['none']) {
            return denormalizedTokenBAmount.div(this.depeg.baseVirtualPrice);
        }
        return denormalizedTokenBAmount;
    }
    computeOutAmountWithoutSlippage(sourceAmount, swapSourceAmount, swapDestinationAmount, invariantD) {
        const SIXTEEN = new BN(16);
        const FOUR = new BN(4);
        const TWO = new BN(2);
        const amp = new BN(this.amp);
        const a = amp.mul(SIXTEEN);
        const b = a;
        const c = invariantD.mul(FOUR).sub(invariantD.mul(amp).mul(SIXTEEN));
        const numerator = TWO.mul(a)
            .mul(swapSourceAmount)
            .add(b.mul(swapDestinationAmount))
            .add(c)
            .mul(swapDestinationAmount);
        const denominator = a.mul(swapSourceAmount).add(TWO.mul(b).mul(swapDestinationAmount).add(c)).mul(swapSourceAmount);
        return sourceAmount.mul(numerator).div(denominator);
    }
    computeOutAmount(sourceAmount, swapSourceAmount, swapDestinationAmount, tradeDirection) {
        this.updateDepegInfoIfExpired();
        const [upscaledSourceAmount, upscaledSwapSourceAmount, upscaledSwapDestinationAmount] = tradeDirection == TradeDirection.AToB
            ? [
                this.upscaleTokenA(sourceAmount),
                this.upscaleTokenA(swapSourceAmount),
                this.upscaleTokenB(swapDestinationAmount),
            ]
            : [
                this.upscaleTokenB(sourceAmount),
                this.upscaleTokenB(swapSourceAmount),
                this.upscaleTokenA(swapDestinationAmount),
            ];
        const invariantD = computeD(JSBI.BigInt(this.amp), JSBI.BigInt(upscaledSwapSourceAmount.toString()), JSBI.BigInt(upscaledSwapDestinationAmount.toString()));
        const newSwapSourceAmount = JSBI.add(JSBI.BigInt(upscaledSwapSourceAmount.toString()), JSBI.BigInt(upscaledSourceAmount.toString()));
        const newSwapDestinationAmount = computeY(JSBI.BigInt(this.amp), newSwapSourceAmount, invariantD);
        let outAmount = upscaledSwapDestinationAmount.sub(new BN(newSwapDestinationAmount.toString())).sub(new BN(1));
        let outAmountWithoutSlippage = this.computeOutAmountWithoutSlippage(upscaledSourceAmount, upscaledSwapSourceAmount, upscaledSwapDestinationAmount, new BN(invariantD.toString()));
        [outAmount, outAmountWithoutSlippage] =
            tradeDirection == TradeDirection.AToB
                ? [this.downscaleTokenB(outAmount), this.downscaleTokenB(outAmountWithoutSlippage)]
                : [this.downscaleTokenA(outAmount), this.downscaleTokenA(outAmountWithoutSlippage)];
        return {
            outAmount,
            priceImpact: getPriceImpact(outAmount, outAmountWithoutSlippage),
        };
    }
    computeD(tokenAAmount, tokenBAmount) {
        this.updateDepegInfoIfExpired();
        const upscaledTokenAAmount = this.upscaleTokenA(tokenAAmount);
        const upscaledTokenBAmount = this.upscaleTokenB(tokenBAmount);
        const invariantD = new BN(computeD(JSBI.BigInt(this.amp), JSBI.BigInt(upscaledTokenAAmount.toString()), JSBI.BigInt(upscaledTokenBAmount.toString())).toString());
        if (!this.depeg.depegType['none']) {
            return invariantD.div(PRECISION);
        }
        return invariantD;
    }
    computeInAmount(destAmount, swapSourceAmount, swapDestinationAmount, tradeDirection) {
        this.updateDepegInfoIfExpired();
        const [upscaledDestAmount, upscaledSwapSourceAmount, upscaledSwapDestinationAmount] = tradeDirection == TradeDirection.AToB
            ? [
                this.upscaleTokenB(destAmount),
                this.upscaleTokenA(swapSourceAmount),
                this.upscaleTokenB(swapDestinationAmount),
            ]
            : [
                this.upscaleTokenA(destAmount),
                this.upscaleTokenB(swapSourceAmount),
                this.upscaleTokenA(swapDestinationAmount),
            ];
        const invariantD = computeD(JSBI.BigInt(this.amp), JSBI.BigInt(upscaledSwapSourceAmount.toString()), JSBI.BigInt(upscaledSwapDestinationAmount.toString()));
        const newSwapDestAmount = JSBI.subtract(JSBI.BigInt(upscaledSwapDestinationAmount.toString()), JSBI.BigInt(upscaledDestAmount.toString()));
        const newSwapSourceAmount = computeY(JSBI.BigInt(this.amp), newSwapDestAmount, invariantD);
        const inAmount = new BN(newSwapSourceAmount.toString()).sub(swapSourceAmount);
        return tradeDirection == TradeDirection.AToB ? this.downscaleTokenA(inAmount) : this.downscaleTokenB(inAmount);
    }
    computeImbalanceDeposit(depositAAmount, depositBAmount, swapTokenAAmount, swapTokenBAmount, lpSupply, fees) {
        this.updateDepegInfoIfExpired();
        const [upscaledDepositAAmount, upscaledDepositBAmount, upscaledSwapTokenAAmount, upscaledSwapTokenBAmount] = [
            this.upscaleTokenA(depositAAmount),
            this.upscaleTokenB(depositBAmount),
            this.upscaleTokenA(swapTokenAAmount),
            this.upscaleTokenB(swapTokenBAmount),
        ];
        const { mintAmount } = calculateEstimatedMintAmount(Helper.toExchange(this.amp, upscaledSwapTokenAAmount, upscaledSwapTokenBAmount, lpSupply, fees), JSBI.BigInt(upscaledDepositAAmount.toString()), JSBI.BigInt(upscaledDepositBAmount.toString()));
        return mintAmount.toU64();
    }
    computeWithdrawOne(lpAmount, lpSupply, swapTokenAAmount, swapTokenBAmount, fees, tradeDirection) {
        this.updateDepegInfoIfExpired();
        const [upscaledSwapTokenAAmount, upscaledSwapTokenBAmount] = [
            this.upscaleTokenA(swapTokenAAmount),
            this.upscaleTokenB(swapTokenBAmount),
        ];
        const exchange = Helper.toExchange(this.amp, upscaledSwapTokenAAmount, upscaledSwapTokenBAmount, lpSupply, fees);
        const withdrawToken = tradeDirection == TradeDirection.BToA ? exchange.reserves[0].amount.token : exchange.reserves[1].amount.token;
        const { withdrawAmountBeforeFees } = calculateEstimatedWithdrawOneAmount({
            exchange,
            poolTokenAmount: Helper.toTokenAmount(lpAmount),
            withdrawToken,
        });
        // Before withdrawal fee
        return tradeDirection == TradeDirection.AToB
            ? this.downscaleTokenB(withdrawAmountBeforeFees.toU64())
            : this.downscaleTokenA(withdrawAmountBeforeFees.toU64());
    }
    getRemainingAccounts() {
        let accounts = [];
        if ('marinade' in this.depeg.depegType) {
            accounts.push({
                pubkey: CURVE_TYPE_ACCOUNTS.marinade,
                isWritable: false,
                isSigner: false,
            });
        }
        if ('lido' in this.depeg.depegType) {
            accounts.push({
                pubkey: CURVE_TYPE_ACCOUNTS.lido,
                isWritable: false,
                isSigner: false,
            });
        }
        if (!this.stakePoolPubkey.equals(PublicKey.default)) {
            accounts.push({
                pubkey: this.stakePoolPubkey,
                isWritable: false,
                isSigner: false,
            });
        }
        return accounts;
    }
}
// Helper class to convert the type to the type from saber stable calculator
class Helper {
    static toExchange(amp, swapTokenAAmount, swapTokenBAmount, lpSupply, fees) {
        return {
            ampFactor: JSBI.BigInt(amp),
            fees: this.toFees(fees),
            lpTotalSupply: this.toTokenAmount(lpSupply),
            reserves: [this.toReserve(swapTokenAAmount), this.toReserve(swapTokenBAmount)],
        };
    }
    static toFees(fees) {
        return {
            adminTrade: new Percent(fees.ownerTradeFeeNumerator, fees.ownerTradeFeeDenominator),
            trade: new Percent(fees.tradeFeeNumerator, fees.tradeFeeDenominator),
            adminWithdraw: new Percent(0, 100),
            withdraw: new Percent(0, 100),
        };
    }
    static toTokenAmount(amount) {
        return new TokenAmount(
        // Only amount, address, and chainId are necessary for the calculation
        new Token({
            address: Keypair.generate().publicKey.toBase58(),
            chainId: ChainId.MainnetBeta,
            decimals: 0,
            name: '',
            symbol: '',
        }), amount.toString());
    }
    static toReserve(amount) {
        // Only amount is necessary for the calculation
        return {
            adminFeeAccount: PublicKey.default,
            amount: this.toTokenAmount(amount),
            reserveAccount: PublicKey.default,
        };
    }
}
//# sourceMappingURL=stable-swap.js.map