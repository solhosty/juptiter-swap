{"version":3,"sources":["../../ts/client/src/numbers/numbers.spec.ts"],"names":[],"mappings":";;;;;;;;;AAAA,OAAO,QAAQ;AACf,SAAS,cAAc;AAIvB,SAAS,QAAQ,MAAM;AACrB,KAAG,8BAA8B,MAAM;AAErC,WAAO,WAAY;AACjB,UAAI,GAAG,gBAAgB;AAAA,IACzB,CAAC,EAAE,GAAG,IAAI,MAAM,kBAAkB;AAClC,WAAO,WAAY;AACjB,UAAI,GAAG,gBAAgB;AAAA,IACzB,CAAC,EAAE,GAAG,MAAM,kBAAkB;AAG9B,WAAO,WAAY;AACjB,iBAAW,SAAS;AAAA,IACtB,CAAC,EAAE,GAAG,MAAM,4CAA4C;AAKxD;AAAA,MACE,OAAO,WAAW,0CAA0C,EACzD,SAAS,EACT,SAAS;AAAA,IACd,EAAE,OAAO,uBAAuB;AAGhC,WAAO,IAAI,OAAO,IAAI,GAAG,EAAE,CAAC,EAAE,SAAS,CAAC,EAAE,IAAI,OAAO,EAAE;AACvD,WAAO,OAAO,QAAQ,IAAI,GAAG,EAAE,CAAC,EAAE,SAAS,CAAC,EAAE,OAAO,EAAE;AAGvD,WAAO,IAAI,GAAG,GAAG,EAAE,SAAS,CAAC,EAAE,OAAO,CAAC;AAAA,EACzC,CAAC;AACH,CAAC","sourcesContent":["import BN from 'bn.js';\nimport { expect } from 'chai';\nimport { U64_MAX_BN } from '../utils';\nimport { I80F48 } from './I80F48';\n\ndescribe('Math', () => {\n  it('js number to BN and I80F48', () => {\n    // BN can be only be created from js numbers which are <=2^53\n    expect(function () {\n      new BN(0x1fffffffffffff);\n    }).to.not.throw('Assertion failed');\n    expect(function () {\n      new BN(0x20000000000000);\n    }).to.throw('Assertion failed');\n\n    // max BN cant be converted to a number\n    expect(function () {\n      U64_MAX_BN.toNumber();\n    }).to.throw('Number can only safely store up to 53 bits');\n\n    // max I80F48 can be converted to a number\n    // though, the number is represented in scientific notation\n    // anything above ^20 gets represented with scientific notation\n    expect(\n      I80F48.fromString('604462909807314587353087.999999999999996')\n        .toNumber()\n        .toString(),\n    ).equals('6.044629098073146e+23');\n\n    // I80F48 constructor takes a BN, but it doesnt do what one might think it does\n    expect(new I80F48(new BN(10)).toNumber()).not.equals(10);\n    expect(I80F48.fromI64(new BN(10)).toNumber()).equals(10);\n\n    // BN treats input as whole integer\n    expect(new BN(1.5).toNumber()).equals(1);\n  });\n});\n"]}