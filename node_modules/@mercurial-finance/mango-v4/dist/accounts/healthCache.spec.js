"use strict";






var _chunkC3X3GVS5js = require('../chunk-C3X3GVS5.js');
require('../chunk-UGHO4YHY.js');


var _chunkZYSI4CYOjs = require('../chunk-ZYSI4CYO.js');
require('../chunk-S6N5Y2X2.js');
require('../chunk-772SHZWX.js');




var _chunkS3PQ6OXSjs = require('../chunk-S3PQ6OXS.js');
require('../chunk-JC4IRQUL.js');

// ts/client/src/accounts/healthCache.spec.ts
var _anchor = require('@project-serum/anchor');
var _chai = require('chai');
var _lodash = require('lodash');
function mockBankAndOracle(tokenIndex, maintWeight, initWeight, price, stablePrice) {
  return {
    tokenIndex,
    maintAssetWeight: _chunkS3PQ6OXSjs.I80F48.fromNumber(1 - maintWeight),
    initAssetWeight: _chunkS3PQ6OXSjs.I80F48.fromNumber(1 - initWeight),
    maintLiabWeight: _chunkS3PQ6OXSjs.I80F48.fromNumber(1 + maintWeight),
    initLiabWeight: _chunkS3PQ6OXSjs.I80F48.fromNumber(1 + initWeight),
    price: _chunkS3PQ6OXSjs.I80F48.fromNumber(price),
    stablePriceModel: { stablePrice },
    scaledInitAssetWeight: () => _chunkS3PQ6OXSjs.I80F48.fromNumber(1 - initWeight),
    scaledInitLiabWeight: () => _chunkS3PQ6OXSjs.I80F48.fromNumber(1 + initWeight)
  };
}
function mockPerpMarket(perpMarketIndex, maintBaseWeight, initBaseWeight, baseLotSize, price) {
  return {
    perpMarketIndex,
    maintBaseAssetWeight: _chunkS3PQ6OXSjs.I80F48.fromNumber(1 - maintBaseWeight),
    initBaseAssetWeight: _chunkS3PQ6OXSjs.I80F48.fromNumber(1 - initBaseWeight),
    maintBaseLiabWeight: _chunkS3PQ6OXSjs.I80F48.fromNumber(1 + maintBaseWeight),
    initBaseLiabWeight: _chunkS3PQ6OXSjs.I80F48.fromNumber(1 + initBaseWeight),
    maintOverallAssetWeight: _chunkS3PQ6OXSjs.I80F48.fromNumber(1 - 0.02),
    initOverallAssetWeight: _chunkS3PQ6OXSjs.I80F48.fromNumber(1 - 0.05),
    price: _chunkS3PQ6OXSjs.I80F48.fromNumber(price),
    stablePriceModel: { stablePrice: price },
    quoteLotSize: new (0, _anchor.BN)(100),
    baseLotSize: new (0, _anchor.BN)(baseLotSize),
    longFunding: _chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, ),
    shortFunding: _chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, )
  };
}
describe("Health Cache", () => {
  it("test_health0", () => {
    const sourceBank = mockBankAndOracle(
      1,
      0.1,
      0.2,
      1,
      1
    );
    const targetBank = mockBankAndOracle(
      4,
      0.3,
      0.5,
      5,
      5
    );
    const ti1 = _chunkC3X3GVS5js.TokenInfo.fromBank(sourceBank, _chunkS3PQ6OXSjs.I80F48.fromNumber(100));
    const ti2 = _chunkC3X3GVS5js.TokenInfo.fromBank(targetBank, _chunkS3PQ6OXSjs.I80F48.fromNumber(-10));
    const si1 = _chunkC3X3GVS5js.Serum3Info.fromOoModifyingTokenInfos(
      1,
      ti2,
      0,
      ti1,
      2,
      {
        quoteTokenTotal: new (0, _anchor.BN)(21),
        baseTokenTotal: new (0, _anchor.BN)(18),
        quoteTokenFree: new (0, _anchor.BN)(1),
        baseTokenFree: new (0, _anchor.BN)(3),
        referrerRebatesAccrued: new (0, _anchor.BN)(2)
      }
    );
    const pM = mockPerpMarket(9, 0.1, 0.2, 10, targetBank.price.toNumber());
    const pp = new (0, _chunkC3X3GVS5js.PerpPosition)(
      pM.perpMarketIndex,
      0,
      new (0, _anchor.BN)(0),
      new (0, _anchor.BN)(3),
      _chunkS3PQ6OXSjs.I80F48.fromNumber(-310),
      new (0, _anchor.BN)(0),
      _chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, ),
      _chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, ),
      new (0, _anchor.BN)(7),
      new (0, _anchor.BN)(11),
      new (0, _anchor.BN)(1),
      new (0, _anchor.BN)(2),
      0,
      0,
      new (0, _anchor.BN)(0),
      new (0, _anchor.BN)(0),
      new (0, _anchor.BN)(0),
      0,
      _chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, ),
      _chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, ),
      new (0, _anchor.BN)(0),
      _chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, )
    );
    const pi1 = _chunkC3X3GVS5js.PerpInfo.fromPerpPosition(pM, pp);
    const hc = new (0, _chunkC3X3GVS5js.HealthCache)([ti1, ti2], [si1], [pi1]);
    const health1 = (100 + 1 + 2 + (20 + 15 * 5)) * 0.8;
    const health2 = (-10 + 3) * 5 * 1.5;
    const health3 = (3 + 7 + 1) * 10 * 5 * 0.8 + (-310 + 2 * 100 - 7 * 10 * 5);
    const health = hc.health(_chunkC3X3GVS5js.HealthType.init).toNumber();
    console.log(
      ` - health ${health.toFixed(3).padStart(
        10
      )}, case "test that includes all the side values (like referrer_rebates_accrued)"`
    );
    _chai.expect.call(void 0, health - (health1 + health2 + health3)).lessThan(1e-7);
  });
  it("test_health1", (done) => {
    function testFixture(fixture) {
      const bank1 = mockBankAndOracle(
        1,
        0.1,
        0.2,
        1,
        1
      );
      const bank2 = mockBankAndOracle(
        4,
        0.3,
        0.5,
        5,
        5
      );
      const bank3 = mockBankAndOracle(
        5,
        0.3,
        0.5,
        10,
        10
      );
      const ti1 = _chunkC3X3GVS5js.TokenInfo.fromBank(bank1, _chunkS3PQ6OXSjs.I80F48.fromNumber(fixture.token1));
      const ti2 = _chunkC3X3GVS5js.TokenInfo.fromBank(bank2, _chunkS3PQ6OXSjs.I80F48.fromNumber(fixture.token2));
      const ti3 = _chunkC3X3GVS5js.TokenInfo.fromBank(bank3, _chunkS3PQ6OXSjs.I80F48.fromNumber(fixture.token3));
      const si1 = _chunkC3X3GVS5js.Serum3Info.fromOoModifyingTokenInfos(
        1,
        ti2,
        0,
        ti1,
        2,
        {
          quoteTokenTotal: new (0, _anchor.BN)(fixture.oo12[0]),
          baseTokenTotal: new (0, _anchor.BN)(fixture.oo12[1]),
          quoteTokenFree: new (0, _anchor.BN)(0),
          baseTokenFree: new (0, _anchor.BN)(0),
          referrerRebatesAccrued: new (0, _anchor.BN)(0)
        }
      );
      const si2 = _chunkC3X3GVS5js.Serum3Info.fromOoModifyingTokenInfos(
        2,
        ti3,
        0,
        ti1,
        2,
        {
          quoteTokenTotal: new (0, _anchor.BN)(fixture.oo13[0]),
          baseTokenTotal: new (0, _anchor.BN)(fixture.oo13[1]),
          quoteTokenFree: new (0, _anchor.BN)(0),
          baseTokenFree: new (0, _anchor.BN)(0),
          referrerRebatesAccrued: new (0, _anchor.BN)(0)
        }
      );
      const pM = mockPerpMarket(9, 0.1, 0.2, 10, bank2.price.toNumber());
      const pp = new (0, _chunkC3X3GVS5js.PerpPosition)(
        pM.perpMarketIndex,
        0,
        new (0, _anchor.BN)(0),
        new (0, _anchor.BN)(fixture.perp1[0]),
        _chunkS3PQ6OXSjs.I80F48.fromNumber(fixture.perp1[1]),
        new (0, _anchor.BN)(0),
        _chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, ),
        _chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, ),
        new (0, _anchor.BN)(fixture.perp1[2]),
        new (0, _anchor.BN)(fixture.perp1[3]),
        new (0, _anchor.BN)(0),
        new (0, _anchor.BN)(0),
        0,
        0,
        new (0, _anchor.BN)(0),
        new (0, _anchor.BN)(0),
        new (0, _anchor.BN)(0),
        0,
        _chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, ),
        _chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, ),
        new (0, _anchor.BN)(0),
        _chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, )
      );
      const pi1 = _chunkC3X3GVS5js.PerpInfo.fromPerpPosition(pM, pp);
      const hc = new (0, _chunkC3X3GVS5js.HealthCache)([ti1, ti2, ti3], [si1, si2], [pi1]);
      const health = hc.health(_chunkC3X3GVS5js.HealthType.init).toNumber();
      console.log(
        ` - case "${fixture.name}" health ${health.toFixed(3).padStart(10)}, expected ${fixture.expectedHealth}`
      );
      _chai.expect.call(void 0, health - fixture.expectedHealth).lessThan(1e-7);
    }
    const basePrice = 5;
    const baseLotsToQuote = 10 * basePrice;
    testFixture({
      name: "0",
      token1: 100,
      token2: -10,
      token3: 0,
      oo12: [20, 15],
      oo13: [0, 0],
      perp1: [3, -131, 7, 11],
      expectedHealth: (
        // for token1, including open orders (scenario: bids execute)
        (100 + (20 + 15 * basePrice)) * 0.8 - // for token2
        10 * basePrice * 1.5 + // for perp (scenario: bids execute)
        (3 + 7) * baseLotsToQuote * 0.8 + (-131 - 7 * baseLotsToQuote)
      )
    });
    testFixture({
      name: "1",
      token1: -100,
      token2: 10,
      token3: 0,
      oo12: [20, 15],
      oo13: [0, 0],
      perp1: [-10, -131, 7, 11],
      expectedHealth: (
        // for token1
        -100 * 1.2 + // for token2, including open orders (scenario: asks execute)
        (10 * basePrice + (20 + 15 * basePrice)) * 0.5 + // for perp (scenario: asks execute)
        (-10 - 11) * baseLotsToQuote * 1.2 + (-131 + 11 * baseLotsToQuote)
      )
    });
    testFixture({
      name: "2: weighted positive perp pnl",
      token1: 0,
      token2: 0,
      token3: 0,
      oo12: [0, 0],
      oo13: [0, 0],
      perp1: [-1, 100, 0, 0],
      expectedHealth: 0.95 * (100 - 1.2 * 1 * baseLotsToQuote)
    });
    testFixture({
      name: "3: negative perp pnl is not weighted",
      token1: 0,
      token2: 0,
      token3: 0,
      oo12: [0, 0],
      oo13: [0, 0],
      perp1: [1, -100, 0, 0],
      expectedHealth: -100 + 0.8 * 1 * baseLotsToQuote
    });
    testFixture({
      name: "4: perp health",
      token1: 0,
      token2: 0,
      token3: 0,
      oo12: [0, 0],
      oo13: [0, 0],
      perp1: [10, 100, 0, 0],
      expectedHealth: 0.95 * (100 + 0.8 * 10 * baseLotsToQuote)
    });
    testFixture({
      name: "5: perp health",
      token1: 0,
      token2: 0,
      token3: 0,
      oo12: [0, 0],
      oo13: [0, 0],
      perp1: [30, -100, 0, 0],
      expectedHealth: 0.95 * (-100 + 0.8 * 30 * baseLotsToQuote)
    });
    testFixture({
      name: "6, reserved oo funds",
      token1: -100,
      token2: -10,
      token3: -10,
      oo12: [1, 1],
      oo13: [1, 1],
      perp1: [0, 0, 0, 0],
      expectedHealth: (
        // tokens
        -100 * 1.2 - 10 * 5 * 1.5 - 10 * 10 * 1.5 + // oo_1_2 (-> token1)
        (1 + 5) * 1.2 + // oo_1_3 (-> token1)
        (1 + 10) * 1.2
      )
    });
    testFixture({
      name: "7, reserved oo funds cross the zero balance level",
      token1: -14,
      token2: -10,
      token3: -10,
      oo12: [1, 1],
      oo13: [1, 1],
      perp1: [0, 0, 0, 0],
      expectedHealth: -14 * 1.2 - 10 * 5 * 1.5 - 10 * 10 * 1.5 + // oo_1_2 (-> token1)
      3 * 1.2 + 3 * 0.8 + // oo_1_3 (-> token1)
      8 * 1.2 + 3 * 0.8
    });
    testFixture({
      name: "8, reserved oo funds in a non-quote currency",
      token1: -100,
      token2: -100,
      token3: -1,
      oo12: [0, 0],
      oo13: [10, 1],
      perp1: [0, 0, 0, 0],
      expectedHealth: (
        // tokens
        -100 * 1.2 - 100 * 5 * 1.5 - 10 * 1.5 + // oo_1_3 (-> token3)
        10 * 1.5 + 10 * 0.5
      )
    });
    testFixture({
      name: "9, like 8 but oo_1_2 flips the oo_1_3 target",
      token1: -100,
      token2: -100,
      token3: -1,
      oo12: [100, 0],
      oo13: [10, 1],
      perp1: [0, 0, 0, 0],
      expectedHealth: (
        // tokens
        -100 * 1.2 - 100 * 5 * 1.5 - 10 * 1.5 + // oo_1_2 (-> token1)
        80 * 1.2 + 20 * 0.8 + // oo_1_3 (-> token1)
        20 * 0.8
      )
    });
    done();
  });
  it("test_max_swap", (done) => {
    const b0 = mockBankAndOracle(0, 0.1, 0.1, 2, 2);
    const b1 = mockBankAndOracle(1, 0.2, 0.2, 3, 3);
    const b2 = mockBankAndOracle(2, 0.3, 0.3, 4, 4);
    const banks = [b0, b1, b2];
    const hc = new (0, _chunkC3X3GVS5js.HealthCache)(
      [
        _chunkC3X3GVS5js.TokenInfo.fromBank(b0, _chunkS3PQ6OXSjs.I80F48.fromNumber(0)),
        _chunkC3X3GVS5js.TokenInfo.fromBank(b1, _chunkS3PQ6OXSjs.I80F48.fromNumber(0)),
        _chunkC3X3GVS5js.TokenInfo.fromBank(b2, _chunkS3PQ6OXSjs.I80F48.fromNumber(0))
      ],
      [],
      []
    );
    _chai.expect.call(void 0, 
      hc.getMaxSwapSourceForHealthRatio(
        b0,
        b1,
        _chunkS3PQ6OXSjs.I80F48.fromNumber(2 / 3),
        _chunkS3PQ6OXSjs.I80F48.fromNumber(50)
      ).toNumber()
    ).lessThan(1e-7);
    function findMaxSwapActual(hc2, source, target, minValue, priceFactor, maxSwapFn2) {
      const clonedHc = _lodash.cloneDeep.call(void 0, hc2);
      const sourcePrice = clonedHc.tokenInfos[source].prices;
      const targetPrice = clonedHc.tokenInfos[target].prices;
      const swapPrice = _chunkS3PQ6OXSjs.I80F48.fromNumber(priceFactor).mul(sourcePrice.oracle).div(targetPrice.oracle);
      const sourceAmount = clonedHc.getMaxSwapSourceForHealthFn(
        banks[source],
        banks[target],
        swapPrice,
        _chunkS3PQ6OXSjs.I80F48.fromNumber(minValue),
        maxSwapFn2
      );
      function valueForAmount(amount) {
        const clonedHcClone = _lodash.cloneDeep.call(void 0, clonedHc);
        clonedHc.tokenInfos[source].balanceNative.isub(amount);
        clonedHc.tokenInfos[target].balanceNative.iadd(amount.mul(swapPrice));
        return maxSwapFn2(clonedHcClone);
      }
      return [
        sourceAmount.toNumber(),
        valueForAmount(sourceAmount).toNumber(),
        valueForAmount(sourceAmount.sub(_chunkS3PQ6OXSjs.ONE_I80F48.call(void 0, ))).toNumber(),
        valueForAmount(sourceAmount.add(_chunkS3PQ6OXSjs.ONE_I80F48.call(void 0, ))).toNumber()
      ];
    }
    function checkMaxSwapResult(hc2, source, target, minValue, priceFactor, maxSwapFn2) {
      const [sourceAmount, actualValue, minusValue, plusValue] = findMaxSwapActual(hc2, source, target, minValue, priceFactor, maxSwapFn2);
      console.log(
        ` -- checking ${source} to ${target} for priceFactor: ${priceFactor}, target: ${minValue} actual: ${minusValue}/${actualValue}/${plusValue}, amount: ${sourceAmount}`
      );
      if (actualValue < minValue) {
        _chai.expect.call(void 0, plusValue < actualValue);
      } else {
        _chai.expect.call(void 0, actualValue >= minValue);
        _chai.expect.call(void 0, actualValue < minValue + 1 || plusValue < minValue);
      }
    }
    function maxSwapFnRatio(hc2) {
      return hc2.healthRatio(_chunkC3X3GVS5js.HealthType.init);
    }
    function maxSwapFn(hc2) {
      return hc2.health(_chunkC3X3GVS5js.HealthType.init);
    }
    for (const fn of [maxSwapFn, maxSwapFnRatio]) {
      {
        console.log(" - test 0");
        const clonedHc = _lodash.cloneDeep.call(void 0, hc);
        clonedHc.tokenInfos[1].balanceNative.iadd(
          _chunkS3PQ6OXSjs.I80F48.fromNumber(100).div(clonedHc.tokenInfos[1].prices.oracle)
        );
        for (const priceFactor of [0.1, 0.9, 1.1]) {
          for (const target of _lodash.range.call(void 0, 1, 100, 1)) {
            checkMaxSwapResult(
              clonedHc,
              0,
              1,
              target,
              priceFactor,
              fn
            );
            checkMaxSwapResult(
              clonedHc,
              1,
              0,
              target,
              priceFactor,
              fn
            );
            checkMaxSwapResult(
              clonedHc,
              0,
              2,
              target,
              priceFactor,
              fn
            );
          }
        }
        _chai.expect.call(void 0, function() {
          findMaxSwapActual(
            clonedHc,
            0,
            1,
            50,
            1.5,
            fn
          );
        }).to.throw("Number out of range");
      }
      {
        console.log(" - test 1");
        const clonedHc = _lodash.cloneDeep.call(void 0, hc);
        clonedHc.tokenInfos[0].balanceNative.iadd(
          _chunkS3PQ6OXSjs.I80F48.fromNumber(-20).div(clonedHc.tokenInfos[0].prices.oracle)
        );
        clonedHc.tokenInfos[1].balanceNative.iadd(
          _chunkS3PQ6OXSjs.I80F48.fromNumber(100).div(clonedHc.tokenInfos[1].prices.oracle)
        );
        for (const priceFactor of [0.1, 0.9, 1.1]) {
          for (const target of _lodash.range.call(void 0, 1, 100, 1)) {
            checkMaxSwapResult(
              clonedHc,
              0,
              1,
              target,
              priceFactor,
              fn
            );
            checkMaxSwapResult(
              clonedHc,
              1,
              0,
              target,
              priceFactor,
              fn
            );
            checkMaxSwapResult(
              clonedHc,
              0,
              2,
              target,
              priceFactor,
              fn
            );
            checkMaxSwapResult(
              clonedHc,
              2,
              0,
              target,
              priceFactor,
              fn
            );
          }
        }
      }
      {
        console.log(" - test 2");
        const clonedHc = _lodash.cloneDeep.call(void 0, hc);
        clonedHc.tokenInfos[0].balanceNative.iadd(
          _chunkS3PQ6OXSjs.I80F48.fromNumber(-50).div(clonedHc.tokenInfos[0].prices.oracle)
        );
        clonedHc.tokenInfos[1].balanceNative.iadd(
          _chunkS3PQ6OXSjs.I80F48.fromNumber(100).div(clonedHc.tokenInfos[1].prices.oracle)
        );
        checkMaxSwapResult(
          clonedHc,
          1,
          0,
          100,
          1,
          maxSwapFn
        );
      }
      {
        console.log(" - test 3");
        const clonedHc = _lodash.cloneDeep.call(void 0, hc);
        clonedHc.tokenInfos[0].balanceNative.iadd(
          _chunkS3PQ6OXSjs.I80F48.fromNumber(-30).div(clonedHc.tokenInfos[0].prices.oracle)
        );
        clonedHc.tokenInfos[1].balanceNative.iadd(
          _chunkS3PQ6OXSjs.I80F48.fromNumber(100).div(clonedHc.tokenInfos[1].prices.oracle)
        );
        clonedHc.tokenInfos[2].balanceNative.iadd(
          _chunkS3PQ6OXSjs.I80F48.fromNumber(-30).div(clonedHc.tokenInfos[2].prices.oracle)
        );
        const initRatio = clonedHc.healthRatio(_chunkC3X3GVS5js.HealthType.init).toNumber();
        const [amount, actualRatio] = findMaxSwapActual(
          clonedHc,
          1,
          0,
          100,
          1,
          maxSwapFn
        );
        _chai.expect.call(void 0, actualRatio / 2 > initRatio);
        _chai.expect.call(void 0, amount - 100 / 3).lessThan(1);
      }
      {
        console.log(" - test 4");
        const clonedHc = _lodash.cloneDeep.call(void 0, hc);
        clonedHc.tokenInfos[0].balanceNative.iadd(
          _chunkS3PQ6OXSjs.I80F48.fromNumber(100).div(clonedHc.tokenInfos[0].prices.oracle)
        );
        clonedHc.tokenInfos[1].balanceNative.iadd(
          _chunkS3PQ6OXSjs.I80F48.fromNumber(-2).div(clonedHc.tokenInfos[1].prices.oracle)
        );
        clonedHc.tokenInfos[2].balanceNative.iadd(
          _chunkS3PQ6OXSjs.I80F48.fromNumber(-65).div(clonedHc.tokenInfos[2].prices.oracle)
        );
        const initRatio = clonedHc.healthRatio(_chunkC3X3GVS5js.HealthType.init);
        _chai.expect.call(void 0, initRatio.toNumber()).greaterThan(3);
        _chai.expect.call(void 0, initRatio.toNumber()).lessThan(4);
        checkMaxSwapResult(
          clonedHc,
          0,
          1,
          1,
          1,
          maxSwapFn
        );
        checkMaxSwapResult(
          clonedHc,
          0,
          1,
          3,
          1,
          maxSwapFn
        );
        checkMaxSwapResult(
          clonedHc,
          0,
          1,
          4,
          1,
          maxSwapFn
        );
      }
      {
        console.log(" - test 6");
        const clonedHc = _lodash.cloneDeep.call(void 0, hc);
        clonedHc.serum3Infos = [
          new (0, _chunkC3X3GVS5js.Serum3Info)(
            _chunkS3PQ6OXSjs.I80F48.fromNumber(30 / 3),
            _chunkS3PQ6OXSjs.I80F48.fromNumber(30 / 2),
            1,
            0,
            0
          )
        ];
        clonedHc.tokenInfos[0].balanceNative.iadd(
          _chunkS3PQ6OXSjs.I80F48.fromNumber(-20).div(clonedHc.tokenInfos[0].prices.oracle)
        );
        clonedHc.tokenInfos[1].balanceNative.iadd(
          _chunkS3PQ6OXSjs.I80F48.fromNumber(-40).div(clonedHc.tokenInfos[1].prices.oracle)
        );
        clonedHc.tokenInfos[2].balanceNative.iadd(
          _chunkS3PQ6OXSjs.I80F48.fromNumber(120).div(clonedHc.tokenInfos[2].prices.oracle)
        );
        for (const priceFactor of [0.9, 1.1]) {
          for (const target of _lodash.range.call(void 0, 1, 100, 1)) {
            checkMaxSwapResult(
              clonedHc,
              0,
              1,
              target,
              priceFactor,
              fn
            );
            checkMaxSwapResult(
              clonedHc,
              1,
              0,
              target,
              priceFactor,
              fn
            );
            checkMaxSwapResult(
              clonedHc,
              0,
              2,
              target,
              priceFactor,
              fn
            );
            checkMaxSwapResult(
              clonedHc,
              1,
              2,
              target,
              priceFactor,
              fn
            );
            checkMaxSwapResult(
              clonedHc,
              2,
              0,
              target,
              priceFactor,
              fn
            );
            checkMaxSwapResult(
              clonedHc,
              2,
              1,
              target,
              priceFactor,
              fn
            );
          }
        }
      }
      {
        console.log(" - test 7");
        const clonedHc = _lodash.cloneDeep.call(void 0, hc);
        clonedHc.tokenInfos[0].balanceNative.iadd(
          _chunkS3PQ6OXSjs.I80F48.fromNumber(-20).div(clonedHc.tokenInfos[0].prices.oracle)
        );
        clonedHc.tokenInfos[1].balanceNative.iadd(
          _chunkS3PQ6OXSjs.I80F48.fromNumber(20).div(clonedHc.tokenInfos[1].prices.oracle)
        );
        _chai.expect.call(void 0, clonedHc.health(_chunkC3X3GVS5js.HealthType.init).toNumber() < 0);
        for (const priceFactor of [0.9, 1.1]) {
          for (const target of _lodash.range.call(void 0, 1, 100, 1)) {
            checkMaxSwapResult(
              clonedHc,
              1,
              0,
              target,
              priceFactor,
              fn
            );
          }
        }
      }
      {
        console.log(" - test 8");
        const clonedHc = _lodash.cloneDeep.call(void 0, hc);
        clonedHc.tokenInfos[0].balanceNative.iadd(
          _chunkS3PQ6OXSjs.I80F48.fromNumber(-20).div(clonedHc.tokenInfos[0].prices.oracle)
        );
        clonedHc.tokenInfos[1].balanceNative.iadd(
          _chunkS3PQ6OXSjs.I80F48.fromNumber(10).div(clonedHc.tokenInfos[1].prices.oracle)
        );
        _chai.expect.call(void 0, clonedHc.health(_chunkC3X3GVS5js.HealthType.init).toNumber() < 0);
        for (const priceFactor of [0.9, 1.1]) {
          for (const target of _lodash.range.call(void 0, 1, 100, 1)) {
            checkMaxSwapResult(
              clonedHc,
              1,
              0,
              target,
              priceFactor,
              fn
            );
          }
        }
      }
      {
        console.log(" - test 9");
        const clonedHc = _lodash.cloneDeep.call(void 0, hc);
        clonedHc.tokenInfos[0].balanceNative.iadd(
          _chunkS3PQ6OXSjs.I80F48.fromNumber(10).div(clonedHc.tokenInfos[0].prices.oracle)
        );
        clonedHc.tokenInfos[1].initAssetWeight = _chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, );
        _chai.expect.call(void 0, 
          findMaxSwapActual(
            clonedHc,
            0,
            1,
            1,
            1,
            maxSwapFn
          )[0] > 0
        );
        for (const priceFactor of [0.9, 1.1]) {
          for (const target of _lodash.range.call(void 0, 1, 100, 1)) {
            checkMaxSwapResult(
              clonedHc,
              0,
              1,
              target,
              priceFactor,
              fn
            );
          }
        }
      }
    }
    done();
  });
  it("test_max_perp", (done) => {
    const baseLotSize = 100;
    const b0 = mockBankAndOracle(0, 0, 0, 1, 1);
    const p0 = mockPerpMarket(0, 0.3, 0.3, baseLotSize, 2);
    const hc = new (0, _chunkC3X3GVS5js.HealthCache)(
      [_chunkC3X3GVS5js.TokenInfo.fromBank(b0, _chunkS3PQ6OXSjs.I80F48.fromNumber(0))],
      [],
      [_chunkC3X3GVS5js.PerpInfo.emptyFromPerpMarket(p0)]
    );
    _chai.expect.call(void 0, hc.health(_chunkC3X3GVS5js.HealthType.init).toNumber()).equals(0);
    _chai.expect.call(void 0, 
      hc.getMaxPerpForHealthRatio(
        p0,
        _chunkS3PQ6OXSjs.I80F48.fromNumber(2),
        _chunkZYSI4CYOjs.PerpOrderSide.bid,
        _chunkS3PQ6OXSjs.I80F48.fromNumber(50)
      ).toNumber()
    ).equals(0);
    function findMaxTrade(hc2, side, ratio, priceFactor) {
      const prices = hc2.perpInfos[0].prices;
      const tradePrice = _chunkS3PQ6OXSjs.I80F48.fromNumber(priceFactor).mul(prices.oracle);
      const baseLots0 = hc2.getMaxPerpForHealthRatio(
        p0,
        tradePrice,
        side,
        _chunkS3PQ6OXSjs.I80F48.fromNumber(ratio)
      ).toNumber();
      const direction = side == _chunkZYSI4CYOjs.PerpOrderSide.bid ? 1 : -1;
      const baseLots1 = direction * baseLots0;
      let baseNative = _chunkS3PQ6OXSjs.I80F48.fromNumber(baseLots1).mul(
        _chunkS3PQ6OXSjs.I80F48.fromNumber(baseLotSize)
      );
      let hcClone = _lodash.cloneDeep.call(void 0, hc2);
      hcClone.perpInfos[0].baseLots.iadd(new (0, _anchor.BN)(baseLots1));
      hcClone.perpInfos[0].quote.isub(baseNative.mul(tradePrice));
      const actualRatio = hcClone.healthRatio(_chunkC3X3GVS5js.HealthType.init);
      const baseLots2 = direction * (baseLots0 + 1);
      baseNative = _chunkS3PQ6OXSjs.I80F48.fromNumber(baseLots2 * baseLotSize);
      hcClone = _lodash.cloneDeep.call(void 0, hc2);
      hcClone.perpInfos[0].baseLots.iadd(new (0, _anchor.BN)(baseLots2));
      hcClone.perpInfos[0].quote.isub(baseNative.mul(tradePrice));
      const plusRatio = hcClone.healthRatio(_chunkC3X3GVS5js.HealthType.init);
      return [baseLots0, actualRatio.toNumber(), plusRatio.toNumber()];
    }
    function checkMaxTrade(hc2, side, ratio, priceFactor) {
      const [baseLots, actualRatio, plusRatio] = findMaxTrade(
        hc2,
        side,
        ratio,
        priceFactor
      );
      console.log(
        `checking for price_factor: ${priceFactor}, target ratio ${ratio}: actual ratio: ${actualRatio}, plus ratio: ${plusRatio}, base_lots: ${baseLots}`
      );
      _chai.expect.call(void 0, ratio).lessThan(actualRatio);
      _chai.expect.call(void 0, plusRatio - 0.1).lessThanOrEqual(ratio);
    }
    hc.tokenInfos[0].balanceNative.iadd(_chunkS3PQ6OXSjs.I80F48.fromNumber(3e3));
    for (const existing of [-5, 0, 3]) {
      const hcClone = _lodash.cloneDeep.call(void 0, hc);
      hcClone.perpInfos[0].baseLots.iadd(new (0, _anchor.BN)(existing));
      hcClone.perpInfos[0].quote.isub(
        _chunkS3PQ6OXSjs.I80F48.fromNumber(existing * baseLotSize * 2)
      );
      for (const side of [_chunkZYSI4CYOjs.PerpOrderSide.bid, _chunkZYSI4CYOjs.PerpOrderSide.ask]) {
        console.log(
          `existing ${existing} ${side === _chunkZYSI4CYOjs.PerpOrderSide.bid ? "bid" : "ask"}`
        );
        for (const priceFactor of [0.8, 1, 1.1]) {
          for (const ratio of _lodash.range.call(void 0, 1, 101, 1)) {
            checkMaxTrade(hcClone, side, ratio, priceFactor);
          }
        }
      }
    }
    checkMaxTrade(hc, _chunkZYSI4CYOjs.PerpOrderSide.bid, 50, 2);
    checkMaxTrade(hc, _chunkZYSI4CYOjs.PerpOrderSide.ask, 50, 0.1);
    _chai.expect.call(void 0, function() {
      findMaxTrade(hc, _chunkZYSI4CYOjs.PerpOrderSide.bid, 50, 0.1);
    }).to.throw();
    _chai.expect.call(void 0, function() {
      findMaxTrade(hc, _chunkZYSI4CYOjs.PerpOrderSide.ask, 50, 1.5);
    }).to.throw();
    done();
  });
});
//# sourceMappingURL=healthCache.spec.js.map