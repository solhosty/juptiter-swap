{"version":3,"sources":["../ts/client/src/builder.ts"],"names":[],"mappings":";AAsCO,SAAS,QACd,gBACA,oBACA,UACa;AACb,MAAI;AACJ,MAAI;AACJ,MAAI;AAEJ,MAAI,0BAA0B,UAAU;AACtC,WAAO;AACP,eAAW;AACX,qBAAiB;AAAA,EACnB,OAAO;AACL,eAAW;AACX,qBAAiB;AAAA,EACnB;AAEA,QAAM,QAAiC,WACnC,OAAO,OAAO,CAAC,GAAG,QAAQ,IAC1B,CAAC;AAEL,QAAM,UAAU,IAAI;AAAA,IAClB,CAAC;AAAA,IACD;AAAA,MACE,IAAI,QAAQ,MAAM;AAChB,YAAI,YAAY,MAAM;AACpB,cAAI,gBAAgB;AAClB,mBAAO,OAAO,OAAO,cAAc;AAAA,UACrC;AAEA,cAAI,MAAM;AAER,kBAAM,MAAS,IAAI,KAAK;AACxB,mBAAO,MACL,OAAO,OAAO,KAAoC,EAAE,GAAG,MAAM,CAAC;AAAA,UAClE,OAAO;AAEL,mBAAO,MAAM;AAAA,UACf;AAAA,QACF;AAEA,eAAO,IAAI,SAA6B;AAEtC,cAAI,MAAM,KAAK,QAAQ;AACrB,mBAAO,MAAM,KAAK,SAAS,CAAC;AAAA,UAC9B;AAEA,gBAAM,KAAK,SAAS,CAAC,IAAI,KAAK,CAAC;AAC/B,iBAAO;AAAA,QACT;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AACT","sourcesContent":["// https://github.com/Vincent-Pang/builder-pattern\n\nexport type IBuilder<T> = {\n  [k in keyof T]-?: ((arg: T[k]) => IBuilder<T>) & (() => T[k]);\n} & {\n  build(): T;\n};\n\ntype Clazz<T> = new (...args: unknown[]) => T;\n\n/**\n * Create a Builder for a class. Returned objects will be of the class type.\n *\n * e.g. let obj: MyClass = Builder(MyClass).setA(5).setB(\"str\").build();\n *\n * @param type the name of the class to instantiate.\n * @param template optional class partial which the builder will derive initial params from.\n * @param override optional class partial which the builder will override params from when calling build().\n */\nexport function Builder<T>(\n  type: Clazz<T>,\n  template?: Partial<T> | null,\n  override?: Partial<T> | null,\n): IBuilder<T>;\n\n/**\n * Create a Builder for an interface. Returned objects will be untyped.\n *\n * e.g. let obj: Interface = Builder<Interface>().setA(5).setB(\"str\").build();\n *\n * @param template optional partial object which the builder will derive initial params from.\n * @param override optional partial object which the builder will override params from when calling build().\n */\nexport function Builder<T>(\n  template?: Partial<T> | null,\n  override?: Partial<T> | null,\n): IBuilder<T>;\n\nexport function Builder<T>(\n  typeOrTemplate?: Clazz<T> | Partial<T> | null,\n  templateOrOverride?: Partial<T> | null,\n  override?: Partial<T> | null,\n): IBuilder<T> {\n  let type: Clazz<T> | undefined;\n  let template: Partial<T> | null | undefined;\n  let overrideValues: Partial<T> | null | undefined;\n\n  if (typeOrTemplate instanceof Function) {\n    type = typeOrTemplate;\n    template = templateOrOverride;\n    overrideValues = override;\n  } else {\n    template = typeOrTemplate;\n    overrideValues = templateOrOverride;\n  }\n\n  const built: Record<string, unknown> = template\n    ? Object.assign({}, template)\n    : {};\n\n  const builder = new Proxy(\n    {},\n    {\n      get(target, prop) {\n        if ('build' === prop) {\n          if (overrideValues) {\n            Object.assign(built, overrideValues);\n          }\n\n          if (type) {\n            // A class name (identified by the constructor) was passed. Instantiate it with props.\n            const obj: T = new type();\n            return () =>\n              Object.assign(obj as T & Record<string, unknown>, { ...built });\n          } else {\n            // No type information - just return the object.\n            return () => built;\n          }\n        }\n\n        return (...args: unknown[]): unknown => {\n          // If no arguments passed return current value.\n          if (0 === args.length) {\n            return built[prop.toString()];\n          }\n\n          built[prop.toString()] = args[0];\n          return builder;\n        };\n      },\n    },\n  );\n\n  return builder as IBuilder<T>;\n}\n"]}