import { BN as BN$1, Program, Provider } from '@project-serum/anchor';
import { PublicKey, Cluster, TransactionSignature, AddressLookupTableAccount, Commitment, TransactionInstruction } from '@solana/web3.js';
import { TokenIndex, Bank, StablePriceModel, OracleConfig, OracleConfigDto, MintInfo } from './accounts/bank.js';
import { Market as Market$1, Orderbook as Orderbook$1 } from '@project-serum/serum';
import BN from 'bn.js';
import { Orderbook, Market, OpenOrders, Order } from '@project-serum/serum/lib/market';
import { I80F48, I80F48Dto } from './numbers/I80F48.js';
import { Modify, OracleConfigParams, InterestRateParams, FlashLoanType } from './types.js';
import { As } from './utils.js';
import { StubOracle } from './accounts/oracle.js';
import { IxGateParams, TokenEditParams, PerpEditParams } from './clientIxParamBuilder.js';
import { Id } from './ids.js';
import { MangoV4 } from './mango_v4.js';

declare type MarketIndex = number & As<'market-index'>;
declare class Serum3Market {
    publicKey: PublicKey;
    group: PublicKey;
    baseTokenIndex: TokenIndex;
    quoteTokenIndex: TokenIndex;
    serumProgram: PublicKey;
    serumMarketExternal: PublicKey;
    marketIndex: MarketIndex;
    registrationTime: BN;
    reduceOnly: boolean;
    name: string;
    static from(publicKey: PublicKey, obj: {
        group: PublicKey;
        baseTokenIndex: number;
        quoteTokenIndex: number;
        name: number[];
        serumProgram: PublicKey;
        serumMarketExternal: PublicKey;
        marketIndex: number;
        registrationTime: BN;
        reduceOnly: number;
    }): Serum3Market;
    constructor(publicKey: PublicKey, group: PublicKey, baseTokenIndex: TokenIndex, quoteTokenIndex: TokenIndex, name: number[], serumProgram: PublicKey, serumMarketExternal: PublicKey, marketIndex: MarketIndex, registrationTime: BN, reduceOnly: boolean);
    findOoPda(programId: PublicKey, mangoAccount: PublicKey): Promise<PublicKey>;
    getFeeRates(taker?: boolean): number;
    /**
     *
     * @param group
     * @returns maximum leverage one can bid on this market, this is only for display purposes,
     *  also see getMaxQuoteForSerum3BidUi and getMaxBaseForSerum3AskUi
     */
    maxBidLeverage(group: Group): number;
    /**
     *
     * @param group
     * @returns maximum leverage one can ask on this market, this is only for display purposes,
     *  also see getMaxQuoteForSerum3BidUi and getMaxBaseForSerum3AskUi
     */
    maxAskLeverage(group: Group): number;
    loadBids(client: MangoClient, group: Group): Promise<Orderbook>;
    loadAsks(client: MangoClient, group: Group): Promise<Orderbook>;
    logOb(client: MangoClient, group: Group): Promise<string>;
}
declare class Serum3SelfTradeBehavior {
    static decrementTake: {
        decrementTake: {};
    };
    static cancelProvide: {
        cancelProvide: {};
    };
    static abortTransaction: {
        abortTransaction: {};
    };
}
declare class Serum3OrderType {
    static limit: {
        limit: {};
    };
    static immediateOrCancel: {
        immediateOrCancel: {};
    };
    static postOnly: {
        postOnly: {};
    };
}
declare class Serum3Side {
    static bid: {
        bid: {};
    };
    static ask: {
        ask: {};
    };
}
declare function generateSerum3MarketExternalVaultSignerAddress(cluster: Cluster, serum3Market: Serum3Market, serum3MarketExternal: Market): Promise<PublicKey>;

declare class MangoAccount {
    publicKey: PublicKey;
    group: PublicKey;
    owner: PublicKey;
    delegate: PublicKey;
    accountNum: number;
    beingLiquidated: boolean;
    inHealthRegion: boolean;
    netDeposits: BN$1;
    perpSpotTransfers: BN$1;
    healthRegionBeginInitHealth: BN$1;
    frozenUntil: BN$1;
    headerVersion: number;
    serum3OosMapByMarketIndex: Map<number, OpenOrders>;
    name: string;
    tokens: TokenPosition[];
    serum3: Serum3Orders[];
    perps: PerpPosition[];
    perpOpenOrders: PerpOo[];
    static from(publicKey: PublicKey, obj: {
        group: PublicKey;
        owner: PublicKey;
        name: number[];
        delegate: PublicKey;
        accountNum: number;
        beingLiquidated: number;
        inHealthRegion: number;
        netDeposits: BN$1;
        perpSpotTransfers: BN$1;
        healthRegionBeginInitHealth: BN$1;
        frozenUntil: BN$1;
        headerVersion: number;
        tokens: unknown;
        serum3: unknown;
        perps: unknown;
        perpOpenOrders: unknown;
    }): MangoAccount;
    constructor(publicKey: PublicKey, group: PublicKey, owner: PublicKey, name: number[], delegate: PublicKey, accountNum: number, beingLiquidated: boolean, inHealthRegion: boolean, netDeposits: BN$1, perpSpotTransfers: BN$1, healthRegionBeginInitHealth: BN$1, frozenUntil: BN$1, headerVersion: number, tokens: TokenPositionDto[], serum3: Serum3PositionDto[], perps: PerpPositionDto[], perpOpenOrders: PerpOoDto[], serum3OosMapByMarketIndex: Map<number, OpenOrders>);
    reload(client: MangoClient): Promise<MangoAccount>;
    reloadWithSlot(client: MangoClient): Promise<{
        value: MangoAccount;
        slot: number;
    }>;
    reloadSerum3OpenOrders(client: MangoClient): Promise<MangoAccount>;
    isDelegate(client: MangoClient): boolean;
    isOperational(): boolean;
    tokensActive(): TokenPosition[];
    serum3Active(): Serum3Orders[];
    perpPositionExistsForMarket(perpMarket: PerpMarket): boolean;
    perpOrderExistsForMarket(perpMarket: PerpMarket): boolean;
    perpActive(): PerpPosition[];
    perpOrdersActive(): PerpOo[];
    getToken(tokenIndex: TokenIndex): TokenPosition | undefined;
    getSerum3Account(marketIndex: MarketIndex): Serum3Orders | undefined;
    getPerpPosition(perpMarketIndex: PerpMarketIndex): PerpPosition | undefined;
    getPerpPositionUi(group: Group, perpMarketIndex: PerpMarketIndex, useEventQueue?: boolean): number;
    getSerum3OoAccount(marketIndex: MarketIndex): OpenOrders;
    /**
     *
     * @param bank
     * @returns native balance for a token, is signed
     */
    getTokenBalance(bank: Bank): I80F48;
    /**
     *
     * @param bank
     * @returns native deposits for a token, 0 if position has borrows
     */
    getTokenDeposits(bank: Bank): I80F48;
    /**
     *
     * @param bank
     * @returns native borrows for a token, 0 if position has deposits
     */
    getTokenBorrows(bank: Bank): I80F48;
    /**
     *
     * @param bank
     * @returns UI balance for a token, is signed
     */
    getTokenBalanceUi(bank: Bank): number;
    /**
     *
     * @param bank
     * @returns UI deposits for a token, 0 or more
     */
    getTokenDepositsUi(bank: Bank): number;
    /**
     *
     * @param bank
     * @returns UI borrows for a token, 0 or less
     */
    getTokenBorrowsUi(bank: Bank): number;
    /**
     * Health, see health.rs or https://docs.mango.markets/mango-markets/health-overview
     * @param healthType
     * @returns raw health number, in native quote
     */
    getHealth(group: Group, healthType: HealthType): I80F48;
    getPerpSettleHealth(group: Group): I80F48;
    /**
     * Health ratio, which is computed so `100 * (assets-liabs)/liabs`
     * Note: health ratio is technically ∞ if liabs are 0
     * @param healthType
     * @returns health ratio, in percentage form
     */
    getHealthRatio(group: Group, healthType: HealthType): I80F48;
    /**
     * Health ratio
     * @param healthType
     * @returns health ratio, in percentage form, capped to 100
     */
    getHealthRatioUi(group: Group, healthType: HealthType): number;
    /**
     * Sum of all the assets i.e. token deposits, borrows, total assets in spot open orders, and perps positions.
     * @returns equity, in native quote
     */
    getEquity(group: Group): I80F48;
    /**
     * The amount of native quote you could withdraw against your existing assets.
     * @returns collateral value, in native quote
     */
    getCollateralValue(group: Group): I80F48;
    /**
     * Sum of all positive assets.
     * @returns assets, in native quote
     */
    getAssetsValue(group: Group, healthType?: HealthType): I80F48;
    /**
     * Sum of all negative assets.
     * @returns liabs, in native quote
     */
    getLiabsValue(group: Group, healthType?: HealthType): I80F48;
    /**
     * @returns Overall PNL, in native quote
     * PNL is defined here as spot value + serum3 open orders value + perp value - net deposits value (evaluated at native quote price at the time of the deposit/withdraw)
     * spot value + serum3 open orders value + perp value is returned by getEquity (open orders values are added to spot token values implicitly)
     */
    getPnl(group: Group): I80F48;
    /**
     * @returns token cumulative interest, in native token units. Sum of deposit and borrow interest.
     * Caveat: This will only return cumulative interest since the tokenPosition was last opened.
     * If the tokenPosition was closed and reopened multiple times it is necessary to add this result to
     * cumulative interest at each of the prior tokenPosition closings (from mango API) to get the all time
     * cumulative interest.
     */
    getCumulativeInterest(bank: Bank): number;
    /**
     * The amount of given native token you can withdraw including borrows, considering all existing assets as collateral.
     * @returns amount of given native token you can borrow, considering all existing assets as collateral, in native token
     *
     * TODO: take into account net_borrow_limit and min_vault_to_deposits_ratio
     */
    getMaxWithdrawWithBorrowForToken(group: Group, mintPk: PublicKey): I80F48;
    getMaxWithdrawWithBorrowForTokenUi(group: Group, mintPk: PublicKey): number;
    /**
     * The max amount of given source ui token you can swap to a target token.
     * @returns max amount of given source ui token you can swap to a target token, in ui token
     */
    getMaxSourceUiForTokenSwap(group: Group, sourceMintPk: PublicKey, targetMintPk: PublicKey, slippageAndFeesFactor?: number): number;
    /**
     * Simulates new health ratio after applying tokenChanges to the token positions.
     * Note: token changes are expected in ui amounts
     *
     * e.g. useful to simulate health after a potential swap.
     * Note: health ratio is technically ∞ if liabs are 0
     * @returns health ratio, in percentage form
     */
    simHealthRatioWithTokenPositionUiChanges(group: Group, uiTokenChanges: {
        uiTokenAmount: number;
        mintPk: PublicKey;
    }[], healthType?: HealthType): number;
    loadSerum3OpenOrdersAccounts(client: MangoClient): Promise<OpenOrders[]>;
    loadSerum3OpenOrdersForMarket(client: MangoClient, group: Group, externalMarketPk: PublicKey): Promise<Order[]>;
    /**
     * TODO REWORK, know to break in binary search, also make work for limit orders
     *
     * @param group
     * @param externalMarketPk
     * @returns maximum ui quote which can be traded at oracle price for base token given current health
     */
    getMaxQuoteForSerum3BidUi(group: Group, externalMarketPk: PublicKey): number;
    /**
     * TODO REWORK, know to break in binary search, also make work for limit orders
     * @param group
     * @param externalMarketPk
     * @returns maximum ui base which can be traded at oracle price for quote token given current health
     */
    getMaxBaseForSerum3AskUi(group: Group, externalMarketPk: PublicKey): number;
    /**
     *
     * @param group
     * @param uiQuoteAmount
     * @param externalMarketPk
     * @param healthType
     * @returns health ratio after a bid with uiQuoteAmount is placed
     */
    simHealthRatioWithSerum3BidUiChanges(group: Group, uiQuoteAmount: number, externalMarketPk: PublicKey, healthType?: HealthType): number;
    /**
     *
     * @param group
     * @param uiBaseAmount
     * @param externalMarketPk
     * @param healthType
     * @returns health ratio after an ask with uiBaseAmount is placed
     */
    simHealthRatioWithSerum3AskUiChanges(group: Group, uiBaseAmount: number, externalMarketPk: PublicKey, healthType?: HealthType): number;
    serum3SettleFundsForAllMarkets(client: MangoClient, group: Group): Promise<TransactionSignature[]>;
    serum3CancelAllOrdersForAllMarkets(client: MangoClient, group: Group): Promise<TransactionSignature[]>;
    /**
     * TODO: also think about limit orders
     *
     * The max ui quote you can place a market/ioc bid on the market,
     * price is the ui price at which you think the order would materialiase.
     * @param group
     * @param perpMarketName
     * @returns maximum ui quote which can be traded at oracle price for quote token given current health
     */
    getMaxQuoteForPerpBidUi(group: Group, perpMarketIndex: PerpMarketIndex): number;
    /**
     * TODO: also think about limit orders
     *
     * The max ui base you can place a market/ioc ask on the market,
     * price is the ui price at which you think the order would materialiase.
     * @param group
     * @param perpMarketName
     * @param uiPrice ui price at which ask would be placed at
     * @returns max ui base ask
     */
    getMaxBaseForPerpAskUi(group: Group, perpMarketIndex: PerpMarketIndex): number;
    simHealthRatioWithPerpBidUiChanges(group: Group, perpMarketIndex: PerpMarketIndex, size: number): number;
    simHealthRatioWithPerpAskUiChanges(group: Group, perpMarketIndex: PerpMarketIndex, size: number): number;
    loadPerpOpenOrdersForMarket(client: MangoClient, group: Group, perpMarketIndex: PerpMarketIndex): Promise<PerpOrder[]>;
    toString(group?: Group, onlyTokens?: boolean): string;
}
declare class TokenPosition {
    indexedPosition: I80F48;
    tokenIndex: TokenIndex;
    inUseCount: number;
    previousIndex: I80F48;
    cumulativeDepositInterest: number;
    cumulativeBorrowInterest: number;
    static TokenIndexUnset: number;
    static from(dto: TokenPositionDto): TokenPosition;
    constructor(indexedPosition: I80F48, tokenIndex: TokenIndex, inUseCount: number, previousIndex: I80F48, cumulativeDepositInterest: number, cumulativeBorrowInterest: number);
    isActive(): boolean;
    /**
     *
     * @param bank
     * @returns native balance
     */
    balance(bank: Bank): I80F48;
    /**
     *
     * @param bank
     * @returns native deposits, 0 if position has borrows
     */
    deposits(bank: Bank): I80F48;
    /**
     *
     * @param bank
     * @returns native borrows, 0 if position has deposits
     */
    borrows(bank: Bank): I80F48;
    /**
     * @param bank
     * @returns UI balance, is signed
     */
    balanceUi(bank: Bank): number;
    /**
     * @param bank
     * @returns UI deposits, 0 if position has borrows
     */
    depositsUi(bank: Bank): number;
    /**
     * @param bank
     * @returns UI borrows, 0 if position has deposits
     */
    borrowsUi(bank: Bank): number;
    toString(group?: Group, index?: number): string;
}
declare class TokenPositionDto {
    indexedPosition: I80F48Dto;
    tokenIndex: number;
    inUseCount: number;
    reserved: number[];
    previousIndex: I80F48Dto;
    cumulativeDepositInterest: number;
    cumulativeBorrowInterest: number;
    constructor(indexedPosition: I80F48Dto, tokenIndex: number, inUseCount: number, reserved: number[], previousIndex: I80F48Dto, cumulativeDepositInterest: number, cumulativeBorrowInterest: number);
}
declare class Serum3Orders {
    openOrders: PublicKey;
    marketIndex: MarketIndex;
    baseTokenIndex: TokenIndex;
    quoteTokenIndex: TokenIndex;
    static Serum3MarketIndexUnset: number;
    static from(dto: Serum3PositionDto): Serum3Orders;
    constructor(openOrders: PublicKey, marketIndex: MarketIndex, baseTokenIndex: TokenIndex, quoteTokenIndex: TokenIndex);
    isActive(): boolean;
}
declare class Serum3PositionDto {
    openOrders: PublicKey;
    marketIndex: number;
    baseBorrowsWithoutFee: BN$1;
    quoteBorrowsWithoutFee: BN$1;
    baseTokenIndex: number;
    quoteTokenIndex: number;
    reserved: number[];
    constructor(openOrders: PublicKey, marketIndex: number, baseBorrowsWithoutFee: BN$1, quoteBorrowsWithoutFee: BN$1, baseTokenIndex: number, quoteTokenIndex: number, reserved: number[]);
}
declare class PerpPosition {
    marketIndex: PerpMarketIndex;
    settlePnlLimitWindow: number;
    settlePnlLimitSettledInCurrentWindowNative: BN$1;
    basePositionLots: BN$1;
    quotePositionNative: I80F48;
    quoteRunningNative: BN$1;
    longSettledFunding: I80F48;
    shortSettledFunding: I80F48;
    bidsBaseLots: BN$1;
    asksBaseLots: BN$1;
    takerBaseLots: BN$1;
    takerQuoteLots: BN$1;
    cumulativeLongFunding: number;
    cumulativeShortFunding: number;
    makerVolume: BN$1;
    takerVolume: BN$1;
    perpSpotTransfers: BN$1;
    avgEntryPricePerBaseLot: number;
    realizedTradePnlNative: I80F48;
    realizedOtherPnlNative: I80F48;
    settlePnlLimitRealizedTrade: BN$1;
    realizedPnlForPositionNative: I80F48;
    static PerpMarketIndexUnset: number;
    static from(dto: PerpPositionDto): PerpPosition;
    static emptyFromPerpMarketIndex(perpMarketIndex: PerpMarketIndex): PerpPosition;
    constructor(marketIndex: PerpMarketIndex, settlePnlLimitWindow: number, settlePnlLimitSettledInCurrentWindowNative: BN$1, basePositionLots: BN$1, quotePositionNative: I80F48, quoteRunningNative: BN$1, longSettledFunding: I80F48, shortSettledFunding: I80F48, bidsBaseLots: BN$1, asksBaseLots: BN$1, takerBaseLots: BN$1, takerQuoteLots: BN$1, cumulativeLongFunding: number, cumulativeShortFunding: number, makerVolume: BN$1, takerVolume: BN$1, perpSpotTransfers: BN$1, avgEntryPricePerBaseLot: number, realizedTradePnlNative: I80F48, realizedOtherPnlNative: I80F48, settlePnlLimitRealizedTrade: BN$1, realizedPnlForPositionNative: I80F48);
    isActive(): boolean;
    getBasePositionNative(perpMarket: PerpMarket): I80F48;
    getBasePositionUi(perpMarket: PerpMarket, useEventQueue?: boolean): number;
    getUnsettledFunding(perpMarket: PerpMarket): I80F48;
    getEquityUi(perpMarket: PerpMarket): number;
    getEquity(perpMarket: PerpMarket): I80F48;
    hasOpenOrders(): boolean;
    getAverageEntryPrice(perpMarket: PerpMarket): I80F48;
    getAverageEntryPriceUi(perpMarket: PerpMarket): number;
    getBreakEvenPriceUi(perpMarket: PerpMarket): number;
    cumulativePnlOverPositionLifetimeUi(perpMarket: PerpMarket): number;
    getUnsettledPnl(perpMarket: PerpMarket): I80F48;
    getUnsettledPnlUi(perpMarket: PerpMarket): number;
    updateSettleLimit(perpMarket: PerpMarket): void;
    availableSettleLimit(perpMarket: PerpMarket): [BN$1, BN$1];
    applyPnlSettleLimit(pnl: I80F48, perpMarket: PerpMarket): I80F48;
    getSettleablePnl(group: Group, perpMarket: PerpMarket, account: MangoAccount): I80F48;
    getSettleablePnlUi(group: Group, perpMarket: PerpMarket, account: MangoAccount): number;
    canSettlePnl(group: Group, perpMarket: PerpMarket, account: MangoAccount): boolean;
    toString(perpMarket?: PerpMarket): string;
}
declare class PerpPositionDto {
    marketIndex: number;
    settlePnlLimitWindow: number;
    settlePnlLimitSettledInCurrentWindowNative: BN$1;
    basePositionLots: BN$1;
    quotePositionNative: {
        val: BN$1;
    };
    quoteRunningNative: BN$1;
    longSettledFunding: I80F48Dto;
    shortSettledFunding: I80F48Dto;
    bidsBaseLots: BN$1;
    asksBaseLots: BN$1;
    takerBaseLots: BN$1;
    takerQuoteLots: BN$1;
    cumulativeLongFunding: number;
    cumulativeShortFunding: number;
    makerVolume: BN$1;
    takerVolume: BN$1;
    perpSpotTransfers: BN$1;
    avgEntryPricePerBaseLot: number;
    realizedTradePnlNative: I80F48Dto;
    realizedOtherPnlNative: I80F48Dto;
    settlePnlLimitRealizedTrade: BN$1;
    realizedPnlForPositionNative: I80F48Dto;
    constructor(marketIndex: number, settlePnlLimitWindow: number, settlePnlLimitSettledInCurrentWindowNative: BN$1, basePositionLots: BN$1, quotePositionNative: {
        val: BN$1;
    }, quoteRunningNative: BN$1, longSettledFunding: I80F48Dto, shortSettledFunding: I80F48Dto, bidsBaseLots: BN$1, asksBaseLots: BN$1, takerBaseLots: BN$1, takerQuoteLots: BN$1, cumulativeLongFunding: number, cumulativeShortFunding: number, makerVolume: BN$1, takerVolume: BN$1, perpSpotTransfers: BN$1, avgEntryPricePerBaseLot: number, realizedTradePnlNative: I80F48Dto, realizedOtherPnlNative: I80F48Dto, settlePnlLimitRealizedTrade: BN$1, realizedPnlForPositionNative: I80F48Dto);
}
declare class PerpOo {
    sideAndTree: any;
    orderMarket: number;
    clientId: BN$1;
    id: BN$1;
    static OrderMarketUnset: number;
    static from(dto: PerpOoDto): PerpOo;
    constructor(sideAndTree: any, orderMarket: number, clientId: BN$1, id: BN$1);
    isActive(): boolean;
}
declare class PerpOoDto {
    sideAndTree: any;
    market: number;
    clientId: BN$1;
    id: BN$1;
    constructor(sideAndTree: any, market: number, clientId: BN$1, id: BN$1);
}
declare class HealthType {
    static maint: {
        maint: {};
    };
    static init: {
        init: {};
    };
    static liquidationEnd: {
        liquidationEnd: {};
    };
}

declare type PerpMarketIndex = number & As<'perp-market-index'>;
declare type ParsedFillEvent = Modify<FillEvent, {
    price: number;
    quantity: number;
}>;
declare class PerpMarket {
    publicKey: PublicKey;
    group: PublicKey;
    settleTokenIndex: TokenIndex;
    perpMarketIndex: PerpMarketIndex;
    groupInsuranceFund: boolean;
    baseDecimals: number;
    bids: PublicKey;
    asks: PublicKey;
    eventQueue: PublicKey;
    oracle: PublicKey;
    stablePriceModel: StablePriceModel;
    quoteLotSize: BN$1;
    baseLotSize: BN$1;
    openInterest: BN$1;
    seqNum: BN$1;
    registrationTime: BN$1;
    impactQuantity: BN$1;
    fundingLastUpdated: BN$1;
    feePenalty: number;
    settleFeeFlat: number;
    settleFeeAmountThreshold: number;
    settleFeeFractionLowHealth: number;
    settlePnlLimitFactor: number;
    settlePnlLimitWindowSizeTs: BN$1;
    reduceOnly: boolean;
    name: string;
    oracleConfig: OracleConfig;
    maintBaseAssetWeight: I80F48;
    initBaseAssetWeight: I80F48;
    maintBaseLiabWeight: I80F48;
    initBaseLiabWeight: I80F48;
    baseLiquidationFee: I80F48;
    makerFee: I80F48;
    takerFee: I80F48;
    minFunding: I80F48;
    maxFunding: I80F48;
    longFunding: I80F48;
    shortFunding: I80F48;
    feesAccrued: I80F48;
    feesSettled: I80F48;
    maintOverallAssetWeight: I80F48;
    initOverallAssetWeight: I80F48;
    _price: I80F48;
    _uiPrice: number;
    _oracleLastUpdatedSlot: number;
    private priceLotsToUiConverter;
    private baseLotsToUiConverter;
    private quoteLotsToUiConverter;
    private _bids;
    private _asks;
    static from(publicKey: PublicKey, obj: {
        group: PublicKey;
        settleTokenIndex: number;
        perpMarketIndex: number;
        groupInsuranceFund: number;
        baseDecimals: number;
        name: number[];
        bids: PublicKey;
        asks: PublicKey;
        eventQueue: PublicKey;
        oracle: PublicKey;
        oracleConfig: OracleConfigDto;
        stablePriceModel: StablePriceModel;
        quoteLotSize: BN$1;
        baseLotSize: BN$1;
        maintBaseAssetWeight: I80F48Dto;
        initBaseAssetWeight: I80F48Dto;
        maintBaseLiabWeight: I80F48Dto;
        initBaseLiabWeight: I80F48Dto;
        openInterest: BN$1;
        seqNum: BN$1;
        registrationTime: BN$1;
        minFunding: I80F48Dto;
        maxFunding: I80F48Dto;
        impactQuantity: BN$1;
        longFunding: I80F48Dto;
        shortFunding: I80F48Dto;
        fundingLastUpdated: BN$1;
        baseLiquidationFee: I80F48Dto;
        makerFee: I80F48Dto;
        takerFee: I80F48Dto;
        feesAccrued: I80F48Dto;
        feesSettled: I80F48Dto;
        feePenalty: number;
        settleFeeFlat: number;
        settleFeeAmountThreshold: number;
        settleFeeFractionLowHealth: number;
        settlePnlLimitFactor: number;
        settlePnlLimitWindowSizeTs: BN$1;
        reduceOnly: number;
        maintOverallAssetWeight: I80F48Dto;
        initOverallAssetWeight: I80F48Dto;
        positivePnlLiquidationFee: I80F48Dto;
    }): PerpMarket;
    constructor(publicKey: PublicKey, group: PublicKey, settleTokenIndex: TokenIndex, perpMarketIndex: PerpMarketIndex, // TODO rename to marketIndex?
    groupInsuranceFund: boolean, baseDecimals: number, name: number[], bids: PublicKey, asks: PublicKey, eventQueue: PublicKey, oracle: PublicKey, oracleConfig: OracleConfigDto, stablePriceModel: StablePriceModel, quoteLotSize: BN$1, baseLotSize: BN$1, maintBaseAssetWeight: I80F48Dto, initBaseAssetWeight: I80F48Dto, maintBaseLiabWeight: I80F48Dto, initBaseLiabWeight: I80F48Dto, openInterest: BN$1, seqNum: BN$1, registrationTime: BN$1, minFunding: I80F48Dto, maxFunding: I80F48Dto, impactQuantity: BN$1, longFunding: I80F48Dto, shortFunding: I80F48Dto, fundingLastUpdated: BN$1, baseLiquidationFee: I80F48Dto, makerFee: I80F48Dto, takerFee: I80F48Dto, feesAccrued: I80F48Dto, feesSettled: I80F48Dto, feePenalty: number, settleFeeFlat: number, settleFeeAmountThreshold: number, settleFeeFractionLowHealth: number, settlePnlLimitFactor: number, settlePnlLimitWindowSizeTs: BN$1, reduceOnly: boolean, maintOverallAssetWeight: I80F48Dto, initOverallAssetWeight: I80F48Dto, positivePnlLiquidationFee: I80F48Dto);
    get price(): I80F48;
    get uiPrice(): number;
    get oracleLastUpdatedSlot(): number;
    get minOrderSize(): number;
    get tickSize(): number;
    insidePriceLimit(side: PerpOrderSide, orderPrice: number): boolean;
    loadAsks(client: MangoClient, forceReload?: boolean): Promise<BookSide>;
    loadBids(client: MangoClient, forceReload?: boolean): Promise<BookSide>;
    loadEventQueue(client: MangoClient): Promise<PerpEventQueue>;
    loadFills(client: MangoClient, lastSeqNum?: BN$1): Promise<(OutEvent | FillEvent | LiquidateEvent)[]>;
    parseFillEvent(event: any): ParsedFillEvent;
    logOb(client: MangoClient): Promise<string>;
    /**
     *
     * @param bids
     * @param asks
     * @returns returns funding rate per hour
     */
    getCurrentFundingRate(bids: BookSide, asks: BookSide): number;
    uiPriceToLots(price: number): BN$1;
    uiBaseToLots(quantity: number): BN$1;
    uiQuoteToLots(uiQuote: number): BN$1;
    priceLotsToUi(price: BN$1): number;
    priceNativeToUi(price: number): number;
    baseLotsToUi(quantity: BN$1): number;
    quoteLotsToUi(quantity: BN$1): number;
    /**
     * Returns a list of (upto count) accounts, and the pnl that is settle'able on this perp market,
     * the list is sorted ascending for 'negative' direction and descending for 'positive' direction.
     *
     * NOTE: keep in sync with perp_pnl.rs:fetch_top
     *
     * TODO: replace with a more performant offchain service call
     * @param client
     * @param group
     * @param direction
     * @returns
     */
    getSettlePnlCandidates(client: MangoClient, group: Group, direction: 'negative' | 'positive', count?: number): Promise<{
        account: MangoAccount;
        settleablePnl: I80F48;
    }[]>;
    toString(): string;
}
interface OrderTreeNodes {
    bumpIndex: number;
    freeListLen: number;
    freeListHead: number;
    nodes: [any];
}
interface OrderTreeRoot {
    maybeNode: number;
    leafCount: number;
}
declare class BookSide {
    client: MangoClient;
    perpMarket: PerpMarket;
    type: BookSideType;
    rootFixed: OrderTreeRoot;
    rootOraclePegged: OrderTreeRoot;
    orderTreeNodes: OrderTreeNodes;
    private static INNER_NODE_TAG;
    private static LEAF_NODE_TAG;
    now: BN$1;
    static from(client: MangoClient, perpMarket: PerpMarket, bookSideType: BookSideType, obj: {
        roots: OrderTreeRoot[];
        nodes: OrderTreeNodes;
    }): BookSide;
    constructor(client: MangoClient, perpMarket: PerpMarket, type: BookSideType, rootFixed: OrderTreeRoot, rootOraclePegged: OrderTreeRoot, orderTreeNodes: OrderTreeNodes, maxBookDelay?: number);
    static getPriceFromKey(key: BN$1): BN$1;
    /**
     * iterates over all orders
     */
    items(): Generator<PerpOrder>;
    /**
     * iterates over all orders,
     * skips oracle pegged orders which are invalid due to oracle price crossing the peg limit,
     * skips tif orders which are invalid due to tif having elapsed,
     */
    itemsValid(): Generator<PerpOrder>;
    fixedItems(): Generator<PerpOrder>;
    oraclePeggedItems(): Generator<PerpOrder>;
    best(): PerpOrder | undefined;
    getImpactPriceUi(baseLots: BN$1): number | undefined;
    getL2(depth: number): [number, number, BN$1, BN$1][];
    getL2Ui(depth: number): [number, number][];
    static toInnerNode(client: MangoClient, data: [number]): InnerNode;
    static toLeafNode(client: MangoClient, data: [number]): LeafNode;
}
declare class BookSideType {
    static bids: {
        bids: {};
    };
    static asks: {
        asks: {};
    };
}
declare class LeafNode {
    ownerSlot: number;
    orderType: PerpOrderType;
    timeInForce: number;
    key: BN$1;
    owner: PublicKey;
    quantity: BN$1;
    timestamp: BN$1;
    pegLimit: BN$1;
    static from(obj: {
        ownerSlot: number;
        orderType: PerpOrderType;
        timeInForce: number;
        key: BN$1;
        owner: PublicKey;
        quantity: BN$1;
        timestamp: BN$1;
        pegLimit: BN$1;
    }): LeafNode;
    constructor(ownerSlot: number, orderType: PerpOrderType, timeInForce: number, key: BN$1, owner: PublicKey, quantity: BN$1, timestamp: BN$1, pegLimit: BN$1);
}
declare class InnerNode {
    children: [number];
    static from(obj: {
        children: [number];
    }): InnerNode;
    constructor(children: [number]);
}
declare class PerpOrderSide {
    static bid: {
        bid: {};
    };
    static ask: {
        ask: {};
    };
}
declare class PerpOrderType {
    static limit: {
        limit: {};
    };
    static immediateOrCancel: {
        immediateOrCancel: {};
    };
    static postOnly: {
        postOnly: {};
    };
    static market: {
        market: {};
    };
    static postOnlySlide: {
        postOnlySlide: {};
    };
}
declare class PerpOrder {
    seqNum: BN$1;
    orderId: BN$1;
    owner: PublicKey;
    openOrdersSlot: number;
    feeTier: 0;
    uiPrice: number;
    priceLots: BN$1;
    uiSize: number;
    sizeLots: BN$1;
    side: PerpOrderSide;
    timestamp: BN$1;
    expiryTimestamp: BN$1;
    perpMarketIndex: number;
    isExpired: boolean;
    isOraclePegged: boolean;
    oraclePeggedProperties?: OraclePeggedProperties;
    static from(perpMarket: PerpMarket, leafNode: LeafNode, type: BookSideType, isExpired?: boolean, isOraclePegged?: boolean): PerpOrder;
    constructor(seqNum: BN$1, orderId: BN$1, owner: PublicKey, openOrdersSlot: number, feeTier: 0, uiPrice: number, priceLots: BN$1, uiSize: number, sizeLots: BN$1, side: PerpOrderSide, timestamp: BN$1, expiryTimestamp: BN$1, perpMarketIndex: number, isExpired?: boolean, isOraclePegged?: boolean, oraclePeggedProperties?: OraclePeggedProperties);
    get price(): number;
    get size(): number;
}
interface OraclePeggedProperties {
    isInvalid: boolean;
    priceOffset: BN$1;
    uiPriceOffset: number;
    pegLimit: BN$1;
    uiPegLimit: number;
}
declare class PerpEventQueue {
    static FILL_EVENT_TYPE: number;
    static OUT_EVENT_TYPE: number;
    static LIQUIDATE_EVENT_TYPE: number;
    head: number;
    count: number;
    seqNum: BN$1;
    rawEvents: (OutEvent | FillEvent | LiquidateEvent)[];
    constructor(client: MangoClient, header: {
        head: number;
        count: number;
        seqNum: BN$1;
    }, buf: any);
    getUnconsumedEvents(): (OutEvent | FillEvent | LiquidateEvent)[];
    eventsSince(lastSeqNum?: BN$1): (OutEvent | FillEvent | LiquidateEvent)[];
}
interface Event {
    eventType: number;
}
interface OutEvent extends Event {
    side: PerpOrderType;
    ownerSlot: number;
    timestamp: BN$1;
    seqNum: BN$1;
    owner: PublicKey;
    quantity: BN$1;
}
interface FillEvent extends Event {
    takerSide: PerpOrderType;
    makerOut: boolean;
    makerSlot: number;
    timestamp: BN$1;
    seqNum: BN$1;
    maker: PublicKey;
    makerOrderId: BN$1;
    makerFee: I80F48;
    makerTimestamp: BN$1;
    taker: PublicKey;
    takerOrderId: BN$1;
    takerClientOrderId: BN$1;
    takerFee: I80F48;
    price: BN$1;
    quantity: BN$1;
}
interface LiquidateEvent extends Event {
    seqNum: BN$1;
}

declare class Group {
    publicKey: PublicKey;
    creator: PublicKey;
    groupNum: number;
    admin: PublicKey;
    fastListingAdmin: PublicKey;
    securityAdmin: PublicKey;
    insuranceMint: PublicKey;
    insuranceVault: PublicKey;
    testing: number;
    version: number;
    ixGate: BN;
    addressLookupTables: PublicKey[];
    addressLookupTablesList: AddressLookupTableAccount[];
    banksMapByName: Map<string, Bank[]>;
    banksMapByMint: Map<string, Bank[]>;
    banksMapByTokenIndex: Map<TokenIndex, Bank[]>;
    serum3MarketsMapByExternal: Map<string, Serum3Market>;
    serum3MarketsMapByMarketIndex: Map<MarketIndex, Serum3Market>;
    serum3ExternalMarketsMap: Map<string, Market$1>;
    perpMarketsMapByOracle: Map<string, PerpMarket>;
    perpMarketsMapByMarketIndex: Map<PerpMarketIndex, PerpMarket>;
    perpMarketsMapByName: Map<string, PerpMarket>;
    mintInfosMapByTokenIndex: Map<TokenIndex, MintInfo>;
    mintInfosMapByMint: Map<string, MintInfo>;
    vaultAmountsMap: Map<string, BN>;
    static from(publicKey: PublicKey, obj: {
        creator: PublicKey;
        groupNum: number;
        admin: PublicKey;
        fastListingAdmin: PublicKey;
        securityAdmin: PublicKey;
        insuranceMint: PublicKey;
        insuranceVault: PublicKey;
        testing: number;
        version: number;
        ixGate: BN;
        addressLookupTables: PublicKey[];
    }): Group;
    constructor(publicKey: PublicKey, creator: PublicKey, groupNum: number, admin: PublicKey, fastListingAdmin: PublicKey, securityAdmin: PublicKey, insuranceMint: PublicKey, insuranceVault: PublicKey, testing: number, version: number, ixGate: BN, addressLookupTables: PublicKey[], addressLookupTablesList: AddressLookupTableAccount[], banksMapByName: Map<string, Bank[]>, banksMapByMint: Map<string, Bank[]>, banksMapByTokenIndex: Map<TokenIndex, Bank[]>, serum3MarketsMapByExternal: Map<string, Serum3Market>, serum3MarketsMapByMarketIndex: Map<MarketIndex, Serum3Market>, serum3ExternalMarketsMap: Map<string, Market$1>, perpMarketsMapByOracle: Map<string, PerpMarket>, perpMarketsMapByMarketIndex: Map<PerpMarketIndex, PerpMarket>, perpMarketsMapByName: Map<string, PerpMarket>, mintInfosMapByTokenIndex: Map<TokenIndex, MintInfo>, mintInfosMapByMint: Map<string, MintInfo>, vaultAmountsMap: Map<string, BN>);
    reloadAll(client: MangoClient): Promise<void>;
    reloadAlts(client: MangoClient): Promise<void>;
    reloadBanks(client: MangoClient, ids?: Id): Promise<void>;
    reloadMintInfos(client: MangoClient, ids?: Id): Promise<void>;
    reloadSerum3Markets(client: MangoClient, ids?: Id): Promise<void>;
    reloadSerum3ExternalMarkets(client: MangoClient): Promise<void>;
    reloadPerpMarkets(client: MangoClient, ids?: Id): Promise<void>;
    reloadBankOraclePrices(client: MangoClient): Promise<void>;
    reloadPerpMarketOraclePrices(client: MangoClient): Promise<void>;
    private decodePriceFromOracleAi;
    reloadVaults(client: MangoClient): Promise<void>;
    getMintDecimals(mintPk: PublicKey): number;
    getMintDecimalsByTokenIndex(tokenIndex: TokenIndex): number;
    getInsuranceMintDecimals(): number;
    getFirstBankByMint(mintPk: PublicKey): Bank;
    getFirstBankByTokenIndex(tokenIndex: TokenIndex): Bank;
    /**
     *
     * @param mintPk
     * @returns sum of ui balances of vaults for all banks for a token
     */
    getTokenVaultBalanceByMintUi(mintPk: PublicKey): number;
    getSerum3MarketByMarketIndex(marketIndex: MarketIndex): Serum3Market;
    getSerum3MarketByName(name: string): Serum3Market;
    getSerum3MarketByExternalMarket(externalMarketPk: PublicKey): Serum3Market;
    getSerum3ExternalMarket(externalMarketPk: PublicKey): Market$1;
    loadSerum3BidsForMarket(client: MangoClient, externalMarketPk: PublicKey): Promise<Orderbook$1>;
    loadSerum3AsksForMarket(client: MangoClient, externalMarketPk: PublicKey): Promise<Orderbook$1>;
    findPerpMarket(marketIndex: PerpMarketIndex): PerpMarket;
    getPerpMarketByOracle(oracle: PublicKey): PerpMarket;
    getPerpMarketByMarketIndex(marketIndex: PerpMarketIndex): PerpMarket;
    getPerpMarketByName(perpMarketName: string): PerpMarket;
    loadPerpBidsForMarket(client: MangoClient, perpMarketIndex: PerpMarketIndex): Promise<BookSide>;
    loadPerpAsksForMarket(client: MangoClient, group: Group, perpMarketIndex: PerpMarketIndex): Promise<BookSide>;
    consoleLogBanks(): void;
    toUiPrice(price: I80F48 | number, baseDecimals: number): number;
    toNativePrice(uiPrice: number, baseDecimals: number): I80F48;
    toNativeDecimals(uiAmount: number, mintPk: PublicKey): BN;
    toString(): string;
}

declare enum AccountRetriever {
    Scanning = 0,
    Fixed = 1
}
declare type IdsSource = 'api' | 'static' | 'get-program-accounts';
declare type MangoClientOptions = {
    idsSource?: IdsSource;
    postSendTxCallback?: ({ txid }: {
        txid: string;
    }) => void;
    prioritizationFee?: number;
    txConfirmationCommitment?: Commitment;
};
declare class MangoClient {
    program: Program<MangoV4>;
    programId: PublicKey;
    cluster: Cluster;
    opts: MangoClientOptions;
    private idsSource;
    private postSendTxCallback?;
    private prioritizationFee;
    private txConfirmationCommitment;
    constructor(program: Program<MangoV4>, programId: PublicKey, cluster: Cluster, opts?: MangoClientOptions);
    sendAndConfirmTransaction(ixs: TransactionInstruction[], opts?: any): Promise<string>;
    private sendAndConfirmTransactionForGroup;
    groupCreate(groupNum: number, testing: boolean, version: number, insuranceMintPk: PublicKey): Promise<TransactionSignature>;
    groupEdit(group: Group, admin?: PublicKey, fastListingAdmin?: PublicKey, securityAdmin?: PublicKey, testing?: number, version?: number, depositLimitQuote?: BN$1): Promise<TransactionSignature>;
    ixGateSet(group: Group, ixGateParams: IxGateParams): Promise<TransactionSignature>;
    groupClose(group: Group): Promise<TransactionSignature>;
    getGroup(groupPk: PublicKey): Promise<Group>;
    getGroupsForCreator(creatorPk: PublicKey): Promise<Group[]>;
    getGroupForCreator(creatorPk: PublicKey, groupNum: number): Promise<Group>;
    getIds(groupPk: PublicKey): Promise<Id | undefined>;
    tokenRegister(group: Group, mintPk: PublicKey, oraclePk: PublicKey, oracleConfig: OracleConfigParams, tokenIndex: number, name: string, interestRateParams: InterestRateParams, loanFeeRate: number, loanOriginationFeeRate: number, maintAssetWeight: number, initAssetWeight: number, maintLiabWeight: number, initLiabWeight: number, liquidationFee: number, minVaultToDepositsRatio: number, netBorrowLimitWindowSizeTs: number, netBorrowLimitPerWindowQuote: number): Promise<TransactionSignature>;
    tokenRegisterTrustless(group: Group, mintPk: PublicKey, oraclePk: PublicKey, tokenIndex: number, name: string): Promise<TransactionSignature>;
    tokenEdit(group: Group, mintPk: PublicKey, params: TokenEditParams): Promise<TransactionSignature>;
    tokenDeregister(group: Group, mintPk: PublicKey): Promise<TransactionSignature>;
    getBanksForGroup(group: Group): Promise<Bank[]>;
    getMintInfosForGroup(group: Group): Promise<MintInfo[]>;
    getMintInfoForTokenIndex(group: Group, tokenIndex: TokenIndex): Promise<MintInfo[]>;
    stubOracleCreate(group: Group, mintPk: PublicKey, price: number): Promise<TransactionSignature>;
    stubOracleClose(group: Group, oracle: PublicKey): Promise<TransactionSignature>;
    stubOracleSet(group: Group, oraclePk: PublicKey, price: number): Promise<TransactionSignature>;
    getStubOracle(group: Group, mintPk?: PublicKey): Promise<StubOracle[]>;
    getOrCreateMangoAccount(group: Group, loadSerum3Oo?: boolean): Promise<MangoAccount>;
    createMangoAccount(group: Group, accountNumber?: number, name?: string, tokenCount?: number, serum3Count?: number, perpCount?: number, perpOoCount?: number): Promise<TransactionSignature>;
    createAndFetchMangoAccount(group: Group, accountNumber?: number, name?: string, tokenCount?: number, serum3Count?: number, perpCount?: number, perpOoCount?: number, loadSerum3Oo?: boolean): Promise<MangoAccount | undefined>;
    expandMangoAccount(group: Group, account: MangoAccount, tokenCount: number, serum3Count: number, perpCount: number, perpOoCount: number): Promise<TransactionSignature>;
    editMangoAccount(group: Group, mangoAccount: MangoAccount, name?: string, delegate?: PublicKey): Promise<TransactionSignature>;
    computeAccountData(group: Group, mangoAccount: MangoAccount): Promise<TransactionSignature>;
    toggleMangoAccountFreeze(group: Group, mangoAccount: MangoAccount, freeze: boolean): Promise<TransactionSignature>;
    getMangoAccount(mangoAccount: MangoAccount | PublicKey, loadSerum3Oo?: boolean): Promise<MangoAccount>;
    getMangoAccountWithSlot(mangoAccountPk: PublicKey, loadSerum3Oo?: boolean): Promise<{
        slot: number;
        value: MangoAccount;
    } | undefined>;
    getMangoAccountForOwner(group: Group, ownerPk: PublicKey, accountNumber: number, loadSerum3Oo?: boolean): Promise<MangoAccount | undefined>;
    getMangoAccountsForOwner(group: Group, ownerPk: PublicKey, loadSerum3Oo?: boolean): Promise<MangoAccount[]>;
    getMangoAccountsForDelegate(group: Group, delegate: PublicKey, loadSerum3Oo?: boolean): Promise<MangoAccount[]>;
    getAllMangoAccounts(group: Group, loadSerum3Oo?: boolean): Promise<MangoAccount[]>;
    /**
     * Note: this ix doesn't settle liabs, reduce open positions, or withdraw tokens to wallet,
     * it simply closes the account. To close successfully ensure all positions are closed, or
     * use forceClose flag
     * @param group
     * @param mangoAccount
     * @param forceClose
     * @returns
     */
    closeMangoAccount(group: Group, mangoAccount: MangoAccount, forceClose?: boolean): Promise<TransactionSignature>;
    emptyAndCloseMangoAccount(group: Group, mangoAccount: MangoAccount): Promise<TransactionSignature>;
    tokenDeposit(group: Group, mangoAccount: MangoAccount, mintPk: PublicKey, amount: number, reduceOnly?: boolean): Promise<TransactionSignature>;
    tokenDepositNative(group: Group, mangoAccount: MangoAccount, mintPk: PublicKey, nativeAmount: BN$1, reduceOnly?: boolean): Promise<TransactionSignature>;
    tokenWithdraw(group: Group, mangoAccount: MangoAccount, mintPk: PublicKey, amount: number, allowBorrow: boolean): Promise<TransactionSignature>;
    tokenWithdrawNativeIx(group: Group, mangoAccount: MangoAccount, mintPk: PublicKey, nativeAmount: BN$1, allowBorrow: boolean, healthAccountsToExclude?: PublicKey[]): Promise<TransactionInstruction[]>;
    tokenWithdrawNative(group: Group, mangoAccount: MangoAccount, mintPk: PublicKey, nativeAmount: BN$1, allowBorrow: boolean, healthAccountsToExclude?: PublicKey[]): Promise<TransactionSignature>;
    serum3RegisterMarket(group: Group, serum3MarketExternalPk: PublicKey, baseBank: Bank, quoteBank: Bank, marketIndex: number, name: string): Promise<TransactionSignature>;
    serum3deregisterMarket(group: Group, externalMarketPk: PublicKey): Promise<TransactionSignature>;
    serum3GetMarkets(group: Group, baseTokenIndex?: number, quoteTokenIndex?: number): Promise<Serum3Market[]>;
    serum3CreateOpenOrders(group: Group, mangoAccount: MangoAccount, externalMarketPk: PublicKey): Promise<TransactionSignature>;
    serum3CreateOpenOrdersIx(group: Group, mangoAccount: MangoAccount, externalMarketPk: PublicKey): Promise<TransactionInstruction>;
    serum3CloseOpenOrdersIx(group: Group, mangoAccount: MangoAccount, externalMarketPk: PublicKey): Promise<TransactionInstruction>;
    serum3CloseOpenOrders(group: Group, mangoAccount: MangoAccount, externalMarketPk: PublicKey): Promise<TransactionSignature>;
    serum3PlaceOrderIx(group: Group, mangoAccount: MangoAccount, externalMarketPk: PublicKey, side: Serum3Side, price: number, size: number, selfTradeBehavior: Serum3SelfTradeBehavior, orderType: Serum3OrderType, clientOrderId: number, limit: number): Promise<TransactionInstruction[]>;
    serum3PlaceOrder(group: Group, mangoAccount: MangoAccount, externalMarketPk: PublicKey, side: Serum3Side, price: number, size: number, selfTradeBehavior: Serum3SelfTradeBehavior, orderType: Serum3OrderType, clientOrderId: number, limit: number): Promise<TransactionSignature>;
    serum3CancelAllOrders(group: Group, mangoAccount: MangoAccount, externalMarketPk: PublicKey, limit?: number): Promise<TransactionSignature>;
    serum3SettleFundsIx(group: Group, mangoAccount: MangoAccount, externalMarketPk: PublicKey): Promise<TransactionInstruction>;
    serum3SettleFunds(group: Group, mangoAccount: MangoAccount, externalMarketPk: PublicKey): Promise<TransactionSignature>;
    serum3CancelOrderIx(group: Group, mangoAccount: MangoAccount, externalMarketPk: PublicKey, side: Serum3Side, orderId: BN$1): Promise<TransactionInstruction>;
    serum3CancelOrder(group: Group, mangoAccount: MangoAccount, externalMarketPk: PublicKey, side: Serum3Side, orderId: BN$1): Promise<TransactionSignature>;
    perpCreateMarket(group: Group, oraclePk: PublicKey, perpMarketIndex: number, name: string, oracleConfig: OracleConfigParams, baseDecimals: number, quoteLotSize: number, baseLotSize: number, maintBaseAssetWeight: number, initBaseAssetWeight: number, maintBaseLiabWeight: number, initBaseLiabWeight: number, maintOverallAssetWeight: number, initOverallAssetWeight: number, baseLiquidationFee: number, makerFee: number, takerFee: number, feePenalty: number, minFunding: number, maxFunding: number, impactQuantity: number, groupInsuranceFund: boolean, settleFeeFlat: number, settleFeeAmountThreshold: number, settleFeeFractionLowHealth: number, settleTokenIndex: number, settlePnlLimitFactor: number, settlePnlLimitWindowSize: number, positivePnlLiquidationFee: number): Promise<TransactionSignature>;
    perpEditMarket(group: Group, perpMarketIndex: PerpMarketIndex, params: PerpEditParams): Promise<TransactionSignature>;
    perpCloseMarket(group: Group, perpMarketIndex: PerpMarketIndex): Promise<TransactionSignature>;
    perpGetMarkets(group: Group): Promise<PerpMarket[]>;
    perpDeactivatePositionIx(group: Group, mangoAccount: MangoAccount, perpMarketIndex: PerpMarketIndex): Promise<TransactionInstruction>;
    perpDeactivatePosition(group: Group, mangoAccount: MangoAccount, perpMarketIndex: PerpMarketIndex): Promise<TransactionSignature>;
    perpPlaceOrder(group: Group, mangoAccount: MangoAccount, perpMarketIndex: PerpMarketIndex, side: PerpOrderSide, price: number, quantity: number, maxQuoteQuantity?: number, clientOrderId?: number, orderType?: PerpOrderType, reduceOnly?: boolean, expiryTimestamp?: number, limit?: number): Promise<TransactionSignature>;
    perpPlaceOrderIx(group: Group, mangoAccount: MangoAccount, perpMarketIndex: PerpMarketIndex, side: PerpOrderSide, price: number, quantity: number, maxQuoteQuantity?: number, clientOrderId?: number, orderType?: PerpOrderType, reduceOnly?: boolean, expiryTimestamp?: number, limit?: number): Promise<TransactionInstruction>;
    perpPlaceOrderPegged(group: Group, mangoAccount: MangoAccount, perpMarketIndex: PerpMarketIndex, side: PerpOrderSide, priceOffset: number, pegLimit: number, quantity: number, maxQuoteQuantity?: number, clientOrderId?: number, orderType?: PerpOrderType, reduceOnly?: boolean, expiryTimestamp?: number, limit?: number): Promise<TransactionSignature>;
    perpPlaceOrderPeggedIx(group: Group, mangoAccount: MangoAccount, perpMarketIndex: PerpMarketIndex, side: PerpOrderSide, priceOffset: number, pegLimit: number, quantity: number, maxQuoteQuantity?: number, clientOrderId?: number, orderType?: PerpOrderType, reduceOnly?: boolean, expiryTimestamp?: number, limit?: number): Promise<TransactionInstruction>;
    perpCancelOrderIx(group: Group, mangoAccount: MangoAccount, perpMarketIndex: PerpMarketIndex, orderId: BN$1): Promise<TransactionInstruction>;
    perpCancelOrder(group: Group, mangoAccount: MangoAccount, perpMarketIndex: PerpMarketIndex, orderId: BN$1): Promise<TransactionSignature>;
    perpCancelAllOrders(group: Group, mangoAccount: MangoAccount, perpMarketIndex: PerpMarketIndex, limit: number): Promise<TransactionSignature>;
    perpCancelAllOrdersIx(group: Group, mangoAccount: MangoAccount, perpMarketIndex: PerpMarketIndex, limit: number): Promise<TransactionInstruction>;
    perpSettlePnl(group: Group, profitableAccount: MangoAccount, unprofitableAccount: MangoAccount, settler: MangoAccount, perpMarketIndex: PerpMarketIndex): Promise<TransactionSignature>;
    perpSettleFees(group: Group, account: MangoAccount, perpMarketIndex: PerpMarketIndex, maxSettleAmount: BN$1): Promise<TransactionSignature>;
    perpConsumeEvents(group: Group, perpMarketIndex: PerpMarketIndex, accounts: PublicKey[], limit: number): Promise<TransactionSignature>;
    perpConsumeAllEvents(group: Group, perpMarketIndex: PerpMarketIndex): Promise<void>;
    marginTrade({ group, mangoAccount, inputMintPk, amountIn, outputMintPk, userDefinedInstructions, userDefinedAlts, flashLoanType, }: {
        group: Group;
        mangoAccount: MangoAccount;
        inputMintPk: PublicKey;
        amountIn: number;
        outputMintPk: PublicKey;
        userDefinedInstructions: TransactionInstruction[];
        userDefinedAlts: AddressLookupTableAccount[];
        flashLoanType: FlashLoanType;
    }): Promise<TransactionSignature>;
    updateIndexAndRate(group: Group, mintPk: PublicKey): Promise<TransactionSignature>;
    liqTokenWithToken(group: Group, liqor: MangoAccount, liqee: MangoAccount, assetMintPk: PublicKey, liabMintPk: PublicKey, maxLiabTransfer: number): Promise<TransactionSignature>;
    altSet(group: Group, addressLookupTable: PublicKey, index: number): Promise<TransactionSignature>;
    altExtend(group: Group, addressLookupTable: PublicKey, index: number, pks: PublicKey[]): Promise<TransactionSignature>;
    healthRegionBeginIx(group: Group, account: MangoAccount, banks?: Bank[], perpMarkets?: PerpMarket[]): Promise<TransactionInstruction>;
    healthRegionEndIx(group: Group, account: MangoAccount, banks?: Bank[], perpMarkets?: PerpMarket[]): Promise<TransactionInstruction>;
    static connect(provider: Provider, cluster: Cluster, programId: PublicKey, opts?: MangoClientOptions): MangoClient;
    static connectForGroupName(provider: Provider, groupName: string): MangoClient;
    buildHealthRemainingAccounts(retriever: AccountRetriever, group: Group, mangoAccounts: MangoAccount[], banks?: Bank[], perpMarkets?: PerpMarket[], openOrdersForMarket?: [Serum3Market, PublicKey][]): PublicKey[];
    private buildFixedAccountRetrieverHealthAccounts;
    private buildScanningAccountRetrieverHealthAccounts;
    modifyPerpOrder(group: Group, mangoAccount: MangoAccount, perpMarketIndex: PerpMarketIndex, orderId: BN$1, side: PerpOrderSide, price: number, quantity: number, maxQuoteQuantity?: number, clientOrderId?: number, orderType?: PerpOrderType, reduceOnly?: boolean, expiryTimestamp?: number, limit?: number): Promise<TransactionSignature>;
    modifySerum3Order(group: Group, orderId: BN$1, mangoAccount: MangoAccount, externalMarketPk: PublicKey, side: Serum3Side, price: number, size: number, selfTradeBehavior: Serum3SelfTradeBehavior, orderType: Serum3OrderType, clientOrderId: number, limit: number): Promise<TransactionSignature>;
}

export { AccountRetriever as A, BookSide as B, Event as E, FillEvent as F, Group as G, HealthType as H, InnerNode as I, LeafNode as L, MangoAccount as M, OutEvent as O, PerpPosition as P, Serum3Market as S, TokenPosition as T, MangoClient as a, Serum3OrderType as b, Serum3SelfTradeBehavior as c, Serum3Side as d, TokenPositionDto as e, Serum3Orders as f, Serum3PositionDto as g, PerpPositionDto as h, PerpOo as i, PerpOoDto as j, PerpMarketIndex as k, ParsedFillEvent as l, PerpMarket as m, BookSideType as n, PerpOrderSide as o, PerpOrderType as p, PerpOrder as q, PerpEventQueue as r, LiquidateEvent as s, MarketIndex as t, generateSerum3MarketExternalVaultSignerAddress as u, IdsSource as v, MangoClientOptions as w };
