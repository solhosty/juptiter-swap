{"version":3,"sources":["../ts/client/src/numbers/I80F48.ts"],"sourcesContent":["import Big from 'big.js';\nimport BN from 'bn.js';\n\nexport class I80F48Dto {\n  constructor(public val: BN) {}\n}\n\n// TODO - this whole class is inefficient; consider optimizing\nexport class I80F48 {\n  /**\n  This is represented by a 128 bit signed integer underneath\n  The first 80 bits are treated as an integer and last 48 bits are treated as fractional part after binary point\n  It's possible to think of an I80F48 as an i128 divided by 2 ^ 40\n\n  Read up on how fixed point math works: https://inst.eecs.berkeley.edu/~cs61c/sp06/handout/fixedpt.html\n  Read up on how 2s complement works: https://en.wikipedia.org/wiki/Two%27s_complement\n   */\n  static MAX_SIZE = 128;\n  static FRACTIONS = 48;\n  static MULTIPLIER_BIG = new Big(2).pow(I80F48.FRACTIONS);\n  static MULTIPLIER_BN = new BN(2).pow(new BN(I80F48.FRACTIONS));\n  static MULTIPLIER_NUMBER = Math.pow(2, I80F48.FRACTIONS);\n  static MAX_BN: BN = new BN(2)\n    .pow(new BN(I80F48.MAX_SIZE))\n    .div(new BN(2))\n    .sub(new BN(1));\n\n  static MIN_BN: BN = new BN(2)\n    .pow(new BN(I80F48.MAX_SIZE))\n    .div(new BN(2))\n    .neg();\n\n  data: BN; // This is i128 => array of 16 bytes\n\n  static from(dto: I80F48Dto): I80F48 {\n    return new I80F48(dto.val);\n  }\n\n  constructor(data: BN) {\n    if (data.lt(I80F48.MIN_BN) || data.gt(I80F48.MAX_BN)) {\n      throw new Error('Number out of range');\n    }\n\n    this.data = data;\n  }\n  static fromNumber(x: number): I80F48 {\n    const int_part = Math.trunc(x);\n    const v = new BN(int_part.toFixed(0)).iushln(48);\n    v.iadd(new BN((x - int_part) * I80F48.MULTIPLIER_NUMBER));\n    return new I80F48(v);\n  }\n  static fromNumberOrUndef(x?: number): I80F48 | undefined {\n    return x === undefined ? undefined : I80F48.fromNumber(x);\n  }\n\n  static fromOptionalString(x?: string): I80F48 | undefined {\n    return x ? I80F48.fromString(x) : undefined;\n  }\n\n  static fromString(x: string): I80F48 {\n    const initialValue = new Big(x).times(I80F48.MULTIPLIER_BIG);\n    const fixedPointValue = new BN(initialValue.round().toFixed());\n    return new I80F48(fixedPointValue);\n  }\n  static fromI64(x: BN): I80F48 {\n    return new I80F48(x.ushln(48));\n  }\n  static fromU64(x: BN): I80F48 {\n    return new I80F48(x.ushln(48));\n  }\n  toTwos(): BN {\n    return this.data.toTwos(I80F48.MAX_SIZE);\n  }\n  toString(): string {\n    return this.toBig().toFixed();\n  }\n\n  /**\n   * The number will be rounded first for UI sensibilities, then toFixed\n   */\n  toFixed(decimals?: number): string {\n    return this.toBig().round(14).toFixed(decimals);\n  }\n  toLocaleString(\n    locales?: string | string[],\n    options?: Intl.NumberFormatOptions,\n  ): string {\n    return this.toNumber().toLocaleString(locales, options);\n  }\n  toBig(): Big {\n    return new Big(this.data.toString()).div(I80F48.MULTIPLIER_BIG);\n  }\n  static fromBig(x: Big): I80F48 {\n    return new I80F48(new BN(x.mul(I80F48.MULTIPLIER_BIG).round().toFixed()));\n  }\n  toNumber(): number {\n    return this.toBig().toNumber();\n  }\n  static fromArray(src: Uint8Array): I80F48 {\n    if (src.length !== 16) {\n      throw new Error('Uint8Array must be of length 16');\n    }\n    return new I80F48(new BN(src, 'le').fromTwos(I80F48.MAX_SIZE));\n  }\n  toArray(): Uint8Array {\n    return new Uint8Array(this.data.toTwos(I80F48.MAX_SIZE).toArray('le', 16));\n  }\n  toArrayLike(\n    ArrayType: typeof Buffer,\n    endian?: BN.Endianness,\n    length?: number,\n  ): Buffer {\n    return this.data\n      .toTwos(I80F48.MAX_SIZE)\n      .toArrayLike(ArrayType, endian, length);\n  }\n  getData(): BN {\n    return this.data;\n  }\n  getBinaryLayout(): string {\n    return this.data\n      .toTwos(I80F48.MAX_SIZE)\n      .toString(2, I80F48.MAX_SIZE)\n      .replace(/-/g, '');\n  }\n  add(x: I80F48): I80F48 {\n    return new I80F48(this.data.add(x.getData()));\n  }\n  sub(x: I80F48): I80F48 {\n    return new I80F48(this.data.sub(x.getData()));\n  }\n  iadd(x: I80F48): I80F48 {\n    this.data.iadd(x.getData());\n    return this;\n  }\n  isub(x: I80F48): I80F48 {\n    this.data.isub(x.getData());\n    return this;\n  }\n  floor(): I80F48 {\n    // Low IQ method\n    return I80F48.fromBig(this.toBig().round(undefined, 0));\n    // return new I80F48(this.data.shrn(I80F48.FRACTIONS).shln(I80F48.FRACTIONS));\n  }\n  ceil(): I80F48 {\n    // Low IQ method, 3 -> round up\n    return I80F48.fromBig(this.toBig().round(undefined, 3));\n\n    // const frac = this.data.maskn(I80F48.FRACTIONS);\n    // if (frac.eq(ZERO_BN)) {\n    //   return this;\n    // } else {\n    //   return this.floor().add(ONE_I80F48);\n    // }\n  }\n  frac(): I80F48 {\n    // TODO verify this works for negative numbers\n    return new I80F48(this.data.maskn(I80F48.FRACTIONS));\n  }\n  /**\n   * Multiply the two and shift\n   */\n  mul(x: I80F48): I80F48 {\n    return new I80F48(this.data.mul(x.data).iushrn(I80F48.FRACTIONS));\n  }\n  imul(x: I80F48): I80F48 {\n    this.data.imul(x.getData()).iushrn(I80F48.FRACTIONS);\n    return this;\n  }\n\n  div(x: I80F48): I80F48 {\n    return new I80F48(this.data.ushln(I80F48.FRACTIONS).div(x.data));\n  }\n  idiv(x: I80F48): I80F48 {\n    this.data = this.data.iushln(I80F48.FRACTIONS).div(x.data);\n    return this;\n  }\n\n  gt(x: I80F48): boolean {\n    return this.data.gt(x.getData());\n  }\n  lt(x: I80F48): boolean {\n    return this.data.lt(x.getData());\n  }\n  gte(x: I80F48): boolean {\n    return this.data.gte(x.getData());\n  }\n  lte(x: I80F48): boolean {\n    return this.data.lte(x.getData());\n  }\n  eq(x: I80F48): boolean {\n    // TODO make sure this works when they're diff signs or 0\n    return this.data.eq(x.getData());\n  }\n  cmp(x: I80F48): -1 | 0 | 1 {\n    // TODO make sure this works when they're diff signs or 0\n    return this.data.cmp(x.getData());\n  }\n  neg(): I80F48 {\n    return this.mul(_NEG_ONE_I80F48);\n  }\n  isPos(): boolean {\n    return this.gt(_ZERO_I80F48);\n  }\n  isNeg(): boolean {\n    return this.data.isNeg();\n  }\n  isZero(): boolean {\n    return this.eq(_ZERO_I80F48);\n  }\n  min(x: I80F48): I80F48 {\n    return this.lte(x) ? this : x;\n  }\n  max(x: I80F48): I80F48 {\n    return this.gte(x) ? this : x;\n  }\n  abs(): I80F48 {\n    if (this.isNeg()) {\n      return this.neg();\n    } else {\n      return this;\n    }\n  }\n}\n\n/** @internal */\nconst _ZERO_I80F48 = I80F48.fromNumber(0);\n/** @internal */\nconst _NEG_ONE_I80F48 = I80F48.fromNumber(-1);\n\nexport function ONE_I80F48(): I80F48 {\n  return I80F48.fromNumber(1);\n}\n\nexport function ZERO_I80F48(): I80F48 {\n  return I80F48.fromNumber(0);\n}\n\nexport function HUNDRED_I80F48(): I80F48 {\n  return I80F48.fromNumber(100);\n}\n\nexport function MAX_I80F48(): I80F48 {\n  return new I80F48(I80F48.MAX_BN);\n}\n"],"mappings":"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","names":[]}