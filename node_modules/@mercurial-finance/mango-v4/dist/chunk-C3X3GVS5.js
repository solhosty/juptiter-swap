"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }

var _chunkUGHO4YHYjs = require('./chunk-UGHO4YHY.js');


var _chunkZYSI4CYOjs = require('./chunk-ZYSI4CYO.js');




var _chunkS6N5Y2X2js = require('./chunk-S6N5Y2X2.js');





var _chunk772SHZWXjs = require('./chunk-772SHZWX.js');






var _chunkS3PQ6OXSjs = require('./chunk-S3PQ6OXS.js');

// ts/client/src/accounts/healthCache.ts
var _anchor = require('@project-serum/anchor');
var _lodash = require('lodash');

// ts/client/src/accounts/mangoAccount.ts

var _bytes = require('@project-serum/anchor/dist/cjs/utils/bytes');
var _market = require('@project-serum/serum/lib/market');
var MangoAccount = class {
  constructor(publicKey, group, owner, name, delegate, accountNum, beingLiquidated, inHealthRegion, netDeposits, perpSpotTransfers, healthRegionBeginInitHealth, frozenUntil, headerVersion, tokens, serum3, perps, perpOpenOrders, serum3OosMapByMarketIndex) {
    this.publicKey = publicKey;
    this.group = group;
    this.owner = owner;
    this.delegate = delegate;
    this.accountNum = accountNum;
    this.beingLiquidated = beingLiquidated;
    this.inHealthRegion = inHealthRegion;
    this.netDeposits = netDeposits;
    this.perpSpotTransfers = perpSpotTransfers;
    this.healthRegionBeginInitHealth = healthRegionBeginInitHealth;
    this.frozenUntil = frozenUntil;
    this.headerVersion = headerVersion;
    this.serum3OosMapByMarketIndex = serum3OosMapByMarketIndex;
    this.name = _bytes.utf8.decode(new Uint8Array(name)).split("\0")[0];
    this.tokens = tokens.map((dto) => TokenPosition.from(dto));
    this.serum3 = serum3.map((dto) => Serum3Orders.from(dto));
    this.perps = perps.map((dto) => PerpPosition.from(dto));
    this.perpOpenOrders = perpOpenOrders.map((dto) => PerpOo.from(dto));
  }
  static from(publicKey, obj) {
    return new MangoAccount(
      publicKey,
      obj.group,
      obj.owner,
      obj.name,
      obj.delegate,
      obj.accountNum,
      obj.beingLiquidated == 1,
      obj.inHealthRegion == 1,
      obj.netDeposits,
      obj.perpSpotTransfers,
      obj.healthRegionBeginInitHealth,
      obj.frozenUntil,
      obj.headerVersion,
      obj.tokens,
      obj.serum3,
      obj.perps,
      obj.perpOpenOrders,
      /* @__PURE__ */ new Map()
      // serum3OosMapByMarketIndex
    );
  }
  async reload(client) {
    const mangoAccount = await client.getMangoAccount(this);
    await mangoAccount.reloadSerum3OpenOrders(client);
    Object.assign(this, mangoAccount);
    return mangoAccount;
  }
  async reloadWithSlot(client) {
    const resp = await client.getMangoAccountWithSlot(this.publicKey);
    await _optionalChain([resp, 'optionalAccess', _ => _.value, 'access', _2 => _2.reloadSerum3OpenOrders, 'call', _3 => _3(client)]);
    Object.assign(this, _optionalChain([resp, 'optionalAccess', _4 => _4.value]));
    return { value: resp.value, slot: resp.slot };
  }
  async reloadSerum3OpenOrders(client) {
    const serum3Active = this.serum3Active();
    const ais = await client.program.provider.connection.getMultipleAccountsInfo(
      serum3Active.map((serum3) => serum3.openOrders)
    );
    this.serum3OosMapByMarketIndex = new Map(
      Array.from(
        ais.map((ai, i) => {
          if (!ai) {
            throw new Error(
              `Undefined AI for open orders ${serum3Active[i].openOrders} and market ${serum3Active[i].marketIndex}!`
            );
          }
          const oo = _market.OpenOrders.fromAccountInfo(
            serum3Active[i].openOrders,
            ai,
            _chunkS6N5Y2X2js.OPENBOOK_PROGRAM_ID[client.cluster]
          );
          return [serum3Active[i].marketIndex, oo];
        })
      )
    );
    return this;
  }
  isDelegate(client) {
    return this.delegate.equals(
      client.program.provider.wallet.publicKey
    );
  }
  isOperational() {
    return this.frozenUntil.lt(new (0, _anchor.BN)(Date.now() / 1e3));
  }
  tokensActive() {
    return this.tokens.filter((token) => token.isActive());
  }
  serum3Active() {
    return this.serum3.filter((serum3) => serum3.isActive());
  }
  perpPositionExistsForMarket(perpMarket) {
    return this.perps.some(
      (pp) => pp.isActive() && pp.marketIndex == perpMarket.perpMarketIndex
    );
  }
  perpOrderExistsForMarket(perpMarket) {
    return this.perpOpenOrders.some(
      (poo) => poo.isActive() && poo.orderMarket == perpMarket.perpMarketIndex
    );
  }
  perpActive() {
    return this.perps.filter((perp) => perp.isActive());
  }
  perpOrdersActive() {
    return this.perpOpenOrders.filter(
      (oo) => oo.orderMarket !== PerpOo.OrderMarketUnset
    );
  }
  getToken(tokenIndex) {
    return this.tokens.find((ta) => ta.tokenIndex == tokenIndex);
  }
  getSerum3Account(marketIndex) {
    return this.serum3.find((sa) => sa.marketIndex == marketIndex);
  }
  getPerpPosition(perpMarketIndex) {
    return this.perps.find((pp) => pp.marketIndex == perpMarketIndex);
  }
  getPerpPositionUi(group, perpMarketIndex, useEventQueue) {
    const pp = this.perps.find((pp2) => pp2.marketIndex == perpMarketIndex);
    if (!pp) {
      throw new Error(`No position found for PerpMarket ${perpMarketIndex}!`);
    }
    const perpMarket = group.getPerpMarketByMarketIndex(perpMarketIndex);
    return pp.getBasePositionUi(perpMarket, useEventQueue);
  }
  getSerum3OoAccount(marketIndex) {
    const oo = this.serum3OosMapByMarketIndex.get(marketIndex);
    if (!oo) {
      throw new Error(
        `Open orders account not loaded for market with marketIndex ${marketIndex}!`
      );
    }
    return oo;
  }
  // How to navigate
  // * if a function is returning a I80F48, then usually the return value is in native quote or native token, unless specified
  // * if a function is returning a number, then usually the return value is in ui tokens, unless specified
  // * functions try to be explicit by having native or ui in the name to better reflect the value
  // * some values might appear unexpected large or small, usually the doc contains a "note"
  /**
   *
   * @param bank
   * @returns native balance for a token, is signed
   */
  getTokenBalance(bank) {
    const tp = this.getToken(bank.tokenIndex);
    return tp ? tp.balance(bank) : _chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, );
  }
  /**
   *
   * @param bank
   * @returns native deposits for a token, 0 if position has borrows
   */
  getTokenDeposits(bank) {
    const tp = this.getToken(bank.tokenIndex);
    return tp ? tp.deposits(bank) : _chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, );
  }
  /**
   *
   * @param bank
   * @returns native borrows for a token, 0 if position has deposits
   */
  getTokenBorrows(bank) {
    const tp = this.getToken(bank.tokenIndex);
    return tp ? tp.borrows(bank) : _chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, );
  }
  /**
   *
   * @param bank
   * @returns UI balance for a token, is signed
   */
  getTokenBalanceUi(bank) {
    const tp = this.getToken(bank.tokenIndex);
    return tp ? tp.balanceUi(bank) : 0;
  }
  /**
   *
   * @param bank
   * @returns UI deposits for a token, 0 or more
   */
  getTokenDepositsUi(bank) {
    const ta = this.getToken(bank.tokenIndex);
    return ta ? ta.depositsUi(bank) : 0;
  }
  /**
   *
   * @param bank
   * @returns UI borrows for a token, 0 or less
   */
  getTokenBorrowsUi(bank) {
    const ta = this.getToken(bank.tokenIndex);
    return ta ? ta.borrowsUi(bank) : 0;
  }
  /**
   * Health, see health.rs or https://docs.mango.markets/mango-markets/health-overview
   * @param healthType
   * @returns raw health number, in native quote
   */
  getHealth(group, healthType) {
    const hc = HealthCache.fromMangoAccount(group, this);
    return hc.health(healthType);
  }
  getPerpSettleHealth(group) {
    const hc = HealthCache.fromMangoAccount(group, this);
    return hc.perpSettleHealth();
  }
  /**
   * Health ratio, which is computed so `100 * (assets-liabs)/liabs`
   * Note: health ratio is technically ∞ if liabs are 0
   * @param healthType
   * @returns health ratio, in percentage form
   */
  getHealthRatio(group, healthType) {
    const hc = HealthCache.fromMangoAccount(group, this);
    return hc.healthRatio(healthType);
  }
  /**
   * Health ratio
   * @param healthType
   * @returns health ratio, in percentage form, capped to 100
   */
  getHealthRatioUi(group, healthType) {
    const ratio = this.getHealthRatio(group, healthType).toNumber();
    return ratio > 100 ? 100 : Math.trunc(ratio);
  }
  /**
   * Sum of all the assets i.e. token deposits, borrows, total assets in spot open orders, and perps positions.
   * @returns equity, in native quote
   */
  getEquity(group) {
    const tokensMap = /* @__PURE__ */ new Map();
    for (const tp of this.tokensActive()) {
      const bank = group.getFirstBankByTokenIndex(tp.tokenIndex);
      tokensMap.set(tp.tokenIndex, tp.balance(bank).mul(bank.price));
    }
    for (const sp of this.serum3Active()) {
      const oo = this.getSerum3OoAccount(sp.marketIndex);
      const baseBank = group.getFirstBankByTokenIndex(sp.baseTokenIndex);
      tokensMap.get(baseBank.tokenIndex).iadd(_chunkS3PQ6OXSjs.I80F48.fromI64(oo.baseTokenTotal).mul(baseBank.price));
      const quoteBank = group.getFirstBankByTokenIndex(sp.quoteTokenIndex);
      tokensMap.get(baseBank.tokenIndex).iadd(
        _chunkS3PQ6OXSjs.I80F48.fromI64(
          oo.quoteTokenTotal.add(oo.referrerRebatesAccrued)
        ).mul(quoteBank.price)
      );
    }
    const tokenEquity = Array.from(tokensMap.values()).reduce(
      (a, b) => a.add(b),
      _chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, )
    );
    const perpEquity = this.perpActive().reduce(
      (a, b) => a.add(b.getEquity(group.getPerpMarketByMarketIndex(b.marketIndex))),
      _chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, )
    );
    return tokenEquity.add(perpEquity);
  }
  /**
   * The amount of native quote you could withdraw against your existing assets.
   * @returns collateral value, in native quote
   */
  getCollateralValue(group) {
    return this.getHealth(group, HealthType.init);
  }
  /**
   * Sum of all positive assets.
   * @returns assets, in native quote
   */
  getAssetsValue(group, healthType) {
    const hc = HealthCache.fromMangoAccount(group, this);
    return hc.assets(healthType);
  }
  /**
   * Sum of all negative assets.
   * @returns liabs, in native quote
   */
  getLiabsValue(group, healthType) {
    const hc = HealthCache.fromMangoAccount(group, this);
    return hc.liabs(healthType);
  }
  /**
   * @returns Overall PNL, in native quote
   * PNL is defined here as spot value + serum3 open orders value + perp value - net deposits value (evaluated at native quote price at the time of the deposit/withdraw)
   * spot value + serum3 open orders value + perp value is returned by getEquity (open orders values are added to spot token values implicitly)
   */
  getPnl(group) {
    return _optionalChain([this, 'access', _5 => _5.getEquity, 'call', _6 => _6(group), 'optionalAccess', _7 => _7.add, 'call', _8 => _8(
      _chunkS3PQ6OXSjs.I80F48.fromI64(this.netDeposits).mul(_chunkS3PQ6OXSjs.I80F48.fromNumber(-1))
    )]);
  }
  /**
   * @returns token cumulative interest, in native token units. Sum of deposit and borrow interest.
   * Caveat: This will only return cumulative interest since the tokenPosition was last opened.
   * If the tokenPosition was closed and reopened multiple times it is necessary to add this result to
   * cumulative interest at each of the prior tokenPosition closings (from mango API) to get the all time
   * cumulative interest.
   */
  getCumulativeInterest(bank) {
    const token = this.getToken(bank.tokenIndex);
    if (token === void 0) {
      return 0;
    } else {
      if (token.indexedPosition.isPos()) {
        const interest = bank.depositIndex.sub(token.previousIndex).mul(token.indexedPosition).toNumber();
        return interest + token.cumulativeDepositInterest + token.cumulativeBorrowInterest;
      } else {
        const interest = bank.borrowIndex.sub(token.previousIndex).mul(token.indexedPosition).toNumber();
        return interest + token.cumulativeDepositInterest + token.cumulativeBorrowInterest;
      }
    }
  }
  /**
   * The amount of given native token you can withdraw including borrows, considering all existing assets as collateral.
   * @returns amount of given native token you can borrow, considering all existing assets as collateral, in native token
   *
   * TODO: take into account net_borrow_limit and min_vault_to_deposits_ratio
   */
  getMaxWithdrawWithBorrowForToken(group, mintPk) {
    const tokenBank = group.getFirstBankByMint(mintPk);
    const initHealth = this.getHealth(group, HealthType.init);
    if (initHealth.lte(_chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, ))) {
      return _chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, );
    }
    const tp = this.getToken(tokenBank.tokenIndex);
    const existingTokenDeposits = tp ? tp.deposits(tokenBank) : _chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, );
    let existingPositionHealthContrib = _chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, );
    if (existingTokenDeposits.gt(_chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, ))) {
      existingPositionHealthContrib = existingTokenDeposits.mul(tokenBank.price).imul(tokenBank.initAssetWeight);
    }
    if (existingPositionHealthContrib.gt(initHealth)) {
      const withdrawAbleExistingPositionHealthContrib = initHealth;
      return withdrawAbleExistingPositionHealthContrib.div(tokenBank.initAssetWeight).div(tokenBank.price);
    }
    const initHealthWithoutExistingPosition = initHealth.sub(
      existingPositionHealthContrib
    );
    let maxBorrowNative = initHealthWithoutExistingPosition.div(tokenBank.initLiabWeight).div(tokenBank.price);
    const vaultAmount = group.vaultAmountsMap.get(tokenBank.vault.toBase58());
    if (!vaultAmount) {
      throw new Error(
        `No vault amount found for ${tokenBank.name} vault ${tokenBank.vault}!`
      );
    }
    const vaultAmountAfterWithdrawingDeposits = _chunkS3PQ6OXSjs.I80F48.fromU64(vaultAmount).sub(
      existingTokenDeposits
    );
    const expectedVaultMinAmount = tokenBank.nativeDeposits().mul(_chunkS3PQ6OXSjs.I80F48.fromNumber(tokenBank.minVaultToDepositsRatio));
    if (vaultAmountAfterWithdrawingDeposits.gt(expectedVaultMinAmount)) {
      maxBorrowNative = maxBorrowNative.min(
        vaultAmountAfterWithdrawingDeposits.sub(expectedVaultMinAmount)
      );
    }
    const maxBorrowNativeWithoutFees = maxBorrowNative.div(
      _chunkS3PQ6OXSjs.ONE_I80F48.call(void 0, ).add(tokenBank.loanOriginationFeeRate)
    );
    return maxBorrowNativeWithoutFees.add(existingTokenDeposits);
  }
  getMaxWithdrawWithBorrowForTokenUi(group, mintPk) {
    const maxWithdrawWithBorrow = this.getMaxWithdrawWithBorrowForToken(
      group,
      mintPk
    );
    return _chunk772SHZWXjs.toUiDecimals.call(void 0, maxWithdrawWithBorrow, group.getMintDecimals(mintPk));
  }
  /**
   * The max amount of given source ui token you can swap to a target token.
   * @returns max amount of given source ui token you can swap to a target token, in ui token
   */
  getMaxSourceUiForTokenSwap(group, sourceMintPk, targetMintPk, slippageAndFeesFactor = 1) {
    if (sourceMintPk.equals(targetMintPk)) {
      return 0;
    }
    const sourceBank = group.getFirstBankByMint(sourceMintPk);
    const targetBank = group.getFirstBankByMint(targetMintPk);
    const hc = HealthCache.fromMangoAccount(group, this);
    let maxSource = hc.getMaxSwapSource(
      sourceBank,
      targetBank,
      _chunkS3PQ6OXSjs.I80F48.fromNumber(
        slippageAndFeesFactor * (sourceBank.uiPrice / targetBank.uiPrice * Math.pow(10, targetBank.mintDecimals - sourceBank.mintDecimals))
      )
    );
    const sourceBalance = this.getTokenBalance(sourceBank);
    if (maxSource.gt(sourceBalance)) {
      const sourceBorrow = maxSource.sub(sourceBalance);
      maxSource = sourceBalance.add(
        sourceBorrow.div(_chunkS3PQ6OXSjs.ONE_I80F48.call(void 0, ).add(sourceBank.loanOriginationFeeRate))
      );
    }
    return _chunk772SHZWXjs.toUiDecimals.call(void 0, maxSource, group.getMintDecimals(sourceMintPk));
  }
  /**
   * Simulates new health ratio after applying tokenChanges to the token positions.
   * Note: token changes are expected in ui amounts
   *
   * e.g. useful to simulate health after a potential swap.
   * Note: health ratio is technically ∞ if liabs are 0
   * @returns health ratio, in percentage form
   */
  simHealthRatioWithTokenPositionUiChanges(group, uiTokenChanges, healthType = HealthType.init) {
    const nativeTokenChanges = uiTokenChanges.map((tokenChange) => {
      return {
        nativeTokenAmount: _chunk772SHZWXjs.toNativeI80F48.call(void 0, 
          tokenChange.uiTokenAmount,
          group.getMintDecimals(tokenChange.mintPk)
        ),
        mintPk: tokenChange.mintPk
      };
    });
    const hc = HealthCache.fromMangoAccount(group, this);
    return hc.simHealthRatioWithTokenPositionChanges(
      group,
      nativeTokenChanges,
      healthType
    ).toNumber();
  }
  async loadSerum3OpenOrdersAccounts(client) {
    const response = await client.program.provider.connection.getMultipleAccountsInfo(
      this.serum3Active().map((s) => s.openOrders)
    );
    const accounts = response.filter(
      (a) => Boolean(a)
    );
    return accounts.map((acc, index) => {
      return _market.OpenOrders.fromAccountInfo(
        this.serum3[index].openOrders,
        acc,
        _chunkS6N5Y2X2js.OPENBOOK_PROGRAM_ID[client.cluster]
      );
    });
  }
  async loadSerum3OpenOrdersForMarket(client, group, externalMarketPk) {
    const serum3Market = group.getSerum3MarketByExternalMarket(externalMarketPk);
    const serum3OO = this.serum3Active().find(
      (s) => s.marketIndex === serum3Market.marketIndex
    );
    if (!serum3OO) {
      throw new Error(`No open orders account found for ${externalMarketPk}`);
    }
    const serum3MarketExternal = group.serum3ExternalMarketsMap.get(
      externalMarketPk.toBase58()
    );
    const [bidsInfo, asksInfo] = await client.program.provider.connection.getMultipleAccountsInfo([
      serum3MarketExternal.bidsAddress,
      serum3MarketExternal.asksAddress
    ]);
    if (!bidsInfo) {
      throw new Error(
        `Undefined bidsInfo for serum3Market with externalMarket ${externalMarketPk.toString()}`
      );
    }
    if (!asksInfo) {
      throw new Error(
        `Undefined asksInfo for serum3Market with externalMarket ${externalMarketPk.toString()}`
      );
    }
    const bids = _market.Orderbook.decode(serum3MarketExternal, bidsInfo.data);
    const asks = _market.Orderbook.decode(serum3MarketExternal, asksInfo.data);
    return [...bids, ...asks].filter(
      (o) => o.openOrdersAddress.equals(serum3OO.openOrders)
    );
  }
  /**
   * TODO REWORK, know to break in binary search, also make work for limit orders
   *
   * @param group
   * @param externalMarketPk
   * @returns maximum ui quote which can be traded at oracle price for base token given current health
   */
  getMaxQuoteForSerum3BidUi(group, externalMarketPk) {
    const serum3Market = group.getSerum3MarketByExternalMarket(externalMarketPk);
    const baseBank = group.getFirstBankByTokenIndex(
      serum3Market.baseTokenIndex
    );
    const quoteBank = group.getFirstBankByTokenIndex(
      serum3Market.quoteTokenIndex
    );
    const hc = HealthCache.fromMangoAccount(group, this);
    const nativeAmount = hc.getMaxSerum3OrderForHealthRatio(
      baseBank,
      quoteBank,
      serum3Market,
      _chunkUGHO4YHYjs.Serum3Side.bid,
      _chunkS3PQ6OXSjs.I80F48.fromNumber(2)
    );
    let quoteAmount = nativeAmount.div(quoteBank.price);
    const quoteBalance = this.getTokenBalance(quoteBank);
    if (quoteAmount.gt(quoteBalance)) {
      const quoteBorrow = quoteAmount.sub(quoteBalance);
      quoteAmount = quoteBalance.add(
        quoteBorrow.div(_chunkS3PQ6OXSjs.ONE_I80F48.call(void 0, ).add(quoteBank.loanOriginationFeeRate))
      );
    }
    quoteAmount = quoteAmount.div(
      _chunkS3PQ6OXSjs.ONE_I80F48.call(void 0, ).add(_chunkS3PQ6OXSjs.I80F48.fromNumber(serum3Market.getFeeRates(true)))
    );
    return _chunk772SHZWXjs.toUiDecimals.call(void 0, nativeAmount, quoteBank.mintDecimals);
  }
  /**
   * TODO REWORK, know to break in binary search, also make work for limit orders
   * @param group
   * @param externalMarketPk
   * @returns maximum ui base which can be traded at oracle price for quote token given current health
   */
  getMaxBaseForSerum3AskUi(group, externalMarketPk) {
    const serum3Market = group.getSerum3MarketByExternalMarket(externalMarketPk);
    const baseBank = group.getFirstBankByTokenIndex(
      serum3Market.baseTokenIndex
    );
    const quoteBank = group.getFirstBankByTokenIndex(
      serum3Market.quoteTokenIndex
    );
    const hc = HealthCache.fromMangoAccount(group, this);
    const nativeAmount = hc.getMaxSerum3OrderForHealthRatio(
      baseBank,
      quoteBank,
      serum3Market,
      _chunkUGHO4YHYjs.Serum3Side.ask,
      _chunkS3PQ6OXSjs.I80F48.fromNumber(2)
    );
    let baseAmount = nativeAmount.div(baseBank.price);
    const baseBalance = this.getTokenBalance(baseBank);
    if (baseAmount.gt(baseBalance)) {
      const baseBorrow = baseAmount.sub(baseBalance);
      baseAmount = baseBalance.add(
        baseBorrow.div(_chunkS3PQ6OXSjs.ONE_I80F48.call(void 0, ).add(baseBank.loanOriginationFeeRate))
      );
    }
    baseAmount = baseAmount.div(
      _chunkS3PQ6OXSjs.ONE_I80F48.call(void 0, ).add(_chunkS3PQ6OXSjs.I80F48.fromNumber(serum3Market.getFeeRates(true)))
    );
    return _chunk772SHZWXjs.toUiDecimals.call(void 0, baseAmount, baseBank.mintDecimals);
  }
  /**
   *
   * @param group
   * @param uiQuoteAmount
   * @param externalMarketPk
   * @param healthType
   * @returns health ratio after a bid with uiQuoteAmount is placed
   */
  simHealthRatioWithSerum3BidUiChanges(group, uiQuoteAmount, externalMarketPk, healthType = HealthType.init) {
    const serum3Market = group.getSerum3MarketByExternalMarket(externalMarketPk);
    const baseBank = group.getFirstBankByTokenIndex(
      serum3Market.baseTokenIndex
    );
    const quoteBank = group.getFirstBankByTokenIndex(
      serum3Market.quoteTokenIndex
    );
    const hc = HealthCache.fromMangoAccount(group, this);
    return hc.simHealthRatioWithSerum3BidChanges(
      baseBank,
      quoteBank,
      _chunk772SHZWXjs.toNativeI80F48.call(void 0, 
        uiQuoteAmount,
        group.getFirstBankByTokenIndex(serum3Market.quoteTokenIndex).mintDecimals
      ),
      serum3Market,
      healthType
    ).toNumber();
  }
  /**
   *
   * @param group
   * @param uiBaseAmount
   * @param externalMarketPk
   * @param healthType
   * @returns health ratio after an ask with uiBaseAmount is placed
   */
  simHealthRatioWithSerum3AskUiChanges(group, uiBaseAmount, externalMarketPk, healthType = HealthType.init) {
    const serum3Market = group.getSerum3MarketByExternalMarket(externalMarketPk);
    const baseBank = group.getFirstBankByTokenIndex(
      serum3Market.baseTokenIndex
    );
    const quoteBank = group.getFirstBankByTokenIndex(
      serum3Market.quoteTokenIndex
    );
    const hc = HealthCache.fromMangoAccount(group, this);
    return hc.simHealthRatioWithSerum3AskChanges(
      baseBank,
      quoteBank,
      _chunk772SHZWXjs.toNativeI80F48.call(void 0, 
        uiBaseAmount,
        group.getFirstBankByTokenIndex(serum3Market.baseTokenIndex).mintDecimals
      ),
      serum3Market,
      healthType
    ).toNumber();
  }
  // TODO: don't send a settle instruction if there's nothing to settle
  async serum3SettleFundsForAllMarkets(client, group) {
    return await Promise.all(
      this.serum3Active().map((s) => {
        const serum3Market = group.getSerum3MarketByMarketIndex(s.marketIndex);
        return client.serum3SettleFunds(
          group,
          this,
          serum3Market.serumMarketExternal
        );
      })
    );
  }
  // TODO: cancel until all are cancelled
  async serum3CancelAllOrdersForAllMarkets(client, group) {
    return await Promise.all(
      this.serum3Active().map((s) => {
        const serum3Market = group.getSerum3MarketByMarketIndex(s.marketIndex);
        return client.serum3CancelAllOrders(
          group,
          this,
          serum3Market.serumMarketExternal
        );
      })
    );
  }
  /**
   * TODO: also think about limit orders
   *
   * The max ui quote you can place a market/ioc bid on the market,
   * price is the ui price at which you think the order would materialiase.
   * @param group
   * @param perpMarketName
   * @returns maximum ui quote which can be traded at oracle price for quote token given current health
   */
  getMaxQuoteForPerpBidUi(group, perpMarketIndex) {
    const perpMarket = group.getPerpMarketByMarketIndex(perpMarketIndex);
    const hc = HealthCache.fromMangoAccount(group, this);
    const baseLots = hc.getMaxPerpForHealthRatio(
      perpMarket,
      _chunkS3PQ6OXSjs.I80F48.fromNumber(perpMarket.uiPrice),
      _chunkZYSI4CYOjs.PerpOrderSide.bid,
      _chunkS3PQ6OXSjs.I80F48.fromNumber(2)
    );
    const nativeBase = baseLots.mul(_chunkS3PQ6OXSjs.I80F48.fromI64(perpMarket.baseLotSize));
    const nativeQuote = nativeBase.mul(perpMarket.price);
    return _chunk772SHZWXjs.toUiDecimalsForQuote.call(void 0, nativeQuote);
  }
  /**
   * TODO: also think about limit orders
   *
   * The max ui base you can place a market/ioc ask on the market,
   * price is the ui price at which you think the order would materialiase.
   * @param group
   * @param perpMarketName
   * @param uiPrice ui price at which ask would be placed at
   * @returns max ui base ask
   */
  getMaxBaseForPerpAskUi(group, perpMarketIndex) {
    const perpMarket = group.getPerpMarketByMarketIndex(perpMarketIndex);
    const hc = HealthCache.fromMangoAccount(group, this);
    const baseLots = hc.getMaxPerpForHealthRatio(
      perpMarket,
      _chunkS3PQ6OXSjs.I80F48.fromNumber(perpMarket.uiPrice),
      _chunkZYSI4CYOjs.PerpOrderSide.ask,
      _chunkS3PQ6OXSjs.I80F48.fromNumber(2)
    );
    return perpMarket.baseLotsToUi(new (0, _anchor.BN)(baseLots.toString()));
  }
  simHealthRatioWithPerpBidUiChanges(group, perpMarketIndex, size) {
    const perpMarket = group.getPerpMarketByMarketIndex(perpMarketIndex);
    const pp = this.getPerpPosition(perpMarket.perpMarketIndex);
    const hc = HealthCache.fromMangoAccount(group, this);
    return hc.simHealthRatioWithPerpOrderChanges(
      perpMarket,
      pp ? pp : PerpPosition.emptyFromPerpMarketIndex(perpMarket.perpMarketIndex),
      _chunkZYSI4CYOjs.PerpOrderSide.bid,
      perpMarket.uiBaseToLots(size),
      _chunkS3PQ6OXSjs.I80F48.fromNumber(perpMarket.uiPrice),
      HealthType.init
    ).toNumber();
  }
  simHealthRatioWithPerpAskUiChanges(group, perpMarketIndex, size) {
    const perpMarket = group.getPerpMarketByMarketIndex(perpMarketIndex);
    const pp = this.getPerpPosition(perpMarket.perpMarketIndex);
    const hc = HealthCache.fromMangoAccount(group, this);
    return hc.simHealthRatioWithPerpOrderChanges(
      perpMarket,
      pp ? pp : PerpPosition.emptyFromPerpMarketIndex(perpMarket.perpMarketIndex),
      _chunkZYSI4CYOjs.PerpOrderSide.ask,
      perpMarket.uiBaseToLots(size),
      _chunkS3PQ6OXSjs.I80F48.fromNumber(perpMarket.uiPrice),
      HealthType.init
    ).toNumber();
  }
  async loadPerpOpenOrdersForMarket(client, group, perpMarketIndex) {
    const perpMarket = group.getPerpMarketByMarketIndex(perpMarketIndex);
    const [bids, asks] = await Promise.all([
      perpMarket.loadBids(client),
      perpMarket.loadAsks(client)
    ]);
    return [...Array.from(bids.items()), ...Array.from(asks.items())].filter(
      (order) => order.owner.equals(this.publicKey)
    );
  }
  toString(group, onlyTokens = false) {
    let res = "MangoAccount";
    res = res + "\n pk: " + this.publicKey.toString();
    res = res + "\n name: " + this.name;
    res = res + "\n accountNum: " + this.accountNum;
    res = res + "\n owner: " + this.owner;
    res = res + "\n delegate: " + this.delegate;
    res = res + `
 max token slots ${this.tokens.length}, max serum3 slots ${this.serum3.length}, max perp slots ${this.perps.length}, max perp oo slots ${this.perpOpenOrders.length}`;
    res = this.tokensActive().length > 0 ? res + "\n tokens:" + JSON.stringify(
      this.tokens.filter((token, i) => token.isActive()).map((token, i) => token.toString(group, i)),
      null,
      4
    ) : res + "";
    if (onlyTokens) {
      return res;
    }
    res = this.serum3Active().length > 0 ? res + "\n serum:" + JSON.stringify(this.serum3Active(), null, 4) : res + "";
    res = this.perpActive().length > 0 ? res + "\n perps:" + JSON.stringify(
      this.perpActive().map(
        (p) => p.toString(_optionalChain([group, 'optionalAccess', _9 => _9.getPerpMarketByMarketIndex, 'call', _10 => _10(p.marketIndex)]))
      ),
      null,
      4
    ) : res + "";
    res = this.perpOrdersActive().length > 0 ? res + "\n perps oo:" + JSON.stringify(this.perpOrdersActive(), null, 4) : res + "";
    return res;
  }
};
var _TokenPosition = class {
  constructor(indexedPosition, tokenIndex, inUseCount, previousIndex, cumulativeDepositInterest, cumulativeBorrowInterest) {
    this.indexedPosition = indexedPosition;
    this.tokenIndex = tokenIndex;
    this.inUseCount = inUseCount;
    this.previousIndex = previousIndex;
    this.cumulativeDepositInterest = cumulativeDepositInterest;
    this.cumulativeBorrowInterest = cumulativeBorrowInterest;
  }
  static from(dto) {
    return new _TokenPosition(
      _chunkS3PQ6OXSjs.I80F48.from(dto.indexedPosition),
      dto.tokenIndex,
      dto.inUseCount,
      _chunkS3PQ6OXSjs.I80F48.from(dto.previousIndex),
      dto.cumulativeDepositInterest,
      dto.cumulativeBorrowInterest
    );
  }
  isActive() {
    return this.tokenIndex !== _TokenPosition.TokenIndexUnset;
  }
  /**
   *
   * @param bank
   * @returns native balance
   */
  balance(bank) {
    if (this.indexedPosition.isPos()) {
      return bank.depositIndex.mul(this.indexedPosition);
    } else {
      return bank.borrowIndex.mul(this.indexedPosition);
    }
  }
  /**
   *
   * @param bank
   * @returns native deposits, 0 if position has borrows
   */
  deposits(bank) {
    if (this.indexedPosition && this.indexedPosition.lt(_chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, ))) {
      return _chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, );
    }
    return this.balance(bank);
  }
  /**
   *
   * @param bank
   * @returns native borrows, 0 if position has deposits
   */
  borrows(bank) {
    if (this.indexedPosition && this.indexedPosition.gt(_chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, ))) {
      return _chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, );
    }
    return this.balance(bank).abs();
  }
  /**
   * @param bank
   * @returns UI balance, is signed
   */
  balanceUi(bank) {
    return _chunk772SHZWXjs.toUiDecimals.call(void 0, this.balance(bank), bank.mintDecimals);
  }
  /**
   * @param bank
   * @returns UI deposits, 0 if position has borrows
   */
  depositsUi(bank) {
    return _chunk772SHZWXjs.toUiDecimals.call(void 0, this.deposits(bank), bank.mintDecimals);
  }
  /**
   * @param bank
   * @returns UI borrows, 0 if position has deposits
   */
  borrowsUi(bank) {
    return _chunk772SHZWXjs.toUiDecimals.call(void 0, this.borrows(bank), bank.mintDecimals);
  }
  toString(group, index) {
    let extra = "";
    if (group) {
      const bank = group.getFirstBankByTokenIndex(this.tokenIndex);
      if (bank) {
        const native = this.balance(bank);
        extra += ", native: " + native.toNumber();
        extra += ", ui: " + this.balanceUi(bank);
        extra += ", tokenName: " + bank.name;
      }
    }
    return (index !== void 0 ? "index: " + index : "") + ", tokenIndex: " + this.tokenIndex + ", inUseCount: " + this.inUseCount + ", indexedValue: " + this.indexedPosition.toNumber() + extra;
  }
};
var TokenPosition = _TokenPosition;
TokenPosition.TokenIndexUnset = 65535;
var TokenPositionDto = class {
  constructor(indexedPosition, tokenIndex, inUseCount, reserved, previousIndex, cumulativeDepositInterest, cumulativeBorrowInterest) {
    this.indexedPosition = indexedPosition;
    this.tokenIndex = tokenIndex;
    this.inUseCount = inUseCount;
    this.reserved = reserved;
    this.previousIndex = previousIndex;
    this.cumulativeDepositInterest = cumulativeDepositInterest;
    this.cumulativeBorrowInterest = cumulativeBorrowInterest;
  }
};
var _Serum3Orders = class {
  constructor(openOrders, marketIndex, baseTokenIndex, quoteTokenIndex) {
    this.openOrders = openOrders;
    this.marketIndex = marketIndex;
    this.baseTokenIndex = baseTokenIndex;
    this.quoteTokenIndex = quoteTokenIndex;
  }
  static from(dto) {
    return new _Serum3Orders(
      dto.openOrders,
      dto.marketIndex,
      dto.baseTokenIndex,
      dto.quoteTokenIndex
    );
  }
  isActive() {
    return this.marketIndex !== _Serum3Orders.Serum3MarketIndexUnset;
  }
};
var Serum3Orders = _Serum3Orders;
Serum3Orders.Serum3MarketIndexUnset = 65535;
var Serum3PositionDto = class {
  constructor(openOrders, marketIndex, baseBorrowsWithoutFee, quoteBorrowsWithoutFee, baseTokenIndex, quoteTokenIndex, reserved) {
    this.openOrders = openOrders;
    this.marketIndex = marketIndex;
    this.baseBorrowsWithoutFee = baseBorrowsWithoutFee;
    this.quoteBorrowsWithoutFee = quoteBorrowsWithoutFee;
    this.baseTokenIndex = baseTokenIndex;
    this.quoteTokenIndex = quoteTokenIndex;
    this.reserved = reserved;
  }
};
var _PerpPosition = class {
  constructor(marketIndex, settlePnlLimitWindow, settlePnlLimitSettledInCurrentWindowNative, basePositionLots, quotePositionNative, quoteRunningNative, longSettledFunding, shortSettledFunding, bidsBaseLots, asksBaseLots, takerBaseLots, takerQuoteLots, cumulativeLongFunding, cumulativeShortFunding, makerVolume, takerVolume, perpSpotTransfers, avgEntryPricePerBaseLot, realizedTradePnlNative, realizedOtherPnlNative, settlePnlLimitRealizedTrade, realizedPnlForPositionNative) {
    this.marketIndex = marketIndex;
    this.settlePnlLimitWindow = settlePnlLimitWindow;
    this.settlePnlLimitSettledInCurrentWindowNative = settlePnlLimitSettledInCurrentWindowNative;
    this.basePositionLots = basePositionLots;
    this.quotePositionNative = quotePositionNative;
    this.quoteRunningNative = quoteRunningNative;
    this.longSettledFunding = longSettledFunding;
    this.shortSettledFunding = shortSettledFunding;
    this.bidsBaseLots = bidsBaseLots;
    this.asksBaseLots = asksBaseLots;
    this.takerBaseLots = takerBaseLots;
    this.takerQuoteLots = takerQuoteLots;
    this.cumulativeLongFunding = cumulativeLongFunding;
    this.cumulativeShortFunding = cumulativeShortFunding;
    this.makerVolume = makerVolume;
    this.takerVolume = takerVolume;
    this.perpSpotTransfers = perpSpotTransfers;
    this.avgEntryPricePerBaseLot = avgEntryPricePerBaseLot;
    this.realizedTradePnlNative = realizedTradePnlNative;
    this.realizedOtherPnlNative = realizedOtherPnlNative;
    this.settlePnlLimitRealizedTrade = settlePnlLimitRealizedTrade;
    this.realizedPnlForPositionNative = realizedPnlForPositionNative;
  }
  static from(dto) {
    return new _PerpPosition(
      dto.marketIndex,
      dto.settlePnlLimitWindow,
      dto.settlePnlLimitSettledInCurrentWindowNative,
      dto.basePositionLots,
      _chunkS3PQ6OXSjs.I80F48.from(dto.quotePositionNative),
      dto.quoteRunningNative,
      _chunkS3PQ6OXSjs.I80F48.from(dto.longSettledFunding),
      _chunkS3PQ6OXSjs.I80F48.from(dto.shortSettledFunding),
      dto.bidsBaseLots,
      dto.asksBaseLots,
      dto.takerBaseLots,
      dto.takerQuoteLots,
      dto.cumulativeLongFunding,
      dto.cumulativeShortFunding,
      dto.makerVolume,
      dto.takerVolume,
      dto.perpSpotTransfers,
      dto.avgEntryPricePerBaseLot,
      _chunkS3PQ6OXSjs.I80F48.from(dto.realizedTradePnlNative),
      _chunkS3PQ6OXSjs.I80F48.from(dto.realizedOtherPnlNative),
      dto.settlePnlLimitRealizedTrade,
      _chunkS3PQ6OXSjs.I80F48.from(dto.realizedPnlForPositionNative)
    );
  }
  static emptyFromPerpMarketIndex(perpMarketIndex) {
    return new _PerpPosition(
      perpMarketIndex,
      0,
      new (0, _anchor.BN)(0),
      new (0, _anchor.BN)(0),
      _chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, ),
      new (0, _anchor.BN)(0),
      _chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, ),
      _chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, ),
      new (0, _anchor.BN)(0),
      new (0, _anchor.BN)(0),
      new (0, _anchor.BN)(0),
      new (0, _anchor.BN)(0),
      0,
      0,
      new (0, _anchor.BN)(0),
      new (0, _anchor.BN)(0),
      new (0, _anchor.BN)(0),
      0,
      _chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, ),
      _chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, ),
      new (0, _anchor.BN)(0),
      _chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, )
    );
  }
  isActive() {
    return this.marketIndex !== _PerpPosition.PerpMarketIndexUnset;
  }
  getBasePositionNative(perpMarket) {
    return _chunkS3PQ6OXSjs.I80F48.fromI64(this.basePositionLots.mul(perpMarket.baseLotSize));
  }
  getBasePositionUi(perpMarket, useEventQueue) {
    if (perpMarket.perpMarketIndex !== this.marketIndex) {
      throw new Error("PerpPosition doesn't belong to the given market!");
    }
    return perpMarket.baseLotsToUi(
      useEventQueue ? this.basePositionLots.add(this.takerBaseLots) : this.basePositionLots
    );
  }
  getUnsettledFunding(perpMarket) {
    if (perpMarket.perpMarketIndex !== this.marketIndex) {
      throw new Error("PerpPosition doesn't belong to the given market!");
    }
    if (this.basePositionLots.gt(new (0, _anchor.BN)(0))) {
      return perpMarket.longFunding.sub(this.longSettledFunding).mul(_chunkS3PQ6OXSjs.I80F48.fromI64(this.basePositionLots));
    } else if (this.basePositionLots.lt(new (0, _anchor.BN)(0))) {
      return perpMarket.shortFunding.sub(this.shortSettledFunding).mul(_chunkS3PQ6OXSjs.I80F48.fromI64(this.basePositionLots));
    }
    return _chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, );
  }
  getEquityUi(perpMarket) {
    if (perpMarket.perpMarketIndex !== this.marketIndex) {
      throw new Error("PerpPosition doesn't belong to the given market!");
    }
    return _chunk772SHZWXjs.toUiDecimalsForQuote.call(void 0, this.getEquity(perpMarket));
  }
  getEquity(perpMarket) {
    if (perpMarket.perpMarketIndex !== this.marketIndex) {
      throw new Error("PerpPosition doesn't belong to the given market!");
    }
    const lotsToQuote = _chunkS3PQ6OXSjs.I80F48.fromI64(perpMarket.baseLotSize).mul(
      perpMarket.price
    );
    const baseLots = _chunkS3PQ6OXSjs.I80F48.fromI64(
      this.basePositionLots.add(this.takerBaseLots)
    );
    const unsettledFunding = this.getUnsettledFunding(perpMarket);
    const takerQuote = _chunkS3PQ6OXSjs.I80F48.fromI64(
      new (0, _anchor.BN)(this.takerQuoteLots).mul(perpMarket.quoteLotSize)
    );
    const quoteCurrent = this.quotePositionNative.sub(unsettledFunding).add(takerQuote);
    return baseLots.mul(lotsToQuote).add(quoteCurrent);
  }
  hasOpenOrders() {
    const zero = new (0, _anchor.BN)(0);
    return !this.asksBaseLots.eq(zero) || !this.bidsBaseLots.eq(zero) || !this.takerBaseLots.eq(zero) || !this.takerQuoteLots.eq(zero);
  }
  getAverageEntryPrice(perpMarket) {
    return _chunkS3PQ6OXSjs.I80F48.fromNumber(this.avgEntryPricePerBaseLot).div(
      _chunkS3PQ6OXSjs.I80F48.fromI64(perpMarket.baseLotSize)
    );
  }
  getAverageEntryPriceUi(perpMarket) {
    return perpMarket.priceNativeToUi(
      this.getAverageEntryPrice(perpMarket).toNumber()
    );
  }
  getBreakEvenPriceUi(perpMarket) {
    if (perpMarket.perpMarketIndex !== this.marketIndex) {
      throw new Error("PerpPosition doesn't belong to the given market!");
    }
    if (this.basePositionLots.eq(new (0, _anchor.BN)(0))) {
      return 0;
    }
    return perpMarket.priceNativeToUi(
      -this.quoteRunningNative.toNumber() / this.basePositionLots.mul(perpMarket.baseLotSize).toNumber()
    );
  }
  cumulativePnlOverPositionLifetimeUi(perpMarket) {
    if (perpMarket.perpMarketIndex !== this.marketIndex) {
      throw new Error("PerpPosition doesn't belong to the given market!");
    }
    const priceChange = perpMarket.price.sub(
      this.getAverageEntryPrice(perpMarket)
    );
    return _chunk772SHZWXjs.toUiDecimalsForQuote.call(void 0, 
      this.realizedPnlForPositionNative.add(
        this.getBasePositionNative(perpMarket).mul(priceChange)
      )
    );
  }
  getUnsettledPnl(perpMarket) {
    if (perpMarket.perpMarketIndex !== this.marketIndex) {
      throw new Error("PerpPosition doesn't belong to the given market!");
    }
    return this.quotePositionNative.add(
      this.getBasePositionNative(perpMarket).mul(perpMarket.price)
    );
  }
  getUnsettledPnlUi(perpMarket) {
    return _chunk772SHZWXjs.toUiDecimalsForQuote.call(void 0, this.getUnsettledPnl(perpMarket));
  }
  updateSettleLimit(perpMarket) {
    if (perpMarket.perpMarketIndex !== this.marketIndex) {
      throw new Error("PerpPosition doesn't belong to the given market!");
    }
    const windowSize = perpMarket.settlePnlLimitWindowSizeTs;
    const windowStart = new (0, _anchor.BN)(this.settlePnlLimitWindow).mul(windowSize);
    const windowEnd = windowStart.add(windowSize);
    const nowTs = new (0, _anchor.BN)(Date.now() / 1e3);
    const newWindow = nowTs.gte(windowEnd) || nowTs.lt(windowStart);
    if (newWindow) {
      this.settlePnlLimitWindow = nowTs.div(windowSize).toNumber();
      this.settlePnlLimitSettledInCurrentWindowNative = new (0, _anchor.BN)(0);
    }
  }
  availableSettleLimit(perpMarket) {
    if (perpMarket.perpMarketIndex !== this.marketIndex) {
      throw new Error("PerpPosition doesn't belong to the given market!");
    }
    if (perpMarket.settlePnlLimitFactor < 0) {
      return [_chunkS6N5Y2X2js.RUST_I64_MIN.call(void 0, ), _chunkS6N5Y2X2js.RUST_I64_MAX.call(void 0, )];
    }
    const baseNative = _chunkS3PQ6OXSjs.I80F48.fromI64(
      this.basePositionLots.mul(perpMarket.baseLotSize)
    );
    const positionValue = _chunkS3PQ6OXSjs.I80F48.fromNumber(
      perpMarket.stablePriceModel.stablePrice
    ).mul(baseNative).toNumber();
    const unrealized = new (0, _anchor.BN)(perpMarket.settlePnlLimitFactor * positionValue);
    const used = new (0, _anchor.BN)(
      this.settlePnlLimitSettledInCurrentWindowNative.toNumber()
    );
    let minPnl = unrealized.neg().sub(used);
    let maxPnl = unrealized.sub(used);
    const realizedTrade = this.settlePnlLimitRealizedTrade;
    if (realizedTrade.gte(new (0, _anchor.BN)(0))) {
      maxPnl = maxPnl.add(realizedTrade);
    } else {
      minPnl = minPnl.add(realizedTrade);
    }
    const realizedOther = new (0, _anchor.BN)(this.realizedOtherPnlNative.toNumber());
    if (realizedOther.gte(new (0, _anchor.BN)(0))) {
      maxPnl = maxPnl.add(realizedOther);
    } else {
      minPnl = minPnl.add(realizedOther);
    }
    return [_anchor.BN.min(minPnl, new (0, _anchor.BN)(0)), _anchor.BN.max(maxPnl, new (0, _anchor.BN)(0))];
  }
  applyPnlSettleLimit(pnl, perpMarket) {
    if (perpMarket.perpMarketIndex !== this.marketIndex) {
      throw new Error("PerpPosition doesn't belong to the given market!");
    }
    if (perpMarket.settlePnlLimitFactor < 0) {
      return pnl;
    }
    const [minPnl, maxPnl] = this.availableSettleLimit(perpMarket);
    if (pnl.lt(_chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, ))) {
      return pnl.max(_chunkS3PQ6OXSjs.I80F48.fromI64(minPnl));
    } else {
      return pnl.min(_chunkS3PQ6OXSjs.I80F48.fromI64(maxPnl));
    }
  }
  getSettleablePnl(group, perpMarket, account) {
    if (perpMarket.perpMarketIndex !== this.marketIndex) {
      throw new Error("PerpPosition doesn't belong to the given market!");
    }
    this.updateSettleLimit(perpMarket);
    const perpSettleHealth = account.getPerpSettleHealth(group);
    const limitedUnsettled = this.applyPnlSettleLimit(
      this.getUnsettledPnl(perpMarket),
      perpMarket
    );
    if (limitedUnsettled.lt(_chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, ))) {
      return limitedUnsettled.max(perpSettleHealth.max(_chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, )).neg());
    }
    return limitedUnsettled;
  }
  getSettleablePnlUi(group, perpMarket, account) {
    return _chunk772SHZWXjs.toUiDecimalsForQuote.call(void 0, 
      this.getSettleablePnl(group, perpMarket, account)
    );
  }
  canSettlePnl(group, perpMarket, account) {
    return !this.getSettleablePnl(group, perpMarket, account).eq(_chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, ));
  }
  toString(perpMarket) {
    return perpMarket ? "market - " + perpMarket.name + ", basePositionLots - " + perpMarket.baseLotsToUi(this.basePositionLots) + ", quotePositive - " + _chunk772SHZWXjs.toUiDecimalsForQuote.call(void 0, this.quotePositionNative.toNumber()) + ", bidsBaseLots - " + perpMarket.baseLotsToUi(this.bidsBaseLots) + ", asksBaseLots - " + perpMarket.baseLotsToUi(this.asksBaseLots) + ", takerBaseLots - " + perpMarket.baseLotsToUi(this.takerBaseLots) + ", takerQuoteLots - " + perpMarket.quoteLotsToUi(this.takerQuoteLots) + ", unsettled pnl - " + this.getUnsettledPnlUi(perpMarket).toString() : "";
  }
};
var PerpPosition = _PerpPosition;
PerpPosition.PerpMarketIndexUnset = 65535;
var PerpPositionDto = class {
  constructor(marketIndex, settlePnlLimitWindow, settlePnlLimitSettledInCurrentWindowNative, basePositionLots, quotePositionNative, quoteRunningNative, longSettledFunding, shortSettledFunding, bidsBaseLots, asksBaseLots, takerBaseLots, takerQuoteLots, cumulativeLongFunding, cumulativeShortFunding, makerVolume, takerVolume, perpSpotTransfers, avgEntryPricePerBaseLot, realizedTradePnlNative, realizedOtherPnlNative, settlePnlLimitRealizedTrade, realizedPnlForPositionNative) {
    this.marketIndex = marketIndex;
    this.settlePnlLimitWindow = settlePnlLimitWindow;
    this.settlePnlLimitSettledInCurrentWindowNative = settlePnlLimitSettledInCurrentWindowNative;
    this.basePositionLots = basePositionLots;
    this.quotePositionNative = quotePositionNative;
    this.quoteRunningNative = quoteRunningNative;
    this.longSettledFunding = longSettledFunding;
    this.shortSettledFunding = shortSettledFunding;
    this.bidsBaseLots = bidsBaseLots;
    this.asksBaseLots = asksBaseLots;
    this.takerBaseLots = takerBaseLots;
    this.takerQuoteLots = takerQuoteLots;
    this.cumulativeLongFunding = cumulativeLongFunding;
    this.cumulativeShortFunding = cumulativeShortFunding;
    this.makerVolume = makerVolume;
    this.takerVolume = takerVolume;
    this.perpSpotTransfers = perpSpotTransfers;
    this.avgEntryPricePerBaseLot = avgEntryPricePerBaseLot;
    this.realizedTradePnlNative = realizedTradePnlNative;
    this.realizedOtherPnlNative = realizedOtherPnlNative;
    this.settlePnlLimitRealizedTrade = settlePnlLimitRealizedTrade;
    this.realizedPnlForPositionNative = realizedPnlForPositionNative;
  }
};
var _PerpOo = class {
  constructor(sideAndTree, orderMarket, clientId, id) {
    this.sideAndTree = sideAndTree;
    this.orderMarket = orderMarket;
    this.clientId = clientId;
    this.id = id;
  }
  static from(dto) {
    return new _PerpOo(dto.sideAndTree, dto.market, dto.clientId, dto.id);
  }
  isActive() {
    return this.orderMarket !== _PerpOo.OrderMarketUnset;
  }
};
var PerpOo = _PerpOo;
PerpOo.OrderMarketUnset = 65535;
var PerpOoDto = class {
  constructor(sideAndTree, market, clientId, id) {
    this.sideAndTree = sideAndTree;
    this.market = market;
    this.clientId = clientId;
    this.id = id;
  }
};
var HealthType = class {
};
HealthType.maint = { maint: {} };
HealthType.init = { init: {} };
HealthType.liquidationEnd = { liquidationEnd: {} };

// ts/client/src/accounts/healthCache.ts
var HealthCache = class {
  constructor(tokenInfos, serum3Infos, perpInfos) {
    this.tokenInfos = tokenInfos;
    this.serum3Infos = serum3Infos;
    this.perpInfos = perpInfos;
  }
  static fromMangoAccount(group, mangoAccount) {
    const tokenInfos = mangoAccount.tokensActive().map((tokenPosition) => {
      const bank = group.getFirstBankByTokenIndex(tokenPosition.tokenIndex);
      return TokenInfo.fromBank(bank, tokenPosition.balance(bank));
    });
    const serum3Infos = mangoAccount.serum3Active().map((serum3) => {
      const oo = mangoAccount.getSerum3OoAccount(serum3.marketIndex);
      const baseIndex = tokenInfos.findIndex(
        (tokenInfo) => tokenInfo.tokenIndex === serum3.baseTokenIndex
      );
      const baseInfo = tokenInfos[baseIndex];
      if (!baseInfo) {
        throw new Error(
          `BaseInfo not found for market with marketIndex ${serum3.marketIndex}!`
        );
      }
      const quoteIndex = tokenInfos.findIndex(
        (tokenInfo) => tokenInfo.tokenIndex === serum3.quoteTokenIndex
      );
      const quoteInfo = tokenInfos[quoteIndex];
      if (!quoteInfo) {
        throw new Error(
          `QuoteInfo not found for market with marketIndex ${serum3.marketIndex}!`
        );
      }
      return Serum3Info.fromOoModifyingTokenInfos(
        baseIndex,
        baseInfo,
        quoteIndex,
        quoteInfo,
        serum3.marketIndex,
        oo
      );
    });
    const perpInfos = mangoAccount.perpActive().map((perpPosition) => {
      const perpMarket = group.getPerpMarketByMarketIndex(
        perpPosition.marketIndex
      );
      return PerpInfo.fromPerpPosition(perpMarket, perpPosition);
    });
    return new HealthCache(tokenInfos, serum3Infos, perpInfos);
  }
  static fromDto(dto) {
    return new HealthCache(
      dto.tokenInfos.map((dto2) => TokenInfo.fromDto(dto2)),
      dto.serum3Infos.map((dto2) => Serum3Info.fromDto(dto2)),
      dto.perpInfos.map((dto2) => PerpInfo.fromDto(dto2))
    );
  }
  computeSerum3Reservations(healthType) {
    const tokenMaxReserved = new Array(this.tokenInfos.length).fill(null).map((ignored) => _chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, ));
    const serum3Reserved = [];
    for (const info of this.serum3Infos) {
      const quote = this.tokenInfos[info.quoteIndex];
      const base = this.tokenInfos[info.baseIndex];
      const reservedBase = info.reservedBase;
      const reservedQuote = info.reservedQuote;
      const quoteAsset = quote.prices.asset(healthType);
      const baseLiab = base.prices.liab(healthType);
      const allReservedAsBase = reservedBase.add(
        reservedQuote.mul(quoteAsset).div(baseLiab)
      );
      const baseAsset = base.prices.asset(healthType);
      const quoteLiab = quote.prices.liab(healthType);
      const allReservedAsQuote = reservedQuote.add(
        reservedBase.mul(baseAsset).div(quoteLiab)
      );
      const baseMaxReserved = tokenMaxReserved[info.baseIndex];
      baseMaxReserved.iadd(allReservedAsBase);
      const quoteMaxReserved = tokenMaxReserved[info.quoteIndex];
      quoteMaxReserved.iadd(allReservedAsQuote);
      serum3Reserved.push(
        new Serum3Reserved(allReservedAsBase, allReservedAsQuote)
      );
    }
    return {
      tokenMaxReserved,
      serum3Reserved
    };
  }
  health(healthType) {
    const health = _chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, );
    for (const tokenInfo of this.tokenInfos) {
      const contrib = tokenInfo.healthContribution(healthType);
      health.iadd(contrib);
    }
    const res = this.computeSerum3Reservations(healthType);
    for (const [index, serum3Info] of this.serum3Infos.entries()) {
      const contrib = serum3Info.healthContribution(
        healthType,
        this.tokenInfos,
        res.tokenMaxReserved,
        res.serum3Reserved[index]
      );
      health.iadd(contrib);
    }
    for (const perpInfo of this.perpInfos) {
      const contrib = perpInfo.healthContribution(healthType);
      health.iadd(contrib);
    }
    return health;
  }
  // Note: only considers positive perp pnl contributions, see program code for more reasoning
  perpSettleHealth() {
    const health = _chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, );
    for (const tokenInfo of this.tokenInfos) {
      const contrib = tokenInfo.healthContribution(HealthType.maint);
      health.iadd(contrib);
    }
    const res = this.computeSerum3Reservations(HealthType.maint);
    for (const [index, serum3Info] of this.serum3Infos.entries()) {
      const contrib = serum3Info.healthContribution(
        HealthType.maint,
        this.tokenInfos,
        res.tokenMaxReserved,
        res.serum3Reserved[index]
      );
      health.iadd(contrib);
    }
    for (const perpInfo of this.perpInfos) {
      const positiveContrib = perpInfo.healthContribution(HealthType.maint).max(_chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, ));
      health.iadd(positiveContrib);
    }
    return health;
  }
  // An undefined HealthType will use an asset and liab weight of 1
  assets(healthType) {
    const assets = _chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, );
    for (const tokenInfo of this.tokenInfos) {
      const contrib = tokenInfo.healthContribution(healthType);
      if (contrib.isPos()) {
        assets.iadd(contrib);
      }
    }
    const res = this.computeSerum3Reservations(HealthType.maint);
    for (const [index, serum3Info] of this.serum3Infos.entries()) {
      const contrib = serum3Info.healthContribution(
        healthType,
        this.tokenInfos,
        res.tokenMaxReserved,
        res.serum3Reserved[index]
      );
      if (contrib.isPos()) {
        assets.iadd(contrib);
      }
    }
    for (const perpInfo of this.perpInfos) {
      const contrib = perpInfo.healthContribution(healthType);
      if (contrib.isPos()) {
        assets.iadd(contrib);
      }
    }
    return assets;
  }
  // An undefined HealthType will use an asset and liab weight of 1
  liabs(healthType) {
    const liabs = _chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, );
    for (const tokenInfo of this.tokenInfos) {
      const contrib = tokenInfo.healthContribution(healthType);
      if (contrib.isNeg()) {
        liabs.isub(contrib);
      }
    }
    const res = this.computeSerum3Reservations(HealthType.maint);
    for (const [index, serum3Info] of this.serum3Infos.entries()) {
      const contrib = serum3Info.healthContribution(
        healthType,
        this.tokenInfos,
        res.tokenMaxReserved,
        res.serum3Reserved[index]
      );
      if (contrib.isNeg()) {
        liabs.isub(contrib);
      }
    }
    for (const perpInfo of this.perpInfos) {
      const contrib = perpInfo.healthContribution(healthType);
      if (contrib.isNeg()) {
        liabs.isub(contrib);
      }
    }
    return liabs;
  }
  healthRatio(healthType) {
    const assets = _chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, );
    const liabs = _chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, );
    for (const tokenInfo of this.tokenInfos) {
      const contrib = tokenInfo.healthContribution(healthType);
      if (contrib.isPos()) {
        assets.iadd(contrib);
      } else {
        liabs.isub(contrib);
      }
    }
    const res = this.computeSerum3Reservations(HealthType.maint);
    for (const [index, serum3Info] of this.serum3Infos.entries()) {
      const contrib = serum3Info.healthContribution(
        healthType,
        this.tokenInfos,
        res.tokenMaxReserved,
        res.serum3Reserved[index]
      );
      if (contrib.isPos()) {
        assets.iadd(contrib);
      } else {
        liabs.isub(contrib);
      }
    }
    for (const perpInfo of this.perpInfos) {
      const contrib = perpInfo.healthContribution(healthType);
      if (contrib.isPos()) {
        assets.iadd(contrib);
      } else {
        liabs.isub(contrib);
      }
    }
    if (liabs.gt(_chunkS3PQ6OXSjs.I80F48.fromNumber(1e-3))) {
      return _chunkS3PQ6OXSjs.HUNDRED_I80F48.call(void 0, ).mul(assets.sub(liabs).div(liabs));
    } else {
      return _chunkS3PQ6OXSjs.MAX_I80F48.call(void 0, );
    }
  }
  findTokenInfoIndex(tokenIndex) {
    return this.tokenInfos.findIndex(
      (tokenInfo) => tokenInfo.tokenIndex === tokenIndex
    );
  }
  getOrCreateTokenInfoIndex(bank) {
    const index = this.findTokenInfoIndex(bank.tokenIndex);
    if (index == -1) {
      this.tokenInfos.push(TokenInfo.fromBank(bank));
    }
    return this.findTokenInfoIndex(bank.tokenIndex);
  }
  simHealthRatioWithTokenPositionChanges(group, nativeTokenChanges, healthType = HealthType.init) {
    const adjustedCache = _lodash.cloneDeep.call(void 0, this);
    for (const change of nativeTokenChanges) {
      const bank = group.getFirstBankByMint(change.mintPk);
      const changeIndex = adjustedCache.getOrCreateTokenInfoIndex(bank);
      adjustedCache.tokenInfos[changeIndex].balanceNative.iadd(
        change.nativeTokenAmount
      );
    }
    return adjustedCache.healthRatio(healthType);
  }
  findSerum3InfoIndex(marketIndex) {
    return this.serum3Infos.findIndex(
      (serum3Info) => serum3Info.marketIndex === marketIndex
    );
  }
  getOrCreateSerum3InfoIndex(baseBank, quoteBank, serum3Market) {
    const index = this.findSerum3InfoIndex(serum3Market.marketIndex);
    const baseEntryIndex = this.getOrCreateTokenInfoIndex(baseBank);
    const quoteEntryIndex = this.getOrCreateTokenInfoIndex(quoteBank);
    if (index == -1) {
      this.serum3Infos.push(
        Serum3Info.emptyFromSerum3Market(
          serum3Market,
          baseEntryIndex,
          quoteEntryIndex
        )
      );
    }
    return this.findSerum3InfoIndex(serum3Market.marketIndex);
  }
  adjustSerum3Reserved(baseBank, quoteBank, serum3Market, reservedBaseChange, freeBaseChange, reservedQuoteChange, freeQuoteChange) {
    const baseEntryIndex = this.getOrCreateTokenInfoIndex(baseBank);
    const quoteEntryIndex = this.getOrCreateTokenInfoIndex(quoteBank);
    const baseEntry = this.tokenInfos[baseEntryIndex];
    const quoteEntry = this.tokenInfos[quoteEntryIndex];
    baseEntry.balanceNative.iadd(freeBaseChange);
    quoteEntry.balanceNative.iadd(freeQuoteChange);
    const index = this.getOrCreateSerum3InfoIndex(
      baseBank,
      quoteBank,
      serum3Market
    );
    const serum3Info = this.serum3Infos[index];
    serum3Info.reservedBase.iadd(reservedBaseChange);
    serum3Info.reservedQuote.iadd(reservedQuoteChange);
  }
  simHealthRatioWithSerum3BidChanges(baseBank, quoteBank, bidNativeQuoteAmount, serum3Market, healthType = HealthType.init) {
    const adjustedCache = _lodash.cloneDeep.call(void 0, this);
    const quoteIndex = adjustedCache.getOrCreateTokenInfoIndex(quoteBank);
    adjustedCache.tokenInfos[quoteIndex].balanceNative.isub(
      bidNativeQuoteAmount
    );
    adjustedCache.adjustSerum3Reserved(
      baseBank,
      quoteBank,
      serum3Market,
      _chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, ),
      _chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, ),
      bidNativeQuoteAmount,
      _chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, )
    );
    return adjustedCache.healthRatio(healthType);
  }
  simHealthRatioWithSerum3AskChanges(baseBank, quoteBank, askNativeBaseAmount, serum3Market, healthType = HealthType.init) {
    const adjustedCache = _lodash.cloneDeep.call(void 0, this);
    const baseIndex = adjustedCache.getOrCreateTokenInfoIndex(baseBank);
    adjustedCache.tokenInfos[baseIndex].balanceNative.isub(askNativeBaseAmount);
    adjustedCache.adjustSerum3Reserved(
      baseBank,
      quoteBank,
      serum3Market,
      askNativeBaseAmount,
      _chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, ),
      _chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, ),
      _chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, )
    );
    return adjustedCache.healthRatio(healthType);
  }
  findPerpInfoIndex(perpMarketIndex) {
    return this.perpInfos.findIndex(
      (perpInfo) => perpInfo.perpMarketIndex === perpMarketIndex
    );
  }
  getOrCreatePerpInfoIndex(perpMarket) {
    const index = this.findPerpInfoIndex(perpMarket.perpMarketIndex);
    if (index == -1) {
      this.perpInfos.push(PerpInfo.emptyFromPerpMarket(perpMarket));
    }
    return this.findPerpInfoIndex(perpMarket.perpMarketIndex);
  }
  adjustPerpInfo(perpInfoIndex, price, side, newOrderBaseLots) {
    if (side == _chunkZYSI4CYOjs.PerpOrderSide.bid) {
      this.perpInfos[perpInfoIndex].baseLots.iadd(newOrderBaseLots);
      this.perpInfos[perpInfoIndex].quote.isub(
        _chunkS3PQ6OXSjs.I80F48.fromI64(newOrderBaseLots).mul(_chunkS3PQ6OXSjs.I80F48.fromI64(this.perpInfos[perpInfoIndex].baseLotSize)).mul(price)
      );
    } else {
      this.perpInfos[perpInfoIndex].baseLots.isub(newOrderBaseLots);
      this.perpInfos[perpInfoIndex].quote.iadd(
        _chunkS3PQ6OXSjs.I80F48.fromI64(newOrderBaseLots).mul(_chunkS3PQ6OXSjs.I80F48.fromI64(this.perpInfos[perpInfoIndex].baseLotSize)).mul(price)
      );
    }
  }
  simHealthRatioWithPerpOrderChanges(perpMarket, existingPerpPosition, side, baseLots, price, healthType = HealthType.init) {
    const clonedHealthCache = _lodash.cloneDeep.call(void 0, this);
    const perpInfoIndex = clonedHealthCache.getOrCreatePerpInfoIndex(perpMarket);
    clonedHealthCache.adjustPerpInfo(perpInfoIndex, price, side, baseLots);
    return clonedHealthCache.healthRatio(healthType);
  }
  logHealthCache(debug) {
    if (debug)
      console.log(debug);
    for (const token of this.tokenInfos) {
      console.log(` ${token.toString()}`);
    }
    const res = this.computeSerum3Reservations(HealthType.maint);
    for (const [index, serum3Info] of this.serum3Infos.entries()) {
      console.log(
        ` ${serum3Info.toString(
          this.tokenInfos,
          res.tokenMaxReserved,
          res.serum3Reserved[index]
        )}`
      );
    }
    console.log(
      ` assets ${this.assets(HealthType.init)}, liabs ${this.liabs(
        HealthType.init
      )}, `
    );
    console.log(` health(HealthType.init) ${this.health(HealthType.init)}`);
    console.log(
      ` healthRatio(HealthType.init) ${this.healthRatio(HealthType.init)}`
    );
  }
  static scanRightUntilLessThan(start, target, fun) {
    const maxIterations = 20;
    let current = start;
    for (const key of Array(maxIterations).fill(0).keys()) {
      const value = fun(current);
      if (value.lt(target)) {
        return current;
      }
      current = current.max(_chunkS3PQ6OXSjs.ONE_I80F48.call(void 0, )).mul(_chunkS3PQ6OXSjs.I80F48.fromNumber(2));
    }
    throw new Error("Could not find amount that led to health ratio <=0");
  }
  /// This is not a generic function. It assumes there is a unique maximum between left and right.
  static findMaximum(left, right, minStep, fun) {
    const half = _chunkS3PQ6OXSjs.I80F48.fromNumber(0.5);
    let mid = half.mul(left.add(right));
    let leftValue = fun(left);
    let rightValue = fun(right);
    let midValue = fun(mid);
    while (right.sub(left).gt(minStep)) {
      if (leftValue.gte(midValue)) {
        right = mid;
        rightValue = midValue;
        mid = half.mul(left.add(mid));
        midValue = fun(mid);
      } else if (midValue.lte(rightValue)) {
        left = mid;
        leftValue = midValue;
        mid = half.mul(mid.add(right));
        midValue = fun(mid);
      } else {
        const leftmid = half.mul(left.add(mid));
        const leftMidValue = fun(leftmid);
        if (leftMidValue.gte(midValue)) {
          right = mid;
          rightValue = midValue;
          mid = leftmid;
          midValue = leftMidValue;
          continue;
        }
        const rightmid = half.mul(mid.add(right));
        const rightMidValue = fun(rightmid);
        if (rightMidValue.gte(midValue)) {
          left = mid;
          leftValue = midValue;
          mid = rightmid;
          midValue = rightMidValue;
          continue;
        }
        left = leftmid;
        leftValue = leftMidValue;
        right = rightmid;
        rightValue = rightMidValue;
      }
    }
    if (leftValue.gte(midValue)) {
      return [left, leftValue];
    } else if (midValue.gte(rightValue)) {
      return [mid, midValue];
    } else {
      return [right, rightValue];
    }
  }
  static binaryApproximationSearch(left, leftValue, right, targetValue, minStep, fun) {
    const maxIterations = 50;
    const targetError = _chunkS3PQ6OXSjs.I80F48.fromNumber(0.1);
    const rightValue = fun(right);
    if (leftValue.sub(targetValue).isPos() && rightValue.sub(targetValue).isPos() || leftValue.sub(targetValue).isNeg() && rightValue.sub(targetValue).isNeg()) {
      throw new Error(
        `Internal error: left ${leftValue.toNumber()}  and right ${rightValue.toNumber()} don't contain the target value ${targetValue.toNumber()}!`
      );
    }
    let newAmount, newAmountValue;
    for (const key of Array(maxIterations).fill(0).keys()) {
      if (right.sub(left).abs().lt(minStep)) {
        return left;
      }
      newAmount = left.add(right).mul(_chunkS3PQ6OXSjs.I80F48.fromNumber(0.5));
      newAmountValue = fun(newAmount);
      const error = newAmountValue.sub(targetValue);
      if (error.isPos() && error.lt(targetError)) {
        return newAmount;
      }
      if (newAmountValue.gt(targetValue) != rightValue.gt(targetValue)) {
        left = newAmount;
      } else {
        right = newAmount;
      }
    }
    console.error(
      `Unable to get targetValue within ${maxIterations} iterations, newAmount ${newAmount}, newAmountValue ${newAmountValue}, target ${targetValue}`
    );
    return newAmount;
  }
  getMaxSwapSource(sourceBank, targetBank, price) {
    const health = this.health(HealthType.init);
    if (health.isNeg()) {
      return this.getMaxSwapSourceForHealth(
        sourceBank,
        targetBank,
        price,
        _chunk772SHZWXjs.toNativeI80F48ForQuote.call(void 0, 1)
        // target 1 ui usd worth health
      );
    }
    return this.getMaxSwapSourceForHealthRatio(
      sourceBank,
      targetBank,
      price,
      _chunkS3PQ6OXSjs.I80F48.fromNumber(2)
      // target 2% health
    );
  }
  getMaxSwapSourceForHealthRatio(sourceBank, targetBank, price, minRatio) {
    return this.getMaxSwapSourceForHealthFn(
      sourceBank,
      targetBank,
      price,
      minRatio,
      function(hc) {
        return hc.healthRatio(HealthType.init);
      }
    );
  }
  getMaxSwapSourceForHealth(sourceBank, targetBank, price, minHealth) {
    return this.getMaxSwapSourceForHealthFn(
      sourceBank,
      targetBank,
      price,
      minHealth,
      function(hc) {
        return hc.health(HealthType.init);
      }
    );
  }
  getMaxSwapSourceForHealthFn(sourceBank, targetBank, price, minFnValue, targetFn) {
    if (sourceBank.initLiabWeight.sub(targetBank.initAssetWeight).abs().lte(_chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, ))) {
      return _chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, );
    }
    const initialRatio = this.healthRatio(HealthType.init);
    const healthCacheClone = _lodash.cloneDeep.call(void 0, this);
    const sourceIndex = healthCacheClone.getOrCreateTokenInfoIndex(sourceBank);
    const targetIndex = healthCacheClone.getOrCreateTokenInfoIndex(targetBank);
    const source = healthCacheClone.tokenInfos[sourceIndex];
    const target = healthCacheClone.tokenInfos[targetIndex];
    const res = healthCacheClone.computeSerum3Reservations(HealthType.init);
    const sourceReserved = res.tokenMaxReserved[sourceIndex];
    const targetReserved = res.tokenMaxReserved[targetIndex];
    const finalHealthSlope = source.initLiabWeight.neg().mul(source.prices.liab(HealthType.init)).add(
      target.initAssetWeight.mul(target.prices.asset(HealthType.init)).mul(price)
    );
    if (finalHealthSlope.gte(_chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, ))) {
      return _chunkS3PQ6OXSjs.MAX_I80F48.call(void 0, );
    }
    function cacheAfterSwap(amount2) {
      const adjustedCache = _lodash.cloneDeep.call(void 0, healthCacheClone);
      adjustedCache.tokenInfos[sourceIndex].balanceNative.isub(amount2);
      adjustedCache.tokenInfos[targetIndex].balanceNative.iadd(
        amount2.mul(price)
      );
      return adjustedCache;
    }
    function fnValueAfterSwap(amount2) {
      return targetFn(cacheAfterSwap(amount2));
    }
    const rightmost = source.balanceNative.abs().add(sourceReserved).max(target.balanceNative.abs().add(targetReserved).div(price));
    const [amountForMaxValue, maxValue] = HealthCache.findMaximum(
      _chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, ),
      rightmost,
      _chunkS3PQ6OXSjs.I80F48.fromNumber(0.1),
      fnValueAfterSwap
    );
    if (maxValue.lte(minFnValue)) {
      return amountForMaxValue;
    }
    let amount;
    const healthAtMaxValue = cacheAfterSwap(amountForMaxValue).health(
      HealthType.init
    );
    if (healthAtMaxValue.lte(_chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, ))) {
      return _chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, );
    }
    const zeroHealthEstimate = amountForMaxValue.sub(
      healthAtMaxValue.div(finalHealthSlope)
    );
    const rightBound = HealthCache.scanRightUntilLessThan(
      zeroHealthEstimate,
      minFnValue,
      fnValueAfterSwap
    );
    if (rightBound.eq(zeroHealthEstimate)) {
      amount = HealthCache.binaryApproximationSearch(
        amountForMaxValue,
        maxValue,
        rightBound,
        minFnValue,
        _chunkS3PQ6OXSjs.I80F48.fromNumber(0.1),
        fnValueAfterSwap
      );
    } else {
      amount = HealthCache.binaryApproximationSearch(
        zeroHealthEstimate,
        fnValueAfterSwap(zeroHealthEstimate),
        rightBound,
        minFnValue,
        _chunkS3PQ6OXSjs.I80F48.fromNumber(0.1),
        fnValueAfterSwap
      );
    }
    return amount;
  }
  getMaxSerum3OrderForHealthRatio(baseBank, quoteBank, serum3Market, side, minRatio) {
    const healthCacheClone = _lodash.cloneDeep.call(void 0, this);
    const baseIndex = healthCacheClone.getOrCreateTokenInfoIndex(baseBank);
    const quoteIndex = healthCacheClone.getOrCreateTokenInfoIndex(quoteBank);
    const base = healthCacheClone.tokenInfos[baseIndex];
    const quote = healthCacheClone.tokenInfos[quoteIndex];
    const initialAmount = _chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, );
    const initialHealth = this.health(HealthType.init);
    const initialRatio = this.healthRatio(HealthType.init);
    if (initialRatio.lte(_chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, ))) {
      return _chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, );
    }
    let zeroAmount;
    if (side == _chunkUGHO4YHYjs.Serum3Side.ask) {
      const quoteBorrows = quote.balanceNative.lt(_chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, )) ? quote.balanceNative.abs().mul(quote.prices.liab(HealthType.init)) : _chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, );
      const max = base.balanceNative.mul(base.prices.asset(HealthType.init)).max(quoteBorrows);
      zeroAmount = max.add(
        initialHealth.add(max.mul(quote.initLiabWeight.sub(base.initAssetWeight))).div(
          base.liabWeight(HealthType.init).sub(quote.assetWeight(HealthType.init))
        )
      );
    } else {
      const baseBorrows = base.balanceNative.lt(_chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, )) ? base.balanceNative.abs().mul(base.prices.liab(HealthType.init)) : _chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, );
      const max = quote.balanceNative.mul(quote.prices.asset(HealthType.init)).max(baseBorrows);
      zeroAmount = max.add(
        initialHealth.add(max.mul(base.initLiabWeight.sub(quote.initAssetWeight))).div(
          quote.liabWeight(HealthType.init).sub(base.assetWeight(HealthType.init))
        )
      );
    }
    const cache = cacheAfterPlacingOrder(zeroAmount);
    const zeroAmountHealth = cache.health(HealthType.init);
    const zeroAmountRatio = cache.healthRatio(HealthType.init);
    function cacheAfterPlacingOrder(amount2) {
      const adjustedCache = _lodash.cloneDeep.call(void 0, healthCacheClone);
      side === _chunkUGHO4YHYjs.Serum3Side.ask ? adjustedCache.tokenInfos[baseIndex].balanceNative.isub(
        amount2.div(base.prices.oracle)
      ) : adjustedCache.tokenInfos[quoteIndex].balanceNative.isub(
        amount2.div(quote.prices.oracle)
      );
      adjustedCache.adjustSerum3Reserved(
        baseBank,
        quoteBank,
        serum3Market,
        side === _chunkUGHO4YHYjs.Serum3Side.ask ? amount2.div(base.prices.oracle) : _chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, ),
        _chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, ),
        side === _chunkUGHO4YHYjs.Serum3Side.bid ? amount2.div(quote.prices.oracle) : _chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, ),
        _chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, )
      );
      return adjustedCache;
    }
    function healthRatioAfterPlacingOrder(amount2) {
      return cacheAfterPlacingOrder(amount2).healthRatio(HealthType.init);
    }
    const amount = HealthCache.binaryApproximationSearch(
      initialAmount,
      initialRatio,
      zeroAmount,
      minRatio,
      _chunkS3PQ6OXSjs.ONE_I80F48.call(void 0, ),
      healthRatioAfterPlacingOrder
    );
    return amount;
  }
  getMaxPerpForHealthRatio(perpMarket, price, side, minRatio) {
    const healthCacheClone = _lodash.cloneDeep.call(void 0, this);
    const initialRatio = this.healthRatio(HealthType.init);
    if (initialRatio.lt(_chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, ))) {
      return _chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, );
    }
    const direction = side == _chunkZYSI4CYOjs.PerpOrderSide.bid ? 1 : -1;
    const perpInfoIndex = healthCacheClone.getOrCreatePerpInfoIndex(perpMarket);
    const perpInfo = healthCacheClone.perpInfos[perpInfoIndex];
    const prices = perpInfo.prices;
    const baseLotSize = _chunkS3PQ6OXSjs.I80F48.fromI64(perpMarket.baseLotSize);
    const finalHealthSlope = direction == 1 ? perpInfo.initBaseAssetWeight.mul(prices.asset(HealthType.init)).sub(price) : price.sub(
      perpInfo.initBaseLiabWeight.mul(prices.liab(HealthType.init))
    );
    if (finalHealthSlope.gte(_chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, ))) {
      return _chunkS3PQ6OXSjs.MAX_I80F48.call(void 0, );
    }
    function cacheAfterTrade(baseLots2) {
      const adjustedCache = _lodash.cloneDeep.call(void 0, healthCacheClone);
      adjustedCache.adjustPerpInfo(perpInfoIndex, price, side, baseLots2);
      return adjustedCache;
    }
    function healthAfterTrade(baseLots2) {
      return cacheAfterTrade(new (0, _anchor.BN)(baseLots2.toNumber())).health(
        HealthType.init
      );
    }
    function healthRatioAfterTrade(baseLots2) {
      return cacheAfterTrade(new (0, _anchor.BN)(baseLots2.toNumber())).healthRatio(
        HealthType.init
      );
    }
    function healthRatioAfterTradeTrunc(baseLots2) {
      return healthRatioAfterTrade(baseLots2.floor());
    }
    const initialBaseLots = _chunkS3PQ6OXSjs.I80F48.fromU64(perpInfo.baseLots);
    const hasCase2 = initialBaseLots.gt(_chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, )) && direction == -1 || initialBaseLots.lt(_chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, )) && direction == 1;
    let case1Start, case1StartRatio;
    if (hasCase2) {
      case1Start = initialBaseLots.abs();
      case1StartRatio = healthRatioAfterTrade(case1Start);
    } else {
      case1Start = _chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, );
      case1StartRatio = initialRatio;
    }
    let baseLots;
    if (initialRatio.lte(minRatio) && case1StartRatio.lt(minRatio)) {
      if (case1StartRatio.gte(initialRatio)) {
        baseLots = case1Start;
      } else {
        baseLots = _chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, );
      }
    } else if (case1StartRatio.gte(minRatio)) {
      const startCache = cacheAfterTrade(new (0, _anchor.BN)(case1Start.toNumber()));
      const startHealth = startCache.health(HealthType.init);
      if (startHealth.lte(_chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, ))) {
        return _chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, );
      }
      const perpInfo2 = startCache.perpInfos[perpInfoIndex];
      const startHealthUncapped = startHealth.sub(perpInfo2.healthContribution(HealthType.init)).add(perpInfo2.unweightedHealthContribution(HealthType.init));
      const zeroHealthAmount = case1Start.sub(startHealthUncapped.div(finalHealthSlope).div(baseLotSize)).add(_chunkS3PQ6OXSjs.ONE_I80F48.call(void 0, ));
      const zeroHealthRatio = healthRatioAfterTradeTrunc(zeroHealthAmount);
      baseLots = HealthCache.binaryApproximationSearch(
        case1Start,
        case1StartRatio,
        zeroHealthAmount,
        minRatio,
        _chunkS3PQ6OXSjs.ONE_I80F48.call(void 0, ),
        healthRatioAfterTradeTrunc
      );
    } else {
      baseLots = HealthCache.binaryApproximationSearch(
        _chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, ),
        initialRatio,
        case1Start,
        minRatio,
        _chunkS3PQ6OXSjs.ONE_I80F48.call(void 0, ),
        healthRatioAfterTradeTrunc
      );
    }
    return baseLots.floor();
  }
};
var Prices = class {
  constructor(oracle, stable) {
    this.oracle = oracle;
    this.stable = stable;
  }
  liab(healthType) {
    if (healthType === HealthType.maint || healthType === HealthType.liquidationEnd || healthType === void 0) {
      return this.oracle;
    }
    return this.oracle.max(this.stable);
  }
  asset(healthType) {
    if (healthType === HealthType.maint || healthType === HealthType.liquidationEnd || healthType === void 0) {
      return this.oracle;
    }
    return this.oracle.min(this.stable);
  }
};
var TokenInfo = class {
  constructor(tokenIndex, maintAssetWeight, initAssetWeight, initScaledAssetWeight, maintLiabWeight, initLiabWeight, initScaledLiabWeight, prices, balanceNative) {
    this.tokenIndex = tokenIndex;
    this.maintAssetWeight = maintAssetWeight;
    this.initAssetWeight = initAssetWeight;
    this.initScaledAssetWeight = initScaledAssetWeight;
    this.maintLiabWeight = maintLiabWeight;
    this.initLiabWeight = initLiabWeight;
    this.initScaledLiabWeight = initScaledLiabWeight;
    this.prices = prices;
    this.balanceNative = balanceNative;
  }
  static fromDto(dto) {
    return new TokenInfo(
      dto.tokenIndex,
      _chunkS3PQ6OXSjs.I80F48.from(dto.maintAssetWeight),
      _chunkS3PQ6OXSjs.I80F48.from(dto.initAssetWeight),
      _chunkS3PQ6OXSjs.I80F48.from(dto.initScaledAssetWeight),
      _chunkS3PQ6OXSjs.I80F48.from(dto.maintLiabWeight),
      _chunkS3PQ6OXSjs.I80F48.from(dto.initLiabWeight),
      _chunkS3PQ6OXSjs.I80F48.from(dto.initScaledLiabWeight),
      new Prices(
        _chunkS3PQ6OXSjs.I80F48.from(dto.prices.oracle),
        _chunkS3PQ6OXSjs.I80F48.from(dto.prices.stable)
      ),
      _chunkS3PQ6OXSjs.I80F48.from(dto.balanceNative)
    );
  }
  static fromBank(bank, nativeBalance) {
    const p = new Prices(
      bank.price,
      _chunkS3PQ6OXSjs.I80F48.fromNumber(bank.stablePriceModel.stablePrice)
    );
    const liabPrice = p.liab(HealthType.init);
    return new TokenInfo(
      bank.tokenIndex,
      bank.maintAssetWeight,
      bank.initAssetWeight,
      bank.scaledInitAssetWeight(liabPrice),
      bank.maintLiabWeight,
      bank.initLiabWeight,
      bank.scaledInitLiabWeight(liabPrice),
      p,
      nativeBalance ? nativeBalance : _chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, )
    );
  }
  assetWeight(healthType) {
    if (healthType == HealthType.init) {
      return this.initScaledAssetWeight;
    } else if (healthType == HealthType.liquidationEnd) {
      return this.initAssetWeight;
    }
    return this.maintAssetWeight;
  }
  liabWeight(healthType) {
    if (healthType == HealthType.init) {
      return this.initScaledLiabWeight;
    } else if (healthType == HealthType.liquidationEnd) {
      return this.initLiabWeight;
    }
    return this.maintLiabWeight;
  }
  healthContribution(healthType) {
    let weight, price;
    if (healthType === void 0) {
      return this.balanceNative.mul(this.prices.oracle);
    }
    if (this.balanceNative.isNeg()) {
      weight = this.liabWeight(healthType);
      price = this.prices.liab(healthType);
    } else {
      weight = this.assetWeight(healthType);
      price = this.prices.asset(healthType);
    }
    return this.balanceNative.mul(weight).mul(price);
  }
  toString() {
    return `  tokenIndex: ${this.tokenIndex}, balanceNative: ${this.balanceNative}, initHealth ${this.healthContribution(HealthType.init)}`;
  }
};
var Serum3Reserved = class {
  constructor(allReservedAsBase, allReservedAsQuote) {
    this.allReservedAsBase = allReservedAsBase;
    this.allReservedAsQuote = allReservedAsQuote;
  }
};
var Serum3Info = class {
  constructor(reservedBase, reservedQuote, baseIndex, quoteIndex, marketIndex) {
    this.reservedBase = reservedBase;
    this.reservedQuote = reservedQuote;
    this.baseIndex = baseIndex;
    this.quoteIndex = quoteIndex;
    this.marketIndex = marketIndex;
  }
  static fromDto(dto) {
    return new Serum3Info(
      _chunkS3PQ6OXSjs.I80F48.from(dto.reservedBase),
      _chunkS3PQ6OXSjs.I80F48.from(dto.reservedQuote),
      dto.baseIndex,
      dto.quoteIndex,
      dto.marketIndex
    );
  }
  static emptyFromSerum3Market(serum3Market, baseEntryIndex, quoteEntryIndex) {
    return new Serum3Info(
      _chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, ),
      _chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, ),
      baseEntryIndex,
      quoteEntryIndex,
      serum3Market.marketIndex
    );
  }
  static fromOoModifyingTokenInfos(baseIndex, baseInfo, quoteIndex, quoteInfo, marketIndex, oo) {
    const baseFree = _chunkS3PQ6OXSjs.I80F48.fromI64(oo.baseTokenFree);
    const quoteFree = _chunkS3PQ6OXSjs.I80F48.fromI64(
      oo.quoteTokenFree.add(oo.referrerRebatesAccrued)
    );
    baseInfo.balanceNative.iadd(baseFree);
    quoteInfo.balanceNative.iadd(quoteFree);
    const reservedBase = _chunkS3PQ6OXSjs.I80F48.fromI64(
      oo.baseTokenTotal.sub(oo.baseTokenFree)
    );
    const reservedQuote = _chunkS3PQ6OXSjs.I80F48.fromI64(
      oo.quoteTokenTotal.sub(oo.quoteTokenFree)
    );
    return new Serum3Info(
      reservedBase,
      reservedQuote,
      baseIndex,
      quoteIndex,
      marketIndex
    );
  }
  // An undefined HealthType will use an asset and liab weight of 1
  healthContribution(healthType, tokenInfos, tokenMaxReserved, marketReserved) {
    if (marketReserved.allReservedAsBase.isZero() || marketReserved.allReservedAsQuote.isZero()) {
      return _chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, );
    }
    const baseInfo = tokenInfos[this.baseIndex];
    const quoteInfo = tokenInfos[this.quoteIndex];
    const baseMaxReserved = tokenMaxReserved[this.baseIndex];
    const quoteMaxReserved = tokenMaxReserved[this.quoteIndex];
    const computeHealthEffect = function(tokenInfo, tokenMaxReserved2, marketReserved2) {
      const maxBalance = tokenInfo.balanceNative.add(tokenMaxReserved2);
      let assetPart, liabPart;
      if (maxBalance.gte(marketReserved2)) {
        assetPart = marketReserved2;
        liabPart = _chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, );
      } else if (maxBalance.isNeg()) {
        assetPart = _chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, );
        liabPart = marketReserved2;
      } else {
        assetPart = maxBalance;
        liabPart = marketReserved2.sub(maxBalance);
      }
      if (healthType === void 0) {
        return assetPart.mul(tokenInfo.prices.oracle).add(liabPart.mul(tokenInfo.prices.oracle));
      }
      const assetWeight = tokenInfo.assetWeight(healthType);
      const liabWeight = tokenInfo.liabWeight(healthType);
      const assetPrice = tokenInfo.prices.asset(healthType);
      const liabPrice = tokenInfo.prices.liab(healthType);
      return assetWeight.mul(assetPart).mul(assetPrice).add(liabWeight.mul(liabPart).mul(liabPrice));
    };
    const healthBase = computeHealthEffect(
      baseInfo,
      baseMaxReserved,
      marketReserved.allReservedAsBase
    );
    const healthQuote = computeHealthEffect(
      quoteInfo,
      quoteMaxReserved,
      marketReserved.allReservedAsQuote
    );
    return healthBase.min(healthQuote);
  }
  toString(tokenInfos, tokenMaxReserved, marketReserved) {
    return `  marketIndex: ${this.marketIndex}, baseIndex: ${this.baseIndex}, quoteIndex: ${this.quoteIndex}, reservedBase: ${this.reservedBase}, reservedQuote: ${this.reservedQuote}, initHealth ${this.healthContribution(
      HealthType.init,
      tokenInfos,
      tokenMaxReserved,
      marketReserved
    )}`;
  }
};
var PerpInfo = class {
  constructor(perpMarketIndex, maintBaseAssetWeight, initBaseAssetWeight, maintBaseLiabWeight, initBaseLiabWeight, maintOverallAssetWeight, initOverallAssetWeight, baseLotSize, baseLots, bidsBaseLots, asksBaseLots, quote, prices, hasOpenOrders) {
    this.perpMarketIndex = perpMarketIndex;
    this.maintBaseAssetWeight = maintBaseAssetWeight;
    this.initBaseAssetWeight = initBaseAssetWeight;
    this.maintBaseLiabWeight = maintBaseLiabWeight;
    this.initBaseLiabWeight = initBaseLiabWeight;
    this.maintOverallAssetWeight = maintOverallAssetWeight;
    this.initOverallAssetWeight = initOverallAssetWeight;
    this.baseLotSize = baseLotSize;
    this.baseLots = baseLots;
    this.bidsBaseLots = bidsBaseLots;
    this.asksBaseLots = asksBaseLots;
    this.quote = quote;
    this.prices = prices;
    this.hasOpenOrders = hasOpenOrders;
  }
  static fromDto(dto) {
    return new PerpInfo(
      dto.perpMarketIndex,
      _chunkS3PQ6OXSjs.I80F48.from(dto.maintBaseAssetWeight),
      _chunkS3PQ6OXSjs.I80F48.from(dto.initBaseAssetWeight),
      _chunkS3PQ6OXSjs.I80F48.from(dto.maintBaseLiabWeight),
      _chunkS3PQ6OXSjs.I80F48.from(dto.initBaseLiabWeight),
      _chunkS3PQ6OXSjs.I80F48.from(dto.maintOverallAssetWeight),
      _chunkS3PQ6OXSjs.I80F48.from(dto.initOverallAssetWeight),
      dto.baseLotSize,
      dto.baseLots,
      dto.bidsBaseLots,
      dto.asksBaseLots,
      _chunkS3PQ6OXSjs.I80F48.from(dto.quote),
      new Prices(
        _chunkS3PQ6OXSjs.I80F48.from(dto.prices.oracle),
        _chunkS3PQ6OXSjs.I80F48.from(dto.prices.stable)
      ),
      dto.hasOpenOrders
    );
  }
  static fromPerpPosition(perpMarket, perpPosition) {
    const baseLots = perpPosition.basePositionLots.add(
      perpPosition.takerBaseLots
    );
    const unsettledFunding = perpPosition.getUnsettledFunding(perpMarket);
    const takerQuote = _chunkS3PQ6OXSjs.I80F48.fromI64(
      new (0, _anchor.BN)(perpPosition.takerQuoteLots).mul(perpMarket.quoteLotSize)
    );
    const quoteCurrent = perpPosition.quotePositionNative.sub(unsettledFunding).add(takerQuote);
    return new PerpInfo(
      perpMarket.perpMarketIndex,
      perpMarket.maintBaseAssetWeight,
      perpMarket.initBaseAssetWeight,
      perpMarket.maintBaseLiabWeight,
      perpMarket.initBaseLiabWeight,
      perpMarket.maintOverallAssetWeight,
      perpMarket.initOverallAssetWeight,
      perpMarket.baseLotSize,
      baseLots,
      perpPosition.bidsBaseLots,
      perpPosition.asksBaseLots,
      quoteCurrent,
      new Prices(
        perpMarket.price,
        _chunkS3PQ6OXSjs.I80F48.fromNumber(perpMarket.stablePriceModel.stablePrice)
      ),
      perpPosition.hasOpenOrders()
    );
  }
  healthContribution(healthType) {
    const contrib = this.unweightedHealthContribution(healthType);
    if (contrib.gt(_chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, ))) {
      const assetWeight = healthType == HealthType.init || healthType == HealthType.liquidationEnd ? this.initOverallAssetWeight : this.maintOverallAssetWeight;
      return assetWeight.mul(contrib);
    }
    return contrib;
  }
  unweightedHealthContribution(healthType) {
    function orderExecutionCase(pi, ordersBaseLots, orderPrice) {
      const netBaseNative = _chunkS3PQ6OXSjs.I80F48.fromU64(
        pi.baseLots.add(ordersBaseLots).mul(pi.baseLotSize)
      );
      let weight, basePrice;
      if (healthType == HealthType.init || healthType == HealthType.liquidationEnd) {
        if (netBaseNative.isNeg()) {
          weight = pi.initBaseLiabWeight;
        } else {
          weight = pi.initBaseAssetWeight;
        }
      } else {
        if (netBaseNative.isNeg()) {
          weight = pi.maintBaseLiabWeight;
        } else {
          weight = pi.maintBaseAssetWeight;
        }
      }
      if (netBaseNative.isNeg()) {
        basePrice = pi.prices.liab(healthType);
      } else {
        basePrice = pi.prices.asset(healthType);
      }
      const baseHealth = netBaseNative.mul(weight).mul(basePrice);
      const ordersBaseNative = _chunkS3PQ6OXSjs.I80F48.fromU64(
        ordersBaseLots.mul(pi.baseLotSize)
      );
      const orderQuote = ordersBaseNative.neg().mul(orderPrice);
      return baseHealth.add(orderQuote);
    }
    const bidsCase = orderExecutionCase(
      this,
      this.bidsBaseLots,
      this.prices.liab(healthType)
    );
    const asksCase = orderExecutionCase(
      this,
      this.asksBaseLots.neg(),
      this.prices.asset(healthType)
    );
    const worstCase = bidsCase.min(asksCase);
    return this.quote.add(worstCase);
  }
  static emptyFromPerpMarket(perpMarket) {
    return new PerpInfo(
      perpMarket.perpMarketIndex,
      perpMarket.maintBaseAssetWeight,
      perpMarket.initBaseAssetWeight,
      perpMarket.maintBaseLiabWeight,
      perpMarket.initBaseLiabWeight,
      perpMarket.maintOverallAssetWeight,
      perpMarket.initOverallAssetWeight,
      perpMarket.baseLotSize,
      new (0, _anchor.BN)(0),
      new (0, _anchor.BN)(0),
      new (0, _anchor.BN)(0),
      _chunkS3PQ6OXSjs.ZERO_I80F48.call(void 0, ),
      new Prices(
        perpMarket.price,
        _chunkS3PQ6OXSjs.I80F48.fromNumber(perpMarket.stablePriceModel.stablePrice)
      ),
      false
    );
  }
  toString() {
    return `  perpMarketIndex: ${this.perpMarketIndex}, base: ${this.baseLots}, quote: ${this.quote}, oraclePrice: ${this.prices.oracle}, uncapped health contribution ${this.unweightedHealthContribution(
      HealthType.init
    )}`;
  }
};
var HealthCacheDto = class {
};
var TokenInfoDto = class {
  constructor(tokenIndex, maintAssetWeight, initAssetWeight, initScaledAssetWeight, maintLiabWeight, initLiabWeight, initScaledLiabWeight, prices, balanceNative) {
    this.tokenIndex = tokenIndex;
    this.maintAssetWeight = maintAssetWeight;
    this.initAssetWeight = initAssetWeight;
    this.initScaledAssetWeight = initScaledAssetWeight;
    this.maintLiabWeight = maintLiabWeight;
    this.initLiabWeight = initLiabWeight;
    this.initScaledLiabWeight = initScaledLiabWeight;
    this.prices = prices;
    this.balanceNative = balanceNative;
  }
};
var Serum3InfoDto = class {
  constructor(reservedBase, reservedQuote, baseIndex, quoteIndex) {
    this.reservedBase = reservedBase;
    this.reservedQuote = reservedQuote;
    this.baseIndex = baseIndex;
    this.quoteIndex = quoteIndex;
  }
};
var PerpInfoDto = class {
};






















exports.HealthCache = HealthCache; exports.Prices = Prices; exports.TokenInfo = TokenInfo; exports.Serum3Reserved = Serum3Reserved; exports.Serum3Info = Serum3Info; exports.PerpInfo = PerpInfo; exports.HealthCacheDto = HealthCacheDto; exports.TokenInfoDto = TokenInfoDto; exports.Serum3InfoDto = Serum3InfoDto; exports.PerpInfoDto = PerpInfoDto; exports.MangoAccount = MangoAccount; exports.TokenPosition = TokenPosition; exports.TokenPositionDto = TokenPositionDto; exports.Serum3Orders = Serum3Orders; exports.Serum3PositionDto = Serum3PositionDto; exports.PerpPosition = PerpPosition; exports.PerpPositionDto = PerpPositionDto; exports.PerpOo = PerpOo; exports.PerpOoDto = PerpOoDto; exports.HealthType = HealthType;
//# sourceMappingURL=chunk-C3X3GVS5.js.map