{"version":3,"sources":["../ts/client/src/accounts/healthCache.ts","../ts/client/src/accounts/mangoAccount.ts"],"sourcesContent":["import { BN } from '@project-serum/anchor';\nimport { OpenOrders } from '@project-serum/serum';\nimport { PublicKey } from '@solana/web3.js';\nimport { cloneDeep } from 'lodash';\nimport {\n  HUNDRED_I80F48,\n  I80F48,\n  I80F48Dto,\n  MAX_I80F48,\n  ONE_I80F48,\n  ZERO_I80F48,\n} from '../numbers/I80F48';\nimport { toNativeI80F48ForQuote } from '../utils';\nimport { Bank, BankForHealth, TokenIndex } from './bank';\nimport { Group } from './group';\n\nimport { HealthType, MangoAccount, PerpPosition } from './mangoAccount';\nimport { PerpMarket, PerpOrderSide } from './perp';\nimport { MarketIndex, Serum3Market, Serum3Side } from './serum3';\n\n//               ░░░░\n//\n//                                           ██\n//                                         ██░░██\n// ░░          ░░                        ██░░░░░░██                            ░░░░\n//                                     ██░░░░░░░░░░██\n//                                     ██░░░░░░░░░░██\n//                                   ██░░░░░░░░░░░░░░██\n//                                 ██░░░░░░██████░░░░░░██\n//                                 ██░░░░░░██████░░░░░░██\n//                               ██░░░░░░░░██████░░░░░░░░██\n//                               ██░░░░░░░░██████░░░░░░░░██\n//                             ██░░░░░░░░░░██████░░░░░░░░░░██\n//                           ██░░░░░░░░░░░░██████░░░░░░░░░░░░██\n//                           ██░░░░░░░░░░░░██████░░░░░░░░░░░░██\n//                         ██░░░░░░░░░░░░░░██████░░░░░░░░░░░░░░██\n//                         ██░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░██\n//                       ██░░░░░░░░░░░░░░░░██████░░░░░░░░░░░░░░░░██\n//                       ██░░░░░░░░░░░░░░░░██████░░░░░░░░░░░░░░░░██\n//                     ██░░░░░░░░░░░░░░░░░░██████░░░░░░░░░░░░░░░░░░██\n//       ░░            ██░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░██\n//                       ██████████████████████████████████████████\n// warning: this code is copy pasta from rust, keep in sync with health.rs\n\nexport class HealthCache {\n  constructor(\n    public tokenInfos: TokenInfo[],\n    public serum3Infos: Serum3Info[],\n    public perpInfos: PerpInfo[],\n  ) {}\n\n  static fromMangoAccount(\n    group: Group,\n    mangoAccount: MangoAccount,\n  ): HealthCache {\n    // token contribution from token accounts\n    const tokenInfos = mangoAccount.tokensActive().map((tokenPosition) => {\n      const bank = group.getFirstBankByTokenIndex(tokenPosition.tokenIndex);\n      return TokenInfo.fromBank(bank, tokenPosition.balance(bank));\n    });\n\n    // Fill the TokenInfo balance with free funds in serum3 oo accounts, and fill\n    // the serum3MaxReserved with their reserved funds. Also build Serum3Infos.\n    const serum3Infos = mangoAccount.serum3Active().map((serum3) => {\n      const oo = mangoAccount.getSerum3OoAccount(serum3.marketIndex);\n\n      // find the TokenInfos for the market's base and quote tokens\n      const baseIndex = tokenInfos.findIndex(\n        (tokenInfo) => tokenInfo.tokenIndex === serum3.baseTokenIndex,\n      );\n      const baseInfo = tokenInfos[baseIndex];\n      if (!baseInfo) {\n        throw new Error(\n          `BaseInfo not found for market with marketIndex ${serum3.marketIndex}!`,\n        );\n      }\n      const quoteIndex = tokenInfos.findIndex(\n        (tokenInfo) => tokenInfo.tokenIndex === serum3.quoteTokenIndex,\n      );\n      const quoteInfo = tokenInfos[quoteIndex];\n      if (!quoteInfo) {\n        throw new Error(\n          `QuoteInfo not found for market with marketIndex ${serum3.marketIndex}!`,\n        );\n      }\n\n      return Serum3Info.fromOoModifyingTokenInfos(\n        baseIndex,\n        baseInfo,\n        quoteIndex,\n        quoteInfo,\n        serum3.marketIndex,\n        oo,\n      );\n    });\n\n    // health contribution from perp accounts\n    const perpInfos = mangoAccount.perpActive().map((perpPosition) => {\n      const perpMarket = group.getPerpMarketByMarketIndex(\n        perpPosition.marketIndex,\n      );\n      return PerpInfo.fromPerpPosition(perpMarket, perpPosition);\n    });\n\n    return new HealthCache(tokenInfos, serum3Infos, perpInfos);\n  }\n\n  static fromDto(dto): HealthCache {\n    return new HealthCache(\n      dto.tokenInfos.map((dto) => TokenInfo.fromDto(dto)),\n      dto.serum3Infos.map((dto) => Serum3Info.fromDto(dto)),\n      dto.perpInfos.map((dto) => PerpInfo.fromDto(dto)),\n    );\n  }\n\n  computeSerum3Reservations(healthType: HealthType): {\n    tokenMaxReserved: I80F48[];\n    serum3Reserved: Serum3Reserved[];\n  } {\n    // For each token, compute the sum of serum-reserved amounts over all markets.\n    const tokenMaxReserved = new Array(this.tokenInfos.length)\n      .fill(null)\n      .map((ignored) => ZERO_I80F48());\n\n    // For each serum market, compute what happened if reserved_base was converted to quote\n    // or reserved_quote was converted to base.\n    const serum3Reserved: Serum3Reserved[] = [];\n\n    for (const info of this.serum3Infos) {\n      const quote = this.tokenInfos[info.quoteIndex];\n      const base = this.tokenInfos[info.baseIndex];\n\n      const reservedBase = info.reservedBase;\n      const reservedQuote = info.reservedQuote;\n\n      const quoteAsset = quote.prices.asset(healthType);\n      const baseLiab = base.prices.liab(healthType);\n      const allReservedAsBase = reservedBase.add(\n        reservedQuote.mul(quoteAsset).div(baseLiab),\n      );\n      const baseAsset = base.prices.asset(healthType);\n      const quoteLiab = quote.prices.liab(healthType);\n      const allReservedAsQuote = reservedQuote.add(\n        reservedBase.mul(baseAsset).div(quoteLiab),\n      );\n\n      const baseMaxReserved = tokenMaxReserved[info.baseIndex];\n      baseMaxReserved.iadd(allReservedAsBase);\n      const quoteMaxReserved = tokenMaxReserved[info.quoteIndex];\n      quoteMaxReserved.iadd(allReservedAsQuote);\n\n      serum3Reserved.push(\n        new Serum3Reserved(allReservedAsBase, allReservedAsQuote),\n      );\n    }\n\n    return {\n      tokenMaxReserved: tokenMaxReserved,\n      serum3Reserved: serum3Reserved,\n    };\n  }\n\n  public health(healthType: HealthType): I80F48 {\n    const health = ZERO_I80F48();\n    for (const tokenInfo of this.tokenInfos) {\n      const contrib = tokenInfo.healthContribution(healthType);\n      // console.log(` - ti ${contrib}`);\n      health.iadd(contrib);\n    }\n    const res = this.computeSerum3Reservations(healthType);\n    for (const [index, serum3Info] of this.serum3Infos.entries()) {\n      const contrib = serum3Info.healthContribution(\n        healthType,\n        this.tokenInfos,\n        res.tokenMaxReserved,\n        res.serum3Reserved[index],\n      );\n      // console.log(` - si ${contrib}`);\n      health.iadd(contrib);\n    }\n    for (const perpInfo of this.perpInfos) {\n      const contrib = perpInfo.healthContribution(healthType);\n      // console.log(` - pi ${contrib}`);\n      health.iadd(contrib);\n    }\n    return health;\n  }\n\n  // Note: only considers positive perp pnl contributions, see program code for more reasoning\n  public perpSettleHealth(): I80F48 {\n    const health = ZERO_I80F48();\n    for (const tokenInfo of this.tokenInfos) {\n      const contrib = tokenInfo.healthContribution(HealthType.maint);\n      // console.log(` - ti ${contrib}`);\n      health.iadd(contrib);\n    }\n    const res = this.computeSerum3Reservations(HealthType.maint);\n    for (const [index, serum3Info] of this.serum3Infos.entries()) {\n      const contrib = serum3Info.healthContribution(\n        HealthType.maint,\n        this.tokenInfos,\n        res.tokenMaxReserved,\n        res.serum3Reserved[index],\n      );\n      // console.log(` - si ${contrib}`);\n      health.iadd(contrib);\n    }\n    for (const perpInfo of this.perpInfos) {\n      const positiveContrib = perpInfo\n        .healthContribution(HealthType.maint)\n        .max(ZERO_I80F48());\n      // console.log(` - pi ${positiveContrib}`);\n      health.iadd(positiveContrib);\n    }\n    return health;\n  }\n\n  // An undefined HealthType will use an asset and liab weight of 1\n  public assets(healthType?: HealthType): I80F48 {\n    const assets = ZERO_I80F48();\n    for (const tokenInfo of this.tokenInfos) {\n      const contrib = tokenInfo.healthContribution(healthType);\n      if (contrib.isPos()) {\n        assets.iadd(contrib);\n      }\n    }\n    const res = this.computeSerum3Reservations(HealthType.maint);\n    for (const [index, serum3Info] of this.serum3Infos.entries()) {\n      const contrib = serum3Info.healthContribution(\n        healthType,\n        this.tokenInfos,\n        res.tokenMaxReserved,\n        res.serum3Reserved[index],\n      );\n      if (contrib.isPos()) {\n        assets.iadd(contrib);\n      }\n    }\n    for (const perpInfo of this.perpInfos) {\n      const contrib = perpInfo.healthContribution(healthType);\n      if (contrib.isPos()) {\n        assets.iadd(contrib);\n      }\n    }\n    return assets;\n  }\n\n  // An undefined HealthType will use an asset and liab weight of 1\n  public liabs(healthType?: HealthType): I80F48 {\n    const liabs = ZERO_I80F48();\n    for (const tokenInfo of this.tokenInfos) {\n      const contrib = tokenInfo.healthContribution(healthType);\n      if (contrib.isNeg()) {\n        liabs.isub(contrib);\n      }\n    }\n    const res = this.computeSerum3Reservations(HealthType.maint);\n    for (const [index, serum3Info] of this.serum3Infos.entries()) {\n      const contrib = serum3Info.healthContribution(\n        healthType,\n        this.tokenInfos,\n        res.tokenMaxReserved,\n        res.serum3Reserved[index],\n      );\n      if (contrib.isNeg()) {\n        liabs.isub(contrib);\n      }\n    }\n    for (const perpInfo of this.perpInfos) {\n      const contrib = perpInfo.healthContribution(healthType);\n      if (contrib.isNeg()) {\n        liabs.isub(contrib);\n      }\n    }\n    return liabs;\n  }\n\n  public healthRatio(healthType: HealthType): I80F48 {\n    const assets = ZERO_I80F48();\n    const liabs = ZERO_I80F48();\n\n    for (const tokenInfo of this.tokenInfos) {\n      const contrib = tokenInfo.healthContribution(healthType);\n      // console.log(` - ti contrib ${contrib.toLocaleString()}`);\n      if (contrib.isPos()) {\n        assets.iadd(contrib);\n      } else {\n        liabs.isub(contrib);\n      }\n    }\n    const res = this.computeSerum3Reservations(HealthType.maint);\n    for (const [index, serum3Info] of this.serum3Infos.entries()) {\n      const contrib = serum3Info.healthContribution(\n        healthType,\n        this.tokenInfos,\n        res.tokenMaxReserved,\n        res.serum3Reserved[index],\n      );\n      // console.log(` - si contrib ${contrib.toLocaleString()}`);\n      if (contrib.isPos()) {\n        assets.iadd(contrib);\n      } else {\n        liabs.isub(contrib);\n      }\n    }\n    for (const perpInfo of this.perpInfos) {\n      const contrib = perpInfo.healthContribution(healthType);\n      // console.log(` - pi contrib ${contrib.toLocaleString()}`);\n      if (contrib.isPos()) {\n        assets.iadd(contrib);\n      } else {\n        liabs.isub(contrib);\n      }\n    }\n\n    // console.log(\n    //   ` - assets ${assets.toLocaleString()}, liabs ${liabs.toLocaleString()}`,\n    // );\n\n    if (liabs.gt(I80F48.fromNumber(0.001))) {\n      return HUNDRED_I80F48().mul(assets.sub(liabs).div(liabs));\n    } else {\n      return MAX_I80F48();\n    }\n  }\n\n  findTokenInfoIndex(tokenIndex: TokenIndex): number {\n    return this.tokenInfos.findIndex(\n      (tokenInfo) => tokenInfo.tokenIndex === tokenIndex,\n    );\n  }\n\n  getOrCreateTokenInfoIndex(bank: BankForHealth): number {\n    const index = this.findTokenInfoIndex(bank.tokenIndex);\n    if (index == -1) {\n      this.tokenInfos.push(TokenInfo.fromBank(bank));\n    }\n    return this.findTokenInfoIndex(bank.tokenIndex);\n  }\n\n  simHealthRatioWithTokenPositionChanges(\n    group: Group,\n    nativeTokenChanges: {\n      nativeTokenAmount: I80F48;\n      mintPk: PublicKey;\n    }[],\n    healthType: HealthType = HealthType.init,\n  ): I80F48 {\n    const adjustedCache: HealthCache = cloneDeep(this);\n    // HealthCache.logHealthCache('beforeChange', adjustedCache);\n    for (const change of nativeTokenChanges) {\n      const bank: Bank = group.getFirstBankByMint(change.mintPk);\n      const changeIndex = adjustedCache.getOrCreateTokenInfoIndex(bank);\n      // TODO: this will no longer work as easily because of the health weight changes\n      adjustedCache.tokenInfos[changeIndex].balanceNative.iadd(\n        change.nativeTokenAmount,\n      );\n    }\n    // HealthCache.logHealthCache('afterChange', adjustedCache);\n    return adjustedCache.healthRatio(healthType);\n  }\n\n  findSerum3InfoIndex(marketIndex: MarketIndex): number {\n    return this.serum3Infos.findIndex(\n      (serum3Info) => serum3Info.marketIndex === marketIndex,\n    );\n  }\n\n  getOrCreateSerum3InfoIndex(\n    baseBank: BankForHealth,\n    quoteBank: BankForHealth,\n    serum3Market: Serum3Market,\n  ): number {\n    const index = this.findSerum3InfoIndex(serum3Market.marketIndex);\n    const baseEntryIndex = this.getOrCreateTokenInfoIndex(baseBank);\n    const quoteEntryIndex = this.getOrCreateTokenInfoIndex(quoteBank);\n    if (index == -1) {\n      this.serum3Infos.push(\n        Serum3Info.emptyFromSerum3Market(\n          serum3Market,\n          baseEntryIndex,\n          quoteEntryIndex,\n        ),\n      );\n    }\n    return this.findSerum3InfoIndex(serum3Market.marketIndex);\n  }\n\n  adjustSerum3Reserved(\n    baseBank: BankForHealth,\n    quoteBank: BankForHealth,\n    serum3Market: Serum3Market,\n    reservedBaseChange: I80F48,\n    freeBaseChange: I80F48,\n    reservedQuoteChange: I80F48,\n    freeQuoteChange: I80F48,\n  ): void {\n    const baseEntryIndex = this.getOrCreateTokenInfoIndex(baseBank);\n    const quoteEntryIndex = this.getOrCreateTokenInfoIndex(quoteBank);\n\n    const baseEntry = this.tokenInfos[baseEntryIndex];\n    const quoteEntry = this.tokenInfos[quoteEntryIndex];\n\n    // Apply it to the tokens\n    baseEntry.balanceNative.iadd(freeBaseChange);\n    quoteEntry.balanceNative.iadd(freeQuoteChange);\n\n    // Apply it to the serum3 info\n    const index = this.getOrCreateSerum3InfoIndex(\n      baseBank,\n      quoteBank,\n      serum3Market,\n    );\n    const serum3Info = this.serum3Infos[index];\n    serum3Info.reservedBase.iadd(reservedBaseChange);\n    serum3Info.reservedQuote.iadd(reservedQuoteChange);\n  }\n\n  simHealthRatioWithSerum3BidChanges(\n    baseBank: BankForHealth,\n    quoteBank: BankForHealth,\n    bidNativeQuoteAmount: I80F48,\n    serum3Market: Serum3Market,\n    healthType: HealthType = HealthType.init,\n  ): I80F48 {\n    const adjustedCache: HealthCache = cloneDeep(this);\n    const quoteIndex = adjustedCache.getOrCreateTokenInfoIndex(quoteBank);\n\n    // Move token balance to reserved funds in open orders,\n    // essentially simulating a place order\n\n    // Reduce token balance for quote\n    adjustedCache.tokenInfos[quoteIndex].balanceNative.isub(\n      bidNativeQuoteAmount,\n    );\n\n    // Increase reserved in Serum3Info for quote\n    adjustedCache.adjustSerum3Reserved(\n      baseBank,\n      quoteBank,\n      serum3Market,\n      ZERO_I80F48(),\n      ZERO_I80F48(),\n      bidNativeQuoteAmount,\n      ZERO_I80F48(),\n    );\n    return adjustedCache.healthRatio(healthType);\n  }\n\n  simHealthRatioWithSerum3AskChanges(\n    baseBank: BankForHealth,\n    quoteBank: BankForHealth,\n    askNativeBaseAmount: I80F48,\n    serum3Market: Serum3Market,\n    healthType: HealthType = HealthType.init,\n  ): I80F48 {\n    const adjustedCache: HealthCache = cloneDeep(this);\n    const baseIndex = adjustedCache.getOrCreateTokenInfoIndex(baseBank);\n\n    // Move token balance to reserved funds in open orders,\n    // essentially simulating a place order\n\n    // Reduce token balance for base\n    adjustedCache.tokenInfos[baseIndex].balanceNative.isub(askNativeBaseAmount);\n\n    // Increase reserved in Serum3Info for base\n    adjustedCache.adjustSerum3Reserved(\n      baseBank,\n      quoteBank,\n      serum3Market,\n      askNativeBaseAmount,\n      ZERO_I80F48(),\n      ZERO_I80F48(),\n      ZERO_I80F48(),\n    );\n    return adjustedCache.healthRatio(healthType);\n  }\n\n  findPerpInfoIndex(perpMarketIndex: number): number {\n    return this.perpInfos.findIndex(\n      (perpInfo) => perpInfo.perpMarketIndex === perpMarketIndex,\n    );\n  }\n\n  getOrCreatePerpInfoIndex(perpMarket: PerpMarket): number {\n    const index = this.findPerpInfoIndex(perpMarket.perpMarketIndex);\n    if (index == -1) {\n      this.perpInfos.push(PerpInfo.emptyFromPerpMarket(perpMarket));\n    }\n    return this.findPerpInfoIndex(perpMarket.perpMarketIndex);\n  }\n\n  adjustPerpInfo(\n    perpInfoIndex: number,\n    price: I80F48,\n    side: PerpOrderSide,\n    newOrderBaseLots: BN,\n  ): void {\n    if (side == PerpOrderSide.bid) {\n      this.perpInfos[perpInfoIndex].baseLots.iadd(newOrderBaseLots);\n      this.perpInfos[perpInfoIndex].quote.isub(\n        I80F48.fromI64(newOrderBaseLots)\n          .mul(I80F48.fromI64(this.perpInfos[perpInfoIndex].baseLotSize))\n          .mul(price),\n      );\n    } else {\n      this.perpInfos[perpInfoIndex].baseLots.isub(newOrderBaseLots);\n      this.perpInfos[perpInfoIndex].quote.iadd(\n        I80F48.fromI64(newOrderBaseLots)\n          .mul(I80F48.fromI64(this.perpInfos[perpInfoIndex].baseLotSize))\n          .mul(price),\n      );\n    }\n  }\n\n  simHealthRatioWithPerpOrderChanges(\n    perpMarket: PerpMarket,\n    existingPerpPosition: PerpPosition,\n    side: PerpOrderSide,\n    baseLots: BN,\n    price: I80F48,\n    healthType: HealthType = HealthType.init,\n  ): I80F48 {\n    const clonedHealthCache: HealthCache = cloneDeep(this);\n    const perpInfoIndex =\n      clonedHealthCache.getOrCreatePerpInfoIndex(perpMarket);\n    clonedHealthCache.adjustPerpInfo(perpInfoIndex, price, side, baseLots);\n    return clonedHealthCache.healthRatio(healthType);\n  }\n\n  public logHealthCache(debug: string): void {\n    if (debug) console.log(debug);\n    for (const token of this.tokenInfos) {\n      console.log(` ${token.toString()}`);\n    }\n    const res = this.computeSerum3Reservations(HealthType.maint);\n    for (const [index, serum3Info] of this.serum3Infos.entries()) {\n      console.log(\n        ` ${serum3Info.toString(\n          this.tokenInfos,\n          res.tokenMaxReserved,\n          res.serum3Reserved[index],\n        )}`,\n      );\n    }\n    console.log(\n      ` assets ${this.assets(HealthType.init)}, liabs ${this.liabs(\n        HealthType.init,\n      )}, `,\n    );\n    console.log(` health(HealthType.init) ${this.health(HealthType.init)}`);\n    console.log(\n      ` healthRatio(HealthType.init) ${this.healthRatio(HealthType.init)}`,\n    );\n  }\n\n  private static scanRightUntilLessThan(\n    start: I80F48,\n    target: I80F48,\n    fun: (amount: I80F48) => I80F48,\n  ): I80F48 {\n    const maxIterations = 20;\n    let current = start;\n    // console.log(`scanRightUntilLessThan, start ${start.toLocaleString()}`);\n    for (const key of Array(maxIterations).fill(0).keys()) {\n      const value = fun(current);\n      if (value.lt(target)) {\n        return current;\n      }\n      // console.log(\n      //   ` - current ${current.toLocaleString()}, value ${value.toLocaleString()}, target ${target.toLocaleString()}`,\n      // );\n      current = current.max(ONE_I80F48()).mul(I80F48.fromNumber(2));\n    }\n    throw new Error('Could not find amount that led to health ratio <=0');\n  }\n\n  /// This is not a generic function. It assumes there is a unique maximum between left and right.\n  private static findMaximum(\n    left: I80F48,\n    right: I80F48,\n    minStep: I80F48,\n    fun: (I80F48) => I80F48,\n  ): I80F48[] {\n    const half = I80F48.fromNumber(0.5);\n    let mid = half.mul(left.add(right));\n    let leftValue = fun(left);\n    let rightValue = fun(right);\n    let midValue = fun(mid);\n    while (right.sub(left).gt(minStep)) {\n      if (leftValue.gte(midValue)) {\n        // max must be between left and mid\n        right = mid;\n        rightValue = midValue;\n        mid = half.mul(left.add(mid));\n        midValue = fun(mid);\n      } else if (midValue.lte(rightValue)) {\n        // max must be between mid and right\n        left = mid;\n        leftValue = midValue;\n        mid = half.mul(mid.add(right));\n        midValue = fun(mid);\n      } else {\n        // mid is larger than both left and right, max could be on either side\n        const leftmid = half.mul(left.add(mid));\n        const leftMidValue = fun(leftmid);\n        if (leftMidValue.gte(midValue)) {\n          // max between left and mid\n          right = mid;\n          rightValue = midValue;\n          mid = leftmid;\n          midValue = leftMidValue;\n          continue;\n        }\n\n        const rightmid = half.mul(mid.add(right));\n        const rightMidValue = fun(rightmid);\n        if (rightMidValue.gte(midValue)) {\n          // max between mid and right\n          left = mid;\n          leftValue = midValue;\n          mid = rightmid;\n          midValue = rightMidValue;\n          continue;\n        }\n\n        // max between leftmid and rightmid\n        left = leftmid;\n        leftValue = leftMidValue;\n        right = rightmid;\n        rightValue = rightMidValue;\n      }\n    }\n\n    if (leftValue.gte(midValue)) {\n      return [left, leftValue];\n    } else if (midValue.gte(rightValue)) {\n      return [mid, midValue];\n    } else {\n      return [right, rightValue];\n    }\n  }\n\n  private static binaryApproximationSearch(\n    left: I80F48,\n    leftValue: I80F48,\n    right: I80F48,\n    targetValue: I80F48,\n    minStep: I80F48,\n    fun: (I80F48) => I80F48,\n  ): I80F48 {\n    const maxIterations = 50;\n    const targetError = I80F48.fromNumber(0.1);\n    const rightValue = fun(right);\n\n    // console.log(\n    //   ` - binaryApproximationSearch left ${left.toLocaleString()}, leftValue ${leftValue.toLocaleString()}, right ${right.toLocaleString()}, rightValue ${rightValue.toLocaleString()}, targetValue ${targetValue.toLocaleString()}`,\n    // );\n\n    if (\n      (leftValue.sub(targetValue).isPos() &&\n        rightValue.sub(targetValue).isPos()) ||\n      (leftValue.sub(targetValue).isNeg() &&\n        rightValue.sub(targetValue).isNeg())\n    ) {\n      throw new Error(\n        `Internal error: left ${leftValue.toNumber()}  and right ${rightValue.toNumber()} don't contain the target value ${targetValue.toNumber()}!`,\n      );\n    }\n\n    let newAmount, newAmountValue;\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    for (const key of Array(maxIterations).fill(0).keys()) {\n      if (right.sub(left).abs().lt(minStep)) {\n        return left;\n      }\n      newAmount = left.add(right).mul(I80F48.fromNumber(0.5));\n      newAmountValue = fun(newAmount);\n      // console.log(\n      //   `   - left ${left.toLocaleString()}, right ${right.toLocaleString()}, newAmount ${newAmount.toLocaleString()}, newAmountValue ${newAmountValue.toLocaleString()}, targetValue ${targetValue.toLocaleString()}`,\n      // );\n      const error = newAmountValue.sub(targetValue);\n      if (error.isPos() && error.lt(targetError)) {\n        return newAmount;\n      }\n      if (newAmountValue.gt(targetValue) != rightValue.gt(targetValue)) {\n        left = newAmount;\n      } else {\n        right = newAmount;\n      }\n    }\n\n    console.error(\n      `Unable to get targetValue within ${maxIterations} iterations, newAmount ${newAmount}, newAmountValue ${newAmountValue}, target ${targetValue}`,\n    );\n\n    return newAmount;\n  }\n\n  getMaxSwapSource(\n    sourceBank: BankForHealth,\n    targetBank: BankForHealth,\n    price: I80F48,\n  ): I80F48 {\n    const health = this.health(HealthType.init);\n    if (health.isNeg()) {\n      return this.getMaxSwapSourceForHealth(\n        sourceBank,\n        targetBank,\n        price,\n        toNativeI80F48ForQuote(1), // target 1 ui usd worth health\n      );\n    }\n    return this.getMaxSwapSourceForHealthRatio(\n      sourceBank,\n      targetBank,\n      price,\n      I80F48.fromNumber(2), // target 2% health\n    );\n  }\n\n  getMaxSwapSourceForHealthRatio(\n    sourceBank: BankForHealth,\n    targetBank: BankForHealth,\n    price: I80F48,\n    minRatio: I80F48,\n  ): I80F48 {\n    return this.getMaxSwapSourceForHealthFn(\n      sourceBank,\n      targetBank,\n      price,\n      minRatio,\n      function (hc: HealthCache): I80F48 {\n        return hc.healthRatio(HealthType.init);\n      },\n    );\n  }\n\n  getMaxSwapSourceForHealth(\n    sourceBank: BankForHealth,\n    targetBank: BankForHealth,\n    price: I80F48,\n    minHealth: I80F48,\n  ): I80F48 {\n    return this.getMaxSwapSourceForHealthFn(\n      sourceBank,\n      targetBank,\n      price,\n      minHealth,\n      function (hc: HealthCache): I80F48 {\n        return hc.health(HealthType.init);\n      },\n    );\n  }\n\n  getMaxSwapSourceForHealthFn(\n    sourceBank: BankForHealth,\n    targetBank: BankForHealth,\n    price: I80F48,\n    minFnValue: I80F48,\n    targetFn: (cache) => I80F48,\n  ): I80F48 {\n    if (\n      sourceBank.initLiabWeight\n        .sub(targetBank.initAssetWeight)\n        .abs()\n        .lte(ZERO_I80F48())\n    ) {\n      return ZERO_I80F48();\n    }\n\n    // The health and health_ratio are nonlinear based on swap amount.\n    // For large swap amounts the slope is guaranteed to be negative, but small amounts\n    // can have positive slope (e.g. using source deposits to pay back target borrows).\n    //\n    // That means:\n    // - even if the initial value is < minRatio it can be useful to swap to *increase* health\n    // - even if initial value is < 0, swapping can increase health (maybe above 0)\n    // - be careful about finding the minFnValue: the function isn't convex\n\n    const initialRatio = this.healthRatio(HealthType.init);\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n    const healthCacheClone: HealthCache = cloneDeep(this);\n    const sourceIndex = healthCacheClone.getOrCreateTokenInfoIndex(sourceBank);\n    const targetIndex = healthCacheClone.getOrCreateTokenInfoIndex(targetBank);\n\n    const source = healthCacheClone.tokenInfos[sourceIndex];\n    const target = healthCacheClone.tokenInfos[targetIndex];\n\n    const res = healthCacheClone.computeSerum3Reservations(HealthType.init);\n    const sourceReserved = res.tokenMaxReserved[sourceIndex];\n    const targetReserved = res.tokenMaxReserved[targetIndex];\n\n    // If the price is sufficiently good, then health will just increase from swapping:\n    // once we've swapped enough, swapping x reduces health by x * source_liab_weight and\n    // increases it by x * target_asset_weight * price_factor.\n    const finalHealthSlope = source.initLiabWeight\n      .neg()\n      .mul(source.prices.liab(HealthType.init))\n      .add(\n        target.initAssetWeight\n          .mul(target.prices.asset(HealthType.init))\n          .mul(price),\n      );\n\n    if (finalHealthSlope.gte(ZERO_I80F48())) {\n      return MAX_I80F48();\n    }\n\n    // There are two key slope changes: Assume source.balance > 0 and target.balance < 0. Then\n    // initially health ratio goes up. When one of balances flips sign, the health ratio slope\n    // may be positive or negative for a bit, until both balances have flipped and the slope is\n    // negative.\n    // The maximum will be at one of these points (ignoring serum3 effects).\n\n    function cacheAfterSwap(amount: I80F48): HealthCache {\n      const adjustedCache: HealthCache = cloneDeep(healthCacheClone);\n      // adjustedCache.logHealthCache('beforeSwap', adjustedCache);\n      // TODO: make a copy of the bank, apply amount, recompute weights,\n      // and set the new weights on the tokenInfos\n      adjustedCache.tokenInfos[sourceIndex].balanceNative.isub(amount);\n      adjustedCache.tokenInfos[targetIndex].balanceNative.iadd(\n        amount.mul(price),\n      );\n      // adjustedCache.logHealthCache('afterSwap', adjustedCache);\n      return adjustedCache;\n    }\n\n    function fnValueAfterSwap(amount: I80F48): I80F48 {\n      return targetFn(cacheAfterSwap(amount));\n    }\n\n    // The function we're looking at has a unique maximum.\n    //\n    // If we discount serum3 reservations, there are two key slope changes:\n    // Assume source.balance > 0 and target.balance < 0.\n    // When these values flip sign, the health slope decreases, but could still be positive.\n    //\n    // The first thing we do is to find this maximum.\n\n    // The largest amount that the maximum could be at\n    const rightmost = source.balanceNative\n      .abs()\n      .add(sourceReserved)\n      .max(target.balanceNative.abs().add(targetReserved).div(price));\n    const [amountForMaxValue, maxValue] = HealthCache.findMaximum(\n      ZERO_I80F48(),\n      rightmost,\n      I80F48.fromNumber(0.1),\n      fnValueAfterSwap,\n    );\n\n    if (maxValue.lte(minFnValue)) {\n      // We cannot reach min_ratio, just return the max\n      return amountForMaxValue;\n    }\n\n    let amount: I80F48;\n\n    // Now max_value is bigger than minFnValue, the target amount must be >amountForMaxValue.\n    // Search to the right of amountForMaxValue: but how far?\n    // Use a simple estimation for the amount that would lead to zero health:\n    //           health\n    //              - source_liab_weight * source_liab_price * a\n    //              + target_asset_weight * target_asset_price * price * a = 0.\n    // where a is the source token native amount.\n    // Note that this is just an estimate. Swapping can increase the amount that serum3\n    // reserved contributions offset, moving the actual zero point further to the right.\n    const healthAtMaxValue = cacheAfterSwap(amountForMaxValue).health(\n      HealthType.init,\n    );\n    if (healthAtMaxValue.lte(ZERO_I80F48())) {\n      return ZERO_I80F48();\n    }\n    const zeroHealthEstimate = amountForMaxValue.sub(\n      healthAtMaxValue.div(finalHealthSlope),\n    );\n    const rightBound = HealthCache.scanRightUntilLessThan(\n      zeroHealthEstimate,\n      minFnValue,\n      fnValueAfterSwap,\n    );\n    if (rightBound.eq(zeroHealthEstimate)) {\n      amount = HealthCache.binaryApproximationSearch(\n        amountForMaxValue,\n        maxValue,\n        rightBound,\n        minFnValue,\n        I80F48.fromNumber(0.1),\n        fnValueAfterSwap,\n      );\n    } else {\n      // Must be between 0 and point0_amount\n      amount = HealthCache.binaryApproximationSearch(\n        zeroHealthEstimate,\n        fnValueAfterSwap(zeroHealthEstimate),\n        rightBound,\n        minFnValue,\n        I80F48.fromNumber(0.1),\n        fnValueAfterSwap,\n      );\n    }\n\n    return amount;\n  }\n\n  getMaxSerum3OrderForHealthRatio(\n    baseBank: BankForHealth,\n    quoteBank: BankForHealth,\n    serum3Market: Serum3Market,\n    side: Serum3Side,\n    minRatio: I80F48,\n  ): I80F48 {\n    const healthCacheClone: HealthCache = cloneDeep(this);\n\n    const baseIndex = healthCacheClone.getOrCreateTokenInfoIndex(baseBank);\n    const quoteIndex = healthCacheClone.getOrCreateTokenInfoIndex(quoteBank);\n    const base = healthCacheClone.tokenInfos[baseIndex];\n    const quote = healthCacheClone.tokenInfos[quoteIndex];\n\n    // Binary search between current health (0 sized new order) and\n    // an amount to trade which will bring health to 0.\n\n    // Current health and amount i.e. 0\n    const initialAmount = ZERO_I80F48();\n    const initialHealth = this.health(HealthType.init);\n    const initialRatio = this.healthRatio(HealthType.init);\n    if (initialRatio.lte(ZERO_I80F48())) {\n      return ZERO_I80F48();\n    }\n\n    // console.log(`getMaxSerum3OrderForHealthRatio`);\n\n    // Amount which would bring health to 0\n    // where M = max(A_deposits, B_borrows)\n    // amount = M + (init_health + M * (B_init_liab - A_init_asset)) / (A_init_liab - B_init_asset);\n    // A is what we would be essentially swapping for B\n    // So when its an ask, then base->quote,\n    // and when its a bid, then quote->bid\n    let zeroAmount;\n    if (side == Serum3Side.ask) {\n      const quoteBorrows = quote.balanceNative.lt(ZERO_I80F48())\n        ? quote.balanceNative.abs().mul(quote.prices.liab(HealthType.init))\n        : ZERO_I80F48();\n      const max = base.balanceNative\n        .mul(base.prices.asset(HealthType.init))\n        .max(quoteBorrows);\n      zeroAmount = max.add(\n        initialHealth\n          .add(max.mul(quote.initLiabWeight.sub(base.initAssetWeight)))\n          .div(\n            base\n              .liabWeight(HealthType.init)\n              .sub(quote.assetWeight(HealthType.init)),\n          ),\n      );\n      // console.log(` - quoteBorrows ${quoteBorrows.toLocaleString()}`);\n      // console.log(` - max ${max.toLocaleString()}`);\n    } else {\n      const baseBorrows = base.balanceNative.lt(ZERO_I80F48())\n        ? base.balanceNative.abs().mul(base.prices.liab(HealthType.init))\n        : ZERO_I80F48();\n      const max = quote.balanceNative\n        .mul(quote.prices.asset(HealthType.init))\n        .max(baseBorrows);\n      zeroAmount = max.add(\n        initialHealth\n          .add(max.mul(base.initLiabWeight.sub(quote.initAssetWeight)))\n          .div(\n            quote\n              .liabWeight(HealthType.init)\n              .sub(base.assetWeight(HealthType.init)),\n          ),\n      );\n      // console.log(` - baseBorrows ${baseBorrows.toLocaleString()}`);\n      // console.log(` - max ${max.toLocaleString()}`);\n    }\n\n    const cache = cacheAfterPlacingOrder(zeroAmount);\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const zeroAmountHealth = cache.health(HealthType.init);\n    const zeroAmountRatio = cache.healthRatio(HealthType.init);\n\n    // console.log(` - zeroAmount ${zeroAmount.toLocaleString()}`);\n    // console.log(` - zeroAmountHealth ${zeroAmountHealth.toLocaleString()}`);\n    // console.log(` - zeroAmountRatio ${zeroAmountRatio.toLocaleString()}`);\n\n    function cacheAfterPlacingOrder(amount: I80F48): HealthCache {\n      const adjustedCache: HealthCache = cloneDeep(healthCacheClone);\n      // adjustedCache.logHealthCache(` before placing order ${amount}`);\n      // TODO: there should also be some issue with oracle vs stable price here;\n      // probably better to pass in not the quote amount but the base or quote native amount\n      side === Serum3Side.ask\n        ? adjustedCache.tokenInfos[baseIndex].balanceNative.isub(\n            amount.div(base.prices.oracle),\n          )\n        : adjustedCache.tokenInfos[quoteIndex].balanceNative.isub(\n            amount.div(quote.prices.oracle),\n          );\n      adjustedCache.adjustSerum3Reserved(\n        baseBank,\n        quoteBank,\n        serum3Market,\n        side === Serum3Side.ask\n          ? amount.div(base.prices.oracle)\n          : ZERO_I80F48(),\n        ZERO_I80F48(),\n        side === Serum3Side.bid\n          ? amount.div(quote.prices.oracle)\n          : ZERO_I80F48(),\n        ZERO_I80F48(),\n      );\n      // adjustedCache.logHealthCache(' after placing order');\n\n      return adjustedCache;\n    }\n\n    function healthRatioAfterPlacingOrder(amount: I80F48): I80F48 {\n      return cacheAfterPlacingOrder(amount).healthRatio(HealthType.init);\n    }\n\n    const amount = HealthCache.binaryApproximationSearch(\n      initialAmount,\n      initialRatio,\n      zeroAmount,\n      minRatio,\n      ONE_I80F48(),\n      healthRatioAfterPlacingOrder,\n    );\n\n    return amount;\n  }\n\n  getMaxPerpForHealthRatio(\n    perpMarket: PerpMarket,\n    price,\n    side: PerpOrderSide,\n    minRatio: I80F48,\n  ): I80F48 {\n    const healthCacheClone: HealthCache = cloneDeep(this);\n\n    const initialRatio = this.healthRatio(HealthType.init);\n    if (initialRatio.lt(ZERO_I80F48())) {\n      return ZERO_I80F48();\n    }\n\n    const direction = side == PerpOrderSide.bid ? 1 : -1;\n\n    const perpInfoIndex = healthCacheClone.getOrCreatePerpInfoIndex(perpMarket);\n    const perpInfo = healthCacheClone.perpInfos[perpInfoIndex];\n    const prices = perpInfo.prices;\n    const baseLotSize = I80F48.fromI64(perpMarket.baseLotSize);\n\n    // If the price is sufficiently good then health will just increase from trading\n    const finalHealthSlope =\n      direction == 1\n        ? perpInfo.initBaseAssetWeight\n            .mul(prices.asset(HealthType.init))\n            .sub(price)\n        : price.sub(\n            perpInfo.initBaseLiabWeight.mul(prices.liab(HealthType.init)),\n          );\n    if (finalHealthSlope.gte(ZERO_I80F48())) {\n      return MAX_I80F48();\n    }\n\n    function cacheAfterTrade(baseLots: BN): HealthCache {\n      const adjustedCache: HealthCache = cloneDeep(healthCacheClone);\n      // adjustedCache.logHealthCache(' -- before trade');\n      adjustedCache.adjustPerpInfo(perpInfoIndex, price, side, baseLots);\n      // adjustedCache.logHealthCache(' -- after trade');\n      return adjustedCache;\n    }\n\n    function healthAfterTrade(baseLots: I80F48): I80F48 {\n      return cacheAfterTrade(new BN(baseLots.toNumber())).health(\n        HealthType.init,\n      );\n    }\n    function healthRatioAfterTrade(baseLots: I80F48): I80F48 {\n      return cacheAfterTrade(new BN(baseLots.toNumber())).healthRatio(\n        HealthType.init,\n      );\n    }\n    function healthRatioAfterTradeTrunc(baseLots: I80F48): I80F48 {\n      return healthRatioAfterTrade(baseLots.floor());\n    }\n\n    const initialBaseLots = I80F48.fromU64(perpInfo.baseLots);\n\n    // There are two cases:\n    // 1. We are increasing abs(baseLots)\n    // 2. We are bringing the base position to 0, and then going to case 1.\n    const hasCase2 =\n      (initialBaseLots.gt(ZERO_I80F48()) && direction == -1) ||\n      (initialBaseLots.lt(ZERO_I80F48()) && direction == 1);\n\n    let case1Start: I80F48, case1StartRatio: I80F48;\n    if (hasCase2) {\n      case1Start = initialBaseLots.abs();\n      case1StartRatio = healthRatioAfterTrade(case1Start);\n    } else {\n      case1Start = ZERO_I80F48();\n      case1StartRatio = initialRatio;\n    }\n\n    // If we start out below minRatio and can't go above, pick the best case\n    let baseLots: I80F48;\n    if (initialRatio.lte(minRatio) && case1StartRatio.lt(minRatio)) {\n      if (case1StartRatio.gte(initialRatio)) {\n        baseLots = case1Start;\n      } else {\n        baseLots = ZERO_I80F48();\n      }\n    } else if (case1StartRatio.gte(minRatio)) {\n      // Must reach minRatio to the right of case1Start\n\n      // Need to figure out how many lots to trade to reach zero health (zero_health_amount).\n      // We do this by looking at the starting health and the health slope per\n      // traded base lot (finalHealthSlope).\n      const startCache = cacheAfterTrade(new BN(case1Start.toNumber()));\n      const startHealth = startCache.health(HealthType.init);\n      if (startHealth.lte(ZERO_I80F48())) {\n        return ZERO_I80F48();\n      }\n\n      // The perp market's contribution to the health above may be capped. But we need to trade\n      // enough to fully reduce any positive-pnl buffer. Thus get the uncapped health:\n      const perpInfo = startCache.perpInfos[perpInfoIndex];\n      const startHealthUncapped = startHealth\n        .sub(perpInfo.healthContribution(HealthType.init))\n        .add(perpInfo.unweightedHealthContribution(HealthType.init));\n\n      const zeroHealthAmount = case1Start\n        .sub(startHealthUncapped.div(finalHealthSlope).div(baseLotSize))\n        .add(ONE_I80F48());\n      const zeroHealthRatio = healthRatioAfterTradeTrunc(zeroHealthAmount);\n\n      baseLots = HealthCache.binaryApproximationSearch(\n        case1Start,\n        case1StartRatio,\n        zeroHealthAmount,\n        minRatio,\n        ONE_I80F48(),\n        healthRatioAfterTradeTrunc,\n      );\n    } else {\n      // Between 0 and case1Start\n      baseLots = HealthCache.binaryApproximationSearch(\n        ZERO_I80F48(),\n        initialRatio,\n        case1Start,\n        minRatio,\n        ONE_I80F48(),\n        healthRatioAfterTradeTrunc,\n      );\n    }\n\n    return baseLots.floor();\n  }\n}\n\nexport class Prices {\n  constructor(public oracle: I80F48, public stable: I80F48) {}\n\n  public liab(healthType: HealthType | undefined): I80F48 {\n    if (\n      healthType === HealthType.maint ||\n      healthType === HealthType.liquidationEnd ||\n      healthType === undefined\n    ) {\n      return this.oracle;\n    }\n    return this.oracle.max(this.stable);\n  }\n\n  public asset(healthType: HealthType | undefined): I80F48 {\n    if (\n      healthType === HealthType.maint ||\n      healthType === HealthType.liquidationEnd ||\n      healthType === undefined\n    ) {\n      return this.oracle;\n    }\n    return this.oracle.min(this.stable);\n  }\n}\n\nexport class TokenInfo {\n  constructor(\n    public tokenIndex: TokenIndex,\n    public maintAssetWeight: I80F48,\n    public initAssetWeight: I80F48,\n    public initScaledAssetWeight: I80F48,\n    public maintLiabWeight: I80F48,\n    public initLiabWeight: I80F48,\n    public initScaledLiabWeight: I80F48,\n    public prices: Prices,\n    public balanceNative: I80F48,\n  ) {}\n\n  static fromDto(dto: TokenInfoDto): TokenInfo {\n    return new TokenInfo(\n      dto.tokenIndex as TokenIndex,\n      I80F48.from(dto.maintAssetWeight),\n      I80F48.from(dto.initAssetWeight),\n      I80F48.from(dto.initScaledAssetWeight),\n      I80F48.from(dto.maintLiabWeight),\n      I80F48.from(dto.initLiabWeight),\n      I80F48.from(dto.initScaledLiabWeight),\n      new Prices(\n        I80F48.from(dto.prices.oracle),\n        I80F48.from(dto.prices.stable),\n      ),\n      I80F48.from(dto.balanceNative),\n    );\n  }\n\n  static fromBank(bank: BankForHealth, nativeBalance?: I80F48): TokenInfo {\n    const p = new Prices(\n      bank.price,\n      I80F48.fromNumber(bank.stablePriceModel.stablePrice),\n    );\n    // Use the liab price for computing weight scaling, because it's pessimistic and\n    // causes the most unfavorable scaling.\n    const liabPrice = p.liab(HealthType.init);\n    return new TokenInfo(\n      bank.tokenIndex,\n      bank.maintAssetWeight,\n      bank.initAssetWeight,\n      bank.scaledInitAssetWeight(liabPrice),\n      bank.maintLiabWeight,\n      bank.initLiabWeight,\n      bank.scaledInitLiabWeight(liabPrice),\n      p,\n      nativeBalance ? nativeBalance : ZERO_I80F48(),\n    );\n  }\n\n  assetWeight(healthType: HealthType): I80F48 {\n    if (healthType == HealthType.init) {\n      return this.initScaledAssetWeight;\n    } else if (healthType == HealthType.liquidationEnd) {\n      return this.initAssetWeight;\n    }\n    // healthType == HealthType.maint\n    return this.maintAssetWeight;\n  }\n\n  liabWeight(healthType: HealthType): I80F48 {\n    if (healthType == HealthType.init) {\n      return this.initScaledLiabWeight;\n    } else if (healthType == HealthType.liquidationEnd) {\n      return this.initLiabWeight;\n    }\n    // healthType == HealthType.maint\n    return this.maintLiabWeight;\n  }\n\n  healthContribution(healthType?: HealthType): I80F48 {\n    let weight, price;\n    if (healthType === undefined) {\n      return this.balanceNative.mul(this.prices.oracle);\n    }\n    if (this.balanceNative.isNeg()) {\n      weight = this.liabWeight(healthType);\n      price = this.prices.liab(healthType);\n    } else {\n      weight = this.assetWeight(healthType);\n      price = this.prices.asset(healthType);\n    }\n    return this.balanceNative.mul(weight).mul(price);\n  }\n\n  toString(): string {\n    return `  tokenIndex: ${this.tokenIndex}, balanceNative: ${\n      this.balanceNative\n    }, initHealth ${this.healthContribution(HealthType.init)}`;\n  }\n}\n\nexport class Serum3Reserved {\n  constructor(\n    public allReservedAsBase: I80F48,\n    public allReservedAsQuote: I80F48,\n  ) {}\n}\n\nexport class Serum3Info {\n  constructor(\n    public reservedBase: I80F48,\n    public reservedQuote: I80F48,\n    public baseIndex: number,\n    public quoteIndex: number,\n    public marketIndex: MarketIndex,\n  ) {}\n\n  static fromDto(dto: Serum3InfoDto): Serum3Info {\n    return new Serum3Info(\n      I80F48.from(dto.reservedBase),\n      I80F48.from(dto.reservedQuote),\n      dto.baseIndex,\n      dto.quoteIndex,\n      dto.marketIndex as MarketIndex,\n    );\n  }\n\n  static emptyFromSerum3Market(\n    serum3Market: Serum3Market,\n    baseEntryIndex: number,\n    quoteEntryIndex: number,\n  ): Serum3Info {\n    return new Serum3Info(\n      ZERO_I80F48(),\n      ZERO_I80F48(),\n      baseEntryIndex,\n      quoteEntryIndex,\n      serum3Market.marketIndex,\n    );\n  }\n\n  static fromOoModifyingTokenInfos(\n    baseIndex: number,\n    baseInfo: TokenInfo,\n    quoteIndex: number,\n    quoteInfo: TokenInfo,\n    marketIndex: MarketIndex,\n    oo: OpenOrders,\n  ): Serum3Info {\n    // add the amounts that are freely settleable immediately to token balances\n    const baseFree = I80F48.fromI64(oo.baseTokenFree);\n    // NOTE: referrerRebatesAccrued is not declared on oo class, but the layout\n    // is aware of it\n    const quoteFree = I80F48.fromI64(\n      oo.quoteTokenFree.add((oo as any).referrerRebatesAccrued),\n    );\n    baseInfo.balanceNative.iadd(baseFree);\n    quoteInfo.balanceNative.iadd(quoteFree);\n\n    // track the reserved amounts\n    const reservedBase = I80F48.fromI64(\n      oo.baseTokenTotal.sub(oo.baseTokenFree),\n    );\n    const reservedQuote = I80F48.fromI64(\n      oo.quoteTokenTotal.sub(oo.quoteTokenFree),\n    );\n\n    return new Serum3Info(\n      reservedBase,\n      reservedQuote,\n      baseIndex,\n      quoteIndex,\n      marketIndex,\n    );\n  }\n\n  // An undefined HealthType will use an asset and liab weight of 1\n  healthContribution(\n    healthType: HealthType | undefined,\n    tokenInfos: TokenInfo[],\n    tokenMaxReserved: I80F48[],\n    marketReserved: Serum3Reserved,\n  ): I80F48 {\n    if (\n      marketReserved.allReservedAsBase.isZero() ||\n      marketReserved.allReservedAsQuote.isZero()\n    ) {\n      return ZERO_I80F48();\n    }\n\n    const baseInfo = tokenInfos[this.baseIndex];\n    const quoteInfo = tokenInfos[this.quoteIndex];\n    const baseMaxReserved = tokenMaxReserved[this.baseIndex];\n    const quoteMaxReserved = tokenMaxReserved[this.quoteIndex];\n\n    // How much the health would increase if the reserved balance were applied to the passed\n    // token info?\n    const computeHealthEffect = function (\n      tokenInfo: TokenInfo,\n      tokenMaxReserved: I80F48,\n      marketReserved: I80F48,\n    ): I80F48 {\n      // This balance includes all possible reserved funds from markets that relate to the\n      // token, including this market itself: `tokenMaxReserved` is already included in `maxBalance`.\n      const maxBalance = tokenInfo.balanceNative.add(tokenMaxReserved);\n\n      // Assuming `reserved` was added to `max_balance` last (because that gives the smallest\n      // health effects): how much did health change because of it?\n      let assetPart, liabPart;\n      if (maxBalance.gte(marketReserved)) {\n        assetPart = marketReserved;\n        liabPart = ZERO_I80F48();\n      } else if (maxBalance.isNeg()) {\n        assetPart = ZERO_I80F48();\n        liabPart = marketReserved;\n      } else {\n        assetPart = maxBalance;\n        liabPart = marketReserved.sub(maxBalance);\n      }\n\n      if (healthType === undefined) {\n        return assetPart\n          .mul(tokenInfo.prices.oracle)\n          .add(liabPart.mul(tokenInfo.prices.oracle));\n      }\n\n      const assetWeight = tokenInfo.assetWeight(healthType);\n      const liabWeight = tokenInfo.liabWeight(healthType);\n      const assetPrice = tokenInfo.prices.asset(healthType);\n      const liabPrice = tokenInfo.prices.liab(healthType);\n\n      return assetWeight\n        .mul(assetPart)\n        .mul(assetPrice)\n        .add(liabWeight.mul(liabPart).mul(liabPrice));\n    };\n\n    const healthBase = computeHealthEffect(\n      baseInfo,\n      baseMaxReserved,\n      marketReserved.allReservedAsBase,\n    );\n    const healthQuote = computeHealthEffect(\n      quoteInfo,\n      quoteMaxReserved,\n      marketReserved.allReservedAsQuote,\n    );\n\n    // console.log(` - healthBase ${healthBase.toLocaleString()}`);\n    // console.log(` - healthQuote ${healthQuote.toLocaleString()}`);\n\n    return healthBase.min(healthQuote);\n  }\n\n  toString(\n    tokenInfos: TokenInfo[],\n    tokenMaxReserved: I80F48[],\n    marketReserved: Serum3Reserved,\n  ): string {\n    return `  marketIndex: ${this.marketIndex}, baseIndex: ${\n      this.baseIndex\n    }, quoteIndex: ${this.quoteIndex}, reservedBase: ${\n      this.reservedBase\n    }, reservedQuote: ${\n      this.reservedQuote\n    }, initHealth ${this.healthContribution(\n      HealthType.init,\n      tokenInfos,\n      tokenMaxReserved,\n      marketReserved,\n    )}`;\n  }\n}\n\nexport class PerpInfo {\n  constructor(\n    public perpMarketIndex: number,\n    public maintBaseAssetWeight: I80F48,\n    public initBaseAssetWeight: I80F48,\n    public maintBaseLiabWeight: I80F48,\n    public initBaseLiabWeight: I80F48,\n    public maintOverallAssetWeight: I80F48,\n    public initOverallAssetWeight: I80F48,\n    public baseLotSize: BN,\n    public baseLots: BN,\n    public bidsBaseLots: BN,\n    public asksBaseLots: BN,\n    public quote: I80F48,\n    public prices: Prices,\n    public hasOpenOrders: boolean,\n  ) {}\n\n  static fromDto(dto: PerpInfoDto): PerpInfo {\n    return new PerpInfo(\n      dto.perpMarketIndex,\n      I80F48.from(dto.maintBaseAssetWeight),\n      I80F48.from(dto.initBaseAssetWeight),\n      I80F48.from(dto.maintBaseLiabWeight),\n      I80F48.from(dto.initBaseLiabWeight),\n      I80F48.from(dto.maintOverallAssetWeight),\n      I80F48.from(dto.initOverallAssetWeight),\n      dto.baseLotSize,\n      dto.baseLots,\n      dto.bidsBaseLots,\n      dto.asksBaseLots,\n      I80F48.from(dto.quote),\n      new Prices(\n        I80F48.from(dto.prices.oracle),\n        I80F48.from(dto.prices.stable),\n      ),\n      dto.hasOpenOrders,\n    );\n  }\n\n  static fromPerpPosition(\n    perpMarket: PerpMarket,\n    perpPosition: PerpPosition,\n  ): PerpInfo {\n    const baseLots = perpPosition.basePositionLots.add(\n      perpPosition.takerBaseLots,\n    );\n    const unsettledFunding = perpPosition.getUnsettledFunding(perpMarket);\n\n    const takerQuote = I80F48.fromI64(\n      new BN(perpPosition.takerQuoteLots).mul(perpMarket.quoteLotSize),\n    );\n    const quoteCurrent = perpPosition.quotePositionNative\n      .sub(unsettledFunding)\n      .add(takerQuote);\n\n    return new PerpInfo(\n      perpMarket.perpMarketIndex,\n      perpMarket.maintBaseAssetWeight,\n      perpMarket.initBaseAssetWeight,\n      perpMarket.maintBaseLiabWeight,\n      perpMarket.initBaseLiabWeight,\n      perpMarket.maintOverallAssetWeight,\n      perpMarket.initOverallAssetWeight,\n      perpMarket.baseLotSize,\n      baseLots,\n      perpPosition.bidsBaseLots,\n      perpPosition.asksBaseLots,\n      quoteCurrent,\n      new Prices(\n        perpMarket.price,\n        I80F48.fromNumber(perpMarket.stablePriceModel.stablePrice),\n      ),\n      perpPosition.hasOpenOrders(),\n    );\n  }\n\n  healthContribution(healthType: HealthType | undefined): I80F48 {\n    const contrib = this.unweightedHealthContribution(healthType);\n    if (contrib.gt(ZERO_I80F48())) {\n      const assetWeight =\n        healthType == HealthType.init || healthType == HealthType.liquidationEnd\n          ? this.initOverallAssetWeight\n          : this.maintOverallAssetWeight;\n      return assetWeight.mul(contrib);\n    }\n    return contrib;\n  }\n\n  unweightedHealthContribution(healthType: HealthType | undefined): I80F48 {\n    function orderExecutionCase(\n      pi: PerpInfo,\n      ordersBaseLots: BN,\n      orderPrice: I80F48,\n    ): I80F48 {\n      const netBaseNative = I80F48.fromU64(\n        pi.baseLots.add(ordersBaseLots).mul(pi.baseLotSize),\n      );\n\n      let weight, basePrice;\n      if (\n        healthType == HealthType.init ||\n        healthType == HealthType.liquidationEnd\n      ) {\n        if (netBaseNative.isNeg()) {\n          weight = pi.initBaseLiabWeight;\n        } else {\n          weight = pi.initBaseAssetWeight;\n        }\n      }\n      // healthType == HealthType.maint\n      else {\n        if (netBaseNative.isNeg()) {\n          weight = pi.maintBaseLiabWeight;\n        } else {\n          weight = pi.maintBaseAssetWeight;\n        }\n      }\n\n      if (netBaseNative.isNeg()) {\n        basePrice = pi.prices.liab(healthType);\n      } else {\n        basePrice = pi.prices.asset(healthType);\n      }\n\n      // Total value of the order-execution adjusted base position\n      const baseHealth = netBaseNative.mul(weight).mul(basePrice);\n\n      const ordersBaseNative = I80F48.fromU64(\n        ordersBaseLots.mul(pi.baseLotSize),\n      );\n      // The quote change from executing the bids/asks\n      const orderQuote = ordersBaseNative.neg().mul(orderPrice);\n\n      return baseHealth.add(orderQuote);\n    }\n\n    // What is worse: Executing all bids at oracle_price.liab, or executing all asks at oracle_price.asset?\n    const bidsCase = orderExecutionCase(\n      this,\n      this.bidsBaseLots,\n      this.prices.liab(healthType),\n    );\n    const asksCase = orderExecutionCase(\n      this,\n      this.asksBaseLots.neg(),\n      this.prices.asset(healthType),\n    );\n    const worstCase = bidsCase.min(asksCase);\n\n    return this.quote.add(worstCase);\n  }\n\n  static emptyFromPerpMarket(perpMarket: PerpMarket): PerpInfo {\n    return new PerpInfo(\n      perpMarket.perpMarketIndex,\n      perpMarket.maintBaseAssetWeight,\n      perpMarket.initBaseAssetWeight,\n      perpMarket.maintBaseLiabWeight,\n      perpMarket.initBaseLiabWeight,\n      perpMarket.maintOverallAssetWeight,\n      perpMarket.initOverallAssetWeight,\n      perpMarket.baseLotSize,\n      new BN(0),\n      new BN(0),\n      new BN(0),\n      ZERO_I80F48(),\n      new Prices(\n        perpMarket.price,\n        I80F48.fromNumber(perpMarket.stablePriceModel.stablePrice),\n      ),\n      false,\n    );\n  }\n\n  toString(): string {\n    return `  perpMarketIndex: ${this.perpMarketIndex}, base: ${\n      this.baseLots\n    }, quote: ${this.quote}, oraclePrice: ${\n      this.prices.oracle\n    }, uncapped health contribution ${this.unweightedHealthContribution(\n      HealthType.init,\n    )}`;\n  }\n}\n\nexport class HealthCacheDto {\n  tokenInfos: TokenInfoDto[];\n  serum3Infos: Serum3InfoDto[];\n  perpInfos: PerpInfoDto[];\n}\nexport class TokenInfoDto {\n  tokenIndex: number;\n  maintAssetWeight: I80F48Dto;\n  initAssetWeight: I80F48Dto;\n  initScaledAssetWeight: I80F48Dto;\n  maintLiabWeight: I80F48Dto;\n  initLiabWeight: I80F48Dto;\n  initScaledLiabWeight: I80F48Dto;\n  prices: { oracle: I80F48Dto; stable: I80F48Dto };\n  balanceNative: I80F48Dto;\n\n  constructor(\n    tokenIndex: number,\n    maintAssetWeight: I80F48Dto,\n    initAssetWeight: I80F48Dto,\n    initScaledAssetWeight: I80F48Dto,\n    maintLiabWeight: I80F48Dto,\n    initLiabWeight: I80F48Dto,\n    initScaledLiabWeight: I80F48Dto,\n    prices: { oracle: I80F48Dto; stable: I80F48Dto },\n    balanceNative: I80F48Dto,\n  ) {\n    this.tokenIndex = tokenIndex;\n    this.maintAssetWeight = maintAssetWeight;\n    this.initAssetWeight = initAssetWeight;\n    this.initScaledAssetWeight = initScaledAssetWeight;\n    this.maintLiabWeight = maintLiabWeight;\n    this.initLiabWeight = initLiabWeight;\n    this.initScaledLiabWeight = initScaledLiabWeight;\n    this.prices = prices;\n    this.balanceNative = balanceNative;\n  }\n}\n\nexport class Serum3InfoDto {\n  reservedBase: I80F48Dto;\n  reservedQuote: I80F48Dto;\n  baseIndex: number;\n  quoteIndex: number;\n  marketIndex: number;\n\n  constructor(\n    reservedBase: I80F48Dto,\n    reservedQuote: I80F48Dto,\n    baseIndex: number,\n    quoteIndex: number,\n  ) {\n    this.reservedBase = reservedBase;\n    this.reservedQuote = reservedQuote;\n    this.baseIndex = baseIndex;\n    this.quoteIndex = quoteIndex;\n  }\n}\n\nexport class PerpInfoDto {\n  perpMarketIndex: number;\n  maintBaseAssetWeight: I80F48Dto;\n  initBaseAssetWeight: I80F48Dto;\n  maintBaseLiabWeight: I80F48Dto;\n  initBaseLiabWeight: I80F48Dto;\n  maintOverallAssetWeight: I80F48Dto;\n  initOverallAssetWeight: I80F48Dto;\n  public baseLotSize: BN;\n  public baseLots: BN;\n  public bidsBaseLots: BN;\n  public asksBaseLots: BN;\n  quote: I80F48Dto;\n  prices: { oracle: I80F48Dto; stable: I80F48Dto };\n  hasOpenOrders: boolean;\n}\n","import { AnchorProvider, BN } from '@project-serum/anchor';\nimport { utf8 } from '@project-serum/anchor/dist/cjs/utils/bytes';\nimport { OpenOrders, Order, Orderbook } from '@project-serum/serum/lib/market';\nimport { AccountInfo, PublicKey, TransactionSignature } from '@solana/web3.js';\nimport { MangoClient } from '../client';\nimport { OPENBOOK_PROGRAM_ID, RUST_I64_MAX, RUST_I64_MIN } from '../constants';\nimport { I80F48, I80F48Dto, ONE_I80F48, ZERO_I80F48 } from '../numbers/I80F48';\nimport { toNativeI80F48, toUiDecimals, toUiDecimalsForQuote } from '../utils';\nimport { Bank, TokenIndex } from './bank';\nimport { Group } from './group';\nimport { HealthCache } from './healthCache';\nimport { PerpMarket, PerpMarketIndex, PerpOrder, PerpOrderSide } from './perp';\nimport { MarketIndex, Serum3Side } from './serum3';\nexport class MangoAccount {\n  public name: string;\n  public tokens: TokenPosition[];\n  public serum3: Serum3Orders[];\n  public perps: PerpPosition[];\n  public perpOpenOrders: PerpOo[];\n\n  static from(\n    publicKey: PublicKey,\n    obj: {\n      group: PublicKey;\n      owner: PublicKey;\n      name: number[];\n      delegate: PublicKey;\n      accountNum: number;\n      beingLiquidated: number;\n      inHealthRegion: number;\n      netDeposits: BN;\n      perpSpotTransfers: BN;\n      healthRegionBeginInitHealth: BN;\n      frozenUntil: BN;\n      headerVersion: number;\n      tokens: unknown;\n      serum3: unknown;\n      perps: unknown;\n      perpOpenOrders: unknown;\n    },\n  ): MangoAccount {\n    return new MangoAccount(\n      publicKey,\n      obj.group,\n      obj.owner,\n      obj.name,\n      obj.delegate,\n      obj.accountNum,\n      obj.beingLiquidated == 1,\n      obj.inHealthRegion == 1,\n      obj.netDeposits,\n      obj.perpSpotTransfers,\n      obj.healthRegionBeginInitHealth,\n      obj.frozenUntil,\n      obj.headerVersion,\n      obj.tokens as TokenPositionDto[],\n      obj.serum3 as Serum3PositionDto[],\n      obj.perps as PerpPositionDto[],\n      obj.perpOpenOrders as PerpOoDto[],\n      new Map(), // serum3OosMapByMarketIndex\n    );\n  }\n\n  constructor(\n    public publicKey: PublicKey,\n    public group: PublicKey,\n    public owner: PublicKey,\n    name: number[],\n    public delegate: PublicKey,\n    public accountNum: number,\n    public beingLiquidated: boolean,\n    public inHealthRegion: boolean,\n    public netDeposits: BN,\n    public perpSpotTransfers: BN,\n    public healthRegionBeginInitHealth: BN,\n    public frozenUntil: BN,\n    public headerVersion: number,\n    tokens: TokenPositionDto[],\n    serum3: Serum3PositionDto[],\n    perps: PerpPositionDto[],\n    perpOpenOrders: PerpOoDto[],\n    public serum3OosMapByMarketIndex: Map<number, OpenOrders>,\n  ) {\n    this.name = utf8.decode(new Uint8Array(name)).split('\\x00')[0];\n    this.tokens = tokens.map((dto) => TokenPosition.from(dto));\n    this.serum3 = serum3.map((dto) => Serum3Orders.from(dto));\n    this.perps = perps.map((dto) => PerpPosition.from(dto));\n    this.perpOpenOrders = perpOpenOrders.map((dto) => PerpOo.from(dto));\n  }\n\n  public async reload(client: MangoClient): Promise<MangoAccount> {\n    const mangoAccount = await client.getMangoAccount(this);\n    await mangoAccount.reloadSerum3OpenOrders(client);\n    Object.assign(this, mangoAccount);\n    return mangoAccount;\n  }\n\n  public async reloadWithSlot(\n    client: MangoClient,\n  ): Promise<{ value: MangoAccount; slot: number }> {\n    const resp = await client.getMangoAccountWithSlot(this.publicKey);\n    await resp?.value.reloadSerum3OpenOrders(client);\n    Object.assign(this, resp?.value);\n    return { value: resp!.value, slot: resp!.slot };\n  }\n\n  async reloadSerum3OpenOrders(client: MangoClient): Promise<MangoAccount> {\n    const serum3Active = this.serum3Active();\n    const ais =\n      await client.program.provider.connection.getMultipleAccountsInfo(\n        serum3Active.map((serum3) => serum3.openOrders),\n      );\n    this.serum3OosMapByMarketIndex = new Map(\n      Array.from(\n        ais.map((ai, i) => {\n          if (!ai) {\n            throw new Error(\n              `Undefined AI for open orders ${serum3Active[i].openOrders} and market ${serum3Active[i].marketIndex}!`,\n            );\n          }\n          const oo = OpenOrders.fromAccountInfo(\n            serum3Active[i].openOrders,\n            ai,\n            OPENBOOK_PROGRAM_ID[client.cluster],\n          );\n          return [serum3Active[i].marketIndex, oo];\n        }),\n      ),\n    );\n\n    return this;\n  }\n\n  public isDelegate(client: MangoClient): boolean {\n    return this.delegate.equals(\n      (client.program.provider as AnchorProvider).wallet.publicKey,\n    );\n  }\n\n  public isOperational(): boolean {\n    return this.frozenUntil.lt(new BN(Date.now() / 1000));\n  }\n\n  public tokensActive(): TokenPosition[] {\n    return this.tokens.filter((token) => token.isActive());\n  }\n\n  public serum3Active(): Serum3Orders[] {\n    return this.serum3.filter((serum3) => serum3.isActive());\n  }\n\n  public perpPositionExistsForMarket(perpMarket: PerpMarket): boolean {\n    return this.perps.some(\n      (pp) => pp.isActive() && pp.marketIndex == perpMarket.perpMarketIndex,\n    );\n  }\n\n  public perpOrderExistsForMarket(perpMarket: PerpMarket): boolean {\n    return this.perpOpenOrders.some(\n      (poo) => poo.isActive() && poo.orderMarket == perpMarket.perpMarketIndex,\n    );\n  }\n\n  public perpActive(): PerpPosition[] {\n    return this.perps.filter((perp) => perp.isActive());\n  }\n\n  public perpOrdersActive(): PerpOo[] {\n    return this.perpOpenOrders.filter(\n      (oo) => oo.orderMarket !== PerpOo.OrderMarketUnset,\n    );\n  }\n\n  public getToken(tokenIndex: TokenIndex): TokenPosition | undefined {\n    return this.tokens.find((ta) => ta.tokenIndex == tokenIndex);\n  }\n\n  public getSerum3Account(marketIndex: MarketIndex): Serum3Orders | undefined {\n    return this.serum3.find((sa) => sa.marketIndex == marketIndex);\n  }\n\n  public getPerpPosition(\n    perpMarketIndex: PerpMarketIndex,\n  ): PerpPosition | undefined {\n    return this.perps.find((pp) => pp.marketIndex == perpMarketIndex);\n  }\n\n  public getPerpPositionUi(\n    group: Group,\n    perpMarketIndex: PerpMarketIndex,\n    useEventQueue?: boolean,\n  ): number {\n    const pp = this.perps.find((pp) => pp.marketIndex == perpMarketIndex);\n    if (!pp) {\n      throw new Error(`No position found for PerpMarket ${perpMarketIndex}!`);\n    }\n    const perpMarket = group.getPerpMarketByMarketIndex(perpMarketIndex);\n    return pp.getBasePositionUi(perpMarket, useEventQueue);\n  }\n\n  public getSerum3OoAccount(marketIndex: MarketIndex): OpenOrders {\n    const oo: OpenOrders | undefined =\n      this.serum3OosMapByMarketIndex.get(marketIndex);\n\n    if (!oo) {\n      throw new Error(\n        `Open orders account not loaded for market with marketIndex ${marketIndex}!`,\n      );\n    }\n    return oo;\n  }\n\n  // How to navigate\n  // * if a function is returning a I80F48, then usually the return value is in native quote or native token, unless specified\n  // * if a function is returning a number, then usually the return value is in ui tokens, unless specified\n  // * functions try to be explicit by having native or ui in the name to better reflect the value\n  // * some values might appear unexpected large or small, usually the doc contains a \"note\"\n\n  /**\n   *\n   * @param bank\n   * @returns native balance for a token, is signed\n   */\n  public getTokenBalance(bank: Bank): I80F48 {\n    const tp = this.getToken(bank.tokenIndex);\n    return tp ? tp.balance(bank) : ZERO_I80F48();\n  }\n\n  /**\n   *\n   * @param bank\n   * @returns native deposits for a token, 0 if position has borrows\n   */\n  public getTokenDeposits(bank: Bank): I80F48 {\n    const tp = this.getToken(bank.tokenIndex);\n    return tp ? tp.deposits(bank) : ZERO_I80F48();\n  }\n\n  /**\n   *\n   * @param bank\n   * @returns native borrows for a token, 0 if position has deposits\n   */\n  public getTokenBorrows(bank: Bank): I80F48 {\n    const tp = this.getToken(bank.tokenIndex);\n    return tp ? tp.borrows(bank) : ZERO_I80F48();\n  }\n\n  /**\n   *\n   * @param bank\n   * @returns UI balance for a token, is signed\n   */\n  public getTokenBalanceUi(bank: Bank): number {\n    const tp = this.getToken(bank.tokenIndex);\n    return tp ? tp.balanceUi(bank) : 0;\n  }\n\n  /**\n   *\n   * @param bank\n   * @returns UI deposits for a token, 0 or more\n   */\n  public getTokenDepositsUi(bank: Bank): number {\n    const ta = this.getToken(bank.tokenIndex);\n    return ta ? ta.depositsUi(bank) : 0;\n  }\n\n  /**\n   *\n   * @param bank\n   * @returns UI borrows for a token, 0 or less\n   */\n  public getTokenBorrowsUi(bank: Bank): number {\n    const ta = this.getToken(bank.tokenIndex);\n    return ta ? ta.borrowsUi(bank) : 0;\n  }\n\n  /**\n   * Health, see health.rs or https://docs.mango.markets/mango-markets/health-overview\n   * @param healthType\n   * @returns raw health number, in native quote\n   */\n  public getHealth(group: Group, healthType: HealthType): I80F48 {\n    const hc = HealthCache.fromMangoAccount(group, this);\n    return hc.health(healthType);\n  }\n\n  public getPerpSettleHealth(group: Group): I80F48 {\n    const hc = HealthCache.fromMangoAccount(group, this);\n    return hc.perpSettleHealth();\n  }\n\n  /**\n   * Health ratio, which is computed so `100 * (assets-liabs)/liabs`\n   * Note: health ratio is technically ∞ if liabs are 0\n   * @param healthType\n   * @returns health ratio, in percentage form\n   */\n  public getHealthRatio(group: Group, healthType: HealthType): I80F48 {\n    const hc = HealthCache.fromMangoAccount(group, this);\n    return hc.healthRatio(healthType);\n  }\n\n  /**\n   * Health ratio\n   * @param healthType\n   * @returns health ratio, in percentage form, capped to 100\n   */\n  public getHealthRatioUi(group: Group, healthType: HealthType): number {\n    const ratio = this.getHealthRatio(group, healthType).toNumber();\n    return ratio > 100 ? 100 : Math.trunc(ratio);\n  }\n\n  /**\n   * Sum of all the assets i.e. token deposits, borrows, total assets in spot open orders, and perps positions.\n   * @returns equity, in native quote\n   */\n  public getEquity(group: Group): I80F48 {\n    const tokensMap = new Map<number, I80F48>();\n    for (const tp of this.tokensActive()) {\n      const bank = group.getFirstBankByTokenIndex(tp.tokenIndex);\n      tokensMap.set(tp.tokenIndex, tp.balance(bank).mul(bank.price));\n    }\n\n    for (const sp of this.serum3Active()) {\n      const oo = this.getSerum3OoAccount(sp.marketIndex);\n      const baseBank = group.getFirstBankByTokenIndex(sp.baseTokenIndex);\n      tokensMap\n        .get(baseBank.tokenIndex)!\n        .iadd(I80F48.fromI64(oo.baseTokenTotal).mul(baseBank.price));\n      const quoteBank = group.getFirstBankByTokenIndex(sp.quoteTokenIndex);\n      // NOTE: referrerRebatesAccrued is not declared on oo class, but the layout\n      // is aware of it\n      tokensMap\n        .get(baseBank.tokenIndex)!\n        .iadd(\n          I80F48.fromI64(\n            oo.quoteTokenTotal.add((oo as any).referrerRebatesAccrued),\n          ).mul(quoteBank.price),\n        );\n    }\n\n    const tokenEquity = Array.from(tokensMap.values()).reduce(\n      (a, b) => a.add(b),\n      ZERO_I80F48(),\n    );\n\n    const perpEquity = this.perpActive().reduce(\n      (a, b) =>\n        a.add(b.getEquity(group.getPerpMarketByMarketIndex(b.marketIndex))),\n      ZERO_I80F48(),\n    );\n\n    return tokenEquity.add(perpEquity);\n  }\n\n  /**\n   * The amount of native quote you could withdraw against your existing assets.\n   * @returns collateral value, in native quote\n   */\n  public getCollateralValue(group: Group): I80F48 {\n    return this.getHealth(group, HealthType.init);\n  }\n\n  /**\n   * Sum of all positive assets.\n   * @returns assets, in native quote\n   */\n  public getAssetsValue(group: Group, healthType?: HealthType): I80F48 {\n    const hc = HealthCache.fromMangoAccount(group, this);\n    return hc.assets(healthType);\n  }\n\n  /**\n   * Sum of all negative assets.\n   * @returns liabs, in native quote\n   */\n  public getLiabsValue(group: Group, healthType?: HealthType): I80F48 {\n    const hc = HealthCache.fromMangoAccount(group, this);\n    return hc.liabs(healthType);\n  }\n\n  /**\n   * @returns Overall PNL, in native quote\n   * PNL is defined here as spot value + serum3 open orders value + perp value - net deposits value (evaluated at native quote price at the time of the deposit/withdraw)\n   * spot value + serum3 open orders value + perp value is returned by getEquity (open orders values are added to spot token values implicitly)\n   */\n  public getPnl(group: Group): I80F48 {\n    return this.getEquity(group)?.add(\n      I80F48.fromI64(this.netDeposits).mul(I80F48.fromNumber(-1)),\n    );\n  }\n\n  /**\n   * @returns token cumulative interest, in native token units. Sum of deposit and borrow interest.\n   * Caveat: This will only return cumulative interest since the tokenPosition was last opened.\n   * If the tokenPosition was closed and reopened multiple times it is necessary to add this result to\n   * cumulative interest at each of the prior tokenPosition closings (from mango API) to get the all time\n   * cumulative interest.\n   */\n  getCumulativeInterest(bank: Bank): number {\n    const token = this.getToken(bank.tokenIndex);\n\n    if (token === undefined) {\n      // tokenPosition does not exist on mangoAccount so no cumulative interest\n      return 0;\n    } else {\n      if (token.indexedPosition.isPos()) {\n        const interest = bank.depositIndex\n          .sub(token.previousIndex)\n          .mul(token.indexedPosition)\n          .toNumber();\n        return (\n          interest +\n          token.cumulativeDepositInterest +\n          token.cumulativeBorrowInterest\n        );\n      } else {\n        const interest = bank.borrowIndex\n          .sub(token.previousIndex)\n          .mul(token.indexedPosition)\n          .toNumber();\n        return (\n          interest +\n          token.cumulativeDepositInterest +\n          token.cumulativeBorrowInterest\n        );\n      }\n    }\n  }\n\n  /**\n   * The amount of given native token you can withdraw including borrows, considering all existing assets as collateral.\n   * @returns amount of given native token you can borrow, considering all existing assets as collateral, in native token\n   *\n   * TODO: take into account net_borrow_limit and min_vault_to_deposits_ratio\n   */\n  public getMaxWithdrawWithBorrowForToken(\n    group: Group,\n    mintPk: PublicKey,\n  ): I80F48 {\n    const tokenBank: Bank = group.getFirstBankByMint(mintPk);\n    const initHealth = this.getHealth(group, HealthType.init);\n\n    // Case 1:\n    // Cannot withdraw if init health is below 0\n    if (initHealth.lte(ZERO_I80F48())) {\n      return ZERO_I80F48();\n    }\n\n    // Deposits need special treatment since they would neither count towards liabilities\n    // nor would be charged loanOriginationFeeRate when withdrawn\n\n    const tp = this.getToken(tokenBank.tokenIndex);\n    const existingTokenDeposits = tp ? tp.deposits(tokenBank) : ZERO_I80F48();\n    let existingPositionHealthContrib = ZERO_I80F48();\n    if (existingTokenDeposits.gt(ZERO_I80F48())) {\n      existingPositionHealthContrib = existingTokenDeposits\n        .mul(tokenBank.price)\n        .imul(tokenBank.initAssetWeight);\n    }\n\n    // Case 2: token deposits have higher contribution than initHealth,\n    // can withdraw without borrowing until initHealth reaches 0\n    if (existingPositionHealthContrib.gt(initHealth)) {\n      const withdrawAbleExistingPositionHealthContrib = initHealth;\n      return withdrawAbleExistingPositionHealthContrib\n        .div(tokenBank.initAssetWeight)\n        .div(tokenBank.price);\n    }\n\n    // Case 3: withdraw = withdraw existing deposits + borrows until initHealth reaches 0\n    const initHealthWithoutExistingPosition = initHealth.sub(\n      existingPositionHealthContrib,\n    );\n    let maxBorrowNative = initHealthWithoutExistingPosition\n      .div(tokenBank.initLiabWeight)\n      .div(tokenBank.price);\n\n    // Cap maxBorrow to maintain minVaultToDepositsRatio on the bank\n    const vaultAmount = group.vaultAmountsMap.get(tokenBank.vault.toBase58());\n    if (!vaultAmount) {\n      throw new Error(\n        `No vault amount found for ${tokenBank.name} vault ${tokenBank.vault}!`,\n      );\n    }\n    const vaultAmountAfterWithdrawingDeposits = I80F48.fromU64(vaultAmount).sub(\n      existingTokenDeposits,\n    );\n    const expectedVaultMinAmount = tokenBank\n      .nativeDeposits()\n      .mul(I80F48.fromNumber(tokenBank.minVaultToDepositsRatio));\n    if (vaultAmountAfterWithdrawingDeposits.gt(expectedVaultMinAmount)) {\n      maxBorrowNative = maxBorrowNative.min(\n        vaultAmountAfterWithdrawingDeposits.sub(expectedVaultMinAmount),\n      );\n    }\n\n    const maxBorrowNativeWithoutFees = maxBorrowNative.div(\n      ONE_I80F48().add(tokenBank.loanOriginationFeeRate),\n    );\n\n    return maxBorrowNativeWithoutFees.add(existingTokenDeposits);\n  }\n\n  public getMaxWithdrawWithBorrowForTokenUi(\n    group: Group,\n    mintPk: PublicKey,\n  ): number {\n    const maxWithdrawWithBorrow = this.getMaxWithdrawWithBorrowForToken(\n      group,\n      mintPk,\n    );\n    return toUiDecimals(maxWithdrawWithBorrow, group.getMintDecimals(mintPk));\n  }\n\n  /**\n   * The max amount of given source ui token you can swap to a target token.\n   * @returns max amount of given source ui token you can swap to a target token, in ui token\n   */\n  getMaxSourceUiForTokenSwap(\n    group: Group,\n    sourceMintPk: PublicKey,\n    targetMintPk: PublicKey,\n    slippageAndFeesFactor = 1,\n  ): number {\n    if (sourceMintPk.equals(targetMintPk)) {\n      return 0;\n    }\n    const sourceBank = group.getFirstBankByMint(sourceMintPk);\n    const targetBank = group.getFirstBankByMint(targetMintPk);\n    const hc = HealthCache.fromMangoAccount(group, this);\n    let maxSource = hc.getMaxSwapSource(\n      sourceBank,\n      targetBank,\n      I80F48.fromNumber(\n        slippageAndFeesFactor *\n          ((sourceBank.uiPrice / targetBank.uiPrice) *\n            Math.pow(10, targetBank.mintDecimals - sourceBank.mintDecimals)),\n      ),\n    );\n    const sourceBalance = this.getTokenBalance(sourceBank);\n    if (maxSource.gt(sourceBalance)) {\n      const sourceBorrow = maxSource.sub(sourceBalance);\n      maxSource = sourceBalance.add(\n        sourceBorrow.div(ONE_I80F48().add(sourceBank.loanOriginationFeeRate)),\n      );\n    }\n    return toUiDecimals(maxSource, group.getMintDecimals(sourceMintPk));\n  }\n\n  /**\n   * Simulates new health ratio after applying tokenChanges to the token positions.\n   * Note: token changes are expected in ui amounts\n   *\n   * e.g. useful to simulate health after a potential swap.\n   * Note: health ratio is technically ∞ if liabs are 0\n   * @returns health ratio, in percentage form\n   */\n  public simHealthRatioWithTokenPositionUiChanges(\n    group: Group,\n    uiTokenChanges: {\n      uiTokenAmount: number;\n      mintPk: PublicKey;\n    }[],\n    healthType: HealthType = HealthType.init,\n  ): number {\n    const nativeTokenChanges = uiTokenChanges.map((tokenChange) => {\n      return {\n        nativeTokenAmount: toNativeI80F48(\n          tokenChange.uiTokenAmount,\n          group.getMintDecimals(tokenChange.mintPk),\n        ),\n        mintPk: tokenChange.mintPk,\n      };\n    });\n    const hc = HealthCache.fromMangoAccount(group, this);\n    return hc\n      .simHealthRatioWithTokenPositionChanges(\n        group,\n        nativeTokenChanges,\n        healthType,\n      )\n      .toNumber();\n  }\n\n  public async loadSerum3OpenOrdersAccounts(\n    client: MangoClient,\n  ): Promise<OpenOrders[]> {\n    const response =\n      await client.program.provider.connection.getMultipleAccountsInfo(\n        this.serum3Active().map((s) => s.openOrders),\n      );\n    const accounts = response.filter((a): a is AccountInfo<Buffer> =>\n      Boolean(a),\n    );\n\n    return accounts.map((acc, index) => {\n      return OpenOrders.fromAccountInfo(\n        this.serum3[index].openOrders,\n        acc,\n        OPENBOOK_PROGRAM_ID[client.cluster],\n      );\n    });\n  }\n\n  public async loadSerum3OpenOrdersForMarket(\n    client: MangoClient,\n    group: Group,\n    externalMarketPk: PublicKey,\n  ): Promise<Order[]> {\n    const serum3Market =\n      group.getSerum3MarketByExternalMarket(externalMarketPk);\n    const serum3OO = this.serum3Active().find(\n      (s) => s.marketIndex === serum3Market.marketIndex,\n    );\n    if (!serum3OO) {\n      throw new Error(`No open orders account found for ${externalMarketPk}`);\n    }\n\n    const serum3MarketExternal = group.serum3ExternalMarketsMap.get(\n      externalMarketPk.toBase58(),\n    )!;\n    const [bidsInfo, asksInfo] =\n      await client.program.provider.connection.getMultipleAccountsInfo([\n        serum3MarketExternal.bidsAddress,\n        serum3MarketExternal.asksAddress,\n      ]);\n    if (!bidsInfo) {\n      throw new Error(\n        `Undefined bidsInfo for serum3Market with externalMarket ${externalMarketPk.toString()!}`,\n      );\n    }\n    if (!asksInfo) {\n      throw new Error(\n        `Undefined asksInfo for serum3Market with externalMarket ${externalMarketPk.toString()!}`,\n      );\n    }\n    const bids = Orderbook.decode(serum3MarketExternal, bidsInfo.data);\n    const asks = Orderbook.decode(serum3MarketExternal, asksInfo.data);\n    return [...bids, ...asks].filter((o) =>\n      o.openOrdersAddress.equals(serum3OO.openOrders),\n    );\n  }\n\n  /**\n   * TODO REWORK, know to break in binary search, also make work for limit orders\n   *\n   * @param group\n   * @param externalMarketPk\n   * @returns maximum ui quote which can be traded at oracle price for base token given current health\n   */\n  public getMaxQuoteForSerum3BidUi(\n    group: Group,\n    externalMarketPk: PublicKey,\n  ): number {\n    const serum3Market =\n      group.getSerum3MarketByExternalMarket(externalMarketPk);\n    const baseBank = group.getFirstBankByTokenIndex(\n      serum3Market.baseTokenIndex,\n    );\n    const quoteBank = group.getFirstBankByTokenIndex(\n      serum3Market.quoteTokenIndex,\n    );\n    const hc = HealthCache.fromMangoAccount(group, this);\n    const nativeAmount = hc.getMaxSerum3OrderForHealthRatio(\n      baseBank,\n      quoteBank,\n      serum3Market,\n      Serum3Side.bid,\n      I80F48.fromNumber(2),\n    );\n    let quoteAmount = nativeAmount.div(quoteBank.price);\n    // If its a bid then the reserved fund and potential loan is in base\n    // also keep some buffer for fees, use taker fees for worst case simulation.\n    const quoteBalance = this.getTokenBalance(quoteBank);\n    if (quoteAmount.gt(quoteBalance)) {\n      const quoteBorrow = quoteAmount.sub(quoteBalance);\n      quoteAmount = quoteBalance.add(\n        quoteBorrow.div(ONE_I80F48().add(quoteBank.loanOriginationFeeRate)),\n      );\n    }\n    quoteAmount = quoteAmount.div(\n      ONE_I80F48().add(I80F48.fromNumber(serum3Market.getFeeRates(true))),\n    );\n    return toUiDecimals(nativeAmount, quoteBank.mintDecimals);\n  }\n\n  /**\n   * TODO REWORK, know to break in binary search, also make work for limit orders\n   * @param group\n   * @param externalMarketPk\n   * @returns maximum ui base which can be traded at oracle price for quote token given current health\n   */\n  public getMaxBaseForSerum3AskUi(\n    group: Group,\n    externalMarketPk: PublicKey,\n  ): number {\n    const serum3Market =\n      group.getSerum3MarketByExternalMarket(externalMarketPk);\n    const baseBank = group.getFirstBankByTokenIndex(\n      serum3Market.baseTokenIndex,\n    );\n    const quoteBank = group.getFirstBankByTokenIndex(\n      serum3Market.quoteTokenIndex,\n    );\n    const hc = HealthCache.fromMangoAccount(group, this);\n    const nativeAmount = hc.getMaxSerum3OrderForHealthRatio(\n      baseBank,\n      quoteBank,\n      serum3Market,\n      Serum3Side.ask,\n      I80F48.fromNumber(2),\n    );\n    let baseAmount = nativeAmount.div(baseBank.price);\n    // If its a ask then the reserved fund and potential loan is in base\n    // also keep some buffer for fees, use taker fees for worst case simulation.\n    const baseBalance = this.getTokenBalance(baseBank);\n    if (baseAmount.gt(baseBalance)) {\n      const baseBorrow = baseAmount.sub(baseBalance);\n      baseAmount = baseBalance.add(\n        baseBorrow.div(ONE_I80F48().add(baseBank.loanOriginationFeeRate)),\n      );\n    }\n    baseAmount = baseAmount.div(\n      ONE_I80F48().add(I80F48.fromNumber(serum3Market.getFeeRates(true))),\n    );\n    return toUiDecimals(baseAmount, baseBank.mintDecimals);\n  }\n\n  /**\n   *\n   * @param group\n   * @param uiQuoteAmount\n   * @param externalMarketPk\n   * @param healthType\n   * @returns health ratio after a bid with uiQuoteAmount is placed\n   */\n  public simHealthRatioWithSerum3BidUiChanges(\n    group: Group,\n    uiQuoteAmount: number,\n    externalMarketPk: PublicKey,\n    healthType: HealthType = HealthType.init,\n  ): number {\n    const serum3Market =\n      group.getSerum3MarketByExternalMarket(externalMarketPk);\n    const baseBank = group.getFirstBankByTokenIndex(\n      serum3Market.baseTokenIndex,\n    );\n    const quoteBank = group.getFirstBankByTokenIndex(\n      serum3Market.quoteTokenIndex,\n    );\n    const hc = HealthCache.fromMangoAccount(group, this);\n    return hc\n      .simHealthRatioWithSerum3BidChanges(\n        baseBank,\n        quoteBank,\n        toNativeI80F48(\n          uiQuoteAmount,\n          group.getFirstBankByTokenIndex(serum3Market.quoteTokenIndex)\n            .mintDecimals,\n        ),\n        serum3Market,\n        healthType,\n      )\n      .toNumber();\n  }\n\n  /**\n   *\n   * @param group\n   * @param uiBaseAmount\n   * @param externalMarketPk\n   * @param healthType\n   * @returns health ratio after an ask with uiBaseAmount is placed\n   */\n  public simHealthRatioWithSerum3AskUiChanges(\n    group: Group,\n    uiBaseAmount: number,\n    externalMarketPk: PublicKey,\n    healthType: HealthType = HealthType.init,\n  ): number {\n    const serum3Market =\n      group.getSerum3MarketByExternalMarket(externalMarketPk);\n    const baseBank = group.getFirstBankByTokenIndex(\n      serum3Market.baseTokenIndex,\n    );\n    const quoteBank = group.getFirstBankByTokenIndex(\n      serum3Market.quoteTokenIndex,\n    );\n    const hc = HealthCache.fromMangoAccount(group, this);\n    return hc\n      .simHealthRatioWithSerum3AskChanges(\n        baseBank,\n        quoteBank,\n        toNativeI80F48(\n          uiBaseAmount,\n          group.getFirstBankByTokenIndex(serum3Market.baseTokenIndex)\n            .mintDecimals,\n        ),\n        serum3Market,\n        healthType,\n      )\n      .toNumber();\n  }\n\n  // TODO: don't send a settle instruction if there's nothing to settle\n  public async serum3SettleFundsForAllMarkets(\n    client: MangoClient,\n    group: Group,\n  ): Promise<TransactionSignature[]> {\n    // Future: collect ixs, batch them, and send them in fewer txs\n    return await Promise.all(\n      this.serum3Active().map((s) => {\n        const serum3Market = group.getSerum3MarketByMarketIndex(s.marketIndex);\n        return client.serum3SettleFunds(\n          group,\n          this,\n          serum3Market.serumMarketExternal,\n        );\n      }),\n    );\n  }\n\n  // TODO: cancel until all are cancelled\n  public async serum3CancelAllOrdersForAllMarkets(\n    client: MangoClient,\n    group: Group,\n  ): Promise<TransactionSignature[]> {\n    // Future: collect ixs, batch them, and send them in in fewer txs\n    return await Promise.all(\n      this.serum3Active().map((s) => {\n        const serum3Market = group.getSerum3MarketByMarketIndex(s.marketIndex);\n        return client.serum3CancelAllOrders(\n          group,\n          this,\n          serum3Market.serumMarketExternal,\n        );\n      }),\n    );\n  }\n\n  /**\n   * TODO: also think about limit orders\n   *\n   * The max ui quote you can place a market/ioc bid on the market,\n   * price is the ui price at which you think the order would materialiase.\n   * @param group\n   * @param perpMarketName\n   * @returns maximum ui quote which can be traded at oracle price for quote token given current health\n   */\n  public getMaxQuoteForPerpBidUi(\n    group: Group,\n    perpMarketIndex: PerpMarketIndex,\n  ): number {\n    const perpMarket = group.getPerpMarketByMarketIndex(perpMarketIndex);\n    const hc = HealthCache.fromMangoAccount(group, this);\n    const baseLots = hc.getMaxPerpForHealthRatio(\n      perpMarket,\n      I80F48.fromNumber(perpMarket.uiPrice),\n      PerpOrderSide.bid,\n      I80F48.fromNumber(2),\n    );\n    const nativeBase = baseLots.mul(I80F48.fromI64(perpMarket.baseLotSize));\n    const nativeQuote = nativeBase.mul(perpMarket.price);\n    return toUiDecimalsForQuote(nativeQuote);\n  }\n\n  /**\n   * TODO: also think about limit orders\n   *\n   * The max ui base you can place a market/ioc ask on the market,\n   * price is the ui price at which you think the order would materialiase.\n   * @param group\n   * @param perpMarketName\n   * @param uiPrice ui price at which ask would be placed at\n   * @returns max ui base ask\n   */\n  public getMaxBaseForPerpAskUi(\n    group: Group,\n    perpMarketIndex: PerpMarketIndex,\n  ): number {\n    const perpMarket = group.getPerpMarketByMarketIndex(perpMarketIndex);\n    const hc = HealthCache.fromMangoAccount(group, this);\n    const baseLots = hc.getMaxPerpForHealthRatio(\n      perpMarket,\n      I80F48.fromNumber(perpMarket.uiPrice),\n      PerpOrderSide.ask,\n      I80F48.fromNumber(2),\n    );\n    return perpMarket.baseLotsToUi(new BN(baseLots.toString()));\n  }\n\n  public simHealthRatioWithPerpBidUiChanges(\n    group: Group,\n    perpMarketIndex: PerpMarketIndex,\n    size: number,\n  ): number {\n    const perpMarket = group.getPerpMarketByMarketIndex(perpMarketIndex);\n    const pp = this.getPerpPosition(perpMarket.perpMarketIndex);\n    const hc = HealthCache.fromMangoAccount(group, this);\n    return hc\n      .simHealthRatioWithPerpOrderChanges(\n        perpMarket,\n        pp\n          ? pp\n          : PerpPosition.emptyFromPerpMarketIndex(perpMarket.perpMarketIndex),\n        PerpOrderSide.bid,\n        perpMarket.uiBaseToLots(size),\n        I80F48.fromNumber(perpMarket.uiPrice),\n        HealthType.init,\n      )\n      .toNumber();\n  }\n\n  public simHealthRatioWithPerpAskUiChanges(\n    group: Group,\n    perpMarketIndex: PerpMarketIndex,\n    size: number,\n  ): number {\n    const perpMarket = group.getPerpMarketByMarketIndex(perpMarketIndex);\n    const pp = this.getPerpPosition(perpMarket.perpMarketIndex);\n    const hc = HealthCache.fromMangoAccount(group, this);\n    return hc\n      .simHealthRatioWithPerpOrderChanges(\n        perpMarket,\n        pp\n          ? pp\n          : PerpPosition.emptyFromPerpMarketIndex(perpMarket.perpMarketIndex),\n        PerpOrderSide.ask,\n        perpMarket.uiBaseToLots(size),\n        I80F48.fromNumber(perpMarket.uiPrice),\n        HealthType.init,\n      )\n      .toNumber();\n  }\n\n  public async loadPerpOpenOrdersForMarket(\n    client: MangoClient,\n    group: Group,\n    perpMarketIndex: PerpMarketIndex,\n  ): Promise<PerpOrder[]> {\n    const perpMarket = group.getPerpMarketByMarketIndex(perpMarketIndex);\n    const [bids, asks] = await Promise.all([\n      perpMarket.loadBids(client),\n      perpMarket.loadAsks(client),\n    ]);\n\n    return [...Array.from(bids.items()), ...Array.from(asks.items())].filter(\n      (order) => order.owner.equals(this.publicKey),\n    );\n  }\n\n  toString(group?: Group, onlyTokens = false): string {\n    let res = 'MangoAccount';\n    res = res + '\\n pk: ' + this.publicKey.toString();\n    res = res + '\\n name: ' + this.name;\n    res = res + '\\n accountNum: ' + this.accountNum;\n    res = res + '\\n owner: ' + this.owner;\n    res = res + '\\n delegate: ' + this.delegate;\n\n    res =\n      res +\n      `\\n max token slots ${this.tokens.length}, max serum3 slots ${this.serum3.length}, max perp slots ${this.perps.length}, max perp oo slots ${this.perpOpenOrders.length}`;\n    res =\n      this.tokensActive().length > 0\n        ? res +\n          '\\n tokens:' +\n          JSON.stringify(\n            this.tokens\n              .filter((token, i) => token.isActive())\n              .map((token, i) => token.toString(group, i)),\n            null,\n            4,\n          )\n        : res + '';\n\n    if (onlyTokens) {\n      return res;\n    }\n\n    res =\n      this.serum3Active().length > 0\n        ? res + '\\n serum:' + JSON.stringify(this.serum3Active(), null, 4)\n        : res + '';\n\n    res =\n      this.perpActive().length > 0\n        ? res +\n          '\\n perps:' +\n          JSON.stringify(\n            this.perpActive().map((p) =>\n              p.toString(group?.getPerpMarketByMarketIndex(p.marketIndex)),\n            ),\n            null,\n            4,\n          )\n        : res + '';\n\n    res =\n      this.perpOrdersActive().length > 0\n        ? res +\n          '\\n perps oo:' +\n          JSON.stringify(this.perpOrdersActive(), null, 4)\n        : res + '';\n\n    return res;\n  }\n}\n\nexport class TokenPosition {\n  static TokenIndexUnset = 65535;\n  static from(dto: TokenPositionDto): TokenPosition {\n    return new TokenPosition(\n      I80F48.from(dto.indexedPosition),\n      dto.tokenIndex as TokenIndex,\n      dto.inUseCount,\n      I80F48.from(dto.previousIndex),\n      dto.cumulativeDepositInterest,\n      dto.cumulativeBorrowInterest,\n    );\n  }\n\n  constructor(\n    public indexedPosition: I80F48,\n    public tokenIndex: TokenIndex,\n    public inUseCount: number,\n    public previousIndex: I80F48,\n    public cumulativeDepositInterest: number,\n    public cumulativeBorrowInterest: number,\n  ) {}\n\n  public isActive(): boolean {\n    return this.tokenIndex !== TokenPosition.TokenIndexUnset;\n  }\n\n  /**\n   *\n   * @param bank\n   * @returns native balance\n   */\n  public balance(bank: Bank): I80F48 {\n    if (this.indexedPosition.isPos()) {\n      return bank.depositIndex.mul(this.indexedPosition);\n    } else {\n      return bank.borrowIndex.mul(this.indexedPosition);\n    }\n  }\n\n  /**\n   *\n   * @param bank\n   * @returns native deposits, 0 if position has borrows\n   */\n  public deposits(bank: Bank): I80F48 {\n    if (this.indexedPosition && this.indexedPosition.lt(ZERO_I80F48())) {\n      return ZERO_I80F48();\n    }\n    return this.balance(bank);\n  }\n\n  /**\n   *\n   * @param bank\n   * @returns native borrows, 0 if position has deposits\n   */\n  public borrows(bank: Bank): I80F48 {\n    if (this.indexedPosition && this.indexedPosition.gt(ZERO_I80F48())) {\n      return ZERO_I80F48();\n    }\n    return this.balance(bank).abs();\n  }\n\n  /**\n   * @param bank\n   * @returns UI balance, is signed\n   */\n  public balanceUi(bank: Bank): number {\n    return toUiDecimals(this.balance(bank), bank.mintDecimals);\n  }\n\n  /**\n   * @param bank\n   * @returns UI deposits, 0 if position has borrows\n   */\n  public depositsUi(bank: Bank): number {\n    return toUiDecimals(this.deposits(bank), bank.mintDecimals);\n  }\n\n  /**\n   * @param bank\n   * @returns UI borrows, 0 if position has deposits\n   */\n  public borrowsUi(bank: Bank): number {\n    return toUiDecimals(this.borrows(bank), bank.mintDecimals);\n  }\n\n  public toString(group?: Group, index?: number): string {\n    let extra = '';\n    if (group) {\n      const bank: Bank = group.getFirstBankByTokenIndex(this.tokenIndex);\n      if (bank) {\n        const native = this.balance(bank);\n        extra += ', native: ' + native.toNumber();\n        extra += ', ui: ' + this.balanceUi(bank);\n        extra += ', tokenName: ' + bank.name;\n      }\n    }\n\n    return (\n      (index !== undefined ? 'index: ' + index : '') +\n      ', tokenIndex: ' +\n      this.tokenIndex +\n      ', inUseCount: ' +\n      this.inUseCount +\n      ', indexedValue: ' +\n      this.indexedPosition.toNumber() +\n      extra\n    );\n  }\n}\n\nexport class TokenPositionDto {\n  constructor(\n    public indexedPosition: I80F48Dto,\n    public tokenIndex: number,\n    public inUseCount: number,\n    public reserved: number[],\n    public previousIndex: I80F48Dto,\n    public cumulativeDepositInterest: number,\n    public cumulativeBorrowInterest: number,\n  ) {}\n}\n\nexport class Serum3Orders {\n  static Serum3MarketIndexUnset = 65535;\n  static from(dto: Serum3PositionDto): Serum3Orders {\n    return new Serum3Orders(\n      dto.openOrders,\n      dto.marketIndex as MarketIndex,\n      dto.baseTokenIndex as TokenIndex,\n      dto.quoteTokenIndex as TokenIndex,\n    );\n  }\n\n  constructor(\n    public openOrders: PublicKey,\n    public marketIndex: MarketIndex,\n    public baseTokenIndex: TokenIndex,\n    public quoteTokenIndex: TokenIndex,\n  ) {}\n\n  public isActive(): boolean {\n    return this.marketIndex !== Serum3Orders.Serum3MarketIndexUnset;\n  }\n}\n\nexport class Serum3PositionDto {\n  constructor(\n    public openOrders: PublicKey,\n    public marketIndex: number,\n    public baseBorrowsWithoutFee: BN,\n    public quoteBorrowsWithoutFee: BN,\n    public baseTokenIndex: number,\n    public quoteTokenIndex: number,\n    public reserved: number[],\n  ) {}\n}\n\nexport class PerpPosition {\n  static PerpMarketIndexUnset = 65535;\n  static from(dto: PerpPositionDto): PerpPosition {\n    return new PerpPosition(\n      dto.marketIndex as PerpMarketIndex,\n      dto.settlePnlLimitWindow,\n      dto.settlePnlLimitSettledInCurrentWindowNative,\n      dto.basePositionLots,\n      I80F48.from(dto.quotePositionNative),\n      dto.quoteRunningNative,\n      I80F48.from(dto.longSettledFunding),\n      I80F48.from(dto.shortSettledFunding),\n      dto.bidsBaseLots,\n      dto.asksBaseLots,\n      dto.takerBaseLots,\n      dto.takerQuoteLots,\n      dto.cumulativeLongFunding,\n      dto.cumulativeShortFunding,\n      dto.makerVolume,\n      dto.takerVolume,\n      dto.perpSpotTransfers,\n      dto.avgEntryPricePerBaseLot,\n      I80F48.from(dto.realizedTradePnlNative),\n      I80F48.from(dto.realizedOtherPnlNative),\n      dto.settlePnlLimitRealizedTrade,\n      I80F48.from(dto.realizedPnlForPositionNative),\n    );\n  }\n\n  static emptyFromPerpMarketIndex(\n    perpMarketIndex: PerpMarketIndex,\n  ): PerpPosition {\n    return new PerpPosition(\n      perpMarketIndex,\n      0,\n      new BN(0),\n      new BN(0),\n      ZERO_I80F48(),\n      new BN(0),\n      ZERO_I80F48(),\n      ZERO_I80F48(),\n      new BN(0),\n      new BN(0),\n      new BN(0),\n      new BN(0),\n      0,\n      0,\n      new BN(0),\n      new BN(0),\n      new BN(0),\n      0,\n      ZERO_I80F48(),\n      ZERO_I80F48(),\n      new BN(0),\n      ZERO_I80F48(),\n    );\n  }\n\n  constructor(\n    public marketIndex: PerpMarketIndex,\n    public settlePnlLimitWindow: number,\n    public settlePnlLimitSettledInCurrentWindowNative: BN,\n    public basePositionLots: BN,\n    public quotePositionNative: I80F48,\n    public quoteRunningNative: BN,\n    public longSettledFunding: I80F48,\n    public shortSettledFunding: I80F48,\n    public bidsBaseLots: BN,\n    public asksBaseLots: BN,\n    public takerBaseLots: BN,\n    public takerQuoteLots: BN,\n    public cumulativeLongFunding: number,\n    public cumulativeShortFunding: number,\n    public makerVolume: BN,\n    public takerVolume: BN,\n    public perpSpotTransfers: BN,\n    public avgEntryPricePerBaseLot: number,\n    public realizedTradePnlNative: I80F48,\n    public realizedOtherPnlNative: I80F48,\n    public settlePnlLimitRealizedTrade: BN,\n    public realizedPnlForPositionNative: I80F48,\n  ) {}\n\n  isActive(): boolean {\n    return this.marketIndex !== PerpPosition.PerpMarketIndexUnset;\n  }\n\n  public getBasePositionNative(perpMarket: PerpMarket): I80F48 {\n    return I80F48.fromI64(this.basePositionLots.mul(perpMarket.baseLotSize));\n  }\n\n  public getBasePositionUi(\n    perpMarket: PerpMarket,\n    useEventQueue?: boolean,\n  ): number {\n    if (perpMarket.perpMarketIndex !== this.marketIndex) {\n      throw new Error(\"PerpPosition doesn't belong to the given market!\");\n    }\n\n    return perpMarket.baseLotsToUi(\n      useEventQueue\n        ? this.basePositionLots.add(this.takerBaseLots)\n        : this.basePositionLots,\n    );\n  }\n\n  public getUnsettledFunding(perpMarket: PerpMarket): I80F48 {\n    if (perpMarket.perpMarketIndex !== this.marketIndex) {\n      throw new Error(\"PerpPosition doesn't belong to the given market!\");\n    }\n\n    if (this.basePositionLots.gt(new BN(0))) {\n      return perpMarket.longFunding\n        .sub(this.longSettledFunding)\n        .mul(I80F48.fromI64(this.basePositionLots));\n    } else if (this.basePositionLots.lt(new BN(0))) {\n      return perpMarket.shortFunding\n        .sub(this.shortSettledFunding)\n        .mul(I80F48.fromI64(this.basePositionLots));\n    }\n    return ZERO_I80F48();\n  }\n\n  public getEquityUi(perpMarket: PerpMarket): number {\n    if (perpMarket.perpMarketIndex !== this.marketIndex) {\n      throw new Error(\"PerpPosition doesn't belong to the given market!\");\n    }\n\n    return toUiDecimalsForQuote(this.getEquity(perpMarket));\n  }\n\n  public getEquity(perpMarket: PerpMarket): I80F48 {\n    if (perpMarket.perpMarketIndex !== this.marketIndex) {\n      throw new Error(\"PerpPosition doesn't belong to the given market!\");\n    }\n\n    const lotsToQuote = I80F48.fromI64(perpMarket.baseLotSize).mul(\n      perpMarket.price,\n    );\n\n    const baseLots = I80F48.fromI64(\n      this.basePositionLots.add(this.takerBaseLots),\n    );\n\n    const unsettledFunding = this.getUnsettledFunding(perpMarket);\n    const takerQuote = I80F48.fromI64(\n      new BN(this.takerQuoteLots).mul(perpMarket.quoteLotSize),\n    );\n    const quoteCurrent = this.quotePositionNative\n      .sub(unsettledFunding)\n      .add(takerQuote);\n\n    return baseLots.mul(lotsToQuote).add(quoteCurrent);\n  }\n\n  public hasOpenOrders(): boolean {\n    const zero = new BN(0);\n    return (\n      !this.asksBaseLots.eq(zero) ||\n      !this.bidsBaseLots.eq(zero) ||\n      !this.takerBaseLots.eq(zero) ||\n      !this.takerQuoteLots.eq(zero)\n    );\n  }\n\n  public getAverageEntryPrice(perpMarket: PerpMarket): I80F48 {\n    return I80F48.fromNumber(this.avgEntryPricePerBaseLot).div(\n      I80F48.fromI64(perpMarket.baseLotSize),\n    );\n  }\n\n  public getAverageEntryPriceUi(perpMarket: PerpMarket): number {\n    return perpMarket.priceNativeToUi(\n      this.getAverageEntryPrice(perpMarket).toNumber(),\n    );\n  }\n\n  public getBreakEvenPriceUi(perpMarket: PerpMarket): number {\n    if (perpMarket.perpMarketIndex !== this.marketIndex) {\n      throw new Error(\"PerpPosition doesn't belong to the given market!\");\n    }\n\n    if (this.basePositionLots.eq(new BN(0))) {\n      return 0;\n    }\n    return perpMarket.priceNativeToUi(\n      -this.quoteRunningNative.toNumber() /\n        this.basePositionLots.mul(perpMarket.baseLotSize).toNumber(),\n    );\n  }\n\n  public cumulativePnlOverPositionLifetimeUi(perpMarket: PerpMarket): number {\n    if (perpMarket.perpMarketIndex !== this.marketIndex) {\n      throw new Error(\"PerpPosition doesn't belong to the given market!\");\n    }\n\n    const priceChange = perpMarket.price.sub(\n      this.getAverageEntryPrice(perpMarket),\n    );\n\n    return toUiDecimalsForQuote(\n      this.realizedPnlForPositionNative.add(\n        this.getBasePositionNative(perpMarket).mul(priceChange),\n      ),\n    );\n  }\n\n  public getUnsettledPnl(perpMarket: PerpMarket): I80F48 {\n    if (perpMarket.perpMarketIndex !== this.marketIndex) {\n      throw new Error(\"PerpPosition doesn't belong to the given market!\");\n    }\n\n    return this.quotePositionNative.add(\n      this.getBasePositionNative(perpMarket).mul(perpMarket.price),\n    );\n  }\n\n  public getUnsettledPnlUi(perpMarket: PerpMarket): number {\n    return toUiDecimalsForQuote(this.getUnsettledPnl(perpMarket));\n  }\n\n  public updateSettleLimit(perpMarket: PerpMarket): void {\n    if (perpMarket.perpMarketIndex !== this.marketIndex) {\n      throw new Error(\"PerpPosition doesn't belong to the given market!\");\n    }\n\n    const windowSize = perpMarket.settlePnlLimitWindowSizeTs;\n    const windowStart = new BN(this.settlePnlLimitWindow).mul(windowSize);\n    const windowEnd = windowStart.add(windowSize);\n    const nowTs = new BN(Date.now() / 1000);\n    const newWindow = nowTs.gte(windowEnd) || nowTs.lt(windowStart);\n    if (newWindow) {\n      this.settlePnlLimitWindow = nowTs.div(windowSize).toNumber();\n      this.settlePnlLimitSettledInCurrentWindowNative = new BN(0);\n    }\n  }\n\n  public availableSettleLimit(perpMarket: PerpMarket): [BN, BN] {\n    if (perpMarket.perpMarketIndex !== this.marketIndex) {\n      throw new Error(\"PerpPosition doesn't belong to the given market!\");\n    }\n\n    if (perpMarket.settlePnlLimitFactor < 0) {\n      return [RUST_I64_MIN(), RUST_I64_MAX()];\n    }\n\n    const baseNative = I80F48.fromI64(\n      this.basePositionLots.mul(perpMarket.baseLotSize),\n    );\n    const positionValue = I80F48.fromNumber(\n      perpMarket.stablePriceModel.stablePrice,\n    )\n      .mul(baseNative)\n      .toNumber();\n    const unrealized = new BN(perpMarket.settlePnlLimitFactor * positionValue);\n    const used = new BN(\n      this.settlePnlLimitSettledInCurrentWindowNative.toNumber(),\n    );\n\n    let minPnl = unrealized.neg().sub(used);\n    let maxPnl = unrealized.sub(used);\n\n    const realizedTrade = this.settlePnlLimitRealizedTrade;\n    if (realizedTrade.gte(new BN(0))) {\n      maxPnl = maxPnl.add(realizedTrade);\n    } else {\n      minPnl = minPnl.add(realizedTrade);\n    }\n\n    const realizedOther = new BN(this.realizedOtherPnlNative.toNumber());\n    if (realizedOther.gte(new BN(0))) {\n      maxPnl = maxPnl.add(realizedOther);\n    } else {\n      minPnl = minPnl.add(realizedOther);\n    }\n\n    return [BN.min(minPnl, new BN(0)), BN.max(maxPnl, new BN(0))];\n  }\n\n  public applyPnlSettleLimit(pnl: I80F48, perpMarket: PerpMarket): I80F48 {\n    if (perpMarket.perpMarketIndex !== this.marketIndex) {\n      throw new Error(\"PerpPosition doesn't belong to the given market!\");\n    }\n\n    if (perpMarket.settlePnlLimitFactor < 0) {\n      return pnl;\n    }\n\n    const [minPnl, maxPnl] = this.availableSettleLimit(perpMarket);\n    if (pnl.lt(ZERO_I80F48())) {\n      return pnl.max(I80F48.fromI64(minPnl));\n    } else {\n      return pnl.min(I80F48.fromI64(maxPnl));\n    }\n  }\n\n  public getSettleablePnl(\n    group: Group,\n    perpMarket: PerpMarket,\n    account: MangoAccount,\n  ): I80F48 {\n    if (perpMarket.perpMarketIndex !== this.marketIndex) {\n      throw new Error(\"PerpPosition doesn't belong to the given market!\");\n    }\n    this.updateSettleLimit(perpMarket);\n    const perpSettleHealth = account.getPerpSettleHealth(group);\n    const limitedUnsettled = this.applyPnlSettleLimit(\n      this.getUnsettledPnl(perpMarket),\n      perpMarket,\n    );\n    if (limitedUnsettled.lt(ZERO_I80F48())) {\n      return limitedUnsettled.max(perpSettleHealth.max(ZERO_I80F48()).neg());\n    }\n    return limitedUnsettled;\n  }\n\n  getSettleablePnlUi(\n    group: Group,\n    perpMarket: PerpMarket,\n    account: MangoAccount,\n  ): number {\n    return toUiDecimalsForQuote(\n      this.getSettleablePnl(group, perpMarket, account),\n    );\n  }\n\n  public canSettlePnl(\n    group: Group,\n    perpMarket: PerpMarket,\n    account: MangoAccount,\n  ): boolean {\n    return !this.getSettleablePnl(group, perpMarket, account).eq(ZERO_I80F48());\n  }\n\n  toString(perpMarket?: PerpMarket): string {\n    return perpMarket\n      ? 'market - ' +\n          perpMarket.name +\n          ', basePositionLots - ' +\n          perpMarket.baseLotsToUi(this.basePositionLots) +\n          ', quotePositive - ' +\n          toUiDecimalsForQuote(this.quotePositionNative.toNumber()) +\n          ', bidsBaseLots - ' +\n          perpMarket.baseLotsToUi(this.bidsBaseLots) +\n          ', asksBaseLots - ' +\n          perpMarket.baseLotsToUi(this.asksBaseLots) +\n          ', takerBaseLots - ' +\n          perpMarket.baseLotsToUi(this.takerBaseLots) +\n          ', takerQuoteLots - ' +\n          perpMarket.quoteLotsToUi(this.takerQuoteLots) +\n          ', unsettled pnl - ' +\n          this.getUnsettledPnlUi(perpMarket!).toString()\n      : '';\n  }\n}\n\nexport class PerpPositionDto {\n  constructor(\n    public marketIndex: number,\n    public settlePnlLimitWindow: number,\n    public settlePnlLimitSettledInCurrentWindowNative: BN,\n    public basePositionLots: BN,\n    public quotePositionNative: { val: BN },\n    public quoteRunningNative: BN,\n    public longSettledFunding: I80F48Dto,\n    public shortSettledFunding: I80F48Dto,\n    public bidsBaseLots: BN,\n    public asksBaseLots: BN,\n    public takerBaseLots: BN,\n    public takerQuoteLots: BN,\n    public cumulativeLongFunding: number,\n    public cumulativeShortFunding: number,\n    public makerVolume: BN,\n    public takerVolume: BN,\n    public perpSpotTransfers: BN,\n    public avgEntryPricePerBaseLot: number,\n    public realizedTradePnlNative: I80F48Dto,\n    public realizedOtherPnlNative: I80F48Dto,\n    public settlePnlLimitRealizedTrade: BN,\n    public realizedPnlForPositionNative: I80F48Dto,\n  ) {}\n}\n\nexport class PerpOo {\n  static OrderMarketUnset = 65535;\n  static from(dto: PerpOoDto): PerpOo {\n    return new PerpOo(dto.sideAndTree, dto.market, dto.clientId, dto.id);\n  }\n\n  constructor(\n    public sideAndTree: any,\n    public orderMarket: number,\n    public clientId: BN,\n    public id: BN,\n  ) {}\n\n  isActive(): boolean {\n    return this.orderMarket !== PerpOo.OrderMarketUnset;\n  }\n}\nexport class PerpOoDto {\n  constructor(\n    public sideAndTree: any,\n    public market: number,\n    public clientId: BN,\n    public id: BN,\n  ) {}\n}\n\nexport class HealthType {\n  static maint = { maint: {} };\n  static init = { init: {} };\n  static liquidationEnd = { liquidationEnd: {} };\n}\n"],"mappings":"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","names":["BN","pp","dto","amount","baseLots","BN","perpInfo","tokenMaxReserved","marketReserved"]}