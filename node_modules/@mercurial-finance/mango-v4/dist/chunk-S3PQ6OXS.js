"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }// ts/client/src/numbers/I80F48.ts
var _bigjs = require('big.js'); var _bigjs2 = _interopRequireDefault(_bigjs);
var _bnjs = require('bn.js'); var _bnjs2 = _interopRequireDefault(_bnjs);
var I80F48Dto = class {
  constructor(val) {
    this.val = val;
  }
};
var _I80F48 = class {
  // This is i128 => array of 16 bytes
  static from(dto) {
    return new _I80F48(dto.val);
  }
  constructor(data) {
    if (data.lt(_I80F48.MIN_BN) || data.gt(_I80F48.MAX_BN)) {
      throw new Error("Number out of range");
    }
    this.data = data;
  }
  static fromNumber(x) {
    const int_part = Math.trunc(x);
    const v = new (0, _bnjs2.default)(int_part.toFixed(0)).iushln(48);
    v.iadd(new (0, _bnjs2.default)((x - int_part) * _I80F48.MULTIPLIER_NUMBER));
    return new _I80F48(v);
  }
  static fromNumberOrUndef(x) {
    return x === void 0 ? void 0 : _I80F48.fromNumber(x);
  }
  static fromOptionalString(x) {
    return x ? _I80F48.fromString(x) : void 0;
  }
  static fromString(x) {
    const initialValue = new (0, _bigjs2.default)(x).times(_I80F48.MULTIPLIER_BIG);
    const fixedPointValue = new (0, _bnjs2.default)(initialValue.round().toFixed());
    return new _I80F48(fixedPointValue);
  }
  static fromI64(x) {
    return new _I80F48(x.ushln(48));
  }
  static fromU64(x) {
    return new _I80F48(x.ushln(48));
  }
  toTwos() {
    return this.data.toTwos(_I80F48.MAX_SIZE);
  }
  toString() {
    return this.toBig().toFixed();
  }
  /**
   * The number will be rounded first for UI sensibilities, then toFixed
   */
  toFixed(decimals) {
    return this.toBig().round(14).toFixed(decimals);
  }
  toLocaleString(locales, options) {
    return this.toNumber().toLocaleString(locales, options);
  }
  toBig() {
    return new (0, _bigjs2.default)(this.data.toString()).div(_I80F48.MULTIPLIER_BIG);
  }
  static fromBig(x) {
    return new _I80F48(new (0, _bnjs2.default)(x.mul(_I80F48.MULTIPLIER_BIG).round().toFixed()));
  }
  toNumber() {
    return this.toBig().toNumber();
  }
  static fromArray(src) {
    if (src.length !== 16) {
      throw new Error("Uint8Array must be of length 16");
    }
    return new _I80F48(new (0, _bnjs2.default)(src, "le").fromTwos(_I80F48.MAX_SIZE));
  }
  toArray() {
    return new Uint8Array(this.data.toTwos(_I80F48.MAX_SIZE).toArray("le", 16));
  }
  toArrayLike(ArrayType, endian, length) {
    return this.data.toTwos(_I80F48.MAX_SIZE).toArrayLike(ArrayType, endian, length);
  }
  getData() {
    return this.data;
  }
  getBinaryLayout() {
    return this.data.toTwos(_I80F48.MAX_SIZE).toString(2, _I80F48.MAX_SIZE).replace(/-/g, "");
  }
  add(x) {
    return new _I80F48(this.data.add(x.getData()));
  }
  sub(x) {
    return new _I80F48(this.data.sub(x.getData()));
  }
  iadd(x) {
    this.data.iadd(x.getData());
    return this;
  }
  isub(x) {
    this.data.isub(x.getData());
    return this;
  }
  floor() {
    return _I80F48.fromBig(this.toBig().round(void 0, 0));
  }
  ceil() {
    return _I80F48.fromBig(this.toBig().round(void 0, 3));
  }
  frac() {
    return new _I80F48(this.data.maskn(_I80F48.FRACTIONS));
  }
  /**
   * Multiply the two and shift
   */
  mul(x) {
    return new _I80F48(this.data.mul(x.data).iushrn(_I80F48.FRACTIONS));
  }
  imul(x) {
    this.data.imul(x.getData()).iushrn(_I80F48.FRACTIONS);
    return this;
  }
  div(x) {
    return new _I80F48(this.data.ushln(_I80F48.FRACTIONS).div(x.data));
  }
  idiv(x) {
    this.data = this.data.iushln(_I80F48.FRACTIONS).div(x.data);
    return this;
  }
  gt(x) {
    return this.data.gt(x.getData());
  }
  lt(x) {
    return this.data.lt(x.getData());
  }
  gte(x) {
    return this.data.gte(x.getData());
  }
  lte(x) {
    return this.data.lte(x.getData());
  }
  eq(x) {
    return this.data.eq(x.getData());
  }
  cmp(x) {
    return this.data.cmp(x.getData());
  }
  neg() {
    return this.mul(_NEG_ONE_I80F48);
  }
  isPos() {
    return this.gt(_ZERO_I80F48);
  }
  isNeg() {
    return this.data.isNeg();
  }
  isZero() {
    return this.eq(_ZERO_I80F48);
  }
  min(x) {
    return this.lte(x) ? this : x;
  }
  max(x) {
    return this.gte(x) ? this : x;
  }
  abs() {
    if (this.isNeg()) {
      return this.neg();
    } else {
      return this;
    }
  }
};
var I80F48 = _I80F48;
/**
  This is represented by a 128 bit signed integer underneath
  The first 80 bits are treated as an integer and last 48 bits are treated as fractional part after binary point
  It's possible to think of an I80F48 as an i128 divided by 2 ^ 40

  Read up on how fixed point math works: https://inst.eecs.berkeley.edu/~cs61c/sp06/handout/fixedpt.html
  Read up on how 2s complement works: https://en.wikipedia.org/wiki/Two%27s_complement
   */
I80F48.MAX_SIZE = 128;
I80F48.FRACTIONS = 48;
I80F48.MULTIPLIER_BIG = new (0, _bigjs2.default)(2).pow(_I80F48.FRACTIONS);
I80F48.MULTIPLIER_BN = new (0, _bnjs2.default)(2).pow(new (0, _bnjs2.default)(_I80F48.FRACTIONS));
I80F48.MULTIPLIER_NUMBER = Math.pow(2, _I80F48.FRACTIONS);
I80F48.MAX_BN = new (0, _bnjs2.default)(2).pow(new (0, _bnjs2.default)(_I80F48.MAX_SIZE)).div(new (0, _bnjs2.default)(2)).sub(new (0, _bnjs2.default)(1));
I80F48.MIN_BN = new (0, _bnjs2.default)(2).pow(new (0, _bnjs2.default)(_I80F48.MAX_SIZE)).div(new (0, _bnjs2.default)(2)).neg();
var _ZERO_I80F48 = I80F48.fromNumber(0);
var _NEG_ONE_I80F48 = I80F48.fromNumber(-1);
function ONE_I80F48() {
  return I80F48.fromNumber(1);
}
function ZERO_I80F48() {
  return I80F48.fromNumber(0);
}
function HUNDRED_I80F48() {
  return I80F48.fromNumber(100);
}
function MAX_I80F48() {
  return new I80F48(I80F48.MAX_BN);
}








exports.I80F48Dto = I80F48Dto; exports.I80F48 = I80F48; exports.ONE_I80F48 = ONE_I80F48; exports.ZERO_I80F48 = ZERO_I80F48; exports.HUNDRED_I80F48 = HUNDRED_I80F48; exports.MAX_I80F48 = MAX_I80F48;
//# sourceMappingURL=chunk-S3PQ6OXS.js.map