{"version":3,"sources":["../ts/client/src/accounts/perp.ts"],"names":["pp"],"mappings":"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","sourcesContent":["import { BN } from '@project-serum/anchor';\nimport { utf8 } from '@project-serum/anchor/dist/cjs/utils/bytes';\nimport { PublicKey } from '@solana/web3.js';\nimport Big from 'big.js';\nimport { MangoClient } from '../client';\nimport { RUST_U64_MAX } from '../constants';\nimport { I80F48, I80F48Dto, ZERO_I80F48 } from '../numbers/I80F48';\nimport { Modify } from '../types';\nimport { As, U64_MAX_BN, toNative, toUiDecimals } from '../utils';\nimport {\n  OracleConfig,\n  OracleConfigDto,\n  QUOTE_DECIMALS,\n  StablePriceModel,\n  TokenIndex,\n} from './bank';\nimport { Group } from './group';\nimport { MangoAccount } from './mangoAccount';\n\nexport type PerpMarketIndex = number & As<'perp-market-index'>;\n\nexport type ParsedFillEvent = Modify<\n  FillEvent,\n  {\n    price: number;\n    quantity: number;\n  }\n>;\n\nexport class PerpMarket {\n  public name: string;\n  public oracleConfig: OracleConfig;\n  public maintBaseAssetWeight: I80F48;\n  public initBaseAssetWeight: I80F48;\n  public maintBaseLiabWeight: I80F48;\n  public initBaseLiabWeight: I80F48;\n  public baseLiquidationFee: I80F48;\n  public makerFee: I80F48;\n  public takerFee: I80F48;\n  public minFunding: I80F48;\n  public maxFunding: I80F48;\n  public longFunding: I80F48;\n  public shortFunding: I80F48;\n  public feesAccrued: I80F48;\n  public feesSettled: I80F48;\n  public maintOverallAssetWeight: I80F48;\n  public initOverallAssetWeight: I80F48;\n\n  public _price: I80F48;\n  public _uiPrice: number;\n  public _oracleLastUpdatedSlot: number;\n\n  private priceLotsToUiConverter: number;\n  private baseLotsToUiConverter: number;\n  private quoteLotsToUiConverter: number;\n\n  private _bids: BookSide;\n  private _asks: BookSide;\n\n  static from(\n    publicKey: PublicKey,\n    obj: {\n      group: PublicKey;\n      settleTokenIndex: number;\n      perpMarketIndex: number;\n      groupInsuranceFund: number;\n      baseDecimals: number;\n      name: number[];\n      bids: PublicKey;\n      asks: PublicKey;\n      eventQueue: PublicKey;\n      oracle: PublicKey;\n      oracleConfig: OracleConfigDto;\n      stablePriceModel: StablePriceModel;\n      quoteLotSize: BN;\n      baseLotSize: BN;\n      maintBaseAssetWeight: I80F48Dto;\n      initBaseAssetWeight: I80F48Dto;\n      maintBaseLiabWeight: I80F48Dto;\n      initBaseLiabWeight: I80F48Dto;\n      openInterest: BN;\n      seqNum: BN;\n      registrationTime: BN;\n      minFunding: I80F48Dto;\n      maxFunding: I80F48Dto;\n      impactQuantity: BN;\n      longFunding: I80F48Dto;\n      shortFunding: I80F48Dto;\n      fundingLastUpdated: BN;\n      baseLiquidationFee: I80F48Dto;\n      makerFee: I80F48Dto;\n      takerFee: I80F48Dto;\n      feesAccrued: I80F48Dto;\n      feesSettled: I80F48Dto;\n      feePenalty: number;\n      settleFeeFlat: number;\n      settleFeeAmountThreshold: number;\n      settleFeeFractionLowHealth: number;\n      settlePnlLimitFactor: number;\n      settlePnlLimitWindowSizeTs: BN;\n      reduceOnly: number;\n      maintOverallAssetWeight: I80F48Dto;\n      initOverallAssetWeight: I80F48Dto;\n      positivePnlLiquidationFee: I80F48Dto;\n    },\n  ): PerpMarket {\n    return new PerpMarket(\n      publicKey,\n      obj.group,\n      obj.settleTokenIndex as TokenIndex,\n      obj.perpMarketIndex as PerpMarketIndex,\n      obj.groupInsuranceFund == 1,\n      obj.baseDecimals,\n      obj.name,\n      obj.bids,\n      obj.asks,\n      obj.eventQueue,\n      obj.oracle,\n      obj.oracleConfig,\n      obj.stablePriceModel,\n      obj.quoteLotSize,\n      obj.baseLotSize,\n      obj.maintBaseAssetWeight,\n      obj.initBaseAssetWeight,\n      obj.maintBaseLiabWeight,\n      obj.initBaseLiabWeight,\n      obj.openInterest,\n      obj.seqNum,\n      obj.registrationTime,\n      obj.minFunding,\n      obj.maxFunding,\n      obj.impactQuantity,\n      obj.longFunding,\n      obj.shortFunding,\n      obj.fundingLastUpdated,\n      obj.baseLiquidationFee,\n      obj.makerFee,\n      obj.takerFee,\n      obj.feesAccrued,\n      obj.feesSettled,\n      obj.feePenalty,\n      obj.settleFeeFlat,\n      obj.settleFeeAmountThreshold,\n      obj.settleFeeFractionLowHealth,\n      obj.settlePnlLimitFactor,\n      obj.settlePnlLimitWindowSizeTs,\n      obj.reduceOnly == 1,\n      obj.maintOverallAssetWeight,\n      obj.initOverallAssetWeight,\n      obj.positivePnlLiquidationFee,\n    );\n  }\n\n  constructor(\n    public publicKey: PublicKey,\n    public group: PublicKey,\n    public settleTokenIndex: TokenIndex,\n    public perpMarketIndex: PerpMarketIndex, // TODO rename to marketIndex?\n    public groupInsuranceFund: boolean,\n    public baseDecimals: number,\n    name: number[],\n    public bids: PublicKey,\n    public asks: PublicKey,\n    public eventQueue: PublicKey,\n    public oracle: PublicKey,\n    oracleConfig: OracleConfigDto,\n    public stablePriceModel: StablePriceModel,\n    public quoteLotSize: BN,\n    public baseLotSize: BN,\n    maintBaseAssetWeight: I80F48Dto,\n    initBaseAssetWeight: I80F48Dto,\n    maintBaseLiabWeight: I80F48Dto,\n    initBaseLiabWeight: I80F48Dto,\n    public openInterest: BN,\n    public seqNum: BN,\n    public registrationTime: BN,\n    minFunding: I80F48Dto,\n    maxFunding: I80F48Dto,\n    public impactQuantity: BN,\n    longFunding: I80F48Dto,\n    shortFunding: I80F48Dto,\n    public fundingLastUpdated: BN,\n    baseLiquidationFee: I80F48Dto,\n    makerFee: I80F48Dto,\n    takerFee: I80F48Dto,\n    feesAccrued: I80F48Dto,\n    feesSettled: I80F48Dto,\n    public feePenalty: number,\n    public settleFeeFlat: number,\n    public settleFeeAmountThreshold: number,\n    public settleFeeFractionLowHealth: number,\n    public settlePnlLimitFactor: number,\n    public settlePnlLimitWindowSizeTs: BN,\n    public reduceOnly: boolean,\n    maintOverallAssetWeight: I80F48Dto,\n    initOverallAssetWeight: I80F48Dto,\n    positivePnlLiquidationFee: I80F48Dto,\n  ) {\n    this.name = utf8.decode(new Uint8Array(name)).split('\\x00')[0];\n    this.oracleConfig = {\n      confFilter: I80F48.from(oracleConfig.confFilter),\n      maxStalenessSlots: oracleConfig.maxStalenessSlots,\n    } as OracleConfig;\n    this.maintBaseAssetWeight = I80F48.from(maintBaseAssetWeight);\n    this.initBaseAssetWeight = I80F48.from(initBaseAssetWeight);\n    this.maintBaseLiabWeight = I80F48.from(maintBaseLiabWeight);\n    this.initBaseLiabWeight = I80F48.from(initBaseLiabWeight);\n    this.baseLiquidationFee = I80F48.from(baseLiquidationFee);\n    this.makerFee = I80F48.from(makerFee);\n    this.takerFee = I80F48.from(takerFee);\n    this.minFunding = I80F48.from(minFunding);\n    this.maxFunding = I80F48.from(maxFunding);\n    this.longFunding = I80F48.from(longFunding);\n    this.shortFunding = I80F48.from(shortFunding);\n    this.feesAccrued = I80F48.from(feesAccrued);\n    this.feesSettled = I80F48.from(feesSettled);\n    this.maintOverallAssetWeight = I80F48.from(maintOverallAssetWeight);\n    this.initOverallAssetWeight = I80F48.from(initOverallAssetWeight);\n\n    this.priceLotsToUiConverter = new Big(10)\n      .pow(baseDecimals - QUOTE_DECIMALS)\n      .mul(new Big(this.quoteLotSize.toString()))\n      .div(new Big(this.baseLotSize.toString()))\n      .toNumber();\n\n    this.baseLotsToUiConverter = new Big(this.baseLotSize.toString())\n      .div(new Big(10).pow(baseDecimals))\n      .toNumber();\n\n    this.quoteLotsToUiConverter = new Big(this.quoteLotSize.toString())\n      .div(new Big(10).pow(QUOTE_DECIMALS))\n      .toNumber();\n  }\n\n  get price(): I80F48 {\n    if (!this._price) {\n      throw new Error(\n        `Undefined price for perpMarket ${this.publicKey} with marketIndex ${this.perpMarketIndex}!`,\n      );\n    }\n    return this._price;\n  }\n\n  get uiPrice(): number {\n    if (!this._uiPrice) {\n      throw new Error(\n        `Undefined price for perpMarket ${this.publicKey} with marketIndex ${this.perpMarketIndex}!`,\n      );\n    }\n    return this._uiPrice;\n  }\n\n  get oracleLastUpdatedSlot(): number {\n    if (!this._oracleLastUpdatedSlot) {\n      throw new Error(\n        `Undefined oracleLastUpdatedSlot for perpMarket ${this.publicKey} with marketIndex ${this.perpMarketIndex}!`,\n      );\n    }\n    return this._oracleLastUpdatedSlot;\n  }\n\n  get minOrderSize(): number {\n    return this.baseLotsToUiConverter;\n  }\n\n  get tickSize(): number {\n    return this.priceLotsToUiConverter;\n  }\n\n  insidePriceLimit(side: PerpOrderSide, orderPrice: number): boolean {\n    return (\n      (side === PerpOrderSide.bid &&\n        orderPrice <= this.maintBaseLiabWeight.toNumber() * this.uiPrice) ||\n      (side === PerpOrderSide.ask &&\n        orderPrice >= this.maintBaseAssetWeight.toNumber() * this.uiPrice)\n    );\n  }\n\n  public async loadAsks(\n    client: MangoClient,\n    forceReload = false,\n  ): Promise<BookSide> {\n    if (forceReload || !this._asks) {\n      const asks = await client.program.account.bookSide.fetch(this.asks);\n      this._asks = BookSide.from(client, this, BookSideType.asks, asks as any);\n    }\n    return this._asks;\n  }\n\n  public async loadBids(\n    client: MangoClient,\n    forceReload = false,\n  ): Promise<BookSide> {\n    if (forceReload || !this._bids) {\n      const bids = await client.program.account.bookSide.fetch(this.bids);\n      this._bids = BookSide.from(client, this, BookSideType.bids, bids as any);\n    }\n    return this._bids;\n  }\n\n  public async loadEventQueue(client: MangoClient): Promise<PerpEventQueue> {\n    const eventQueue = await client.program.account.eventQueue.fetch(\n      this.eventQueue,\n    );\n    return new PerpEventQueue(client, eventQueue.header, eventQueue.buf);\n  }\n\n  public async loadFills(\n    client: MangoClient,\n    lastSeqNum: BN = new BN(0),\n  ): Promise<(OutEvent | FillEvent | LiquidateEvent)[]> {\n    const eventQueue = await this.loadEventQueue(client);\n    return eventQueue\n      .eventsSince(lastSeqNum)\n      .filter((event) => event.eventType == PerpEventQueue.FILL_EVENT_TYPE)\n      .map(this.parseFillEvent.bind(this)) as ParsedFillEvent[];\n  }\n\n  public parseFillEvent(event): ParsedFillEvent {\n    const quantity = this.baseLotsToUi(event.quantity);\n    const price = this.priceLotsToUi(event.price);\n\n    return {\n      ...event,\n      quantity,\n      size: quantity,\n      price,\n    };\n  }\n\n  public async logOb(client: MangoClient): Promise<string> {\n    let res = ``;\n    res += `  ${this.name} OrderBook`;\n    let orders = await this?.loadAsks(client);\n    for (const order of orders!.items()) {\n      res += `\\n ${order.uiPrice.toFixed(5).padStart(10)}, ${order.uiSize\n        .toString()\n        .padStart(10)} ${\n        order.isOraclePegged && order.oraclePeggedProperties\n          ? order.oraclePeggedProperties.pegLimit.toNumber() + ' (PegLimit)'\n          : ''\n      }`;\n    }\n    res += `\\n  asks ↑ --------- ↓ bids`;\n    orders = await this?.loadBids(client);\n    for (const order of orders!.items()) {\n      res += `\\n  ${order.uiPrice.toFixed(5).padStart(10)}, ${order.uiSize\n        .toString()\n        .padStart(10)} ${\n        order.isOraclePegged && order.oraclePeggedProperties\n          ? order.oraclePeggedProperties.pegLimit.toNumber() + ' (PegLimit)'\n          : ''\n      }`;\n    }\n    return res;\n  }\n\n  /**\n   *\n   * @param bids\n   * @param asks\n   * @returns returns funding rate per hour\n   */\n  public getCurrentFundingRate(bids: BookSide, asks: BookSide): number {\n    const MIN_FUNDING = this.minFunding.toNumber();\n    const MAX_FUNDING = this.maxFunding.toNumber();\n\n    const bid = bids.getImpactPriceUi(new BN(this.impactQuantity));\n    const ask = asks.getImpactPriceUi(new BN(this.impactQuantity));\n    const indexPrice = this._uiPrice;\n\n    let funding;\n    if (bid !== undefined && ask !== undefined) {\n      const bookPrice = (bid + ask) / 2;\n      funding = Math.min(\n        Math.max(bookPrice / indexPrice - 1, MIN_FUNDING),\n        MAX_FUNDING,\n      );\n    } else if (bid !== undefined) {\n      funding = MAX_FUNDING;\n    } else if (ask !== undefined) {\n      funding = MIN_FUNDING;\n    } else {\n      funding = 0;\n    }\n    return funding / 24 / Math.pow(10, QUOTE_DECIMALS);\n  }\n\n  public uiPriceToLots(price: number): BN {\n    return toNative(price, QUOTE_DECIMALS)\n      .mul(this.baseLotSize)\n      .div(this.quoteLotSize.mul(new BN(Math.pow(10, this.baseDecimals))));\n  }\n\n  public uiBaseToLots(quantity: number): BN {\n    return toNative(quantity, this.baseDecimals).div(this.baseLotSize);\n  }\n\n  public uiQuoteToLots(uiQuote: number): BN {\n    return toNative(uiQuote, QUOTE_DECIMALS).div(this.quoteLotSize);\n  }\n\n  public priceLotsToUi(price: BN): number {\n    return parseFloat(price.toString()) * this.priceLotsToUiConverter;\n  }\n\n  public priceNativeToUi(price: number): number {\n    return toUiDecimals(price, QUOTE_DECIMALS - this.baseDecimals);\n  }\n\n  public baseLotsToUi(quantity: BN): number {\n    return parseFloat(quantity.toString()) * this.baseLotsToUiConverter;\n  }\n\n  public quoteLotsToUi(quantity: BN): number {\n    return parseFloat(quantity.toString()) * this.quoteLotsToUiConverter;\n  }\n\n  /**\n   * Returns a list of (upto count) accounts, and the pnl that is settle'able on this perp market,\n   * the list is sorted ascending for 'negative' direction and descending for 'positive' direction.\n   *\n   * NOTE: keep in sync with perp_pnl.rs:fetch_top\n   *\n   * TODO: replace with a more performant offchain service call\n   * @param client\n   * @param group\n   * @param direction\n   * @returns\n   */\n  public async getSettlePnlCandidates(\n    client: MangoClient,\n    group: Group,\n    direction: 'negative' | 'positive',\n    count = 2,\n  ): Promise<{ account: MangoAccount; settleablePnl: I80F48 }[]> {\n    let accountsWithSettleablePnl = (\n      await client.getAllMangoAccounts(group, true)\n    )\n      .filter((acc) => acc.perpPositionExistsForMarket(this))\n      .map((acc) => {\n        const pp = acc\n          .perpActive()\n          .find((pp) => pp.marketIndex === this.perpMarketIndex)!;\n\n        return {\n          account: acc,\n          settleablePnl: pp.getSettleablePnl(group, this, acc),\n        };\n      });\n\n    accountsWithSettleablePnl = accountsWithSettleablePnl\n      .filter(\n        (acc) =>\n          // need perp positions with -ve pnl to settle +ve pnl and vice versa\n          (direction === 'negative' && acc.settleablePnl.lt(ZERO_I80F48())) ||\n          (direction === 'positive' && acc.settleablePnl.gt(ZERO_I80F48())),\n      )\n      .sort((a, b) =>\n        direction === 'negative'\n          ? // most negative\n            a.settleablePnl.cmp(b.settleablePnl)\n          : // most positive\n            b.settleablePnl.cmp(a.settleablePnl),\n      );\n\n    if (direction === 'negative') {\n      let stable = 0;\n      for (let i = 0; i < accountsWithSettleablePnl.length; i++) {\n        const acc = accountsWithSettleablePnl[i];\n        const nextPnl =\n          i + 1 < accountsWithSettleablePnl.length\n            ? accountsWithSettleablePnl[i + 1].settleablePnl\n            : ZERO_I80F48();\n\n        const perpSettleHealth = acc.account.getPerpSettleHealth(group);\n        acc.settleablePnl =\n          // need positive settle health to settle against +ve pnl\n          perpSettleHealth.gt(ZERO_I80F48())\n            ? // can only settle min\n              acc.settleablePnl.max(perpSettleHealth.neg())\n            : ZERO_I80F48();\n\n        // If the ordering was unchanged `count` times we know we have the top `count` accounts\n        if (acc.settleablePnl.lte(nextPnl)) {\n          stable += 1;\n          if (stable >= count) {\n            break;\n          }\n        }\n      }\n    }\n\n    accountsWithSettleablePnl.sort((a, b) =>\n      direction === 'negative'\n        ? // most negative\n          a.settleablePnl.cmp(b.settleablePnl)\n        : // most positive\n          b.settleablePnl.cmp(a.settleablePnl),\n    );\n\n    return accountsWithSettleablePnl.slice(0, count);\n  }\n\n  toString(): string {\n    return (\n      'PerpMarket ' +\n      '\\n perpMarketIndex -' +\n      this.perpMarketIndex +\n      '\\n maintAssetWeight -' +\n      this.maintBaseAssetWeight.toString() +\n      '\\n initAssetWeight -' +\n      this.initBaseAssetWeight.toString() +\n      '\\n maintLiabWeight -' +\n      this.maintBaseLiabWeight.toString() +\n      '\\n initLiabWeight -' +\n      this.initBaseLiabWeight.toString() +\n      '\\n baseLiquidationFee -' +\n      this.baseLiquidationFee.toString() +\n      '\\n makerFee -' +\n      this.makerFee.toString() +\n      '\\n takerFee -' +\n      this.takerFee.toString()\n    );\n  }\n}\n\ninterface OrderTreeNodes {\n  bumpIndex: number;\n  freeListLen: number;\n  freeListHead: number;\n  nodes: [any];\n}\n\ninterface OrderTreeRoot {\n  maybeNode: number;\n  leafCount: number;\n}\n\nexport class BookSide {\n  private static INNER_NODE_TAG = 1;\n  private static LEAF_NODE_TAG = 2;\n  now: BN;\n\n  static from(\n    client: MangoClient,\n    perpMarket: PerpMarket,\n    bookSideType: BookSideType,\n    obj: {\n      roots: OrderTreeRoot[];\n      nodes: OrderTreeNodes;\n    },\n  ): BookSide {\n    return new BookSide(\n      client,\n      perpMarket,\n      bookSideType,\n      obj.roots[0],\n      obj.roots[1],\n      obj.nodes,\n    );\n  }\n\n  constructor(\n    public client: MangoClient,\n    public perpMarket: PerpMarket,\n    public type: BookSideType,\n    public rootFixed: OrderTreeRoot,\n    public rootOraclePegged: OrderTreeRoot,\n    public orderTreeNodes: OrderTreeNodes,\n    maxBookDelay?: number,\n  ) {\n    // Determine the maxTimestamp found on the book to use for tif\n    // If maxBookDelay is not provided, use 3600 as a very large number\n    maxBookDelay = maxBookDelay === undefined ? 3600 : maxBookDelay;\n    let maxTimestamp = new BN(new Date().getTime() / 1000 - maxBookDelay);\n    for (const node of this.orderTreeNodes.nodes) {\n      if (node.tag !== BookSide.LEAF_NODE_TAG) {\n        continue;\n      }\n\n      const leafNode = BookSide.toLeafNode(client, node.data);\n      if (leafNode.timestamp.gt(maxTimestamp)) {\n        maxTimestamp = leafNode.timestamp;\n      }\n    }\n    this.now = maxTimestamp;\n  }\n\n  static getPriceFromKey(key: BN): BN {\n    return key.ushrn(64);\n  }\n\n  /**\n   * iterates over all orders\n   */\n  public *items(): Generator<PerpOrder> {\n    function isBetter(\n      type: PerpOrderSide,\n      a: PerpOrder,\n      b: PerpOrder,\n    ): boolean {\n      return a.priceLots.eq(b.priceLots)\n        ? a.seqNum.lt(b.seqNum) // if prices are equal prefer perp orders in the order they are placed\n        : type === BookSideType.bids // else compare the actual prices\n        ? a.priceLots.gt(b.priceLots)\n        : b.priceLots.gt(a.priceLots);\n    }\n\n    const fGen = this.fixedItems();\n    const oPegGen = this.oraclePeggedItems();\n\n    let fOrderRes = fGen.next();\n    let oPegOrderRes = oPegGen.next();\n\n    while (true) {\n      if (fOrderRes.value && oPegOrderRes.value) {\n        if (isBetter(this.type, fOrderRes.value, oPegOrderRes.value)) {\n          yield fOrderRes.value;\n          fOrderRes = fGen.next();\n        } else {\n          yield oPegOrderRes.value;\n          oPegOrderRes = oPegGen.next();\n        }\n      } else if (fOrderRes.value && !oPegOrderRes.value) {\n        yield fOrderRes.value;\n        fOrderRes = fGen.next();\n      } else if (!fOrderRes.value && oPegOrderRes.value) {\n        yield oPegOrderRes.value;\n        oPegOrderRes = oPegGen.next();\n      } else if (!fOrderRes.value && !oPegOrderRes.value) {\n        break;\n      }\n    }\n  }\n\n  /**\n   * iterates over all orders,\n   * skips oracle pegged orders which are invalid due to oracle price crossing the peg limit,\n   * skips tif orders which are invalid due to tif having elapsed,\n   */\n  public *itemsValid(): Generator<PerpOrder> {\n    const itemsGen = this.items();\n    let itemsRes = itemsGen.next();\n    while (true) {\n      if (itemsRes.value) {\n        const val = itemsRes.value;\n        if (\n          !val.isExpired &&\n          (!val.isOraclePegged ||\n            (val.isOraclePegged && !val.oraclePeggedProperties.isInvalid))\n        ) {\n          yield val;\n        }\n        itemsRes = itemsGen.next();\n      } else {\n        break;\n      }\n    }\n  }\n\n  public *fixedItems(): Generator<PerpOrder> {\n    if (this.rootFixed.leafCount === 0) {\n      return;\n    }\n    const now = this.now;\n    const stack = [this.rootFixed.maybeNode];\n    const [left, right] = this.type === BookSideType.bids ? [1, 0] : [0, 1];\n\n    while (stack.length > 0) {\n      const index = stack.pop()!;\n      const node = this.orderTreeNodes.nodes[index];\n      if (node.tag === BookSide.INNER_NODE_TAG) {\n        const innerNode = BookSide.toInnerNode(this.client, node.data);\n        stack.push(innerNode.children[right], innerNode.children[left]);\n      } else if (node.tag === BookSide.LEAF_NODE_TAG) {\n        const leafNode = BookSide.toLeafNode(this.client, node.data);\n        const expiryTimestamp = leafNode.timeInForce\n          ? leafNode.timestamp.add(new BN(leafNode.timeInForce))\n          : U64_MAX_BN;\n\n        yield PerpOrder.from(\n          this.perpMarket,\n          leafNode,\n          this.type,\n          now.lt(expiryTimestamp),\n        );\n      }\n    }\n  }\n\n  public *oraclePeggedItems(): Generator<PerpOrder> {\n    if (this.rootOraclePegged.leafCount === 0) {\n      return;\n    }\n    const now = this.now;\n    const stack = [this.rootOraclePegged.maybeNode];\n    const [left, right] = this.type === BookSideType.bids ? [1, 0] : [0, 1];\n\n    while (stack.length > 0) {\n      const index = stack.pop()!;\n      const node = this.orderTreeNodes.nodes[index];\n      if (node.tag === BookSide.INNER_NODE_TAG) {\n        const innerNode = BookSide.toInnerNode(this.client, node.data);\n        stack.push(innerNode.children[right], innerNode.children[left]);\n      } else if (node.tag === BookSide.LEAF_NODE_TAG) {\n        const leafNode = BookSide.toLeafNode(this.client, node.data);\n        const expiryTimestamp = leafNode.timeInForce\n          ? leafNode.timestamp.add(new BN(leafNode.timeInForce))\n          : U64_MAX_BN;\n\n        yield PerpOrder.from(\n          this.perpMarket,\n          leafNode,\n          this.type,\n          now.lt(expiryTimestamp),\n          true,\n        );\n      }\n    }\n  }\n\n  public best(): PerpOrder | undefined {\n    return this.items().next().value;\n  }\n\n  getImpactPriceUi(baseLots: BN): number | undefined {\n    const s = new BN(0);\n    for (const order of this.items()) {\n      s.iadd(order.sizeLots);\n      if (s.gte(baseLots)) {\n        return order.uiPrice;\n      }\n    }\n    return undefined;\n  }\n\n  public getL2(depth: number): [number, number, BN, BN][] {\n    const levels: [BN, BN][] = [];\n    for (const { priceLots, sizeLots } of this.items()) {\n      if (levels.length > 0 && levels[levels.length - 1][0].eq(priceLots)) {\n        levels[levels.length - 1][1].iadd(sizeLots);\n      } else if (levels.length === depth) {\n        break;\n      } else {\n        levels.push([priceLots, sizeLots]);\n      }\n    }\n    return levels.map(([priceLots, sizeLots]) => [\n      this.perpMarket.priceLotsToUi(priceLots),\n      this.perpMarket.baseLotsToUi(sizeLots),\n      priceLots,\n      sizeLots,\n    ]);\n  }\n\n  public getL2Ui(depth: number): [number, number][] {\n    const levels: [number, number][] = [];\n    for (const { uiPrice: price, uiSize: size } of this.items()) {\n      if (levels.length > 0 && levels[levels.length - 1][0] === price) {\n        levels[levels.length - 1][1] += size;\n      } else if (levels.length === depth) {\n        break;\n      } else {\n        levels.push([price, size]);\n      }\n    }\n    return levels;\n  }\n\n  static toInnerNode(client: MangoClient, data: [number]): InnerNode {\n    return (client.program as any)._coder.types.typeLayouts\n      .get('InnerNode')\n      .decode(Buffer.from([BookSide.INNER_NODE_TAG].concat(data)));\n  }\n  static toLeafNode(client: MangoClient, data: [number]): LeafNode {\n    return LeafNode.from(\n      (client.program as any)._coder.types.typeLayouts\n        .get('LeafNode')\n        .decode(Buffer.from([BookSide.LEAF_NODE_TAG].concat(data))),\n    );\n  }\n}\n\nexport class BookSideType {\n  static bids = { bids: {} };\n  static asks = { asks: {} };\n}\nexport class LeafNode {\n  static from(obj: {\n    ownerSlot: number;\n    orderType: PerpOrderType;\n    timeInForce: number;\n    key: BN;\n    owner: PublicKey;\n    quantity: BN;\n    timestamp: BN;\n    pegLimit: BN;\n  }): LeafNode {\n    return new LeafNode(\n      obj.ownerSlot,\n      obj.orderType,\n      obj.timeInForce,\n      obj.key,\n      obj.owner,\n      obj.quantity,\n      obj.timestamp,\n      obj.pegLimit,\n    );\n  }\n\n  constructor(\n    public ownerSlot: number,\n    public orderType: PerpOrderType,\n    public timeInForce: number,\n    public key: BN,\n    public owner: PublicKey,\n    public quantity: BN,\n    public timestamp: BN,\n    public pegLimit: BN,\n  ) {}\n}\nexport class InnerNode {\n  static from(obj: { children: [number] }): InnerNode {\n    return new InnerNode(obj.children);\n  }\n\n  constructor(public children: [number]) {}\n}\n\nexport class PerpOrderSide {\n  static bid = { bid: {} };\n  static ask = { ask: {} };\n}\n\nexport class PerpOrderType {\n  static limit = { limit: {} };\n  static immediateOrCancel = { immediateOrCancel: {} };\n  static postOnly = { postOnly: {} };\n  static market = { market: {} };\n  static postOnlySlide = { postOnlySlide: {} };\n}\n\nexport class PerpOrder {\n  static from(\n    perpMarket: PerpMarket,\n    leafNode: LeafNode,\n    type: BookSideType,\n    isExpired = false,\n    isOraclePegged = false,\n  ): PerpOrder {\n    const side =\n      type == BookSideType.bids ? PerpOrderSide.bid : PerpOrderSide.ask;\n    let priceLots;\n    let oraclePeggedProperties;\n    if (isOraclePegged) {\n      const priceData = leafNode.key.ushrn(64);\n      const priceOffset = priceData.sub(new BN(1).ushln(63));\n      priceLots = perpMarket.uiPriceToLots(perpMarket.uiPrice).add(priceOffset);\n      const isInvalid =\n        type === BookSideType.bids\n          ? priceLots.gt(leafNode.pegLimit)\n          : leafNode.pegLimit.gt(priceLots);\n      oraclePeggedProperties = {\n        isInvalid,\n        priceOffset,\n        uiPriceOffset: perpMarket.priceLotsToUi(priceOffset),\n        pegLimit: leafNode.pegLimit,\n        uiPegLimit: perpMarket.priceLotsToUi(leafNode.pegLimit),\n      } as OraclePeggedProperties;\n    } else {\n      priceLots = BookSide.getPriceFromKey(leafNode.key);\n    }\n    const expiryTimestamp = leafNode.timeInForce\n      ? leafNode.timestamp.add(new BN(leafNode.timeInForce))\n      : U64_MAX_BN;\n\n    return new PerpOrder(\n      type === BookSideType.bids\n        ? RUST_U64_MAX().sub(leafNode.key.maskn(64))\n        : leafNode.key.maskn(64),\n      leafNode.key,\n      leafNode.owner,\n      leafNode.ownerSlot,\n      0,\n      perpMarket.priceLotsToUi(priceLots),\n      priceLots,\n      perpMarket.baseLotsToUi(leafNode.quantity),\n      leafNode.quantity,\n      side,\n      leafNode.timestamp,\n      expiryTimestamp,\n      perpMarket.perpMarketIndex,\n      isExpired,\n      isOraclePegged,\n      oraclePeggedProperties,\n    );\n  }\n\n  constructor(\n    public seqNum: BN,\n    public orderId: BN,\n    public owner: PublicKey,\n    public openOrdersSlot: number,\n    public feeTier: 0,\n    public uiPrice: number,\n    public priceLots: BN,\n    public uiSize: number,\n    public sizeLots: BN,\n    public side: PerpOrderSide,\n    public timestamp: BN,\n    public expiryTimestamp: BN,\n    public perpMarketIndex: number,\n    public isExpired = false,\n    public isOraclePegged = false,\n    public oraclePeggedProperties?: OraclePeggedProperties,\n  ) {}\n\n  get price(): number {\n    return this.uiPrice;\n  }\n\n  get size(): number {\n    return this.uiSize;\n  }\n}\n\ninterface OraclePeggedProperties {\n  isInvalid: boolean;\n  priceOffset: BN;\n  uiPriceOffset: number;\n  pegLimit: BN;\n  uiPegLimit: number;\n}\n\nexport class PerpEventQueue {\n  static FILL_EVENT_TYPE = 0;\n  static OUT_EVENT_TYPE = 1;\n  static LIQUIDATE_EVENT_TYPE = 2;\n  public head: number;\n  public count: number;\n  public seqNum: BN;\n  public rawEvents: (OutEvent | FillEvent | LiquidateEvent)[];\n  constructor(\n    client: MangoClient,\n    header: { head: number; count: number; seqNum: BN },\n    buf,\n  ) {\n    this.head = header.head;\n    this.count = header.count;\n    this.seqNum = header.seqNum;\n    this.rawEvents = buf.map((event) => {\n      if (event.eventType === PerpEventQueue.FILL_EVENT_TYPE) {\n        return (client.program as any)._coder.types.typeLayouts\n          .get('FillEvent')\n          .decode(\n            Buffer.from([PerpEventQueue.FILL_EVENT_TYPE].concat(event.padding)),\n          );\n      } else if (event.eventType === PerpEventQueue.OUT_EVENT_TYPE) {\n        return (client.program as any)._coder.types.typeLayouts\n          .get('OutEvent')\n          .decode(\n            Buffer.from([PerpEventQueue.OUT_EVENT_TYPE].concat(event.padding)),\n          );\n      } else if (event.eventType === PerpEventQueue.LIQUIDATE_EVENT_TYPE) {\n        return (client.program as any)._coder.types.typeLayouts\n          .get('LiquidateEvent')\n          .decode(\n            Buffer.from(\n              [PerpEventQueue.LIQUIDATE_EVENT_TYPE].concat(event.padding),\n            ),\n          );\n      }\n      throw new Error(`Unknown event with eventType ${event.eventType}!`);\n    });\n  }\n\n  public getUnconsumedEvents(): (OutEvent | FillEvent | LiquidateEvent)[] {\n    const events: (OutEvent | FillEvent | LiquidateEvent)[] = [];\n    const head = this.head;\n    for (let i = 0; i < this.count; i++) {\n      events.push(this.rawEvents[(head + i) % this.rawEvents.length]);\n    }\n    return events;\n  }\n\n  public eventsSince(\n    lastSeqNum?: BN,\n  ): (OutEvent | FillEvent | LiquidateEvent)[] {\n    return this.rawEvents\n      .filter((e) =>\n        e.seqNum.gt(lastSeqNum === undefined ? new BN(0) : lastSeqNum),\n      )\n      .sort((a, b) => a.seqNum.cmp(b.seqNum));\n  }\n}\n\nexport interface Event {\n  eventType: number;\n}\n\nexport interface OutEvent extends Event {\n  side: PerpOrderType;\n  ownerSlot: number;\n  timestamp: BN;\n  seqNum: BN;\n  owner: PublicKey;\n  quantity: BN;\n}\n\nexport interface FillEvent extends Event {\n  takerSide: PerpOrderType;\n  makerOut: boolean;\n  makerSlot: number;\n  timestamp: BN;\n  seqNum: BN;\n  maker: PublicKey;\n  makerOrderId: BN;\n  makerFee: I80F48;\n  makerTimestamp: BN;\n  taker: PublicKey;\n  takerOrderId: BN;\n  takerClientOrderId: BN;\n  takerFee: I80F48;\n  price: BN;\n  quantity: BN;\n}\n\nexport interface LiquidateEvent extends Event {\n  seqNum: BN;\n}\n"]}