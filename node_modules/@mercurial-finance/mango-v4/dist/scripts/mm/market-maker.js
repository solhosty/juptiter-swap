"use strict"; function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }



var _chunkSIOG45C4js = require('../../chunk-SIOG45C4.js');


var _chunk6NQYHTRKjs = require('../../chunk-6NQYHTRK.js');


var _chunkHFEILVW4js = require('../../chunk-HFEILVW4.js');


var _chunkA355EMTIjs = require('../../chunk-A355EMTI.js');
require('../../chunk-74ANAXXV.js');


var _chunkC3X3GVS5js = require('../../chunk-C3X3GVS5.js');
require('../../chunk-UGHO4YHY.js');
require('../../chunk-3ZYUOGD4.js');



var _chunkZYSI4CYOjs = require('../../chunk-ZYSI4CYO.js');


var _chunkS6N5Y2X2js = require('../../chunk-S6N5Y2X2.js');


var _chunk772SHZWXjs = require('../../chunk-772SHZWX.js');
require('../../chunk-S3PQ6OXS.js');
require('../../chunk-WKB2GIFW.js');
require('../../chunk-TBVE5N24.js');
require('../../chunk-Y7A4QF6J.js');
require('../../chunk-JC4IRQUL.js');

// ts/client/src/scripts/mm/market-maker.ts
var _anchor = require('@project-serum/anchor');




var _web3js = require('@solana/web3.js');
var _binanceapinode = require('binance-api-node'); var _binanceapinode2 = _interopRequireDefault(_binanceapinode);
var _fs = require('fs'); var _fs2 = _interopRequireDefault(_fs);
var _nodekrakenapi = require('node-kraken-api');
var _path = require('path'); var _path2 = _interopRequireDefault(_path);
console.log(_chunk6NQYHTRKjs.default_exports);
var CLUSTER = process.env.CLUSTER_OVERRIDE || "mainnet-beta";
var CLUSTER_URL = process.env.CLUSTER_URL_OVERRIDE || process.env.MB_CLUSTER_URL;
var USER_KEYPAIR = process.env.USER_KEYPAIR_OVERRIDE || process.env.MB_PAYER_KEYPAIR;
var MANGO_ACCOUNT_PK = process.env.MANGO_ACCOUNT_PK || "";
var paramsFileName = process.env.PARAMS || "default.json";
var params = JSON.parse(
  _fs2.default.readFileSync(
    _path2.default.resolve(__dirname, `./params/${paramsFileName}`),
    "utf-8"
  )
);
var control = { isRunning: true, interval: params.interval };
var binanceClient = _binanceapinode2.default.call(void 0, );
var krakenClient = new (0, _nodekrakenapi.Kraken)();
function getPerpMarketAssetsToTradeOn(group) {
  const allMangoGroupPerpMarketAssets = Array.from(
    group.perpMarketsMapByName.keys()
  ).map((marketName) => marketName.replace("-PERP", ""));
  return Object.keys(params.assets).filter(
    (asset) => allMangoGroupPerpMarketAssets.includes(asset)
  );
}
async function refreshState(client, group, mangoAccount, marketContexts) {
  const ts = Date.now() / 1e3;
  const result = await Promise.all([
    group.reloadAll(client),
    mangoAccount.reload(client),
    ...Array.from(marketContexts.values()).map(
      (mc) => krakenClient.depth({
        pair: mc.params.krakenCode
      })
      // binanceClient.book({
      //   symbol: mc.perpMarket.name.replace('-PERP', 'USDT'),
      // }),
    )
  ]);
  Array.from(marketContexts.values()).map(async (mc, i) => {
    const perpMarket = mc.perpMarket;
    mc.perpMarket = group.getPerpMarketByMarketIndex(
      perpMarket.perpMarketIndex
    );
    mc.bids = await perpMarket.loadBids(client, true);
    mc.asks = await perpMarket.loadAsks(client, true);
    mc.lastBookUpdate = ts;
    mc.krakenAsk = parseFloat(
      result[i + 2][mc.params.krakenCode].asks[0][0]
    );
    mc.krakenBid = parseFloat(
      result[i + 2][mc.params.krakenCode].bids[0][0]
    );
  });
  return {
    mangoAccount,
    lastMangoAccountUpdate: ts,
    marketContexts
  };
}
async function initSequenceEnforcerAccounts(client, marketContexts) {
  const seqAccIxs = marketContexts.map(
    (mc) => _chunkSIOG45C4js.makeInitSequenceEnforcerAccountIx.call(void 0, 
      mc.sequenceAccount,
      client.program.provider.wallet.publicKey,
      mc.sequenceAccountBump,
      mc.perpMarket.name,
      CLUSTER
    )
  );
  while (true) {
    try {
      const sig = await _chunkA355EMTIjs.sendTransaction.call(void 0, 
        client.program.provider,
        seqAccIxs,
        []
      );
      console.log(
        `Sequence enforcer accounts created, sig https://explorer.solana.com/tx/${sig}?cluster=${CLUSTER == "devnet" ? "devnet" : ""}`
      );
    } catch (e) {
      console.log("Failed to initialize sequence enforcer accounts!");
      console.log(e);
      continue;
    }
    break;
  }
}
async function cancelAllOrdersForAMarket(client, group, mangoAccount, perpMarket) {
  for (const i of Array(100).keys()) {
    await _chunkA355EMTIjs.sendTransaction.call(void 0, 
      client.program.provider,
      [
        await client.perpCancelAllOrdersIx(
          group,
          mangoAccount,
          perpMarket.perpMarketIndex,
          10
        )
      ],
      []
    );
    await mangoAccount.reload(client);
    if ((await mangoAccount.loadPerpOpenOrdersForMarket(
      client,
      group,
      perpMarket.perpMarketIndex
    )).length === 0) {
      break;
    }
  }
}
async function onExit(client, group, mangoAccount, marketContexts) {
  for (const mc of marketContexts) {
    cancelAllOrdersForAMarket(client, group, mangoAccount, mc.perpMarket);
  }
}
async function fullMarketMaker() {
  const options = _anchor.AnchorProvider.defaultOptions();
  const connection = new (0, _web3js.Connection)(CLUSTER_URL, options);
  const user = _web3js.Keypair.fromSecretKey(
    Buffer.from(
      JSON.parse(
        process.env.KEYPAIR || _fs2.default.readFileSync(USER_KEYPAIR, "utf-8")
      )
    )
  );
  const userWallet = new (0, _anchor.Wallet)(user);
  const userProvider = new (0, _anchor.AnchorProvider)(connection, userWallet, options);
  const client = await _chunkHFEILVW4js.MangoClient.connect(
    userProvider,
    CLUSTER,
    _chunkS6N5Y2X2js.MANGO_V4_ID[CLUSTER],
    {
      idsSource: "get-program-accounts"
    }
  );
  let mangoAccount = await client.getMangoAccount(
    new (0, _web3js.PublicKey)(MANGO_ACCOUNT_PK)
  );
  console.log(
    `MangoAccount ${mangoAccount.publicKey} for user ${user.publicKey} ${mangoAccount.isDelegate(client) ? "via delegate " + user.publicKey : ""}`
  );
  await mangoAccount.reload(client);
  const group = await client.getGroup(mangoAccount.group);
  await group.reloadAll(client);
  for (const perpMarket of Array.from(
    group.perpMarketsMapByMarketIndex.values()
  )) {
    await client.perpCancelAllOrders(
      group,
      mangoAccount,
      perpMarket.perpMarketIndex,
      10
    );
  }
  const marketContexts = /* @__PURE__ */ new Map();
  for (const perpMarketAsset of getPerpMarketAssetsToTradeOn(group)) {
    const perpMarket = group.getPerpMarketByName(perpMarketAsset + "-PERP");
    const [sequenceAccount, sequenceAccountBump] = await _web3js.PublicKey.findProgramAddress(
      [
        Buffer.from(perpMarket.name, "utf-8"),
        client.program.provider.wallet.publicKey.toBytes()
      ],
      _chunkSIOG45C4js.seqEnforcerProgramIds[CLUSTER]
    );
    marketContexts.set(perpMarket.perpMarketIndex, {
      params: params.assets[perpMarketAsset].perp,
      perpMarket,
      bids: await perpMarket.loadBids(client),
      asks: await perpMarket.loadAsks(client),
      lastBookUpdate: 0,
      sequenceAccount,
      sequenceAccountBump,
      sentBidPrice: 0,
      sentAskPrice: 0,
      lastOrderUpdate: 0,
      krakenBid: void 0,
      krakenAsk: void 0
    });
  }
  await initSequenceEnforcerAccounts(
    client,
    Array.from(marketContexts.values())
  );
  console.log(`Loading state first time`);
  let state = await refreshState(client, group, mangoAccount, marketContexts);
  process.on("SIGINT", function() {
    console.log("Caught keyboard interrupt. Canceling orders");
    control.isRunning = false;
    onExit(client, group, mangoAccount, Array.from(marketContexts.values()));
  });
  while (control.isRunning) {
    try {
      console.log(`
Refreshing state`);
      refreshState(client, group, mangoAccount, marketContexts).then(
        (result) => state = result
      );
      mangoAccount = state.mangoAccount;
      let pfQuoteValue = 0;
      for (const mc of Array.from(marketContexts.values())) {
        const pos = mangoAccount.perpPositionExistsForMarket(mc.perpMarket) ? mangoAccount.getPerpPositionUi(group, mc.perpMarket.perpMarketIndex) : 0;
        const mid = (mc.krakenBid + mc.krakenAsk) / 2;
        if (mid) {
          pfQuoteValue += pos * mid;
        } else {
          pfQuoteValue = void 0;
          console.log(
            `Breaking pfQuoteValue computation, since mid is undefined for ${mc.perpMarket.name}!`
          );
          break;
        }
      }
      if (pfQuoteValue === void 0) {
        console.log(
          `Continuing control loop, since pfQuoteValue is undefined!`
        );
        continue;
      }
      for (const mc of Array.from(marketContexts.values())) {
        const ixs = await makeMarketUpdateInstructions(
          client,
          group,
          mangoAccount,
          mc,
          pfQuoteValue
        );
        if (ixs.length === 0) {
          continue;
        }
        const sig = await _chunkA355EMTIjs.sendTransaction.call(void 0, 
          client.program.provider,
          ixs,
          group.addressLookupTablesList
        );
        console.log(
          `Orders for market updated, sig https://explorer.solana.com/tx/${sig}?cluster=${CLUSTER == "devnet" ? "devnet" : ""}`
        );
      }
    } catch (e) {
      console.log(e);
    } finally {
      console.log(
        `${(/* @__PURE__ */ new Date()).toUTCString()} sleeping for ${control.interval / 1e3}s`
      );
      await new Promise((r) => setTimeout(r, control.interval));
    }
  }
}
async function makeMarketUpdateInstructions(client, group, mangoAccount, mc, pfQuoteValue) {
  const perpMarketIndex = mc.perpMarket.perpMarketIndex;
  const perpMarket = mc.perpMarket;
  const aggBid = mc.krakenBid;
  const aggAsk = mc.krakenAsk;
  if (aggBid === void 0 || aggAsk === void 0) {
    console.log(`No Aggregate Book for ${mc.perpMarket.name}!`);
    return [];
  }
  const leanCoeff = mc.params.leanCoeff;
  const fairValue = (aggBid + aggAsk) / 2;
  const aggSpread = (aggAsk - aggBid) / fairValue;
  const requoteThresh = mc.params.requoteThresh;
  const equity = _chunk772SHZWXjs.toUiDecimalsForQuote.call(void 0, mangoAccount.getEquity(group));
  const sizePerc = mc.params.sizePerc;
  const quoteSize = equity * sizePerc;
  const size = quoteSize / fairValue;
  const basePos = mangoAccount.perpPositionExistsForMarket(mc.perpMarket) ? mangoAccount.getPerpPositionUi(group, perpMarketIndex, true) : 0;
  const unsettledPnl = mangoAccount.perpPositionExistsForMarket(mc.perpMarket) ? mangoAccount.getPerpPosition(perpMarketIndex).getUnsettledPnlUi(perpMarket) : 0;
  const lean = -leanCoeff * basePos / size;
  const pfQuoteLeanCoeff = params.pfQuoteLeanCoeff || 1e-3;
  const pfQuoteLean = pfQuoteValue / equity * -pfQuoteLeanCoeff;
  const charge = (mc.params.charge || 12e-4) + aggSpread / 2;
  const bias = mc.params.bias;
  const fairValueInLots = perpMarket.uiPriceToLots(fairValue);
  const nativeBidSize = perpMarket.uiBaseToLots(size);
  const nativeAskSize = perpMarket.uiBaseToLots(size);
  const bids = mc.bids;
  const asks = mc.asks;
  const bestBid = bids.best();
  const bestAsk = asks.best();
  let moveOrders = false;
  const instructions = [
    _chunkSIOG45C4js.makeCheckAndSetSequenceNumberIx.call(void 0, 
      mc.sequenceAccount,
      client.program.provider.wallet.publicKey,
      Date.now(),
      CLUSTER
    )
  ];
  instructions.push(
    await client.healthRegionBeginIx(group, mangoAccount, [], [perpMarket])
  );
  const expiryTimestamp = params.tif !== void 0 ? Date.now() / 1e3 + params.tif : 0;
  if (params.oraclePegged) {
    const uiOPegBidOffset = fairValue * (-charge + lean + bias + pfQuoteLean);
    const uiOPegAskOffset = fairValue * (charge + lean + bias + pfQuoteLean);
    const modelBidOPegOffset = perpMarket.uiPriceToLots(uiOPegBidOffset);
    const modelAskOPegOffset = perpMarket.uiPriceToLots(uiOPegAskOffset);
    const bookAdjBidOPegOffset = _optionalChain([bestAsk, 'optionalAccess', _ => _.priceLots, 'access', _2 => _2.sub, 'call', _3 => _3(new (0, _anchor.BN)(1)), 'access', _4 => _4.lt, 'call', _5 => _5(fairValueInLots.add(modelBidOPegOffset))]) ? fairValueInLots.sub(bestAsk.priceLots.sub(new (0, _anchor.BN)(1))) : modelBidOPegOffset;
    const bookAdjAskOPegOffset = _optionalChain([bestBid, 'optionalAccess', _6 => _6.priceLots, 'access', _7 => _7.add, 'call', _8 => _8(new (0, _anchor.BN)(1)), 'access', _9 => _9.gt, 'call', _10 => _10(fairValueInLots.add(modelAskOPegOffset))]) ? bestBid.priceLots.sub(new (0, _anchor.BN)(1)).sub(fairValueInLots) : modelAskOPegOffset;
    const openOrders = await mangoAccount.loadPerpOpenOrdersForMarket(
      client,
      group,
      perpMarketIndex
    );
    moveOrders = openOrders.length < 2;
    const placeBidOPegIx = await client.perpPlaceOrderPeggedIx(
      group,
      mangoAccount,
      perpMarketIndex,
      _chunkZYSI4CYOjs.PerpOrderSide.bid,
      perpMarket.priceLotsToUi(bookAdjBidOPegOffset),
      perpMarket.priceLotsToUi(
        fairValueInLots.mul(new (0, _anchor.BN)(101)).div(new (0, _anchor.BN)(100))
      ),
      perpMarket.baseLotsToUi(nativeBidSize),
      void 0,
      Date.now(),
      _chunkZYSI4CYOjs.PerpOrderType.limit,
      false,
      expiryTimestamp,
      20
    );
    const placeAskOPegIx = await client.perpPlaceOrderPeggedIx(
      group,
      mangoAccount,
      perpMarketIndex,
      _chunkZYSI4CYOjs.PerpOrderSide.ask,
      perpMarket.priceLotsToUi(bookAdjAskOPegOffset),
      perpMarket.priceLotsToUi(
        fairValueInLots.mul(new (0, _anchor.BN)(98)).div(new (0, _anchor.BN)(100))
      ),
      perpMarket.baseLotsToUi(nativeAskSize),
      void 0,
      Date.now(),
      _chunkZYSI4CYOjs.PerpOrderType.limit,
      false,
      expiryTimestamp,
      20
    );
    const posAsTradeSizes = basePos / size;
    if (posAsTradeSizes < 15) {
      instructions.push(placeBidOPegIx);
    }
    if (posAsTradeSizes > -15) {
      instructions.push(placeAskOPegIx);
    }
    const approxOPegBidPrice = perpMarket.priceLotsToUi(
      fairValueInLots.add(bookAdjBidOPegOffset)
    );
    const approxOPegAskPrice = perpMarket.priceLotsToUi(
      fairValueInLots.add(bookAdjAskOPegOffset)
    );
    if (posAsTradeSizes < 15 || posAsTradeSizes > -15) {
      console.log(
        `Requoting for market ${mc.perpMarket.name} sentBid: ${mc.sentBidPrice} newBid: ${approxOPegBidPrice} sentAsk: ${mc.sentAskPrice} newAsk: ${approxOPegAskPrice} pfLean: ${(pfQuoteLean * 1e4).toFixed(
          1
        )} aggBid: ${aggBid} addAsk: ${aggAsk}`
      );
      mc.sentBidPrice = approxOPegAskPrice;
      mc.sentAskPrice = approxOPegAskPrice;
      mc.lastOrderUpdate = Date.now() / 1e3;
    }
  } else {
    const uiBidPrice = fairValue * (1 - charge + lean + bias + pfQuoteLean);
    const uiAskPrice = fairValue * (1 + charge + lean + bias + pfQuoteLean);
    const modelBidPrice = perpMarket.uiPriceToLots(uiBidPrice);
    const modelAskPrice = perpMarket.uiPriceToLots(uiAskPrice);
    const bookAdjBid = bestAsk !== void 0 ? _anchor.BN.min(bestAsk.priceLots.sub(new (0, _anchor.BN)(1)), modelBidPrice) : modelBidPrice;
    const bookAdjAsk = bestBid !== void 0 ? _anchor.BN.max(bestBid.priceLots.add(new (0, _anchor.BN)(1)), modelAskPrice) : modelAskPrice;
    if (mc.lastBookUpdate >= mc.lastOrderUpdate + 2) {
      const openOrders = await mangoAccount.loadPerpOpenOrdersForMarket(
        client,
        group,
        perpMarketIndex
      );
      moveOrders = openOrders.length < 2 || openOrders.length > 2;
      for (const o of openOrders) {
        const refPrice = o.side === "buy" ? bookAdjBid : bookAdjAsk;
        moveOrders = moveOrders || Math.abs(o.priceLots.toNumber() / refPrice.toNumber() - 1) > requoteThresh;
      }
    } else {
      moveOrders = moveOrders || Math.abs(mc.sentBidPrice / bookAdjBid.toNumber() - 1) > requoteThresh || Math.abs(mc.sentAskPrice / bookAdjAsk.toNumber() - 1) > requoteThresh;
    }
    if (moveOrders) {
      const cancelAllIx = await client.perpCancelAllOrdersIx(
        group,
        mangoAccount,
        perpMarketIndex,
        10
      );
      const placeBidIx = await client.perpPlaceOrderIx(
        group,
        mangoAccount,
        perpMarketIndex,
        _chunkZYSI4CYOjs.PerpOrderSide.bid,
        perpMarket.priceLotsToUi(bookAdjBid),
        perpMarket.baseLotsToUi(nativeBidSize),
        void 0,
        Date.now(),
        _chunkZYSI4CYOjs.PerpOrderType.postOnlySlide,
        false,
        expiryTimestamp,
        20
      );
      const placeAskIx = await client.perpPlaceOrderIx(
        group,
        mangoAccount,
        perpMarketIndex,
        _chunkZYSI4CYOjs.PerpOrderSide.ask,
        perpMarket.priceLotsToUi(bookAdjAsk),
        perpMarket.baseLotsToUi(nativeAskSize),
        void 0,
        Date.now(),
        _chunkZYSI4CYOjs.PerpOrderType.postOnlySlide,
        false,
        expiryTimestamp,
        20
      );
      const posAsTradeSizes = basePos / size;
      instructions.push(cancelAllIx);
      if (posAsTradeSizes < 15) {
        instructions.push(placeBidIx);
      }
      if (posAsTradeSizes > -15) {
        instructions.push(placeAskIx);
      }
      console.log(
        `
Requoting for market ${mc.perpMarket.name} sentBid: ${mc.sentBidPrice} newBid: ${bookAdjBid} sentAsk: ${mc.sentAskPrice} newAsk: ${bookAdjAsk} pfLean: ${(pfQuoteLean * 1e4).toFixed(
          1
        )} aggBid: ${aggBid} addAsk: ${aggAsk}`
      );
      console.log(
        `Health ratio ${mangoAccount.getHealthRatio(group, _chunkC3X3GVS5js.HealthType.maint).toFixed(3)}, maint health ${_chunk772SHZWXjs.toUiDecimalsForQuote.call(void 0, 
          mangoAccount.getHealth(group, _chunkC3X3GVS5js.HealthType.maint)
        ).toFixed(3)}, account equity ${equity.toFixed(
          3
        )}, base position ${Math.abs(basePos).toFixed(3)} ${basePos >= 0 ? "LONG" : "SHORT"}, notional ${Math.abs(basePos * perpMarket.uiPrice).toFixed(
          3
        )}, unsettled Pnl ${unsettledPnl.toFixed(3)}`
      );
      mc.sentBidPrice = bookAdjBid.toNumber();
      mc.sentAskPrice = bookAdjAsk.toNumber();
      mc.lastOrderUpdate = Date.now() / 1e3;
    } else {
      console.log(
        `Not requoting for market ${mc.perpMarket.name}. No need to move orders`
      );
    }
  }
  instructions.push(
    await client.healthRegionEndIx(group, mangoAccount, [], [perpMarket])
  );
  if (instructions.length === 3) {
    return [];
  } else {
    return instructions;
  }
}
function startMarketMaker() {
  try {
    if (control.isRunning) {
      fullMarketMaker().catch((error) => console.log(error)).finally(startMarketMaker);
    }
  } catch (error) {
    console.log(error);
  }
}
startMarketMaker();
//# sourceMappingURL=market-maker.js.map