"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _nullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } } function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }// ts/client/src/utils/rpc.ts
var _nodewallet = require('@project-serum/anchor/dist/cjs/nodewallet'); var _nodewallet2 = _interopRequireDefault(_nodewallet);




var _web3js = require('@solana/web3.js');
async function sendTransaction(provider, ixs, alts, opts = {}) {
  const connection = provider.connection;
  const latestBlockhash = await connection.getLatestBlockhash(
    _nullishCoalesce(_nullishCoalesce(opts.preflightCommitment, () => ( provider.opts.preflightCommitment)), () => ( "finalized"))
  );
  const payer = provider.wallet;
  if (opts.prioritizationFee) {
    ixs = [createComputeBudgetIx(opts.prioritizationFee), ...ixs];
  }
  const message = _web3js.MessageV0.compile({
    payerKey: provider.wallet.publicKey,
    instructions: ixs,
    recentBlockhash: latestBlockhash.blockhash,
    addressLookupTableAccounts: alts
  });
  let vtx = new (0, _web3js.VersionedTransaction)(message);
  if (_optionalChain([opts, 'optionalAccess', _ => _.additionalSigners, 'optionalAccess', _2 => _2.length])) {
    vtx.sign([..._optionalChain([opts, 'optionalAccess', _3 => _3.additionalSigners])]);
  }
  if (typeof payer.signTransaction === "function" && !(payer instanceof _nodewallet2.default)) {
    vtx = await payer.signTransaction(
      vtx
    );
  } else {
    vtx.sign([payer.payer]);
  }
  const signature = await connection.sendRawTransaction(vtx.serialize(), {
    skipPreflight: true
    // mergedOpts.skipPreflight,
  });
  if (opts.postSendTxCallback) {
    try {
      opts.postSendTxCallback({ txid: signature });
    } catch (e) {
      console.warn(`postSendTxCallback error ${e}`);
    }
  }
  const txConfirmationCommitment = _nullishCoalesce(opts.txConfirmationCommitment, () => ( "processed"));
  let status;
  if (latestBlockhash.blockhash != null && latestBlockhash.lastValidBlockHeight != null) {
    status = (await connection.confirmTransaction(
      {
        signature,
        blockhash: latestBlockhash.blockhash,
        lastValidBlockHeight: latestBlockhash.lastValidBlockHeight
      },
      txConfirmationCommitment
    )).value;
  } else {
    status = (await connection.confirmTransaction(signature, txConfirmationCommitment)).value;
  }
  if (status.err) {
    console.warn("Tx status: ", status);
    throw new MangoError({
      txid: signature,
      message: `${JSON.stringify(status)}`
    });
  }
  return signature;
}
var createComputeBudgetIx = (microLamports) => {
  const computeBudgetIx = _web3js.ComputeBudgetProgram.setComputeUnitPrice({
    microLamports
  });
  return computeBudgetIx;
};
var MangoError = class extends Error {
  constructor({ txid, message }) {
    super();
    this.message = message;
    this.txid = txid;
  }
};




exports.sendTransaction = sendTransaction; exports.createComputeBudgetIx = createComputeBudgetIx;
//# sourceMappingURL=chunk-A355EMTI.js.map