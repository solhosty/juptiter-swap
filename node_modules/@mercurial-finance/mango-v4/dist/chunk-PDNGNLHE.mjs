// ts/client/src/utils/rpc.ts
import NodeWallet from "@project-serum/anchor/dist/cjs/nodewallet";
import {
  ComputeBudgetProgram,
  MessageV0,
  VersionedTransaction
} from "@solana/web3.js";
async function sendTransaction(provider, ixs, alts, opts = {}) {
  const connection = provider.connection;
  const latestBlockhash = await connection.getLatestBlockhash(
    opts.preflightCommitment ?? provider.opts.preflightCommitment ?? "finalized"
  );
  const payer = provider.wallet;
  if (opts.prioritizationFee) {
    ixs = [createComputeBudgetIx(opts.prioritizationFee), ...ixs];
  }
  const message = MessageV0.compile({
    payerKey: provider.wallet.publicKey,
    instructions: ixs,
    recentBlockhash: latestBlockhash.blockhash,
    addressLookupTableAccounts: alts
  });
  let vtx = new VersionedTransaction(message);
  if (opts?.additionalSigners?.length) {
    vtx.sign([...opts?.additionalSigners]);
  }
  if (typeof payer.signTransaction === "function" && !(payer instanceof NodeWallet)) {
    vtx = await payer.signTransaction(
      vtx
    );
  } else {
    vtx.sign([payer.payer]);
  }
  const signature = await connection.sendRawTransaction(vtx.serialize(), {
    skipPreflight: true
    // mergedOpts.skipPreflight,
  });
  if (opts.postSendTxCallback) {
    try {
      opts.postSendTxCallback({ txid: signature });
    } catch (e) {
      console.warn(`postSendTxCallback error ${e}`);
    }
  }
  const txConfirmationCommitment = opts.txConfirmationCommitment ?? "processed";
  let status;
  if (latestBlockhash.blockhash != null && latestBlockhash.lastValidBlockHeight != null) {
    status = (await connection.confirmTransaction(
      {
        signature,
        blockhash: latestBlockhash.blockhash,
        lastValidBlockHeight: latestBlockhash.lastValidBlockHeight
      },
      txConfirmationCommitment
    )).value;
  } else {
    status = (await connection.confirmTransaction(signature, txConfirmationCommitment)).value;
  }
  if (status.err) {
    console.warn("Tx status: ", status);
    throw new MangoError({
      txid: signature,
      message: `${JSON.stringify(status)}`
    });
  }
  return signature;
}
var createComputeBudgetIx = (microLamports) => {
  const computeBudgetIx = ComputeBudgetProgram.setComputeUnitPrice({
    microLamports
  });
  return computeBudgetIx;
};
var MangoError = class extends Error {
  constructor({ txid, message }) {
    super();
    this.message = message;
    this.txid = txid;
  }
};

export {
  sendTransaction,
  createComputeBudgetIx
};
//# sourceMappingURL=chunk-PDNGNLHE.mjs.map