"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } } function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _nullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } } function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }// src/instructions/lending/borrowObligationLiquidity.ts



var _web3js = require('@solana/web3.js');
var _spltoken = require('@solana/spl-token');
var _bufferlayout = require('@solana/buffer-layout'); var BufferLayout2 = _interopRequireWildcard(_bufferlayout); var BufferLayout = _interopRequireWildcard(_bufferlayout); var BufferLayout3 = _interopRequireWildcard(_bufferlayout); var BufferLayout4 = _interopRequireWildcard(_bufferlayout); var BufferLayout5 = _interopRequireWildcard(_bufferlayout); var BufferLayout6 = _interopRequireWildcard(_bufferlayout); var BufferLayout7 = _interopRequireWildcard(_bufferlayout); var BufferLayout9 = _interopRequireWildcard(_bufferlayout); var BufferLayout8 = _interopRequireWildcard(_bufferlayout); var BufferLayout14 = _interopRequireWildcard(_bufferlayout); var BufferLayout12 = _interopRequireWildcard(_bufferlayout); var BufferLayout10 = _interopRequireWildcard(_bufferlayout); var BufferLayout11 = _interopRequireWildcard(_bufferlayout); var BufferLayout13 = _interopRequireWildcard(_bufferlayout);

// src/serialization/layout.ts


var _bnjs = require('bn.js'); var _bnjs2 = _interopRequireDefault(_bnjs);
var publicKey = (property) => {
  const publicKeyLayout = BufferLayout.blob(
    32,
    property
  );
  const _decode = publicKeyLayout.decode.bind(publicKeyLayout);
  const _encode = publicKeyLayout.encode.bind(publicKeyLayout);
  publicKeyLayout.decode = (buffer, offset) => {
    const data = _decode(buffer, offset);
    return new (0, _web3js.PublicKey)(data);
  };
  publicKeyLayout.encode = (key, buffer, offset) => {
    return _encode(key.toBuffer(), buffer, offset);
  };
  return publicKeyLayout;
};
var uint64 = (property = "uint64") => {
  return _uint(8, property);
};
var uint128 = (property = "uint128") => {
  return _uint(16, property);
};
var _uint = (length, property) => {
  const layout = BufferLayout.blob(length, property);
  const _decode = layout.decode.bind(layout);
  const _encode = layout.encode.bind(layout);
  layout.decode = (buffer, offset) => {
    const data = _decode(buffer, offset);
    return new (0, _bnjs2.default)(
      [...data].reverse().map((i) => `00${i.toString(16)}`.slice(-2)).join(""),
      16
    );
  };
  layout.encode = (num, buffer, offset) => {
    const a = num.toArray().reverse();
    let b = Buffer.from(a);
    if (b.length !== length) {
      const zeroPad = Buffer.alloc(length);
      b.copy(zeroPad);
      b = zeroPad;
    }
    return _encode(b, buffer, offset);
  };
  return layout;
};

// src/utils/Instructions.ts
function getAccess(key, type) {
  switch (type) {
    case 1 /* READ */:
      return { pubkey: key, isSigner: false, isWritable: false };
    case 2 /* WRITE */:
      return { pubkey: key, isSigner: false, isWritable: true };
    case 3 /* SIGNER */:
      return { pubkey: key, isSigner: true, isWritable: false };
    default:
      throw new Error(`Unknown access type ${type}`);
  }
}

// src/instructions/lending/borrowObligationLiquidity.ts


// src/constants.ts


// src/models/QuantityContext.ts
var _bigjs = require('big.js'); var _bigjs2 = _interopRequireDefault(_bigjs);
var QuantityContext = class {
  constructor(decimals, increment) {
    this.decimals = decimals;
    this.multiplier = increment;
  }
  static fromDecimals(decimals) {
    console.assert(Number.isInteger(decimals));
    console.assert(decimals >= 0);
    return new QuantityContext(decimals, new (0, _bigjs2.default)(10).pow(decimals));
  }
};

// src/constants.ts
var PORT_LENDING = new (0, _web3js.PublicKey)(
  "Port7uDYB3wk6GJAw4KT1WpTeMtSu9bTcChBHkX2LfR"
);
var PORT_STAKING = new (0, _web3js.PublicKey)(
  "stkarvwmSzv2BygN5e2LeTwimTczLWHCKPKGC2zVLiq"
);
var DEFAULT_PORT_LENDING_MARKET = new (0, _web3js.PublicKey)(
  "6T4XxKerq744sSuj3jaoV6QiZ8acirf4TrPwQzHAoSy5"
);
var PORT_QUANTITY_CONTEXT = QuantityContext.fromDecimals(6);
var MARKET_MAP = {
  H27Quk3DSbu55T4dCr1NddTTSAezXwHU67FPCZVKLhSW: "dev market",
  "6T4XxKerq744sSuj3jaoV6QiZ8acirf4TrPwQzHAoSy5": "prod market"
};

// src/instructions/lending/borrowObligationLiquidity.ts
var borrowObligationLiquidityInstruction = (liquidityAmount, srcLiquidityPubkey, dstLiquidityPubkey, borrowReservePubkey, borrowReserveFeeReceiverPubkey, obligationPubkey, lendingMarketPubkey, marketAuthorityPubkey, obligationOwner, lendingProgramId = PORT_LENDING) => {
  const dataLayout = BufferLayout2.struct([
    BufferLayout2.u8("instruction"),
    uint64("liquidityAmount")
  ]);
  const data = Buffer.alloc(dataLayout.span);
  dataLayout.encode(
    {
      instruction: 10 /* BorrowObligationLiquidity */,
      liquidityAmount: new (0, _bnjs2.default)(liquidityAmount)
    },
    data
  );
  const keys = [
    getAccess(srcLiquidityPubkey, 2 /* WRITE */),
    getAccess(dstLiquidityPubkey, 2 /* WRITE */),
    getAccess(borrowReservePubkey, 2 /* WRITE */),
    getAccess(borrowReserveFeeReceiverPubkey, 2 /* WRITE */),
    getAccess(obligationPubkey, 2 /* WRITE */),
    getAccess(lendingMarketPubkey, 1 /* READ */),
    getAccess(marketAuthorityPubkey, 1 /* READ */),
    getAccess(obligationOwner, 3 /* SIGNER */),
    getAccess(_web3js.SYSVAR_CLOCK_PUBKEY, 1 /* READ */),
    getAccess(_spltoken.TOKEN_PROGRAM_ID, 1 /* READ */)
  ];
  return new (0, _web3js.TransactionInstruction)({
    keys,
    programId: lendingProgramId,
    data
  });
};

// src/instructions/lending/depositObligationCollateral.ts







var depositObligationCollateralInstruction = (collateralAmount, srcCollateralPubkey, dstCollateralPubkey, depositReservePubkey, obligationPubkey, lendingMarketPubkey, marketAuthorityPubkey, obligationOwnerPubkey, transferAuthorityPubkey, lendingProgramId = PORT_LENDING, stakeAccountPubkey, stakingPoolPubkey) => {
  const dataLayout = BufferLayout3.struct([
    BufferLayout3.u8("instruction"),
    uint64("collateralAmount")
  ]);
  const data = Buffer.alloc(dataLayout.span);
  dataLayout.encode(
    {
      instruction: 8 /* DepositObligationCollateral */,
      collateralAmount: new (0, _bnjs2.default)(collateralAmount)
    },
    data
  );
  const keys = [
    getAccess(srcCollateralPubkey, 2 /* WRITE */),
    getAccess(dstCollateralPubkey, 2 /* WRITE */),
    getAccess(depositReservePubkey, 1 /* READ */),
    getAccess(obligationPubkey, 2 /* WRITE */),
    getAccess(lendingMarketPubkey, 1 /* READ */),
    getAccess(marketAuthorityPubkey, 1 /* READ */),
    getAccess(obligationOwnerPubkey, 3 /* SIGNER */),
    getAccess(transferAuthorityPubkey, 3 /* SIGNER */),
    getAccess(_web3js.SYSVAR_CLOCK_PUBKEY, 1 /* READ */),
    getAccess(_spltoken.TOKEN_PROGRAM_ID, 1 /* READ */)
  ];
  if (stakeAccountPubkey && stakingPoolPubkey) {
    keys.push(
      getAccess(stakeAccountPubkey, 2 /* WRITE */),
      getAccess(stakingPoolPubkey, 2 /* WRITE */),
      getAccess(PORT_STAKING, 1 /* READ */)
    );
  }
  return new (0, _web3js.TransactionInstruction)({
    keys,
    programId: lendingProgramId,
    data
  });
};

// src/instructions/lending/depositReserveLiquidity.ts







var depositReserveLiquidityInstruction = (liquidityAmount, srcLiquidityPubkey, dstCollateralPubkey, reservePubkey, reserveLiquiditySupplyPubkey, reserveCollateralMintPubkey, lendingMarketPubkey, lendingMarketAuthorityPubkey, transferAuthorityPubkey, lendingProgramId = PORT_LENDING) => {
  const dataLayout = BufferLayout4.struct([
    BufferLayout4.u8("instruction"),
    uint64("liquidityAmount")
  ]);
  const data = Buffer.alloc(dataLayout.span);
  dataLayout.encode(
    {
      instruction: 4 /* DepositReserveLiquidity */,
      liquidityAmount: new (0, _bnjs2.default)(liquidityAmount)
    },
    data
  );
  const keys = [
    getAccess(srcLiquidityPubkey, 2 /* WRITE */),
    getAccess(dstCollateralPubkey, 2 /* WRITE */),
    getAccess(reservePubkey, 2 /* WRITE */),
    getAccess(reserveLiquiditySupplyPubkey, 2 /* WRITE */),
    getAccess(reserveCollateralMintPubkey, 2 /* WRITE */),
    getAccess(lendingMarketPubkey, 1 /* READ */),
    getAccess(lendingMarketAuthorityPubkey, 1 /* READ */),
    getAccess(transferAuthorityPubkey, 3 /* SIGNER */),
    getAccess(_web3js.SYSVAR_CLOCK_PUBKEY, 1 /* READ */),
    getAccess(_spltoken.TOKEN_PROGRAM_ID, 1 /* READ */)
  ];
  return new (0, _web3js.TransactionInstruction)({
    keys,
    programId: lendingProgramId,
    data
  });
};

// src/instructions/lending/redeemReserveCollateral.ts







var redeemReserveCollateralInstruction = (collateralAmount, sourceCollateral, destinationLiquidity, reserve, reserveCollateralMint, reserveLiquiditySupply, lendingMarket, lendingMarketAuthority, transferAuthority, lendingProgramId = PORT_LENDING) => {
  const dataLayout = BufferLayout5.struct([
    BufferLayout5.u8("instruction"),
    uint64("collateralAmount")
  ]);
  const data = Buffer.alloc(dataLayout.span);
  dataLayout.encode(
    {
      instruction: 5 /* RedeemReserveCollateral */,
      collateralAmount: new (0, _bnjs2.default)(collateralAmount)
    },
    data
  );
  const keys = [
    getAccess(sourceCollateral, 2 /* WRITE */),
    getAccess(destinationLiquidity, 2 /* WRITE */),
    getAccess(reserve, 2 /* WRITE */),
    getAccess(reserveCollateralMint, 2 /* WRITE */),
    getAccess(reserveLiquiditySupply, 2 /* WRITE */),
    getAccess(lendingMarket, 1 /* READ */),
    getAccess(lendingMarketAuthority, 1 /* READ */),
    getAccess(transferAuthority, 3 /* SIGNER */),
    getAccess(_web3js.SYSVAR_CLOCK_PUBKEY, 1 /* READ */),
    getAccess(_spltoken.TOKEN_PROGRAM_ID, 1 /* READ */)
  ];
  return new (0, _web3js.TransactionInstruction)({
    keys,
    programId: lendingProgramId,
    data
  });
};

// src/instructions/lending/refreshReserve.ts





var DataLayout = BufferLayout6.struct([BufferLayout6.u8("instruction")]);
var refreshReserveInstruction = (reserve, oracle, lendingProgramId = PORT_LENDING) => {
  const data = Buffer.alloc(DataLayout.span);
  DataLayout.encode({ instruction: 3 /* RefreshReserve */ }, data);
  const keys = [
    getAccess(reserve, 2 /* WRITE */),
    getAccess(_web3js.SYSVAR_CLOCK_PUBKEY, 1 /* READ */)
  ];
  if (oracle) {
    keys.push(getAccess(oracle, 1 /* READ */));
  }
  return new (0, _web3js.TransactionInstruction)({
    keys,
    programId: lendingProgramId,
    data
  });
};

// src/models/basic/Comparable.ts
var Comparable = class {
  eq(that) {
    if (!that) {
      return false;
    }
    return this.checkAndCompare(that) === 0;
  }
  lt(that) {
    if (!that) {
      return false;
    }
    return this.checkAndCompare(that) < 0;
  }
  lte(that) {
    if (!that) {
      return false;
    }
    return this.checkAndCompare(that) <= 0;
  }
  gt(that) {
    if (!that) {
      return false;
    }
    return this.checkAndCompare(that) > 0;
  }
  gte(that) {
    if (!that) {
      return false;
    }
    return this.checkAndCompare(that) >= 0;
  }
  checkCompatible(that) {
    console.assert(this.isCompatibleWith(that));
  }
  checkAndCompare(that) {
    this.checkCompatible(that);
    return this.compare(that);
  }
};

// src/models/basic/Decimal.ts


// src/serialization/Field.ts

var Field = class extends BufferLayout7.Layout {
};

// src/serialization/BigField.ts

var BigField = class extends Field {
  constructor(type, property) {
    super(type.getBytes(), property);
    this.type = type;
  }
  static forType(type, property) {
    return new BigField(type, property);
  }
  decode(b, offset) {
    const bn = this.type.getLayout().decode(b, offset);
    const big = new (0, _bigjs2.default)(bn.toString());
    const multiplier = this.type.getMultiplier();
    if (!multiplier) {
      return big;
    }
    return big.div(multiplier);
  }
};

// src/models/basic/Numerical.ts

var _Numerical = class extends Comparable {
  constructor() {
    super();
  }
  static sum(a, b) {
    return a.add(b);
  }
  min(that) {
    this.checkCompatible(that);
    if (this.getRaw().lte(that.getRaw())) {
      return this.replaceWithValue(this.getRaw());
    }
    return this.replaceWithValue(that.getRaw());
  }
  max(that) {
    this.checkCompatible(that);
    if (this.getRaw().gte(that.getRaw())) {
      return this.replaceWithValue(this.getRaw());
    }
    return this.replaceWithValue(that.getRaw());
  }
  add(that) {
    this.checkCompatible(that);
    return this.replaceWithValue(this.getRaw().add(that.getRaw()));
  }
  subtract(that) {
    this.checkCompatible(that);
    return this.replaceWithValue(this.getRaw().sub(that.getRaw()));
  }
  multiply(pct) {
    return this.replaceWithValue(this.getRaw().mul(pct));
  }
  divide(pct) {
    return this.replaceWithValue(this.getRaw().div(pct));
  }
  compare(that) {
    return this.compareRaw(that.getRaw());
  }
  isZero() {
    return this.getSignum() === 0;
  }
  isPositive() {
    return this.getSignum() > 0;
  }
  isNegative() {
    return this.getSignum() < 0;
  }
  getSignum() {
    return this.compareRaw(_Numerical.BIG_ZERO);
  }
  compareRaw(raw) {
    return this.getRaw().cmp(raw);
  }
};
var Numerical = _Numerical;
Numerical.BIG_ZERO = new (0, _bigjs2.default)(0);

// src/models/basic/Decimal.ts
var Decimal = class extends Numerical {
  constructor(raw) {
    super();
    this.raw = new (0, _bigjs2.default)(raw);
  }
  getRaw() {
    return this.raw;
  }
  isCompatibleWith(that) {
    return true;
  }
};
var DecimalField = class extends Field {
  constructor(type, property) {
    super(type.getBytes(), property);
    this.delegate = BigField.forType(type, property);
  }
  decode(b, offset) {
    return this.fromBig(this.delegate.decode(b, offset));
  }
};

// src/models/basic/Id.ts

var Id = class extends _web3js.PublicKey {
  getAccess(type) {
    return getAccess(this, type);
  }
};

// src/models/basic/Lamport.ts

var _Lamport = class extends Decimal {
  constructor(raw) {
    super(raw);
  }
  static zero() {
    return _Lamport.ZERO;
  }
  static max() {
    return _Lamport.MAX;
  }
  static of(raw) {
    return new _Lamport(raw);
  }
  static field(type, property) {
    return new LamportField(type, property);
  }
  isTrivial() {
    return this.lt(_Lamport.ONE);
  }
  isMax() {
    return this.eq(_Lamport.MAX);
  }
  toU64() {
    return new (0, _spltoken.u64)(this.raw.toFixed(0, 0));
  }
  replaceWithValue(value) {
    return _Lamport.of(value);
  }
};
var Lamport = _Lamport;
Lamport.ZERO = new _Lamport(0);
Lamport.ONE = new _Lamport(1);
Lamport.MAX = new _Lamport("18446744073709551615");
var LamportField = class extends DecimalField {
  constructor(type, property) {
    super(type, property);
  }
  fromBig(big) {
    return Lamport.of(big);
  }
};

// src/models/basic/Percentage.ts


// src/serialization/BigType.ts



// src/serialization/BlobField.ts

var BlobField = class extends Field {
  constructor(span, property) {
    super(span, property);
    this.delegate = new BufferLayout8.Blob(span, property);
  }
  decode(b, offset) {
    const blob4 = this.delegate.decode(b, offset);
    return this.fromBuffer(blob4);
  }
};

// src/serialization/UIntField.ts

var UintField = class extends BlobField {
  constructor(bytes, property) {
    super(bytes, property);
  }
  fromBuffer(buffer) {
    return new (0, _bnjs2.default)(
      [...buffer].reverse().map((i) => `00${i.toString(16)}`.slice(-2)).join(""),
      16
    );
  }
};

// src/serialization/BigType.ts
var _BigType = class {
  constructor(bytes, multiplier) {
    this.bytes = bytes;
    this.multiplier = multiplier;
  }
  getLayout() {
    if (this.bytes === 1) {
      return BufferLayout9.u8();
    }
    if (this.bytes === 2) {
      return BufferLayout9.u16();
    }
    if (this.bytes === 3) {
      return BufferLayout9.u24();
    }
    if (this.bytes === 4) {
      return BufferLayout9.u32();
    }
    return new UintField(this.bytes);
  }
  getBytes() {
    return this.bytes;
  }
  getMultiplier() {
    return this.multiplier;
  }
};
var BigType = _BigType;
BigType.WAD = new (0, _bigjs2.default)(10).pow(18);
BigType.U8 = new _BigType(1);
BigType.U16 = new _BigType(2);
BigType.U32 = new _BigType(4);
BigType.U64 = new _BigType(8);
BigType.U128 = new _BigType(16);
BigType.D64 = new _BigType(8, _BigType.WAD);
BigType.D128 = new _BigType(16, _BigType.WAD);

// src/models/basic/Percentage.ts
var _Percentage = class extends Decimal {
  constructor(value) {
    super(value);
  }
  static zero() {
    return _Percentage.PCT_ZERO;
  }
  static hundred() {
    return _Percentage.PCT_HUNDRED;
  }
  static fromOneBased(oneBased) {
    return _Percentage.fromRaw(oneBased, false);
  }
  static fromHundredBased(hundredBased) {
    return _Percentage.fromRaw(hundredBased, true);
  }
  static fromRaw(raw, isHundredBased) {
    const big = new (0, _bigjs2.default)(raw);
    if (!isHundredBased) {
      return new _Percentage(big);
    }
    return new _Percentage(big.div(100));
  }
  static field(property) {
    return new PercentageField(true, property);
  }
  isTrivial() {
    return this.lt(_Percentage.PCT_BIP);
  }
  isHundredPct() {
    return this.eq(_Percentage.PCT_HUNDRED);
  }
  toOneBasedNumber(dp) {
    return this.raw.round(dp).toNumber();
  }
  toHundredBasedNumber(dp) {
    return this.raw.mul(100).round(dp, 0).toNumber();
  }
  print() {
    if (this.gt(_Percentage.PCT_THOUSAND)) {
      return this.raw.round(1, 1).toString() + "x";
    }
    return this.raw.mul(100).round(2, 1).toString() + "%";
  }
  replaceWithValue(value) {
    return new _Percentage(value);
  }
};
var Percentage = _Percentage;
Percentage.PCT_BIP = new _Percentage(1e-4);
Percentage.PCT_ZERO = new _Percentage(0);
Percentage.PCT_HUNDRED = new _Percentage(1);
Percentage.PCT_THOUSAND = new _Percentage(10);
var PercentageField = class extends DecimalField {
  constructor(isHundredBased, property) {
    super(BigType.U8, property);
    this.isHundredBased = isHundredBased;
  }
  fromBig(big) {
    return Percentage.fromRaw(big, this.isHundredBased);
  }
};

// src/models/basic/Ratio.ts
var Ratio = class extends Comparable {
  constructor(pct) {
    super();
    this.pct = pct;
  }
  isTrivial() {
    const pct = this.getPct();
    return !pct || pct.isTrivial();
  }
  isPresent() {
    return !!this.pct;
  }
  isPositive() {
    return !!_optionalChain([this, 'access', _ => _.getPct, 'call', _2 => _2(), 'optionalAccess', _3 => _3.isPositive, 'call', _4 => _4()]);
  }
  isNegative() {
    return !!_optionalChain([this, 'access', _5 => _5.getPct, 'call', _6 => _6(), 'optionalAccess', _7 => _7.isNegative, 'call', _8 => _8()]);
  }
  getUnchecked() {
    if (!this.pct) {
      throw new Error("No value available");
    }
    return this.pct.getRaw();
  }
  getPct() {
    return this.pct;
  }
  print() {
    return !this.pct ? "--" : this.pct.print();
  }
  compare(that) {
    const thisPct = this.getPct();
    const thatPct = that.getPct();
    if (!thisPct || !thatPct) {
      return 0;
    }
    return thisPct.compare(thatPct);
  }
  toString() {
    return this.print();
  }
};

// src/models/basic/WrappedDecimal.ts
var WrappedDecimal = class extends Numerical {
  constructor(wrapped) {
    super();
    this.wrapped = wrapped;
  }
  getRaw() {
    return this.getWrapped().getRaw();
  }
  getWrapped() {
    return this.wrapped;
  }
  replaceWithValue(value) {
    return this.wrap(this.getWrapped().replaceWithValue(value));
  }
};

// src/models/basic/WrappedLamport.ts
var WrappedLamport = class extends WrappedDecimal {
  isMax() {
    return this.getWrapped().isMax();
  }
  toU64() {
    return this.getAmount().toU64();
  }
  getAmount() {
    return this.getWrapped();
  }
};

// src/models/basic/Token.ts
var Token = class extends WrappedLamport {
  constructor(mintId, lamport) {
    super(lamport);
    this.mintId = mintId;
  }
  isNative() {
    return this.getMintId().isNative();
  }
  getMintId() {
    return this.mintId;
  }
  isCompatibleWith(that) {
    return this.mintId.equals(that.mintId);
  }
};

// src/models/staking/StakingPoolId.ts


// src/serialization/PublicKeyField.ts

var PublicKeyField = class extends BlobField {
  constructor(property) {
    super(_web3js.MAX_SEED_LENGTH, property);
  }
  fromBuffer(buffer) {
    return this.fromPublicKey(new (0, _web3js.PublicKey)(buffer));
  }
};

// src/models/staking/StakingPoolId.ts
var StakingPoolId = class extends Id {
  constructor(key) {
    super(key);
  }
  static fromBase58(base58) {
    return StakingPoolId.of(new (0, _web3js.PublicKey)(base58));
  }
  static of(key) {
    return new StakingPoolId(key);
  }
  static field(property) {
    return new StakingPoolIdField(property);
  }
};
var StakingPoolIdField = class extends PublicKeyField {
  constructor(property) {
    super(property);
  }
  fromPublicKey(pubKey) {
    return StakingPoolId.of(pubKey);
  }
};

// src/models/AdditionalReward.ts
var AdditionalReward = class {
  constructor(reserveId, apy, accurate, mintId) {
    this.reserveId = reserveId;
    this.apy = apy;
    this.accurate = !!accurate;
    this.mintId = mintId;
  }
  getReserveId() {
    return this.reserveId;
  }
  getApy() {
    return this.apy;
  }
  getAccurate() {
    return this.accurate;
  }
  getMintId() {
    return this.mintId;
  }
};

// src/models/Apy.ts
var _Apy = class extends Ratio {
  constructor(pct) {
    super(pct);
  }
  static na() {
    return _Apy.APY_NA;
  }
  static of(raw) {
    return new _Apy(Percentage.fromOneBased(raw));
  }
  isCompatibleWith(that) {
    return true;
  }
};
var Apy = _Apy;
Apy.APY_NA = new _Apy();

// src/models/Asset.ts


// src/models/Value.ts
var _Value = class extends Decimal {
  constructor(raw) {
    super(raw);
  }
  toAsset(price, context) {
    const lamport = Lamport.of(
      this.raw.div(price.getRaw()).mul(context.multiplier)
    );
    return Asset.of(price.getMintId(), lamport);
  }
  toNumber() {
    return this.raw.round(2, 0).toNumber();
  }
  print() {
    return _Value.FORMATTER.format(this.toNumber());
  }
  toString() {
    return this.print();
  }
};
var Value = _Value;
Value.FORMATTER = Intl.NumberFormat("en-US", {
  style: "currency",
  currency: "USD"
});

// src/models/ValueRatio.ts
var _ValueRatio = class extends Ratio {
  constructor(pct) {
    super(pct);
  }
  static of(pct) {
    if (!pct) {
      return _ValueRatio.na();
    }
    return new _ValueRatio(pct);
  }
  static na() {
    return _ValueRatio.VALUE_RATIO_NA;
  }
  isCompatibleWith(that) {
    return true;
  }
};
var ValueRatio = _ValueRatio;
ValueRatio.VALUE_RATIO_NA = new _ValueRatio();

// src/models/MarginRatio.ts
var _MarginRatio = class extends Ratio {
  constructor(pct) {
    super(pct);
  }
  static of(pct) {
    if (!pct) {
      return _MarginRatio.na();
    }
    return new _MarginRatio(pct);
  }
  static na() {
    return _MarginRatio.MARGIN_RATIO_NA;
  }
  isCompatibleWith(that) {
    return true;
  }
};
var MarginRatio = _MarginRatio;
MarginRatio.MARGIN_RATIO_NA = new _MarginRatio();

// src/models/Margin.ts
var _Margin = class extends Value {
  constructor(value) {
    super(value);
  }
  static of(raw) {
    return new _Margin(raw);
  }
  static zero() {
    return _Margin.MARGIN_ZERO;
  }
  static field(property) {
    return new MarginField(property);
  }
  toCollateralValue(loanToValue) {
    return QuoteValue.of(this.getRaw().div(loanToValue.getRaw()));
  }
  toRatioAgainst(threshold) {
    if (threshold.isZero()) {
      return MarginRatio.na();
    }
    return MarginRatio.of(
      Percentage.fromOneBased(this.getRaw().div(threshold.raw))
    );
  }
  replaceWithValue(value) {
    return new _Margin(value);
  }
};
var Margin = _Margin;
Margin.MARGIN_ZERO = new _Margin(0);
var MarginField = class extends DecimalField {
  constructor(property) {
    super(BigType.D128, property);
  }
  fromBig(big) {
    return Margin.of(big);
  }
};

// src/models/QuoteValue.ts
var _QuoteValue = class extends Value {
  constructor(raw) {
    super(raw);
  }
  static of(raw) {
    const result = new _QuoteValue(raw);
    if (result.isZero()) {
      return _QuoteValue.zero();
    }
    return result;
  }
  static zero() {
    return _QuoteValue.QUOTE_VALUE_ZERO;
  }
  static field(property) {
    return new QuoteValueField(property);
  }
  toCollateralMargin(loanToValue) {
    return Margin.of(this.getRaw().mul(loanToValue.getRaw()));
  }
  toLoanMargin() {
    return Margin.of(this.getRaw());
  }
  toRatioAgainst(threshold) {
    if (threshold.isZero()) {
      return ValueRatio.na();
    }
    const pct = Percentage.fromOneBased(this.getRaw().div(threshold.raw));
    return ValueRatio.of(pct);
  }
  replaceWithValue(value) {
    return new _QuoteValue(value);
  }
};
var QuoteValue = _QuoteValue;
QuoteValue.QUOTE_VALUE_ZERO = new _QuoteValue(0);
var QuoteValueField = class extends DecimalField {
  constructor(property) {
    super(BigType.D128, property);
  }
  fromBig(big) {
    return QuoteValue.of(big);
  }
};

// src/models/Share.ts
var Share = class extends Token {
  constructor(mintId, lamport) {
    super(mintId, lamport);
  }
  static zero(mintId) {
    return Share.of(mintId, Lamport.zero());
  }
  static max(mintId) {
    return Share.of(mintId, Lamport.max());
  }
  static fromTokenAccount(account) {
    return Share.of(account.getMintId(), account.getAmount());
  }
  static of(mintId, lamport) {
    return new Share(mintId, lamport);
  }
  toAsset(exchangeRatio) {
    console.assert(this.getMintId().equals(exchangeRatio.getShareMintId()));
    if (!exchangeRatio.isPresent()) {
      return Asset.zero(exchangeRatio.getAssetMintId());
    }
    const pct = exchangeRatio.getUnchecked();
    const lamport = Lamport.of(this.getRaw().div(pct).round(0));
    return Asset.of(exchangeRatio.getAssetMintId(), lamport);
  }
  wrap(value) {
    return Share.of(this.getMintId(), value);
  }
};

// src/models/MintId.ts


var MintId = class extends Id {
  constructor(key) {
    super(key);
  }
  static native() {
    return MintId.of(_spltoken.NATIVE_MINT);
  }
  static fromBase58(base58) {
    return MintId.of(new (0, _web3js.PublicKey)(base58));
  }
  static of(key) {
    return new MintId(key);
  }
  static field(property) {
    return new MintIdField(property);
  }
  isNative() {
    return this.equals(_spltoken.NATIVE_MINT);
  }
};
var MintIdField = class extends PublicKeyField {
  constructor(property) {
    super(property);
  }
  fromPublicKey(pubKey) {
    return MintId.of(pubKey);
  }
};

// src/models/Asset.ts
var _Asset = class extends Token {
  constructor(mintId, lamport) {
    super(mintId, lamport);
  }
  static fromString(str, mintId, context) {
    const increment = context.multiplier;
    const lamport = Lamport.of(new (0, _bigjs2.default)(str).mul(increment).round(0, 0));
    return new _Asset(mintId, lamport);
  }
  static zero(mintId) {
    return _Asset.of(mintId);
  }
  static max(mintId) {
    return _Asset.of(mintId, Lamport.max());
  }
  static native(lamport) {
    return _Asset.of(MintId.native(), lamport);
  }
  static fromTokenAccount(account) {
    return _Asset.of(account.getMintId(), account.getAmount());
  }
  static of(mintId, lamport) {
    return new _Asset(mintId, lamport || Lamport.zero());
  }
  isNative() {
    return this.getMintId().isNative();
  }
  toValue(price, quantityContext) {
    console.assert(
      this.getMintId().equals(price.getMintId()),
      `asset id: ${this.getMintId()} price id: ${price.getMintId()}`
    );
    if (!price) {
      return QuoteValue.zero();
    }
    const increment = quantityContext.multiplier;
    const value = this.getRaw().div(increment).mul(price.getRaw());
    return QuoteValue.of(value);
  }
  toInterest(supplyApy) {
    if (!supplyApy.isPresent()) {
      return _Asset.zero(this.getMintId());
    }
    const lamport = Lamport.of(this.getRaw().mul(supplyApy.getUnchecked()));
    return _Asset.of(this.getMintId(), lamport);
  }
  toShare(exchangeRatio) {
    console.assert(this.getMintId().equals(exchangeRatio.getAssetMintId()));
    if (!exchangeRatio.isPresent()) {
      return Share.zero(exchangeRatio.getShareMintId());
    }
    const lamport = Lamport.of(
      this.getRaw().mul(exchangeRatio.getUnchecked()).round(0)
    );
    return Share.of(exchangeRatio.getShareMintId(), lamport);
  }
  addFee(pct) {
    return this.multiply(new (0, _bigjs2.default)(1).add(pct.getRaw()));
  }
  toNumber(context) {
    const multiplier = context.multiplier;
    const decimals = context.decimals;
    return this.getRaw().div(multiplier).round(decimals, 0).toNumber();
  }
  plain(context) {
    return this.toLimitRoundNumber(context).toString();
  }
  toLimitRoundNumber(context) {
    const multiplier = context.multiplier;
    const decimals = context.decimals;
    return this.getRaw().div(multiplier).round(Math.min(decimals, 6), 0).toNumber();
  }
  print(context, symbol) {
    if (!context) {
      return "--";
    }
    const num = this.toLimitRoundNumber(context);
    const formatted = num > _Asset.LARGE_THRESHOLD ? _Asset.FORMATTER_LARGE.format(num) : _Asset.FORMATTER_NORMAL.format(num);
    if (!symbol) {
      return formatted;
    }
    return formatted + " " + symbol;
  }
  wrap(value) {
    return _Asset.of(this.getMintId(), value);
  }
};
var Asset = _Asset;
Asset.MIN_NATIVE_LAMPORT = _Asset.native(
  Lamport.of(5e6)
);
Asset.SIGNIFICANT_DIGITS = 6;
Asset.LARGE_THRESHOLD = new (0, _bigjs2.default)(10).pow(6).toNumber();
Asset.FORMATTER_NORMAL = new Intl.NumberFormat("en-US", {
  style: "decimal",
  maximumSignificantDigits: _Asset.SIGNIFICANT_DIGITS
});
Asset.FORMATTER_LARGE = new Intl.NumberFormat("en-US", {
  style: "decimal",
  maximumFractionDigits: 0
});

// src/models/AssetConfig.ts
var AssetConfig = class {
  constructor(mintId, display, price, deposit, isDefault) {
    this.mintId = mintId;
    this.display = display;
    this.price = price;
    this.deposit = deposit;
    this.isDefault = _nullishCoalesce(isDefault, () => ( false));
  }
  checkIsDefault() {
    return this.isDefault;
  }
  getMintId() {
    return this.mintId;
  }
  getName() {
    return this.getDisplayConfig().getName();
  }
  getSymbol() {
    return this.getDisplayConfig().getSymbol();
  }
  getColor() {
    return this.getDisplayConfig().getColor();
  }
  getDisplayConfig() {
    return this.display;
  }
  getPriceDecimals() {
    return this.getPriceConfig().getDecimals();
  }
  getPriceConfig() {
    return this.price;
  }
  getReserveId() {
    return _optionalChain([this, 'access', _9 => _9.getDepositConfig, 'call', _10 => _10(), 'optionalAccess', _11 => _11.getReserveId, 'call', _12 => _12()]);
  }
  getMaxDeposit() {
    const raw = _optionalChain([this, 'access', _13 => _13.getDepositConfig, 'call', _14 => _14(), 'optionalAccess', _15 => _15.getMax, 'call', _16 => _16()]);
    return raw ? Asset.of(this.mintId, Lamport.of(raw)) : void 0;
  }
  getMinDeposit() {
    const raw = _optionalChain([this, 'access', _17 => _17.getDepositConfig, 'call', _18 => _18(), 'optionalAccess', _19 => _19.getMin, 'call', _20 => _20()]);
    return raw ? Asset.of(this.mintId, Lamport.of(raw)) : void 0;
  }
  getRemainAsset() {
    const raw = _optionalChain([this, 'access', _21 => _21.getDepositConfig, 'call', _22 => _22(), 'optionalAccess', _23 => _23.getRemain, 'call', _24 => _24()]);
    return raw ? Asset.of(this.mintId, Lamport.of(raw)) : void 0;
  }
  getDepositConfig() {
    return this.deposit;
  }
};

// src/models/AssetDisplayConfig.ts
var AssetDisplayConfig = class {
  constructor(name, symbol, color) {
    this.name = name;
    this.symbol = symbol;
    this.color = color;
  }
  getName() {
    return this.name;
  }
  getSymbol() {
    return this.symbol;
  }
  getColor() {
    return this.color;
  }
};

// src/models/AssetPriceConfig.ts

var AssetPriceConfig = class {
  constructor(decimals, increment) {
    this.decimals = decimals;
    this.increment = increment;
  }
  static fromDecimals(decimals) {
    console.assert(Number.isInteger(decimals));
    console.assert(decimals >= 0);
    return new AssetPriceConfig(decimals, new (0, _bigjs2.default)(10).pow(decimals));
  }
  getDecimals() {
    return this.decimals;
  }
  getIncrement() {
    return this.increment;
  }
};

// src/utils/defaultAssetConfig.ts
var DEFAULT_ASSET_CONFIG = new AssetConfig(
  MintId.fromBase58("So11111111111111111111111111111111111111112"),
  new AssetDisplayConfig("Default Token", "Default"),
  AssetPriceConfig.fromDecimals(3)
);

// src/models/AssetContext.ts
var AssetContext = class {
  constructor(cache, bySymbol, byReserveId) {
    this.cache = cache;
    this.bySymbol = bySymbol;
    this.byReserveId = byReserveId;
  }
  static index(configs) {
    const cache = /* @__PURE__ */ new Map();
    configs.forEach(
      (config) => cache.set(config.getMintId().toString(), config)
    );
    const bySymbol = /* @__PURE__ */ new Map();
    configs.forEach((config) => bySymbol.set(config.getSymbol(), config));
    const byReserveId = /* @__PURE__ */ new Map();
    for (const config of configs) {
      const reserveId = config.getReserveId();
      if (reserveId) {
        byReserveId.set(reserveId.toBase58(), config);
      }
    }
    return new AssetContext(cache, bySymbol, byReserveId);
  }
  getAllConfigs() {
    return Array.from(this.cache.values());
  }
  findConfig(mintId) {
    const key = mintId.toString();
    return _nullishCoalesce(this.cache.get(key), () => ( DEFAULT_ASSET_CONFIG));
  }
  findConfigBySymbol(symbol) {
    return _nullishCoalesce(this.bySymbol.get(symbol), () => ( DEFAULT_ASSET_CONFIG));
  }
  findConfigByReserveId(reserveId) {
    return _nullishCoalesce(this.byReserveId.get(reserveId.toBase58()), () => ( DEFAULT_ASSET_CONFIG));
  }
};

// src/models/AssetDepositConfig.ts

var AssetDepositConfig = class {
  constructor(reserveId, args) {
    this.reserveId = reserveId;
    this.min = _optionalChain([args, 'optionalAccess', _25 => _25.min]) ? new (0, _bigjs2.default)(args.min) : void 0;
    this.max = _optionalChain([args, 'optionalAccess', _26 => _26.max]) ? new (0, _bigjs2.default)(args.max) : void 0;
    this.remain = _optionalChain([args, 'optionalAccess', _27 => _27.remain]) ? new (0, _bigjs2.default)(args.remain) : void 0;
  }
  getReserveId() {
    return this.reserveId;
  }
  getMin() {
    return this.min;
  }
  getMax() {
    return this.max;
  }
  getRemain() {
    return this.remain;
  }
};

// src/models/AssetExchangeRate.ts
var AssetExchangeRate = class extends Ratio {
  constructor(shareMintId, assetMintId, pct) {
    super(pct);
    this.shareMintId = shareMintId;
    this.assetMintId = assetMintId;
  }
  getShareMintId() {
    return this.shareMintId;
  }
  getAssetMintId() {
    return this.assetMintId;
  }
  isCompatibleWith(that) {
    return this.shareMintId.equals(that.shareMintId) && this.assetMintId.equals(that.assetMintId);
  }
};

// src/models/AssetPrice.ts

var AssetPrice = class extends Decimal {
  constructor(mintId, value) {
    super(value);
    this.mintId = mintId;
  }
  static of(mintId, value) {
    return new AssetPrice(mintId, value);
  }
  getMintId() {
    return this.mintId;
  }
  addFee(pct) {
    return this.multiply(new (0, _bigjs2.default)(1).add(pct.getRaw()));
  }
  print(config) {
    const decimals = config.getPriceDecimals();
    return "$" + this.raw.round(decimals, 1).toFixed(decimals);
  }
  replaceWithValue(value) {
    return new AssetPrice(this.getMintId(), value);
  }
  isCompatibleWith(that) {
    return this.getMintId().equals(that.getMintId());
  }
};

// src/models/AssetValue.ts
var AssetValue = class {
  constructor(asset, value) {
    this.asset = asset;
    this.value = value;
  }
  static zero(mintId) {
    return new AssetValue(Asset.zero(mintId), QuoteValue.zero());
  }
  getMintId() {
    return this.getAsset().getMintId();
  }
  getAsset() {
    return this.asset;
  }
  getValue() {
    return this.value;
  }
};

// src/models/AuthorityId.ts

var AuthorityId = class extends Id {
  constructor(pubKey) {
    super(pubKey);
  }
  static fromBase58(base58) {
    return AuthorityId.of(new (0, _web3js.PublicKey)(base58));
  }
  static of(pubKey) {
    return new AuthorityId(pubKey);
  }
  static field(property) {
    return new AuthorityIdField(property);
  }
};
var AuthorityIdField = class extends PublicKeyField {
  constructor(property) {
    super(property);
  }
  fromPublicKey(pubKey) {
    return AuthorityId.of(pubKey);
  }
};

// src/models/ProfileEntry.ts
var ProfileEntry = class extends WrappedLamport {
  constructor(reserveId, amount) {
    super(amount);
    this.reserveId = reserveId;
  }
  getReserveId() {
    return this.reserveId;
  }
  isCompatibleWith(that) {
    return this.getReserveId().equals(that.getReserveId());
  }
};

// src/models/Collateral.ts
var Collateral = class extends ProfileEntry {
  constructor(reserveId, amount) {
    super(reserveId, amount);
  }
  static zero(reserveId) {
    return new Collateral(reserveId, Lamport.zero());
  }
  wrap(value) {
    return new Collateral(this.getReserveId(), value);
  }
};

// src/models/ExchangeRate.ts
var _ExchangeRate = class extends Decimal {
  constructor(value) {
    super(value);
  }
  static zero() {
    return _ExchangeRate.ZERO;
  }
  static of(raw) {
    return new _ExchangeRate(raw);
  }
  static field(type, property) {
    return new ExchangeRateField(type, property);
  }
  replaceWithValue(value) {
    return _ExchangeRate.of(value);
  }
};
var ExchangeRate = _ExchangeRate;
ExchangeRate.ZERO = _ExchangeRate.of(0);
var ExchangeRateField = class extends DecimalField {
  constructor(type, property) {
    super(type, property);
  }
  fromBig(big) {
    return ExchangeRate.of(big);
  }
};

// src/models/Loan.ts
var Loan = class extends ProfileEntry {
  constructor(reserveId, amount, cumulativeBorrowRate) {
    super(reserveId, amount);
    this.cumulativeBorrowRate = cumulativeBorrowRate;
  }
  static zero(reserve) {
    return new Loan(
      reserve.getReserveId(),
      Lamport.zero(),
      reserve.asset.getCumulativeBorrowRate()
    );
  }
  accrueInterest(newCumulativeBorrowRate) {
    const compoundedInterestRate = newCumulativeBorrowRate.divide(
      this.cumulativeBorrowRate.getRaw()
    );
    const newAmount = this.getAmount().multiply(
      compoundedInterestRate.getRaw()
    );
    return new Loan(this.getReserveId(), newAmount, newCumulativeBorrowRate);
  }
  getCumulativeBorrowRate() {
    return this.cumulativeBorrowRate;
  }
  wrap(value) {
    return new Loan(this.getReserveId(), value, this.cumulativeBorrowRate);
  }
};

// src/models/MarketId.ts

var MarketId = class extends Id {
  constructor(key) {
    super(key);
  }
  static fromBase58(base58) {
    return MarketId.of(new (0, _web3js.PublicKey)(base58));
  }
  static of(key) {
    return new MarketId(key);
  }
  static field(property) {
    return new MarketIdField(property);
  }
  getName() {
    return _nullishCoalesce(MARKET_MAP[this.toBase58()], () => ( "unknown"));
  }
};
var MarketIdField = class extends PublicKeyField {
  constructor(property) {
    super(property);
  }
  fromPublicKey(pubKey) {
    return MarketId.of(pubKey);
  }
};

// src/models/OracleId.ts

var OracleId = class extends Id {
  static fromBase58(base58) {
    return new OracleId(new (0, _web3js.PublicKey)(base58));
  }
};

// src/models/PortProfileId.ts

var PortProfileId = class extends Id {
  constructor(key) {
    super(key);
  }
  static of(pubKey) {
    return new PortProfileId(pubKey);
  }
  static fromBase58(base58) {
    return PortProfileId.of(new (0, _web3js.PublicKey)(base58));
  }
  static field(property) {
    return new PortProfileIdField(property);
  }
};
var PortProfileIdField = class extends PublicKeyField {
  constructor(property) {
    super(property);
  }
  fromPublicKey(pubKey) {
    return PortProfileId.of(pubKey);
  }
};

// src/models/ReserveId.ts

var ReserveId = class extends Id {
  constructor(key) {
    super(key);
  }
  static fromBase58(base58) {
    return ReserveId.of(new (0, _web3js.PublicKey)(base58));
  }
  static of(pubKey) {
    return new ReserveId(pubKey);
  }
  static field(property) {
    return new ReserveIdField(property);
  }
};
var ReserveIdField = class extends PublicKeyField {
  constructor(property) {
    super(property);
  }
  fromPublicKey(pubKey) {
    return ReserveId.of(pubKey);
  }
};

// src/models/PortProfile.ts


// src/structs/ReserveData.ts


// src/models/TokenAccountId.ts
var TokenAccountId = class extends Id {
  constructor(key) {
    super(key);
  }
  static native(walletId) {
    return TokenAccountId.of(walletId);
  }
  static of(pubKey) {
    return new TokenAccountId(pubKey);
  }
  static field(property) {
    return new SplAccountIdField(property);
  }
};
var SplAccountIdField = class extends PublicKeyField {
  constructor(property) {
    super(property);
  }
  fromPublicKey(pubKey) {
    return TokenAccountId.of(pubKey);
  }
};

// src/serialization/Optional.ts

var Optional = class extends Field {
  constructor(field) {
    super(field.span + 1, field.property);
    this.delegate = field;
  }
  static of(field) {
    return new Optional(field);
  }
  decode(b, offset) {
    const flag = BufferLayout10.u8().decode(b, offset);
    if (!flag) {
      return void 0;
    }
    return this.delegate.decode(b, (offset || 0) + 1);
  }
};

// src/structs/SlotInfo.ts

var SlotInfoLayout = (property) => BufferLayout11.struct(
  [uint64("slot"), BufferLayout11.u8("stale")],
  property
);

// src/structs/ReserveData.ts
var ReserveConfigProtoLayout = (property) => BufferLayout12.struct(
  [
    BufferLayout12.u8("optimalUtilizationRate"),
    BufferLayout12.u8("loanToValueRatio"),
    BufferLayout12.u8("liquidationBonus"),
    BufferLayout12.u8("liquidationThreshold"),
    BufferLayout12.u8("minBorrowRate"),
    BufferLayout12.u8("optimalBorrowRate"),
    BufferLayout12.u8("maxBorrowRate"),
    ReserveFeesProtoLayout("fees"),
    BufferLayout12.u8("stakingPoolOption"),
    publicKey("stakingPool")
  ],
  property
);
var ReserveFeesProtoLayout = (property) => BufferLayout12.struct(
  [
    uint64("borrowFeeWad"),
    uint64("flashLoanFeeWad"),
    BufferLayout12.u8("hostFeePercentage")
  ],
  property
);
var ReserveLiquidityLayout = (property) => BufferLayout12.struct(
  [
    MintId.field("mintPubkey"),
    BufferLayout12.u8("mintDecimals"),
    TokenAccountId.field("supplyPubkey"),
    TokenAccountId.field("feeReceiver"),
    BufferLayout12.u32("oracleOption"),
    publicKey("oraclePubkey"),
    Lamport.field(BigType.U64, "availableAmount"),
    Lamport.field(BigType.D128, "borrowedAmountWads"),
    ExchangeRate.field(BigType.D128, "cumulativeBorrowRateWads"),
    BigField.forType(BigType.D128, "marketPrice")
  ],
  property
);
var ReserveCollateralLayout = (property) => BufferLayout12.struct(
  [
    MintId.field("mintPubkey"),
    Lamport.field(BigType.U64, "mintTotalSupply"),
    TokenAccountId.field("supplyPubkey")
  ],
  property
);
var ReserveFeesLayout = (property) => BufferLayout12.struct(
  [
    BigField.forType(BigType.D64, "borrowFeeWad"),
    BigField.forType(BigType.D64, "flashLoanFeeWad"),
    BufferLayout12.u8("hostFeePercentage")
  ],
  property
);
var ReserveConfigLayout = (property) => BufferLayout12.struct(
  [
    Percentage.field("optimalUtilizationRate"),
    Percentage.field("loanToValueRatio"),
    Percentage.field("liquidationBonus"),
    Percentage.field("liquidationThreshold"),
    Percentage.field("minBorrowRate"),
    Percentage.field("optimalBorrowRate"),
    Percentage.field("maxBorrowRate"),
    ReserveFeesLayout("fees"),
    Optional.of(StakingPoolId.field("stakingPoolId"))
  ],
  property
);
var ReserveLayout = BufferLayout12.struct([
  BufferLayout12.u8("version"),
  SlotInfoLayout("lastUpdate"),
  publicKey("lendingMarket"),
  ReserveLiquidityLayout("liquidity"),
  ReserveCollateralLayout("collateral"),
  ReserveConfigLayout("config"),
  BufferLayout12.blob(215, "padding2")
]);
var isReserve = (info) => {
  return info.data.length === ReserveLayout.span;
};
var RESERVE_DATA_SIZE = ReserveLayout.span;

// src/models/WalletId.ts

var WalletId = class extends Id {
  constructor(key) {
    super(key);
  }
  static fromBase58(base58) {
    return WalletId.of(new (0, _web3js.PublicKey)(base58));
  }
  static of(key) {
    return new WalletId(key);
  }
  static field(property) {
    return new WalletIdField(property);
  }
};
var WalletIdField = class extends PublicKeyField {
  constructor(property) {
    super(property);
  }
  fromPublicKey(pubKey) {
    return WalletId.of(pubKey);
  }
};

// src/structs/PortProfileData.ts

var ObligationLayout = BufferLayout13.struct([
  BufferLayout13.u8("version"),
  SlotInfoLayout("lastUpdate"),
  publicKey("lendingMarket"),
  WalletId.field("owner"),
  QuoteValue.field("depositedValue"),
  Margin.field("borrowedValue"),
  Margin.field("allowedBorrowValue"),
  Margin.field("unhealthyBorrowValue"),
  BufferLayout13.u8("depositsLen"),
  BufferLayout13.u8("borrowsLen"),
  BufferLayout13.blob(776, "dataFlat")
]);
var ObligationCollateralLayout = BufferLayout13.struct([
  ReserveId.field("depositReserve"),
  Lamport.field(BigType.U64, "depositedAmount"),
  QuoteValue.field("marketValue")
]);
var ObligationLiquidityLayout = BufferLayout13.struct([
  ReserveId.field("borrowReserve"),
  ExchangeRate.field(BigType.D128, "cumulativeBorrowRateWads"),
  Lamport.field(BigType.D128, "borrowedAmountWads"),
  QuoteValue.field("marketValue")
]);
var PORT_PROFILE_DATA_SIZE = ObligationLayout.span;

// src/models/PortProfile.ts
var PortProfile = class {
  constructor(profileId, collaterals, loans, loanMargin, initialMargin, maintenanceMargin, owner, depositedValue) {
    this.profileId = profileId;
    this.collaterals = collaterals;
    this.loans = loans;
    this.loanMargin = loanMargin;
    this.initialMargin = initialMargin;
    this.maintenanceMargin = maintenanceMargin;
    this.owner = owner;
    this.depositedValue = depositedValue;
  }
  static newAccount(profileId) {
    return new PortProfile(
      profileId,
      [],
      [],
      Margin.zero(),
      Margin.zero(),
      Margin.zero()
    );
  }
  static fromRaw(raw) {
    const profileId = PortProfileId.of(raw.pubkey);
    const proto = PortProfileParser(raw.account.data);
    const collaterals = proto.deposits.map(
      (c) => new Collateral(ReserveId.of(c.depositReserve), c.depositedAmount)
    );
    const loans = proto.borrows.map(
      (l) => new Loan(
        l.borrowReserve,
        l.borrowedAmountWads,
        l.cumulativeBorrowRateWads
      )
    );
    const loanMargin = proto.borrowedValue;
    const initialMargin = proto.allowedBorrowValue;
    const maintenanceMargin = proto.unhealthyBorrowValue;
    const depositedValue = proto.depositedValue;
    const owner = proto.owner;
    return new PortProfile(
      profileId,
      collaterals,
      loans,
      loanMargin,
      initialMargin,
      maintenanceMargin,
      owner,
      depositedValue
    );
  }
  getDepositedValue() {
    return this.depositedValue;
  }
  getOwner() {
    return this.owner;
  }
  getId() {
    return this.getProfileId();
  }
  getProfileId() {
    return this.profileId;
  }
  getCollateral(reserveId) {
    return this.getCollaterals().find(
      (c) => c.getReserveId().equals(reserveId)
    );
  }
  getCollateralReserveIds() {
    return this.getCollaterals().map((c) => c.getReserveId());
  }
  getCollaterals() {
    return this.collaterals;
  }
  getLoan(reserveId) {
    return this.getLoans().find((l) => l.getReserveId().equals(reserveId));
  }
  getLoanReserveIds() {
    return this.getLoans().map((l) => l.getReserveId());
  }
  getLoans() {
    return this.loans;
  }
  getLoanMargin() {
    return this.loanMargin;
  }
  getInitialMargin() {
    return this.initialMargin;
  }
  getMaintenanceMargin() {
    return this.maintenanceMargin;
  }
  getRiskFactor() {
    return this.getLoanMargin().toRatioAgainst(this.getMaintenanceMargin());
  }
  getLoanToValue() {
    return this.getLoanMargin().toRatioAgainst(this.getInitialMargin());
  }
};
var PortProfileParser = (buffer) => {
  const {
    version,
    lastUpdate,
    lendingMarket,
    owner,
    depositedValue,
    borrowedValue,
    allowedBorrowValue,
    unhealthyBorrowValue,
    depositsLen,
    borrowsLen,
    dataFlat
  } = ObligationLayout.decode(buffer);
  const depositsBuffer = dataFlat.slice(
    0,
    depositsLen * ObligationCollateralLayout.span
  );
  const deposits = BufferLayout14.seq(
    ObligationCollateralLayout,
    depositsLen
  ).decode(depositsBuffer);
  const borrowsBuffer = dataFlat.slice(
    depositsBuffer.length,
    depositsBuffer.length + borrowsLen * ObligationLiquidityLayout.span
  );
  const borrows = BufferLayout14.seq(
    ObligationLiquidityLayout,
    borrowsLen
  ).decode(borrowsBuffer);
  return {
    version,
    lastUpdate,
    lendingMarket,
    owner,
    depositedValue,
    borrowedValue,
    allowedBorrowValue,
    unhealthyBorrowValue,
    deposits,
    borrows
  };
};

// src/models/PortProfileContext.ts
var PortProfileContext = class {
  constructor(selectedProfile, allProfiles) {
    this.selectedProfile = selectedProfile;
    this.allProfiles = allProfiles;
  }
  static index(profiles, whitelist) {
    profiles = profiles.sort(byCollateralAndLoanCountDesc);
    let selected = whitelist ? profiles.find((p) => p.getProfileId().equals(whitelist)) : void 0;
    if (!selected && profiles.length) {
      selected = profiles[0];
    }
    return new PortProfileContext(selected, profiles);
  }
  getSelectedProfile() {
    return this.selectedProfile;
  }
  getAllProfiles() {
    return this.allProfiles;
  }
};
function byCollateralAndLoanCountDesc(a, b) {
  const aCount = a.getCollaterals().length + a.getLoans().length;
  const bCount = b.getCollaterals().length + b.getLoans().length;
  return bCount - aCount;
}

// src/models/PriceOracle.ts
var PriceOracle = class {
  constructor(cache) {
    this.cache = cache;
  }
  static index(prices) {
    const cache = /* @__PURE__ */ new Map();
    prices.forEach((price) => cache.set(price.getMintId().toString(), price));
    return new PriceOracle(cache);
  }
  getPrice(mintId) {
    const key = mintId.toString();
    return this.cache.get(key);
  }
};

// src/models/ProgramId.ts

var ProgramId = class extends Id {
  constructor(key) {
    super(key);
  }
  static fromBase58(base58) {
    return ProgramId.of(new (0, _web3js.PublicKey)(base58));
  }
  static of(key) {
    return new ProgramId(key);
  }
};

// src/models/ProposedAction.ts
var ProposedAction = class {
  constructor(assets, shares, collaterals, loans) {
    this.assets = assets;
    this.shares = shares;
    this.collaterals = collaterals;
    this.loans = loans;
  }
  static newProposal(args) {
    const assets = [];
    const shares = [];
    const collaterals = [];
    const loans = [];
    if (args.newAsset) {
      assets.push(args.newAsset);
    }
    if (args.newShare) {
      shares.push(args.newShare);
    }
    if (args.newCollateral) {
      collaterals.push(args.newCollateral);
    }
    if (args.newLoan) {
      loans.push(args.newLoan);
    }
    return new ProposedAction(assets, shares, collaterals, loans);
  }
  getUpdatedAsset(assetMintId) {
    return this.assets.find((a) => a.getMintId().equals(assetMintId));
  }
  getUpdatedShare(shareMintId) {
    return this.shares.find((s) => s.getMintId().equals(shareMintId));
  }
  getUpdatedCollateral(reserveId) {
    return this.collaterals.find((c) => c.getReserveId().equals(reserveId));
  }
  getUpdatedLoan(reserveId) {
    return this.loans.find((l) => l.getReserveId().equals(reserveId));
  }
  getUpdatedCollaterals(collaterals) {
    return ProposedAction.proposal(collaterals, this.collaterals);
  }
  getUpdatedLoans(loans) {
    return ProposedAction.proposal(loans, this.loans);
  }
  static proposal(entries, proposal) {
    if (!proposal.length) {
      return entries;
    }
    const map = /* @__PURE__ */ new Map();
    for (const e of entries) {
      map.set(e.getReserveId().toBase58(), e);
    }
    for (const e of proposal) {
      map.set(e.getReserveId().toBase58(), e);
    }
    return Array.from(map.values());
  }
};

// src/models/ReserveBorrowRate.ts
var ReserveBorrowRate = class extends Ratio {
  constructor(mintId, pct) {
    super(pct);
    this.mintId = mintId;
  }
  static na(mintId) {
    return new ReserveBorrowRate(mintId);
  }
  getMintId() {
    return this.mintId;
  }
  isCompatibleWith(that) {
    return this.mintId.equals(that.mintId);
  }
};

// src/models/ReserveContext.ts
var _ReserveContext = class {
  constructor(reserves, byReserveId, byAssetMintId, byShareMintId, byStakingPoolId) {
    this.reserves = reserves;
    this.byReserveId = byReserveId;
    this.byAssetMintId = byAssetMintId;
    this.byShareMintId = byShareMintId;
    this.byStakingPoolId = byStakingPoolId;
  }
  static empty() {
    return _ReserveContext.RESERVE_CONTEXT_EMPTY;
  }
  static index(reserves, tokenMap) {
    if (!reserves.length) {
      return _ReserveContext.empty();
    }
    const readyToSortReserves = tokenMap ? reserves.filter((r) => {
      return tokenMap.has(r.getAssetMintId().toString());
    }) : reserves;
    const sorted = readyToSortReserves.sort(
      (a, b) => -a.getMarketCap().getValue().compare(b.getMarketCap().getValue())
    );
    const byReserveId = /* @__PURE__ */ new Map();
    const byAssetMintId = /* @__PURE__ */ new Map();
    const byShareMintId = /* @__PURE__ */ new Map();
    const byStakingPoolId = /* @__PURE__ */ new Map();
    sorted.forEach(
      (reserve) => byReserveId.set(reserve.getReserveId().toString(), reserve)
    );
    sorted.forEach(
      (reserve) => byAssetMintId.set(reserve.getAssetMintId().toString(), reserve)
    );
    sorted.forEach(
      (reserve) => byShareMintId.set(reserve.getShareMintId().toString(), reserve)
    );
    sorted.forEach((reserve) => {
      const stakingPoolId = reserve.getStakingPoolId();
      if (stakingPoolId) {
        byStakingPoolId.set(stakingPoolId.toString(), reserve);
      }
    });
    return new _ReserveContext(
      sorted,
      byReserveId,
      byAssetMintId,
      byShareMintId,
      byStakingPoolId
    );
  }
  isReady() {
    return this.reserves.length > 0;
  }
  getAllReserves() {
    return this.reserves;
  }
  getAllReservesPricePubKey() {
    return this.reserves.map((r) => r.getOracleId());
  }
  getReserve(reserveId) {
    const result = this.findReserve(reserveId);
    if (!result) {
      throw new Error(`No reserve for ${reserveId}`);
    }
    return result;
  }
  getByAssetMintId(mintId) {
    const result = this.findByAssetMintId(mintId);
    if (!result) {
      throw new Error(`No reserve for asset mint ${mintId}`);
    }
    return result;
  }
  getByShareMintId(mintId) {
    const result = this.findByShareMintId(mintId);
    if (!result) {
      throw new Error(`No reserve for share mint ${mintId}`);
    }
    return result;
  }
  findReserve(reserveId) {
    const key = reserveId.toString();
    return this.byReserveId.get(key);
  }
  findByAssetMintId(mintId) {
    const key = mintId.toString();
    return this.byAssetMintId.get(key);
  }
  findByShareMintId(mintId) {
    const key = mintId.toString();
    return this.byShareMintId.get(key);
  }
  findByStakingPoolId(stakingPoolId) {
    if (!stakingPoolId) {
      return void 0;
    }
    const key = stakingPoolId.toString();
    return this.byStakingPoolId.get(key);
  }
};
var ReserveContext = _ReserveContext;
ReserveContext.RESERVE_CONTEXT_EMPTY = new _ReserveContext(
  [],
  /* @__PURE__ */ new Map(),
  /* @__PURE__ */ new Map(),
  /* @__PURE__ */ new Map(),
  /* @__PURE__ */ new Map()
);

// src/models/ReserveUtilizationRatio.ts
var ReserveUtilizationRatio = class extends Ratio {
  constructor(mintId, pct) {
    super(pct);
    this.mintId = mintId;
  }
  static na(mintId) {
    return new ReserveUtilizationRatio(mintId);
  }
  getMintId() {
    return this.mintId;
  }
  isCompatibleWith(that) {
    return this.mintId.equals(that.mintId);
  }
};

// src/models/ReserveInfo.ts


var ReserveInfo = class {
  constructor(reserveId, marketId, asset, share, params, stakingPoolId, proto) {
    this.reserveId = reserveId;
    this.marketId = marketId;
    this.asset = asset;
    this.share = share;
    this.params = params;
    this.stakingPoolId = stakingPoolId;
    this.proto = proto;
  }
  static fromRaw(raw) {
    const buffer = raw.account.data;
    const proto = ReserveLayout.decode(buffer);
    const marketId = MarketId.of(proto.lendingMarket);
    const asset = ReserveAssetInfo.fromRaw(proto.liquidity);
    const token = ReserveTokenInfo.fromRaw(proto.collateral);
    const params = ReserveParams.fromRaw(asset.getMintId(), proto.config);
    const stakingPoolId = proto.config.stakingPoolId;
    return new ReserveInfo(
      ReserveId.of(raw.pubkey),
      marketId,
      asset,
      token,
      params,
      stakingPoolId,
      proto
    );
  }
  getProto() {
    return this.proto;
  }
  getId() {
    return this.getReserveId();
  }
  getReserveId() {
    return this.reserveId;
  }
  getMarketId() {
    return this.marketId;
  }
  getAssetMintId() {
    return this.asset.getMintId();
  }
  getAssetBalanceId() {
    return this.asset.getSplAccountId();
  }
  getShareMintId() {
    return this.share.getMintId();
  }
  getShareBalanceId() {
    return this.share.getSplAccountId();
  }
  getOracleId() {
    return this.asset.getOracleId();
  }
  getFeeBalanceId() {
    return this.asset.getFeeAccountId();
  }
  getMarketCap(price) {
    const asset = this.getTotalAsset();
    return new AssetValue(
      asset,
      asset.toValue(_nullishCoalesce(price, () => ( this.getMarkPrice())), this.getQuantityContext())
    );
  }
  getTotalAsset() {
    return this.getAvailableAsset().add(this.getBorrowedAsset());
  }
  getAvailableAssetValue(price) {
    const asset = this.getAvailableAsset();
    return new AssetValue(
      asset,
      asset.toValue(_nullishCoalesce(price, () => ( this.getMarkPrice())), this.getQuantityContext())
    );
  }
  getAvailableAsset() {
    return this.asset.getAvailableAsset();
  }
  getBorrowedAssetValue(price) {
    const asset = this.getBorrowedAsset();
    return new AssetValue(
      asset,
      asset.toValue(_nullishCoalesce(price, () => ( this.getMarkPrice())), this.getQuantityContext())
    );
  }
  getBorrowedAsset() {
    return this.asset.getBorrowedAsset();
  }
  getQuantityContext() {
    return this.asset.getQuantityContext();
  }
  getMarkPrice() {
    return this.asset.getMarkPrice();
  }
  getExchangeRatio() {
    const asset = this.getTotalAsset();
    const share = this.share.getIssuedShare();
    const assetMintId = asset.getMintId();
    const shareMintId = share.getMintId();
    if (asset.isZero()) {
      return new AssetExchangeRate(shareMintId, assetMintId);
    }
    const ratio = Percentage.fromOneBased(share.getRaw().div(asset.getRaw()));
    return new AssetExchangeRate(shareMintId, assetMintId, ratio);
  }
  getUtilizationRatio() {
    const total = this.getTotalAsset();
    if (total.isZero()) {
      return ReserveUtilizationRatio.na(total.getMintId());
    }
    const pct = Percentage.fromOneBased(
      this.getBorrowedAsset().getRaw().div(total.getRaw())
    );
    return new ReserveUtilizationRatio(total.getMintId(), pct);
  }
  getSupplyApy() {
    const utilizationRatio = this.getUtilizationRatio();
    const borrowApy = this.getBorrowApy();
    if (!utilizationRatio.isPresent() || !borrowApy.isPresent()) {
      return Apy.na();
    }
    const utilizationRatioRaw = utilizationRatio.getUnchecked();
    const borrowApyRaw = borrowApy.getUnchecked();
    return Apy.of(utilizationRatioRaw.mul(borrowApyRaw));
  }
  getBorrowApy() {
    const params = this.params;
    const utilizationRatio = this.getUtilizationRatio();
    const optimalUtilizationRatio = params.optimalUtilizationRatio;
    const optimalBorrowRate = params.optimalBorrowRate;
    if (!utilizationRatio.isPresent() || !optimalUtilizationRatio.isPresent() || !optimalBorrowRate.isPresent()) {
      return Apy.na();
    }
    const utilizationRatioRaw = utilizationRatio.getUnchecked();
    const optimalUtilizationRatioRaw = optimalUtilizationRatio.getUnchecked();
    const optimalBorrowRateRaw = optimalBorrowRate.getUnchecked();
    if (optimalUtilizationRatioRaw.eq(1) || utilizationRatioRaw.lt(optimalUtilizationRatioRaw)) {
      const minBorrowRate = params.minBorrowRate;
      if (!minBorrowRate.isPresent()) {
        return Apy.na();
      }
      const minBorrowRateRaw = minBorrowRate.getUnchecked();
      const normalizedFactor2 = utilizationRatioRaw.div(
        optimalUtilizationRatioRaw
      );
      const borrowRateDiff2 = optimalBorrowRateRaw.sub(minBorrowRateRaw);
      return Apy.of(normalizedFactor2.mul(borrowRateDiff2).add(minBorrowRateRaw));
    }
    const maxBorrowRate = params.maxBorrowRate;
    if (!maxBorrowRate.isPresent()) {
      return Apy.na();
    }
    const maxBorrowRateRaw = maxBorrowRate.getUnchecked();
    const normalizedFactor = utilizationRatioRaw.sub(optimalUtilizationRatioRaw).div(new (0, _bigjs2.default)(1).sub(optimalUtilizationRatioRaw));
    const borrowRateDiff = maxBorrowRateRaw.sub(optimalBorrowRateRaw);
    return Apy.of(
      normalizedFactor.mul(borrowRateDiff).add(optimalBorrowRateRaw)
    );
  }
  getStakingPoolId() {
    return this.stakingPoolId;
  }
  async getMarketAuthority() {
    return await _web3js.PublicKey.findProgramAddress(
      [this.getMarketId().toBuffer()],
      PORT_LENDING
    );
  }
  async depositReserve({
    amount,
    userLiquidityWallet,
    destinationCollateralWallet,
    userTransferAuthority
  }) {
    const [authority] = await this.getMarketAuthority();
    const ixs = [];
    ixs.push(
      refreshReserveInstruction(
        this.getReserveId(),
        _nullishCoalesce(this.getOracleId(), () => ( null))
      ),
      depositReserveLiquidityInstruction(
        amount,
        userLiquidityWallet,
        destinationCollateralWallet,
        this.getReserveId(),
        this.getAssetBalanceId(),
        this.getShareMintId(),
        this.getMarketId(),
        authority,
        userTransferAuthority
      )
    );
    return ixs;
  }
  async depositObligationCollateral({
    amount,
    userCollateralWallet,
    obligation,
    obligationOwner,
    userTransferAuthority
  }) {
    const [authority] = await this.getMarketAuthority();
    const ixs = [];
    ixs.push(
      refreshReserveInstruction(
        this.getReserveId(),
        _nullishCoalesce(this.getOracleId(), () => ( null))
      ),
      depositObligationCollateralInstruction(
        amount,
        userCollateralWallet,
        this.getShareBalanceId(),
        this.getReserveId(),
        obligation,
        this.getMarketId(),
        authority,
        obligationOwner,
        userTransferAuthority
      )
    );
    return ixs;
  }
  async borrowObligationLiquidity({
    amount,
    userWallet,
    owner,
    obligation
  }) {
    const [authority] = await this.getMarketAuthority();
    const ixs = [];
    ixs.push(
      borrowObligationLiquidityInstruction(
        amount,
        this.getAssetBalanceId(),
        userWallet,
        this.getReserveId(),
        this.getFeeBalanceId(),
        obligation,
        this.getMarketId(),
        authority,
        owner
      )
    );
    return ixs;
  }
  async redeemCollateral({
    amount,
    userCollateralWallet,
    destinationLiquidityWallet,
    userTransferAuthority
  }) {
    const [authority] = await this.getMarketAuthority();
    const ixs = [];
    ixs.push(
      redeemReserveCollateralInstruction(
        amount,
        userCollateralWallet,
        destinationLiquidityWallet,
        this.getReserveId(),
        this.getShareMintId(),
        this.getAssetBalanceId(),
        this.getMarketId(),
        authority,
        userTransferAuthority
      )
    );
    return ixs;
  }
};
var ReserveAssetInfo = class {
  constructor(mintId, oracleId, feeBalanceId, supplyAccountId, available, borrowed, markPrice, cumulativeBorrowRate, quantityContext) {
    this.mintId = mintId;
    this.oracleId = oracleId;
    this.feeAccountId = feeBalanceId;
    this.supplyAccountId = supplyAccountId;
    this.available = available;
    this.borrowed = borrowed;
    this.markPrice = markPrice;
    this.cumulativeBorrowRate = cumulativeBorrowRate;
    this.quantityContext = quantityContext;
  }
  static fromRaw(raw) {
    const mintId = raw.mintPubkey;
    const oracleId = raw.oracleOption === 1 ? MintId.of(raw.oraclePubkey) : null;
    const feeAccountId = raw.feeReceiver;
    const supplyBalanceId = raw.supplyPubkey;
    const available = Asset.of(mintId, raw.availableAmount);
    const borrowed = Asset.of(mintId, raw.borrowedAmountWads);
    const markPrice = AssetPrice.of(mintId, raw.marketPrice);
    const cumulativeBorrowRate = raw.cumulativeBorrowRateWads;
    const quantityContext = QuantityContext.fromDecimals(raw.mintDecimals);
    return new ReserveAssetInfo(
      mintId,
      oracleId,
      feeAccountId,
      supplyBalanceId,
      available,
      borrowed,
      markPrice,
      cumulativeBorrowRate,
      quantityContext
    );
  }
  getMintId() {
    return this.mintId;
  }
  getOracleId() {
    return this.oracleId;
  }
  getFeeAccountId() {
    return this.feeAccountId;
  }
  getSplAccountId() {
    return this.supplyAccountId;
  }
  getAvailableAsset() {
    return this.available;
  }
  getBorrowedAsset() {
    return this.borrowed;
  }
  getMarkPrice() {
    return this.markPrice;
  }
  getCumulativeBorrowRate() {
    return this.cumulativeBorrowRate;
  }
  getQuantityContext() {
    return this.quantityContext;
  }
};
var ReserveTokenInfo = class {
  constructor(mintId, splAccount, issuedShare) {
    this.mintId = mintId;
    this.splAccountId = splAccount;
    this.issuedShare = issuedShare;
  }
  static fromRaw(raw) {
    const mintId = raw.mintPubkey;
    const splAccountId = raw.supplyPubkey;
    const issuedShare = Share.of(mintId, raw.mintTotalSupply);
    return new ReserveTokenInfo(mintId, splAccountId, issuedShare);
  }
  getMintId() {
    return this.mintId;
  }
  getSplAccountId() {
    return this.splAccountId;
  }
  getIssuedShare() {
    return this.issuedShare;
  }
};
var ReserveParams = class {
  constructor(loanToValueRatio, optimalUtilizationRatio, optimalBorrowRate, minBorrowRate, maxBorrowRate, liquidationThreshold, liquidationPenalty, borrowFee) {
    this.loanToValueRatio = loanToValueRatio;
    this.optimalUtilizationRatio = optimalUtilizationRatio;
    this.optimalBorrowRate = optimalBorrowRate;
    this.minBorrowRate = minBorrowRate;
    this.maxBorrowRate = maxBorrowRate;
    this.liquidationThreshold = liquidationThreshold;
    this.liquidationPenalty = liquidationPenalty;
    this.borrowFee = borrowFee;
  }
  static fromRaw(mintId, config) {
    const loanToValueRatio = config.loanToValueRatio;
    const optimalUtilizationRatio = new ReserveUtilizationRatio(
      mintId,
      config.optimalUtilizationRate
    );
    const optimalBorrowRate = new ReserveBorrowRate(
      mintId,
      config.optimalBorrowRate
    );
    const minBorrowRate = new ReserveBorrowRate(mintId, config.minBorrowRate);
    const maxBorrowRate = new ReserveBorrowRate(mintId, config.maxBorrowRate);
    const liquidationThreshold = config.liquidationThreshold;
    const liquidationPenalty = config.liquidationBonus;
    const borrowFee = Percentage.fromOneBased(config.fees.borrowFeeWad);
    return new ReserveParams(
      loanToValueRatio,
      optimalUtilizationRatio,
      optimalBorrowRate,
      minBorrowRate,
      maxBorrowRate,
      liquidationThreshold,
      liquidationPenalty,
      borrowFee
    );
  }
};

// src/models/Slot.ts
var _Slot = class extends Decimal {
  constructor(value) {
    super(value);
  }
  static zero() {
    return _Slot.SLOT_ZERO;
  }
  static of(raw) {
    return new _Slot(raw);
  }
  static field(property) {
    return new SlotField(property);
  }
  replaceWithValue(value) {
    return _Slot.of(value);
  }
};
var Slot = _Slot;
Slot.SLOT_ZERO = _Slot.of(0);
var SlotField = class extends DecimalField {
  constructor(property) {
    super(BigType.U64, property);
  }
  fromBig(big) {
    return Slot.of(big);
  }
};

// src/models/TokenAccount.ts


var TokenAccount = class {
  constructor(balanceId, walletId, mintId, amount) {
    this.splAccountId = balanceId;
    this.walletId = walletId;
    this.mintId = mintId;
    this.amount = amount;
  }
  static forNative(raw) {
    return new TokenAccount(
      TokenAccountId.of(raw.pubkey),
      WalletId.of(raw.pubkey),
      MintId.native(),
      Lamport.of(raw.account.lamports)
    );
  }
  static fromRaw(raw) {
    const buffer = Buffer.from(raw.account.data);
    const accountInfo = _spltoken.AccountLayout.decode(buffer);
    accountInfo.mint = new (0, _web3js.PublicKey)(accountInfo.mint);
    accountInfo.owner = new (0, _web3js.PublicKey)(accountInfo.owner);
    accountInfo.amount = _spltoken.u64.fromBuffer(accountInfo.amount);
    return new TokenAccount(
      TokenAccountId.of(raw.pubkey),
      WalletId.of(accountInfo.owner),
      MintId.of(accountInfo.mint),
      Lamport.of(accountInfo.amount)
    );
  }
  getId() {
    return this.getSplAccountId();
  }
  getSplAccountId() {
    return this.splAccountId;
  }
  getWalletId() {
    return this.walletId;
  }
  isNative() {
    return this.getMintId().isNative();
  }
  getMintId() {
    return this.mintId;
  }
  isPositive() {
    return this.amount.isPositive();
  }
  getAmount() {
    return this.amount;
  }
};

// src/models/TokenAccountContext.ts
var _TokenAccountContext = class {
  constructor(accounts, bySplAccountId) {
    this.accounts = accounts;
    this.bySplAccountId = bySplAccountId;
  }
  static empty() {
    return _TokenAccountContext.SPL_ACCOUNT_CONTEXT_EMPTY;
  }
  static index(accounts) {
    const bySplAccountId = /* @__PURE__ */ new Map();
    accounts.forEach(
      (a) => bySplAccountId.set(a.getSplAccountId().toString(), a)
    );
    return new _TokenAccountContext(accounts, bySplAccountId);
  }
  isReady() {
    return this.accounts.length > 0;
  }
  getAllTokenAccounts() {
    return this.accounts;
  }
  getSplAccount(splAccountId) {
    const result = this.findSplAccount(splAccountId);
    if (!result) {
      throw new Error(`No account for ${splAccountId}`);
    }
    return result;
  }
  findSplAccount(splAccountId) {
    const key = splAccountId.toString();
    return this.bySplAccountId.get(key);
  }
  getSplAccountByMintId(mintId) {
    const result = this.findSplAccountByMintId(mintId);
    if (!result) {
      throw new Error(`No account for mint ${mintId}`);
    }
    return result;
  }
  findSplAccountByMintId(mintId) {
    const accounts = this.accounts.filter((account) => account.getMintId().equals(mintId)).sort((a, b) => -a.getAmount().compare(b.getAmount()));
    return accounts[0];
  }
};
var TokenAccountContext = _TokenAccountContext;
TokenAccountContext.SPL_ACCOUNT_CONTEXT_EMPTY = _TokenAccountContext.index(
  []
);



























































































exports.AdditionalReward = AdditionalReward; exports.Apy = Apy; exports.Asset = Asset; exports.AssetConfig = AssetConfig; exports.AssetContext = AssetContext; exports.AssetDepositConfig = AssetDepositConfig; exports.AssetDisplayConfig = AssetDisplayConfig; exports.AssetExchangeRate = AssetExchangeRate; exports.AssetPrice = AssetPrice; exports.AssetPriceConfig = AssetPriceConfig; exports.AssetValue = AssetValue; exports.AuthorityId = AuthorityId; exports.BigField = BigField; exports.BigType = BigType; exports.BlobField = BlobField; exports.Collateral = Collateral; exports.Comparable = Comparable; exports.DEFAULT_PORT_LENDING_MARKET = DEFAULT_PORT_LENDING_MARKET; exports.Decimal = Decimal; exports.DecimalField = DecimalField; exports.ExchangeRate = ExchangeRate; exports.Field = Field; exports.Id = Id; exports.Lamport = Lamport; exports.Loan = Loan; exports.MARKET_MAP = MARKET_MAP; exports.Margin = Margin; exports.MarginRatio = MarginRatio; exports.MarketId = MarketId; exports.MintId = MintId; exports.Numerical = Numerical; exports.ObligationCollateralLayout = ObligationCollateralLayout; exports.ObligationLayout = ObligationLayout; exports.ObligationLiquidityLayout = ObligationLiquidityLayout; exports.Optional = Optional; exports.OracleId = OracleId; exports.PORT_LENDING = PORT_LENDING; exports.PORT_PROFILE_DATA_SIZE = PORT_PROFILE_DATA_SIZE; exports.PORT_QUANTITY_CONTEXT = PORT_QUANTITY_CONTEXT; exports.PORT_STAKING = PORT_STAKING; exports.Percentage = Percentage; exports.PortProfile = PortProfile; exports.PortProfileContext = PortProfileContext; exports.PortProfileId = PortProfileId; exports.PriceOracle = PriceOracle; exports.ProfileEntry = ProfileEntry; exports.ProgramId = ProgramId; exports.ProposedAction = ProposedAction; exports.PublicKeyField = PublicKeyField; exports.QuantityContext = QuantityContext; exports.QuoteValue = QuoteValue; exports.RESERVE_DATA_SIZE = RESERVE_DATA_SIZE; exports.Ratio = Ratio; exports.ReserveAssetInfo = ReserveAssetInfo; exports.ReserveBorrowRate = ReserveBorrowRate; exports.ReserveCollateralLayout = ReserveCollateralLayout; exports.ReserveConfigLayout = ReserveConfigLayout; exports.ReserveConfigProtoLayout = ReserveConfigProtoLayout; exports.ReserveContext = ReserveContext; exports.ReserveFeesLayout = ReserveFeesLayout; exports.ReserveId = ReserveId; exports.ReserveInfo = ReserveInfo; exports.ReserveLayout = ReserveLayout; exports.ReserveLiquidityLayout = ReserveLiquidityLayout; exports.ReserveParams = ReserveParams; exports.ReserveTokenInfo = ReserveTokenInfo; exports.ReserveUtilizationRatio = ReserveUtilizationRatio; exports.Share = Share; exports.Slot = Slot; exports.SlotInfoLayout = SlotInfoLayout; exports.StakingPoolId = StakingPoolId; exports.Token = Token; exports.TokenAccount = TokenAccount; exports.TokenAccountContext = TokenAccountContext; exports.TokenAccountId = TokenAccountId; exports.UintField = UintField; exports.Value = Value; exports.ValueRatio = ValueRatio; exports.WalletId = WalletId; exports.WrappedDecimal = WrappedDecimal; exports.WrappedLamport = WrappedLamport; exports.borrowObligationLiquidityInstruction = borrowObligationLiquidityInstruction; exports.depositObligationCollateralInstruction = depositObligationCollateralInstruction; exports.depositReserveLiquidityInstruction = depositReserveLiquidityInstruction; exports.isReserve = isReserve; exports.publicKey = publicKey; exports.redeemReserveCollateralInstruction = redeemReserveCollateralInstruction; exports.refreshReserveInstruction = refreshReserveInstruction; exports.uint128 = uint128; exports.uint64 = uint64;
//# sourceMappingURL=index.js.map