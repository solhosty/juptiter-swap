import { PublicKey, TransactionInstruction, AccountMeta, AccountInfo } from '@solana/web3.js';
import BN from 'bn.js';
import Big, { Comparison, BigSource } from 'big.js';
import * as BufferLayout from '@solana/buffer-layout';
import { u64 } from '@solana/spl-token';
import { TokenInfo } from '@solana/spl-token-registry';

declare const borrowObligationLiquidityInstruction: (liquidityAmount: number | BN, srcLiquidityPubkey: PublicKey, dstLiquidityPubkey: PublicKey, borrowReservePubkey: PublicKey, borrowReserveFeeReceiverPubkey: PublicKey, obligationPubkey: PublicKey, lendingMarketPubkey: PublicKey, marketAuthorityPubkey: PublicKey, obligationOwner: PublicKey, lendingProgramId?: PublicKey) => TransactionInstruction;

declare const depositObligationCollateralInstruction: (collateralAmount: number | BN, srcCollateralPubkey: PublicKey, dstCollateralPubkey: PublicKey, depositReservePubkey: PublicKey, obligationPubkey: PublicKey, lendingMarketPubkey: PublicKey, marketAuthorityPubkey: PublicKey, obligationOwnerPubkey: PublicKey, transferAuthorityPubkey: PublicKey, lendingProgramId?: PublicKey, stakeAccountPubkey?: PublicKey, stakingPoolPubkey?: PublicKey) => TransactionInstruction;

declare const depositReserveLiquidityInstruction: (liquidityAmount: number | BN, srcLiquidityPubkey: PublicKey, dstCollateralPubkey: PublicKey, reservePubkey: PublicKey, reserveLiquiditySupplyPubkey: PublicKey, reserveCollateralMintPubkey: PublicKey, lendingMarketPubkey: PublicKey, lendingMarketAuthorityPubkey: PublicKey, transferAuthorityPubkey: PublicKey, lendingProgramId?: PublicKey) => TransactionInstruction;

declare const redeemReserveCollateralInstruction: (collateralAmount: number | BN, sourceCollateral: PublicKey, destinationLiquidity: PublicKey, reserve: PublicKey, reserveCollateralMint: PublicKey, reserveLiquiditySupply: PublicKey, lendingMarket: PublicKey, lendingMarketAuthority: PublicKey, transferAuthority: PublicKey, lendingProgramId?: PublicKey) => TransactionInstruction;

declare const refreshReserveInstruction: (reserve: PublicKey, oracle: PublicKey | null, lendingProgramId?: PublicKey) => TransactionInstruction;

declare abstract class Comparable<C extends Comparable<C>> {
    eq(that?: C): boolean;
    lt(that?: C): boolean;
    lte(that?: C): boolean;
    gt(that?: C): boolean;
    gte(that?: C): boolean;
    protected abstract compare(that: C): Comparison;
    protected abstract isCompatibleWith(that: C): boolean;
    protected checkCompatible(that: C): void;
    private checkAndCompare;
}

declare abstract class Field<T> extends BufferLayout.Layout {
    abstract decode(b: Uint8Array, offset?: number): T;
}

declare abstract class Numerical<N extends Numerical<N>> extends Comparable<N> {
    private static readonly BIG_ZERO;
    protected constructor();
    static sum<D extends Numerical<D>>(a: D, b: D): D;
    min(that: N): N;
    max(that: N): N;
    add(that: N): N;
    subtract(that: N): N;
    multiply(pct: BigSource): N;
    divide(pct: BigSource): N;
    compare(that: N): Comparison;
    isZero(): boolean;
    isPositive(): boolean;
    isNegative(): boolean;
    getSignum(): number;
    abstract getRaw(): Big;
    abstract replaceWithValue(value: BigSource): N;
    private compareRaw;
}

declare class BigType {
    private static readonly WAD;
    static readonly U8: BigType;
    static readonly U16: BigType;
    static readonly U32: BigType;
    static readonly U64: BigType;
    static readonly U128: BigType;
    static readonly D64: BigType;
    static readonly D128: BigType;
    private readonly bytes;
    private readonly multiplier?;
    private constructor();
    getLayout(): BufferLayout.Layout;
    getBytes(): number;
    getMultiplier(): Big | undefined;
}

declare abstract class Decimal<D extends Decimal<D>> extends Numerical<D> {
    protected readonly raw: Big;
    protected constructor(raw: BigSource);
    getRaw(): Big;
    protected isCompatibleWith(that: D): boolean;
}
declare abstract class DecimalField<T extends Decimal<any>> extends Field<T> {
    private readonly delegate;
    protected constructor(type: BigType, property: string);
    decode(b: Uint8Array, offset?: number): T;
    protected abstract fromBig(big: Big): T;
}

declare enum AccessType {
    UNKNOWN = 0,
    READ = 1,
    WRITE = 2,
    SIGNER = 3
}

declare abstract class Id extends PublicKey {
    getAccess(type: AccessType): AccountMeta;
}

declare class Lamport extends Decimal<Lamport> {
    protected static readonly ZERO: Lamport;
    protected static readonly ONE: Lamport;
    protected static readonly MAX: Lamport;
    private constructor();
    static zero(): Lamport;
    static max(): Lamport;
    static of(raw: BigSource): Lamport;
    static field(type: BigType, property: string): Field<Lamport>;
    isTrivial(): boolean;
    isMax(): boolean;
    toU64(): u64;
    replaceWithValue(value: BigSource): Lamport;
}

declare class Percentage extends Decimal<Percentage> {
    private static PCT_BIP;
    private static PCT_ZERO;
    private static PCT_HUNDRED;
    private static PCT_THOUSAND;
    private constructor();
    static zero(): Percentage;
    static hundred(): Percentage;
    static fromOneBased(oneBased: BigSource): Percentage;
    static fromHundredBased(hundredBased: BigSource): Percentage;
    static fromRaw(raw: BigSource, isHundredBased: boolean): Percentage;
    static field(property: string): Field<Percentage>;
    isTrivial(): boolean;
    isHundredPct(): boolean;
    toOneBasedNumber(dp: number): number;
    toHundredBasedNumber(dp: number): number;
    print(): string;
    replaceWithValue(value: BigSource): Percentage;
}

declare abstract class Ratio<R extends Ratio<R>> extends Comparable<R> {
    private readonly pct?;
    protected constructor(pct?: Percentage);
    isTrivial(): boolean;
    isPresent(): boolean;
    isPositive(): boolean;
    isNegative(): boolean;
    getUnchecked(): Big;
    getPct(): Percentage | undefined;
    print(): string;
    compare(that: R): Comparison;
    toString(): string;
}

declare class MintId extends Id {
    private constructor();
    static native(): MintId;
    static fromBase58(base58: string): MintId;
    static of(key: PublicKey): MintId;
    static field(property: string): Field<MintId>;
    isNative(): boolean;
}

declare abstract class WrappedDecimal<D extends Decimal<D>, W extends WrappedDecimal<D, W>> extends Numerical<W> {
    private readonly wrapped;
    protected constructor(wrapped: D);
    getRaw(): Big;
    getWrapped(): D;
    replaceWithValue(value: BigSource): W;
    protected abstract wrap(value: D): W;
}

declare abstract class WrappedLamport<T extends WrappedLamport<T>> extends WrappedDecimal<Lamport, T> {
    isMax(): boolean;
    toU64(): u64;
    getAmount(): Lamport;
}

declare abstract class Token<T extends Token<T>> extends WrappedLamport<T> {
    private readonly mintId;
    protected constructor(mintId: MintId, lamport: Lamport);
    isNative(): boolean;
    getMintId(): MintId;
    protected isCompatibleWith(that: T): boolean;
}

declare class StakingPoolId extends Id {
    private constructor();
    static fromBase58(base58: string): StakingPoolId;
    static of(key: PublicKey): StakingPoolId;
    static field(property: string): Field<StakingPoolId>;
}

declare class Apy extends Ratio<Apy> {
    private static APY_NA;
    private constructor();
    static na(): Apy;
    static of(raw: BigSource): Apy;
    protected isCompatibleWith(that: Apy): boolean;
}

declare class ReserveId extends Id {
    private constructor();
    static fromBase58(base58: string): ReserveId;
    static of(pubKey: PublicKey): ReserveId;
    static field(property: string): Field<ReserveId>;
}

declare class AdditionalReward {
    private readonly reserveId;
    private readonly apy;
    private readonly accurate;
    private readonly mintId?;
    constructor(reserveId: ReserveId, apy: Apy, accurate?: boolean, mintId?: MintId);
    getReserveId(): ReserveId;
    getApy(): Apy;
    getAccurate(): boolean;
    getMintId(): MintId | undefined;
}

declare class AssetDisplayConfig {
    private readonly name;
    private readonly symbol;
    private readonly color?;
    constructor(name: string, symbol: string, color?: string);
    getName(): string;
    getSymbol(): string;
    getColor(): string | undefined;
}

declare class AssetPriceConfig {
    private readonly decimals;
    private readonly increment;
    private constructor();
    static fromDecimals(decimals: number): AssetPriceConfig;
    getDecimals(): number;
    getIncrement(): Big;
}

declare class AssetDepositConfig {
    private readonly reserveId;
    private readonly min?;
    private readonly max?;
    private readonly remain?;
    constructor(reserveId: ReserveId, args?: {
        min?: BigSource;
        max?: BigSource;
        remain?: BigSource;
    });
    getReserveId(): ReserveId;
    getMin(): Big | undefined;
    getMax(): Big | undefined;
    getRemain(): Big | undefined;
}

declare class AssetConfig {
    private readonly mintId;
    private readonly display;
    private readonly price;
    private readonly deposit;
    private readonly isDefault;
    constructor(mintId: MintId, display: AssetDisplayConfig, price: AssetPriceConfig, deposit?: AssetDepositConfig, isDefault?: boolean);
    checkIsDefault(): boolean;
    getMintId(): MintId;
    getName(): string;
    getSymbol(): string;
    getColor(): string | undefined;
    getDisplayConfig(): AssetDisplayConfig;
    getPriceDecimals(): number;
    getPriceConfig(): AssetPriceConfig;
    getReserveId(): ReserveId | undefined;
    getMaxDeposit(): Asset | undefined;
    getMinDeposit(): Asset | undefined;
    getRemainAsset(): Asset | undefined;
    getDepositConfig(): AssetDepositConfig | undefined;
}

declare class AssetPrice extends Decimal<AssetPrice> {
    private readonly mintId;
    private constructor();
    static of(mintId: MintId, value: BigSource): AssetPrice;
    getMintId(): MintId;
    addFee(pct: Percentage): AssetPrice;
    print(config: AssetConfig): string;
    replaceWithValue(value: BigSource): AssetPrice;
    protected isCompatibleWith(that: AssetPrice): boolean;
}

declare class QuantityContext {
    readonly decimals: number;
    readonly multiplier: Big;
    private constructor();
    static fromDecimals(decimals: number): QuantityContext;
}

declare abstract class Value<V extends Value<V>> extends Decimal<V> {
    private static FORMATTER;
    protected constructor(raw: BigSource);
    toAsset(price: AssetPrice, context: QuantityContext): Asset;
    toNumber(): number;
    print(): string;
    toString(): string;
}

declare class ValueRatio extends Ratio<ValueRatio> {
    private static VALUE_RATIO_NA;
    private constructor();
    static of(pct?: Percentage): ValueRatio;
    static na(): ValueRatio;
    protected isCompatibleWith(that: ValueRatio): boolean;
}

declare class MarginRatio extends Ratio<MarginRatio> {
    private static MARGIN_RATIO_NA;
    private constructor();
    static of(pct?: Percentage): MarginRatio;
    static na(): MarginRatio;
    protected isCompatibleWith(that: MarginRatio): boolean;
}

declare class Margin extends Value<Margin> {
    private static MARGIN_ZERO;
    private constructor();
    static of(raw: Big): Margin;
    static zero(): Margin;
    static field(property: string): Field<Margin>;
    toCollateralValue(loanToValue: Percentage): QuoteValue;
    toRatioAgainst(threshold: Margin): MarginRatio;
    replaceWithValue(value: BigSource): Margin;
}

declare class QuoteValue extends Value<QuoteValue> {
    private static readonly QUOTE_VALUE_ZERO;
    private constructor();
    static of(raw: BigSource): QuoteValue;
    static zero(): QuoteValue;
    static field(property: string): Field<QuoteValue>;
    toCollateralMargin(loanToValue: Percentage): Margin;
    toLoanMargin(): Margin;
    toRatioAgainst(threshold: QuoteValue): ValueRatio;
    replaceWithValue(value: BigSource): QuoteValue;
}

declare class AssetExchangeRate extends Ratio<AssetExchangeRate> {
    private readonly shareMintId;
    private readonly assetMintId;
    constructor(shareMintId: MintId, assetMintId: MintId, pct?: Percentage);
    getShareMintId(): MintId;
    getAssetMintId(): MintId;
    protected isCompatibleWith(that: AssetExchangeRate): boolean;
}

declare class WalletId extends Id {
    private constructor();
    static fromBase58(base58: string): WalletId;
    static of(key: PublicKey): WalletId;
    static field(property: string): Field<WalletId>;
}

declare class TokenAccountId extends Id {
    private constructor();
    static native(walletId: WalletId): TokenAccountId;
    static of(pubKey: PublicKey): TokenAccountId;
    static field(property: string): Field<TokenAccountId>;
}

interface Parsed<I extends Id> {
    getId: () => I;
}

type RawData = {
    pubkey: PublicKey;
    account: AccountInfo<Buffer>;
};

declare class TokenAccount implements Parsed<TokenAccountId> {
    private readonly splAccountId;
    private readonly walletId;
    private readonly mintId;
    private readonly amount;
    constructor(balanceId: TokenAccountId, walletId: WalletId, mintId: MintId, amount: Lamport);
    static forNative(raw: RawData): TokenAccount;
    static fromRaw(raw: RawData): TokenAccount;
    getId(): TokenAccountId;
    getSplAccountId(): TokenAccountId;
    getWalletId(): WalletId;
    isNative(): boolean;
    getMintId(): MintId;
    isPositive(): boolean;
    getAmount(): Lamport;
}

declare class Share extends Token<Share> {
    private constructor();
    static zero(mintId: MintId): Share;
    static max(mintId: MintId): Share;
    static fromTokenAccount(account: TokenAccount): Share;
    static of(mintId: MintId, lamport: Lamport): Share;
    toAsset(exchangeRatio: AssetExchangeRate): Asset;
    protected wrap(value: Lamport): Share;
}

declare class Asset extends Token<Asset> {
    static readonly MIN_NATIVE_LAMPORT: Asset;
    private static SIGNIFICANT_DIGITS;
    private static LARGE_THRESHOLD;
    private static FORMATTER_NORMAL;
    private static FORMATTER_LARGE;
    private constructor();
    static fromString(str: string, mintId: MintId, context: QuantityContext): Asset;
    static zero(mintId: MintId): Asset;
    static max(mintId: MintId): Asset;
    static native(lamport: Lamport): Asset;
    static fromTokenAccount(account: TokenAccount): Asset;
    static of(mintId: MintId, lamport?: Lamport): Asset;
    isNative(): boolean;
    toValue(price: AssetPrice, quantityContext: QuantityContext): QuoteValue;
    toInterest(supplyApy: Apy): Asset;
    toShare(exchangeRatio: AssetExchangeRate): Share;
    addFee(pct: Percentage): Asset;
    toNumber(context: QuantityContext): number;
    plain(context: QuantityContext): string;
    toLimitRoundNumber(context: QuantityContext): number;
    print(context: QuantityContext | undefined, symbol?: string): string;
    protected wrap(value: Lamport): Asset;
}

declare class AssetContext {
    private readonly cache;
    private readonly bySymbol;
    private readonly byReserveId;
    private constructor();
    static index(configs: AssetConfig[]): AssetContext;
    getAllConfigs(): AssetConfig[];
    findConfig(mintId: MintId): AssetConfig;
    findConfigBySymbol(symbol: string): AssetConfig;
    findConfigByReserveId(reserveId: ReserveId): AssetConfig;
}

declare class AssetValue {
    private readonly asset;
    private readonly value;
    constructor(asset: Asset, value: QuoteValue);
    static zero(mintId: MintId): AssetValue;
    getMintId(): MintId;
    getAsset(): Asset;
    getValue(): QuoteValue;
}

declare class AuthorityId extends Id {
    private constructor();
    static fromBase58(base58: string): AuthorityId;
    static of(pubKey: PublicKey): AuthorityId;
    static field(property: string): Field<AuthorityId>;
}

declare abstract class ProfileEntry<T extends ProfileEntry<T>> extends WrappedLamport<T> {
    private readonly reserveId;
    protected constructor(reserveId: ReserveId, amount: Lamport);
    getReserveId(): ReserveId;
    protected isCompatibleWith(that: T): boolean;
}

declare class Collateral extends ProfileEntry<Collateral> {
    constructor(reserveId: ReserveId, amount: Lamport);
    static zero(reserveId: ReserveId): Collateral;
    protected wrap(value: Lamport): Collateral;
}

declare class ExchangeRate extends Decimal<ExchangeRate> {
    private static ZERO;
    private constructor();
    static zero(): ExchangeRate;
    static of(raw: BigSource): ExchangeRate;
    static field(type: BigType, property: string): Field<ExchangeRate>;
    replaceWithValue(value: BigSource): ExchangeRate;
}

declare class ReserveUtilizationRatio extends Ratio<ReserveUtilizationRatio> {
    private readonly mintId;
    constructor(mintId: MintId, pct?: Percentage);
    static na(mintId: MintId): ReserveUtilizationRatio;
    getMintId(): MintId;
    protected isCompatibleWith(that: ReserveUtilizationRatio): boolean;
}

declare class ReserveBorrowRate extends Ratio<ReserveBorrowRate> {
    private readonly mintId;
    constructor(mintId: MintId, pct?: Percentage);
    static na(mintId: MintId): ReserveBorrowRate;
    getMintId(): MintId;
    protected isCompatibleWith(that: ReserveBorrowRate): boolean;
}

declare class OracleId extends Id {
    static fromBase58(base58: string): OracleId;
}

declare class MarketId extends Id {
    private constructor();
    static fromBase58(base58: string): MarketId;
    static of(key: PublicKey): MarketId;
    static field(property: string): Field<MarketId>;
    getName(): string;
}

declare const SlotInfoLayout: (property: string) => BufferLayout.Structure;
interface SlotInfo {
    slot: BN;
    stale: boolean;
}

interface ReserveData {
    version: number;
    lastUpdate: SlotInfo;
    lendingMarket: PublicKey;
    liquidity: ReserveLiquidity;
    collateral: ReserveCollateral;
    config: ReserveConfig;
}
interface ReserveLiquidity {
    mintPubkey: MintId;
    mintDecimals: number;
    supplyPubkey: TokenAccountId;
    feeReceiver: TokenAccountId;
    oracleOption: number;
    oraclePubkey: PublicKey;
    availableAmount: Lamport;
    borrowedAmountWads: Lamport;
    cumulativeBorrowRateWads: ExchangeRate;
    marketPrice: Big;
}
interface ReserveCollateral {
    mintPubkey: MintId;
    mintTotalSupply: Lamport;
    supplyPubkey: TokenAccountId;
}
interface ReserveConfigProto {
    optimalUtilizationRate: number;
    loanToValueRatio: number;
    liquidationBonus: number;
    liquidationThreshold: number;
    minBorrowRate: number;
    optimalBorrowRate: number;
    maxBorrowRate: number;
    fees: {
        borrowFeeWad: BN;
        flashLoanFeeWad: BN;
        hostFeePercentage: number;
    };
    stakingPoolOption: number;
    stakingPool: PublicKey;
}
declare const ReserveConfigProtoLayout: (property: string) => BufferLayout.Structure;
interface ReserveConfig {
    optimalUtilizationRate: Percentage;
    loanToValueRatio: Percentage;
    liquidationBonus: Percentage;
    liquidationThreshold: Percentage;
    minBorrowRate: Percentage;
    optimalBorrowRate: Percentage;
    maxBorrowRate: Percentage;
    fees: {
        borrowFeeWad: Big;
        flashLoanFeeWad: Big;
        hostFeePercentage: number;
    };
    stakingPoolId: StakingPoolId | undefined;
}
declare const ReserveLiquidityLayout: (property: string) => BufferLayout.Structure;
declare const ReserveCollateralLayout: (property: string) => BufferLayout.Structure;
declare const ReserveFeesLayout: (property: string) => BufferLayout.Structure;
declare const ReserveConfigLayout: (property: string) => BufferLayout.Structure;
declare const ReserveLayout: BufferLayout.Structure;
declare const isReserve: (info: AccountInfo<Buffer>) => boolean;
declare const RESERVE_DATA_SIZE: number;

declare const ObligationLayout: BufferLayout.Structure;
declare const ObligationCollateralLayout: BufferLayout.Structure;
declare const ObligationLiquidityLayout: BufferLayout.Structure;
interface ProtoObligation {
    version: number;
    lastUpdate: SlotInfo;
    lendingMarket: PublicKey;
    owner: WalletId;
    depositedValue: QuoteValue;
    borrowedValue: Margin;
    allowedBorrowValue: Margin;
    unhealthyBorrowValue: Margin;
    depositsLen: number;
    borrowsLen: number;
    dataFlat: Buffer;
}
interface PortProfileData {
    version: number;
    lastUpdate: SlotInfo;
    lendingMarket: PublicKey;
    owner: PublicKey;
    deposits: PortProfileCollateralData[];
    borrows: PortProfileLoanData[];
    depositedValue: QuoteValue;
    borrowedValue: Margin;
    allowedBorrowValue: Margin;
    unhealthyBorrowValue: Margin;
}
interface PortProfileCollateralData {
    depositReserve: ReserveId;
    depositedAmount: Lamport;
    marketValue: QuoteValue;
}
interface PortProfileLoanData {
    borrowReserve: ReserveId;
    cumulativeBorrowRateWads: ExchangeRate;
    borrowedAmountWads: Lamport;
    marketValue: QuoteValue;
}
declare const PORT_PROFILE_DATA_SIZE: number;

declare class ReserveInfo implements Parsed<ReserveId> {
    private readonly reserveId;
    readonly marketId: MarketId;
    readonly asset: ReserveAssetInfo;
    readonly share: ReserveTokenInfo;
    readonly params: ReserveParams;
    private readonly stakingPoolId;
    readonly proto: ReserveData;
    constructor(reserveId: ReserveId, marketId: MarketId, asset: ReserveAssetInfo, share: ReserveTokenInfo, params: ReserveParams, stakingPoolId: StakingPoolId | undefined, proto: ReserveData);
    static fromRaw(raw: RawData): ReserveInfo;
    getProto(): ReserveData;
    getId(): ReserveId;
    getReserveId(): ReserveId;
    getMarketId(): MarketId;
    getAssetMintId(): MintId;
    getAssetBalanceId(): TokenAccountId;
    getShareMintId(): MintId;
    getShareBalanceId(): TokenAccountId;
    getOracleId(): OracleId | null;
    getFeeBalanceId(): TokenAccountId;
    getMarketCap(price?: AssetPrice): AssetValue;
    getTotalAsset(): Asset;
    getAvailableAssetValue(price?: AssetPrice): AssetValue;
    getAvailableAsset(): Asset;
    getBorrowedAssetValue(price?: AssetPrice): AssetValue;
    getBorrowedAsset(): Asset;
    getQuantityContext(): QuantityContext;
    getMarkPrice(): AssetPrice;
    getExchangeRatio(): AssetExchangeRate;
    getUtilizationRatio(): ReserveUtilizationRatio;
    getSupplyApy(): Apy;
    getBorrowApy(): Apy;
    getStakingPoolId(): StakingPoolId | undefined;
    getMarketAuthority(): Promise<[PublicKey, number]>;
    depositReserve({ amount, userLiquidityWallet, destinationCollateralWallet, userTransferAuthority, }: {
        amount: BN;
        userLiquidityWallet: PublicKey;
        destinationCollateralWallet: PublicKey;
        userTransferAuthority: PublicKey;
    }): Promise<TransactionInstruction[]>;
    depositObligationCollateral({ amount, userCollateralWallet, obligation, obligationOwner, userTransferAuthority, }: {
        amount: BN;
        userCollateralWallet: PublicKey;
        obligation: PublicKey;
        obligationOwner: PublicKey;
        userTransferAuthority: PublicKey;
    }): Promise<TransactionInstruction[]>;
    borrowObligationLiquidity({ amount, userWallet, owner, obligation, }: {
        amount: BN;
        userWallet: PublicKey;
        obligation: PublicKey;
        owner: PublicKey;
        userTransferAuthority: PublicKey;
    }): Promise<TransactionInstruction[]>;
    redeemCollateral({ amount, userCollateralWallet, destinationLiquidityWallet, userTransferAuthority, }: {
        amount: BN;
        userCollateralWallet: PublicKey;
        destinationLiquidityWallet: PublicKey;
        userTransferAuthority: PublicKey;
    }): Promise<TransactionInstruction[]>;
}
declare class ReserveAssetInfo {
    private readonly mintId;
    private readonly oracleId;
    private readonly feeAccountId;
    private readonly supplyAccountId;
    private readonly available;
    private readonly borrowed;
    private readonly markPrice;
    private readonly cumulativeBorrowRate;
    private readonly quantityContext;
    constructor(mintId: MintId, oracleId: OracleId | null, feeBalanceId: TokenAccountId, supplyAccountId: TokenAccountId, available: Asset, borrowed: Asset, markPrice: AssetPrice, cumulativeBorrowRate: ExchangeRate, quantityContext: QuantityContext);
    static fromRaw(raw: ReserveLiquidity): ReserveAssetInfo;
    getMintId(): MintId;
    getOracleId(): OracleId | null;
    getFeeAccountId(): TokenAccountId;
    getSplAccountId(): TokenAccountId;
    getAvailableAsset(): Asset;
    getBorrowedAsset(): Asset;
    getMarkPrice(): AssetPrice;
    getCumulativeBorrowRate(): ExchangeRate;
    getQuantityContext(): QuantityContext;
}
declare class ReserveTokenInfo {
    private readonly mintId;
    private readonly splAccountId;
    private readonly issuedShare;
    constructor(mintId: MintId, splAccount: TokenAccountId, issuedShare: Share);
    static fromRaw(raw: ReserveCollateral): ReserveTokenInfo;
    getMintId(): MintId;
    getSplAccountId(): TokenAccountId;
    getIssuedShare(): Share;
}
declare class ReserveParams {
    loanToValueRatio: Percentage;
    optimalUtilizationRatio: ReserveUtilizationRatio;
    optimalBorrowRate: ReserveBorrowRate;
    minBorrowRate: ReserveBorrowRate;
    maxBorrowRate: ReserveBorrowRate;
    liquidationThreshold: Percentage;
    liquidationPenalty: Percentage;
    borrowFee: Percentage;
    constructor(loanToValueRatio: Percentage, optimalUtilizationRatio: ReserveUtilizationRatio, optimalBorrowRate: ReserveBorrowRate, minBorrowRate: ReserveBorrowRate, maxBorrowRate: ReserveBorrowRate, liquidationThreshold: Percentage, liquidationPenalty: Percentage, borrowFee: Percentage);
    static fromRaw(mintId: MintId, config: ReserveConfig): ReserveParams;
}

declare class Loan extends ProfileEntry<Loan> {
    private readonly cumulativeBorrowRate;
    constructor(reserveId: ReserveId, amount: Lamport, cumulativeBorrowRate: ExchangeRate);
    static zero(reserve: ReserveInfo): Loan;
    accrueInterest(newCumulativeBorrowRate: ExchangeRate): Loan;
    getCumulativeBorrowRate(): ExchangeRate;
    protected wrap(value: Lamport): Loan;
}

declare class PortProfileId extends Id {
    private constructor();
    static of(pubKey: PublicKey): PortProfileId;
    static fromBase58(base58: string): PortProfileId;
    static field(property: string): Field<PortProfileId>;
}

declare class PortProfile implements Parsed<PortProfileId> {
    private readonly profileId;
    private readonly collaterals;
    private readonly loans;
    private readonly loanMargin;
    private readonly initialMargin;
    private readonly maintenanceMargin;
    private readonly owner;
    private readonly depositedValue;
    private constructor();
    static newAccount(profileId: PortProfileId): PortProfile;
    static fromRaw(raw: RawData): PortProfile;
    getDepositedValue(): QuoteValue | undefined;
    getOwner(): PublicKey | undefined;
    getId(): PortProfileId;
    getProfileId(): PortProfileId;
    getCollateral(reserveId: ReserveId): Collateral | undefined;
    getCollateralReserveIds(): ReserveId[];
    getCollaterals(): Collateral[];
    getLoan(reserveId: ReserveId): Loan | undefined;
    getLoanReserveIds(): ReserveId[];
    getLoans(): Loan[];
    getLoanMargin(): Margin;
    getInitialMargin(): Margin;
    getMaintenanceMargin(): Margin;
    getRiskFactor(): MarginRatio;
    getLoanToValue(): MarginRatio;
}

declare class PortProfileContext {
    private readonly selectedProfile;
    private readonly allProfiles;
    private constructor();
    static index(profiles: PortProfile[], whitelist: PortProfileId | undefined): PortProfileContext;
    getSelectedProfile(): PortProfile | undefined;
    getAllProfiles(): PortProfile[];
}

declare class PriceOracle {
    readonly cache: Map<string, AssetPrice>;
    constructor(cache: Map<string, AssetPrice>);
    static index(prices: AssetPrice[]): PriceOracle;
    getPrice(mintId: MintId): AssetPrice | undefined;
}

declare class ProgramId extends Id {
    private constructor();
    static fromBase58(base58: string): ProgramId;
    static of(key: PublicKey): ProgramId;
}

declare class ProposedAction {
    private readonly assets;
    private readonly shares;
    private readonly collaterals;
    private readonly loans;
    constructor(assets: Asset[], shares: Share[], collaterals: Collateral[], loans: Loan[]);
    static newProposal(args: {
        newAsset?: Asset;
        newShare?: Share;
        newCollateral?: Collateral;
        newLoan?: Loan;
    }): ProposedAction;
    getUpdatedAsset(assetMintId: MintId): Asset | undefined;
    getUpdatedShare(shareMintId: MintId): Share | undefined;
    getUpdatedCollateral(reserveId: ReserveId): Collateral | undefined;
    getUpdatedLoan(reserveId: ReserveId): Loan | undefined;
    getUpdatedCollaterals(collaterals: Collateral[]): Collateral[];
    getUpdatedLoans(loans: Loan[]): Loan[];
    private static proposal;
}

declare class ReserveContext {
    private static readonly RESERVE_CONTEXT_EMPTY;
    private readonly reserves;
    private readonly byReserveId;
    private readonly byAssetMintId;
    private readonly byShareMintId;
    private readonly byStakingPoolId;
    private constructor();
    static empty(): ReserveContext;
    static index(reserves: ReserveInfo[], tokenMap?: Map<string, TokenInfo>): ReserveContext;
    isReady(): boolean;
    getAllReserves(): ReserveInfo[];
    getAllReservesPricePubKey(): (OracleId | null)[];
    getReserve(reserveId: ReserveId): ReserveInfo;
    getByAssetMintId(mintId: MintId): ReserveInfo;
    getByShareMintId(mintId: MintId): ReserveInfo;
    findReserve(reserveId: ReserveId): ReserveInfo | undefined;
    findByAssetMintId(mintId: MintId): ReserveInfo | undefined;
    findByShareMintId(mintId: MintId): ReserveInfo | undefined;
    findByStakingPoolId(stakingPoolId: StakingPoolId): ReserveInfo | undefined;
}

declare class Slot extends Decimal<Slot> {
    private static SLOT_ZERO;
    private constructor();
    static zero(): Slot;
    static of(raw: BigSource): Slot;
    static field(property: string): Field<Slot>;
    replaceWithValue(value: BigSource): Slot;
}

declare class TokenAccountContext {
    private static readonly SPL_ACCOUNT_CONTEXT_EMPTY;
    private readonly accounts;
    private readonly bySplAccountId;
    private constructor();
    static empty(): TokenAccountContext;
    static index(accounts: TokenAccount[]): TokenAccountContext;
    isReady(): boolean;
    getAllTokenAccounts(): TokenAccount[];
    getSplAccount(splAccountId: TokenAccountId): TokenAccount;
    findSplAccount(splAccountId: TokenAccountId): TokenAccount | undefined;
    getSplAccountByMintId(mintId: MintId): TokenAccount;
    findSplAccountByMintId(mintId: MintId): TokenAccount | undefined;
}

declare const PORT_LENDING: PublicKey;
declare const PORT_STAKING: PublicKey;
declare const DEFAULT_PORT_LENDING_MARKET: PublicKey;
declare const PORT_QUANTITY_CONTEXT: QuantityContext;
declare const MARKET_MAP: Record<string, string>;

declare class BigField extends Field<Big> {
    private readonly type;
    private constructor();
    static forType(type: BigType, property: string): BigField;
    decode(b: Uint8Array, offset?: number): Big;
}

declare abstract class BlobField<T> extends Field<T> {
    private readonly delegate;
    protected constructor(span: number, property?: string);
    decode(b: Uint8Array, offset?: number): T;
    protected abstract fromBuffer(buffer: Buffer): T;
}

declare const publicKey: (property: string) => BufferLayout.Layout;
declare const uint64: (property?: string) => BufferLayout.Layout;
declare const uint128: (property?: string) => BufferLayout.Layout;

declare class Optional<T> extends Field<T | undefined> {
    private readonly delegate;
    private constructor();
    static of<T>(field: Field<T>): Optional<T>;
    decode(b: Uint8Array, offset?: number): T | undefined;
}

declare abstract class PublicKeyField<T extends PublicKey> extends BlobField<T> {
    protected constructor(property?: string);
    protected fromBuffer(buffer: Buffer): T;
    protected abstract fromPublicKey(pubKey: PublicKey): T;
}

declare class UintField extends BlobField<BN> {
    constructor(bytes: number, property?: string);
    protected fromBuffer(buffer: Buffer): BN;
}

export { AdditionalReward, Apy, Asset, AssetConfig, AssetContext, AssetDepositConfig, AssetDisplayConfig, AssetExchangeRate, AssetPrice, AssetPriceConfig, AssetValue, AuthorityId, BigField, BigType, BlobField, Collateral, Comparable, DEFAULT_PORT_LENDING_MARKET, Decimal, DecimalField, ExchangeRate, Field, Id, Lamport, Loan, MARKET_MAP, Margin, MarginRatio, MarketId, MintId, Numerical, ObligationCollateralLayout, ObligationLayout, ObligationLiquidityLayout, Optional, OracleId, PORT_LENDING, PORT_PROFILE_DATA_SIZE, PORT_QUANTITY_CONTEXT, PORT_STAKING, Parsed, Percentage, PortProfile, PortProfileCollateralData, PortProfileContext, PortProfileData, PortProfileId, PortProfileLoanData, PriceOracle, ProfileEntry, ProgramId, ProposedAction, ProtoObligation, PublicKeyField, QuantityContext, QuoteValue, RESERVE_DATA_SIZE, Ratio, RawData, ReserveAssetInfo, ReserveBorrowRate, ReserveCollateral, ReserveCollateralLayout, ReserveConfig, ReserveConfigLayout, ReserveConfigProto, ReserveConfigProtoLayout, ReserveContext, ReserveData, ReserveFeesLayout, ReserveId, ReserveInfo, ReserveLayout, ReserveLiquidity, ReserveLiquidityLayout, ReserveParams, ReserveTokenInfo, ReserveUtilizationRatio, Share, Slot, SlotInfo, SlotInfoLayout, StakingPoolId, Token, TokenAccount, TokenAccountContext, TokenAccountId, UintField, Value, ValueRatio, WalletId, WrappedDecimal, WrappedLamport, borrowObligationLiquidityInstruction, depositObligationCollateralInstruction, depositReserveLiquidityInstruction, isReserve, publicKey, redeemReserveCollateralInstruction, refreshReserveInstruction, uint128, uint64 };
