import promiseRetry from 'promise-retry';
import { AccountLayout, u64, MintLayout, Token, ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID } from '@solana/spl-token';
import { PublicKey, SystemProgram, Transaction } from '@solana/web3.js';

class TransactionError extends Error {
  constructor(m, txid, code) {
    super(m);
    this.txid = void 0;
    this.code = void 0;
    this.txid = txid;
    this.code = code; // Set the prototype explicitly.

    Object.setPrototypeOf(this, Error.prototype);
  }

}
const UNKNOWN_ERROR = 'Unknown error, visit the explorer';
const SYSTEM_PROGRAM_ID = '11111111111111111111111111111111';
function parseErrorForTransaction(tx) {
  var _tx$meta;

  // Easy case, logMessages has an obvious error message. From dapp-scaffold
  const errors = [];

  if (tx !== null && tx !== void 0 && tx.meta && tx.meta.logMessages) {
    tx.meta.logMessages.forEach(log => {
      const regex = /Error: (.*)/gm;
      let m;

      while ((m = regex.exec(log)) !== null) {
        // This is necessary to avoid infinite loops with zero-width matches
        if (m.index === regex.lastIndex) {
          regex.lastIndex++;
        }

        if (m.length > 1) {
          errors.push(m[1]);
        }
      }
    });
  }

  if (errors.length > 0) {
    return {
      message: errors.join(',')
    };
  } // Harder case, we need to dig for a custom code


  const transactionError = tx === null || tx === void 0 ? void 0 : (_tx$meta = tx.meta) === null || _tx$meta === void 0 ? void 0 : _tx$meta.err;
  let errorCode;

  if (transactionError && typeof transactionError !== 'string') {
    const instructionError = transactionError.InstructionError;
    const [index, {
      Custom
    }] = instructionError;
    errorCode = Custom !== null && Custom !== void 0 ? Custom : instructionError[1];

    if (tx !== null && tx !== void 0 && tx.meta && tx.meta.logMessages) {
      var _tx$meta2;

      const failedProgramId = getFailedProgram((_tx$meta2 = tx.meta) === null || _tx$meta2 === void 0 ? void 0 : _tx$meta2.logMessages, errorCode);

      if (failedProgramId) {
        if (failedProgramId === SYSTEM_PROGRAM_ID) {
          return getSystemProgramError(instructionError);
        }

        return {
          message: UNKNOWN_ERROR,
          programId: failedProgramId,
          code: errorCode
        };
      }
    }
  }

  return {
    message: typeof transactionError === 'string' ? transactionError : UNKNOWN_ERROR,
    code: errorCode
  };
}

function getFailedProgram(logMessages, errorCode) {
  for (let i = 0; i < logMessages.length; i++) {
    const log = logMessages[i];
    const found = log.match(new RegExp(`Program ([1-9A-HJ-NP-Za-km-z]{32,44}) failed: custom program error: 0x${errorCode.toString(16)}`));

    if (found) {
      return found[1];
    }
  }

  return;
}

function getSystemProgramError(instructionError) {
  const code = instructionError[1].Custom;
  let message = '';

  switch (code) {
    // https://github.com/solana-labs/solana/blob/22a18a68e3ee68ae013d647e62e12128433d7230/sdk/program/src/system_instruction.rs#L12-L26
    // TODO: Do we need to translate all error codes.
    case 0:
      message = 'An account with the same address already exists';

    case 1:
      message = 'The account does not have enough SOL to perform the operation';

    default:
      message = UNKNOWN_ERROR;
  }

  return {
    code,
    programId: SYSTEM_PROGRAM_ID,
    message
  };
}

async function pollForConfirmedTransaction(connection, txid) {
  return promiseRetry(async retry => {
    const response = await connection.getTransaction(txid, {
      commitment: 'confirmed'
    });

    if (!response) {
      retry(new TransactionError('Transaction was not confirmed', txid));
    }

    return response;
  }, {
    retries: 30,
    minTimeout: 500
  }).catch(() => null);
}

const deserializeAccount = data => {
  if (data == undefined || data.length == 0) {
    return undefined;
  }

  const accountInfo = AccountLayout.decode(data);
  accountInfo.mint = new PublicKey(accountInfo.mint);
  accountInfo.owner = new PublicKey(accountInfo.owner);
  accountInfo.amount = u64.fromBuffer(accountInfo.amount);

  if (accountInfo.delegateOption === 0) {
    accountInfo.delegate = null;
    accountInfo.delegatedAmount = new u64(0);
  } else {
    accountInfo.delegate = new PublicKey(accountInfo.delegate);
    accountInfo.delegatedAmount = u64.fromBuffer(accountInfo.delegatedAmount);
  }

  accountInfo.isInitialized = accountInfo.state !== 0;
  accountInfo.isFrozen = accountInfo.state === 2;

  if (accountInfo.isNativeOption === 1) {
    accountInfo.rentExemptReserve = u64.fromBuffer(accountInfo.isNative);
    accountInfo.isNative = true;
  } else {
    accountInfo.rentExemptReserve = null;
    accountInfo.isNative = false;
  }

  if (accountInfo.closeAuthorityOption === 0) {
    accountInfo.closeAuthority = null;
  } else {
    accountInfo.closeAuthority = new PublicKey(accountInfo.closeAuthority);
  }

  return accountInfo;
};

const deserializeMint = (data, address) => {
  if (data.length !== MintLayout.span) {
    // This is causing problem with mainnet token
    // throw new Error('Not a valid Mint')
    return;
  }

  const mintInfo = MintLayout.decode(data);
  mintInfo.address = address;

  if (mintInfo.mintAuthorityOption === 0) {
    mintInfo.mintAuthority = null;
  } else {
    mintInfo.mintAuthority = new PublicKey(mintInfo.mintAuthority);
  }

  mintInfo.supply = u64.fromBuffer(mintInfo.supply);
  mintInfo.isInitialized = mintInfo.isInitialized !== 0;

  if (mintInfo.freezeAuthorityOption === 0) {
    mintInfo.freezeAuthority = null;
  } else {
    mintInfo.freezeAuthority = new PublicKey(mintInfo.freezeAuthority);
  }

  return mintInfo;
};

const SOL_MINT = 'So11111111111111111111111111111111111111112';

async function getWSolATA(connection, publicKey) {
  const wSolAddress = await Token.getAssociatedTokenAddress(ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID, new PublicKey(SOL_MINT), publicKey);
  const accountInfo = await connection.getAccountInfo(wSolAddress);
  return {
    address: wSolAddress,
    accountInfo
  };
}

async function createAndTransferWSOLInstructions(connection, publicKey, amountToTransferInLamports) {
  const wSolAccount = await getWSolATA(connection, publicKey);
  const instructions = []; // If no accountInfo, create one

  if (!wSolAccount.accountInfo) {
    // Create ATA account
    instructions.push(Token.createAssociatedTokenAccountInstruction(ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID, new PublicKey(SOL_MINT), wSolAccount.address, publicKey, publicKey));
  } // Fund account and sync


  instructions.push(SystemProgram.transfer({
    fromPubkey: publicKey,
    toPubkey: wSolAccount.address,
    lamports: amountToTransferInLamports
  }));
  instructions.push( // This is not exposed by the types, but indeed it exists
  Token.createSyncNativeInstruction(TOKEN_PROGRAM_ID, wSolAccount.address));
  const {
    blockhash,
    lastValidBlockHeight
  } = await connection.getLatestBlockhash();
  const transaction = new Transaction({
    feePayer: publicKey,
    blockhash,
    lastValidBlockHeight
  });
  transaction.add(...instructions);
  return transaction;
}

async function createUnwrapSolInstructions(connection, publicKey) {
  const wSolAccount = await getWSolATA(connection, publicKey);
  const instructions = [];

  if (!wSolAccount.accountInfo) {
    return;
  } // Close account


  instructions.push(Token.createCloseAccountInstruction(TOKEN_PROGRAM_ID, wSolAccount.address, publicKey, publicKey, []));
  const {
    blockhash,
    lastValidBlockHeight
  } = await connection.getLatestBlockhash();
  const transaction = new Transaction({
    feePayer: publicKey,
    blockhash,
    lastValidBlockHeight
  });
  transaction.add(...instructions);
  return transaction;
}

export { TransactionError, UNKNOWN_ERROR, createAndTransferWSOLInstructions, createUnwrapSolInstructions, deserializeAccount, deserializeMint, parseErrorForTransaction, pollForConfirmedTransaction };
//# sourceMappingURL=optimist.esm.js.map
