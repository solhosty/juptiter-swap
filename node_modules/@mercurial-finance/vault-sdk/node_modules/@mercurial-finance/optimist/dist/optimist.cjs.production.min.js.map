{"version":3,"file":"optimist.cjs.production.min.js","sources":["../src/tx/errors.ts","../src/utils/wrapSOL.ts","../src/utils/deserializeAccount.ts","../src/utils/deserializeMint.ts","../src/tx/poll.ts"],"sourcesContent":["import { TransactionResponse } from '@solana/web3.js';\n\ntype CustomInstructionError = [index: number, code: { Custom: number }];\ninterface ITransactionError {\n  InstructionError: CustomInstructionError;\n}\n\nexport class TransactionError extends Error {\n  constructor(m: string, public txid?: string, public code?: number) {\n    super(m);\n\n    // Set the prototype explicitly.\n    Object.setPrototypeOf(this, Error.prototype);\n  }\n}\nexport const UNKNOWN_ERROR = 'Unknown error, visit the explorer';\nconst SYSTEM_PROGRAM_ID = '11111111111111111111111111111111';\n\nexport function parseErrorForTransaction(tx: TransactionResponse): {\n  message: string;\n  programId?: string;\n  code?: number;\n} {\n  // Easy case, logMessages has an obvious error message. From dapp-scaffold\n  const errors: string[] = [];\n  if (tx?.meta && tx.meta.logMessages) {\n    tx.meta.logMessages.forEach((log) => {\n      const regex = /Error: (.*)/gm;\n      let m;\n      while ((m = regex.exec(log)) !== null) {\n        // This is necessary to avoid infinite loops with zero-width matches\n        if (m.index === regex.lastIndex) {\n          regex.lastIndex++;\n        }\n\n        if (m.length > 1) {\n          errors.push(m[1]);\n        }\n      }\n    });\n  }\n\n  if (errors.length > 0) {\n    return { message: errors.join(',') };\n  }\n\n  // Harder case, we need to dig for a custom code\n  const transactionError = tx?.meta?.err;\n  let errorCode;\n\n  if (transactionError && typeof transactionError !== 'string') {\n    const instructionError = (transactionError as ITransactionError).InstructionError;\n\n    const [index, { Custom }] = instructionError;\n    errorCode = Custom ?? (instructionError[1] as any as number);\n\n    if (tx?.meta && tx.meta.logMessages) {\n      const failedProgramId = getFailedProgram(tx.meta?.logMessages, errorCode);\n\n      if (failedProgramId) {\n        if (failedProgramId === SYSTEM_PROGRAM_ID) {\n          return getSystemProgramError(instructionError);\n        }\n\n        return {\n          message: UNKNOWN_ERROR,\n          programId: failedProgramId,\n          code: errorCode,\n        };\n      }\n    }\n  }\n\n  return { message: typeof transactionError === 'string' ? transactionError : UNKNOWN_ERROR, code: errorCode };\n}\n\nfunction getFailedProgram(logMessages: String[], errorCode: number) {\n  for (let i = 0; i < logMessages.length; i++) {\n    const log = logMessages[i];\n\n    const found = log.match(\n      new RegExp(`Program ([1-9A-HJ-NP-Za-km-z]{32,44}) failed: custom program error: 0x${errorCode.toString(16)}`),\n    );\n\n    if (found) {\n      return found[1];\n    }\n  }\n\n  return;\n}\n\nfunction getSystemProgramError(instructionError: CustomInstructionError) {\n  const code = instructionError[1].Custom;\n\n  let message = '';\n  switch (code) {\n    // https://github.com/solana-labs/solana/blob/22a18a68e3ee68ae013d647e62e12128433d7230/sdk/program/src/system_instruction.rs#L12-L26\n    // TODO: Do we need to translate all error codes.\n    case 0:\n      message = 'An account with the same address already exists';\n    case 1:\n      message = 'The account does not have enough SOL to perform the operation';\n    default:\n      message = UNKNOWN_ERROR;\n  }\n\n  return {\n    code,\n    programId: SYSTEM_PROGRAM_ID,\n    message,\n  };\n}\n","import { ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID, Token } from '@solana/spl-token';\nimport { Connection, PublicKey, SystemProgram, Transaction } from '@solana/web3.js';\n\nconst SOL_MINT = 'So11111111111111111111111111111111111111112';\n\nasync function getWSolATA(connection: Connection, publicKey: PublicKey) {\n  const wSolAddress = await Token.getAssociatedTokenAddress(\n    ASSOCIATED_TOKEN_PROGRAM_ID,\n    TOKEN_PROGRAM_ID,\n    new PublicKey(SOL_MINT),\n    publicKey,\n  );\n  const accountInfo = await connection.getAccountInfo(wSolAddress);\n  return { address: wSolAddress, accountInfo };\n}\n\nasync function createAndTransferWSOLInstructions(\n  connection: Connection,\n  publicKey: PublicKey,\n  amountToTransferInLamports: number,\n) {\n  const wSolAccount = await getWSolATA(connection, publicKey);\n  const instructions = [];\n\n  // If no accountInfo, create one\n  if (!wSolAccount.accountInfo) {\n    // Create ATA account\n    instructions.push(\n      Token.createAssociatedTokenAccountInstruction(\n        ASSOCIATED_TOKEN_PROGRAM_ID,\n        TOKEN_PROGRAM_ID,\n        new PublicKey(SOL_MINT),\n        wSolAccount.address,\n        publicKey,\n        publicKey,\n      ),\n    );\n  }\n\n  // Fund account and sync\n  instructions.push(\n    SystemProgram.transfer({\n      fromPubkey: publicKey,\n      toPubkey: wSolAccount.address,\n      lamports: amountToTransferInLamports,\n    }),\n  );\n  instructions.push(\n    // This is not exposed by the types, but indeed it exists\n    (Token as any).createSyncNativeInstruction(TOKEN_PROGRAM_ID, wSolAccount.address),\n  );\n\n  const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash();\n  const transaction = new Transaction({ feePayer: publicKey, blockhash, lastValidBlockHeight });\n  transaction.add(...instructions);\n  return transaction;\n}\n\nasync function createUnwrapSolInstructions(connection: Connection, publicKey: PublicKey) {\n  const wSolAccount = await getWSolATA(connection, publicKey);\n  const instructions = [];\n\n  if (!wSolAccount.accountInfo) {\n    return;\n  }\n  // Close account\n  instructions.push(\n    Token.createCloseAccountInstruction(TOKEN_PROGRAM_ID, wSolAccount.address, publicKey, publicKey, []),\n  );\n\n  const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash();\n  const transaction = new Transaction({ feePayer: publicKey, blockhash, lastValidBlockHeight });\n  transaction.add(...instructions);\n  return transaction;\n}\n\nexport { createAndTransferWSOLInstructions, createUnwrapSolInstructions };\n","import { AccountInfo, AccountLayout, u64 } from '@solana/spl-token';\nimport { PublicKey } from '@solana/web3.js';\n\nexport const deserializeAccount = (data: Buffer | undefined): AccountInfo | undefined => {\n  if (data == undefined || data.length == 0) {\n    return undefined;\n  }\n\n  const accountInfo = AccountLayout.decode(data);\n  accountInfo.mint = new PublicKey(accountInfo.mint);\n  accountInfo.owner = new PublicKey(accountInfo.owner);\n  accountInfo.amount = u64.fromBuffer(accountInfo.amount);\n\n  if (accountInfo.delegateOption === 0) {\n    accountInfo.delegate = null;\n    accountInfo.delegatedAmount = new u64(0);\n  } else {\n    accountInfo.delegate = new PublicKey(accountInfo.delegate);\n    accountInfo.delegatedAmount = u64.fromBuffer(accountInfo.delegatedAmount);\n  }\n\n  accountInfo.isInitialized = accountInfo.state !== 0;\n  accountInfo.isFrozen = accountInfo.state === 2;\n\n  if (accountInfo.isNativeOption === 1) {\n    accountInfo.rentExemptReserve = u64.fromBuffer(accountInfo.isNative);\n    accountInfo.isNative = true;\n  } else {\n    accountInfo.rentExemptReserve = null;\n    accountInfo.isNative = false;\n  }\n\n  if (accountInfo.closeAuthorityOption === 0) {\n    accountInfo.closeAuthority = null;\n  } else {\n    accountInfo.closeAuthority = new PublicKey(accountInfo.closeAuthority);\n  }\n\n  return accountInfo;\n};\n","import { PublicKey } from '@solana/web3.js';\nimport { u64, MintInfo, MintLayout } from '@solana/spl-token';\n\n// Backward compatibility for new Mint.\ntype Mint = MintInfo & {\n  address?: PublicKey;\n};\n\nexport const deserializeMint = (data: Buffer, address?: PublicKey) => {\n  if (data.length !== MintLayout.span) {\n    // This is causing problem with mainnet token\n    // throw new Error('Not a valid Mint')\n    return;\n  }\n\n  const mintInfo = MintLayout.decode(data);\n  mintInfo.address = address;\n\n  if (mintInfo.mintAuthorityOption === 0) {\n    mintInfo.mintAuthority = null;\n  } else {\n    mintInfo.mintAuthority = new PublicKey(mintInfo.mintAuthority);\n  }\n\n  mintInfo.supply = u64.fromBuffer(mintInfo.supply);\n  mintInfo.isInitialized = mintInfo.isInitialized !== 0;\n\n  if (mintInfo.freezeAuthorityOption === 0) {\n    mintInfo.freezeAuthority = null;\n  } else {\n    mintInfo.freezeAuthority = new PublicKey(mintInfo.freezeAuthority);\n  }\n\n  return mintInfo as Mint;\n};\n","import { Connection, TransactionResponse, TransactionSignature } from '@solana/web3.js';\nimport { TransactionError } from './errors';\nimport promiseRetry from 'promise-retry';\n\nexport async function pollForConfirmedTransaction(\n  connection: Connection,\n  txid: TransactionSignature,\n): Promise<TransactionResponse | null> {\n  return promiseRetry(\n    async (retry) => {\n      const response = await connection.getTransaction(txid, {\n        commitment: 'confirmed',\n      });\n      if (!response) {\n        retry(new TransactionError('Transaction was not confirmed', txid));\n      }\n      return response;\n    },\n    {\n      retries: 30,\n      minTimeout: 500,\n    },\n  ).catch(() => null);\n}\n"],"names":["TransactionError","Error","constructor","m","txid","code","super","this","Object","setPrototypeOf","prototype","UNKNOWN_ERROR","SOL_MINT","async","getWSolATA","connection","publicKey","wSolAddress","Token","getAssociatedTokenAddress","ASSOCIATED_TOKEN_PROGRAM_ID","TOKEN_PROGRAM_ID","PublicKey","address","accountInfo","getAccountInfo","amountToTransferInLamports","wSolAccount","instructions","push","createAssociatedTokenAccountInstruction","SystemProgram","transfer","fromPubkey","toPubkey","lamports","createSyncNativeInstruction","blockhash","lastValidBlockHeight","getLatestBlockhash","transaction","Transaction","feePayer","add","createCloseAccountInstruction","data","undefined","length","AccountLayout","decode","mint","owner","amount","u64","fromBuffer","delegateOption","delegate","delegatedAmount","isInitialized","state","isFrozen","isNativeOption","rentExemptReserve","isNative","closeAuthority","closeAuthorityOption","MintLayout","span","mintInfo","mintAuthority","mintAuthorityOption","supply","freezeAuthority","freezeAuthorityOption","tx","_tx$meta","errors","meta","logMessages","forEach","log","regex","exec","index","lastIndex","message","join","transactionError","err","errorCode","instructionError","InstructionError","Custom","_tx$meta2","failedProgramId","i","found","match","RegExp","toString","getFailedProgram","programId","getSystemProgramError","promiseRetry","response","getTransaction","commitment","retry","retries","minTimeout","catch"],"mappings":"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"}