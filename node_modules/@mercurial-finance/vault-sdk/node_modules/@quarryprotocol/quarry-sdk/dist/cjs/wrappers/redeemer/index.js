"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RedeemerWrapper = void 0;
const tslib_1 = require("tslib");
const solana_contrib_1 = require("@saberhq/solana-contrib");
const token_utils_1 = require("@saberhq/token-utils");
const web3_js_1 = require("@solana/web3.js");
const pda_1 = require("./pda");
tslib_1.__exportStar(require("./pda"), exports);
class RedeemerWrapper {
    constructor(sdk, iouMint, redemptionMint, key, data) {
        this.sdk = sdk;
        this.iouMint = iouMint;
        this.redemptionMint = redemptionMint;
        this.key = key;
        this.data = data;
    }
    get program() {
        return this.sdk.programs.Redeemer;
    }
    static load({ sdk, iouMint, redemptionMint, }) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const [redeemer] = yield (0, pda_1.findRedeemerKey)({ iouMint, redemptionMint });
            const program = sdk.programs.Redeemer;
            const data = yield program.account.redeemer.fetch(redeemer);
            return new RedeemerWrapper(sdk, iouMint, redemptionMint, redeemer, data);
        });
    }
    static createRedeemer({ sdk, iouMint, redemptionMint, }) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { provider } = sdk;
            const [redeemer, bump] = yield (0, pda_1.findRedeemerKey)({ iouMint, redemptionMint });
            const ata = yield (0, token_utils_1.getOrCreateATA)({
                provider,
                mint: redemptionMint,
                owner: redeemer,
            });
            return {
                bump,
                vaultTokenAccount: ata.address,
                tx: new solana_contrib_1.TransactionEnvelope(sdk.provider, [
                    ...(ata.instruction ? [ata.instruction] : []),
                    sdk.programs.Redeemer.instruction.createRedeemer(bump, {
                        accounts: {
                            redeemer,
                            iouMint,
                            redemptionMint,
                            payer: provider.wallet.publicKey,
                            systemProgram: web3_js_1.SystemProgram.programId,
                        },
                    }),
                ]),
            };
        });
    }
    /**
     * redeemTokensIx
     */
    redeemTokensIx(args) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this.program.instruction.redeemTokens(args.tokenAmount, {
                accounts: yield this.getRedeemTokenAccounts(args),
            });
        });
    }
    redeemTokens(args) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return new solana_contrib_1.TransactionEnvelope(this.sdk.provider, [
                yield this.redeemTokensIx(args),
            ]);
        });
    }
    getVaultAddress() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return yield (0, token_utils_1.getATAAddress)({
                mint: this.redemptionMint,
                owner: this.key,
            });
        });
    }
    getRedeemTokenAccounts(args) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { iouSource, redemptionDestination, sourceAuthority } = args;
            return {
                redeemer: this.key,
                iouMint: this.data.iouMint,
                redemptionMint: this.data.redemptionMint,
                redemptionVault: yield (0, token_utils_1.getATAAddress)({
                    mint: this.data.redemptionMint,
                    owner: this.key,
                }),
                tokenProgram: token_utils_1.TOKEN_PROGRAM_ID,
                sourceAuthority,
                iouSource,
                redemptionDestination,
            };
        });
    }
}
exports.RedeemerWrapper = RedeemerWrapper;
//# sourceMappingURL=index.js.map