"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MinerWrapper = void 0;
const tslib_1 = require("tslib");
const solana_contrib_1 = require("@saberhq/solana-contrib");
const token_utils_1 = require("@saberhq/token-utils");
const web3_js_1 = require("@solana/web3.js");
const pda_1 = require("../mintWrapper/pda");
class MinerWrapper {
    /**
     *
     * @param quarry
     * @param authority
     * @param minerKey
     * @param tokenVaultKey (associated w/ minerKey)
     * @param stakedTokenATA Staked token ATA (associated w/ authority)
     */
    constructor(quarry, authority, minerKey, tokenVaultKey, stakedTokenATA) {
        this.quarry = quarry;
        this.authority = authority;
        this.minerKey = minerKey;
        this.tokenVaultKey = tokenVaultKey;
        this.stakedTokenATA = stakedTokenATA;
    }
    /**
     * The program.
     */
    get program() {
        return this.quarry.program;
    }
    /**
     * The provider.
     */
    get provider() {
        return this.quarry.provider;
    }
    /**
     * The mining SDK.
     */
    get sdk() {
        return this.quarry.sdk;
    }
    /**
     * Creates the miner of the provided wallet.
     */
    initialize() {
        const instruction = this.program.instruction.createMinerV2({
            accounts: {
                authority: this.authority,
                miner: this.minerKey,
                quarry: this.quarry.key,
                systemProgram: web3_js_1.SystemProgram.programId,
                payer: this.provider.wallet.publicKey,
                minerVault: this.tokenVaultKey,
                rewarder: this.quarry.quarryData.rewarder,
                tokenProgram: token_utils_1.TOKEN_PROGRAM_ID,
                tokenMint: this.quarry.token.mintAccount,
            },
        });
        return {
            miner: this.minerKey,
            wrapper: this,
            tx: new solana_contrib_1.TransactionEnvelope(this.provider, [instruction]),
        };
    }
    /**
     * Generates stake accounts for the user.
     * @returns
     */
    get userStakeAccounts() {
        const minerVault = this.tokenVaultKey;
        return Object.assign(Object.assign({}, this.userClaimAccounts), { tokenAccount: this.stakedTokenATA, minerVault });
    }
    /**
     * Generates stake accounts for the user.
     * @returns
     */
    get userClaimAccounts() {
        const authority = this.authority;
        const miner = this.minerKey;
        return {
            authority,
            miner,
            quarry: this.quarry.key,
            tokenProgram: token_utils_1.TOKEN_PROGRAM_ID,
            rewarder: this.quarry.quarryData.rewarder,
            // dummies for backwards compatibility
            unusedMinerVault: token_utils_1.TOKEN_PROGRAM_ID,
            unusedTokenAccount: token_utils_1.TOKEN_PROGRAM_ID,
        };
    }
    _performStakeAction(amount, action) {
        const instruction = this.program.instruction[action](amount.toU64(), {
            accounts: this.userStakeAccounts,
        });
        return new solana_contrib_1.TransactionEnvelope(this.provider, [instruction]);
    }
    _getOrCreateStakedAssociatedTokenAccountInternal() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return yield (0, token_utils_1.getOrCreateATA)({
                provider: this.provider,
                mint: this.quarry.token.mintAccount,
                owner: this.authority,
            });
        });
    }
    /**
     * Creates the ATA of the user's staked token if it doesn't exist.
     */
    createATAIfNotExists() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { instruction } = yield this._getOrCreateStakedAssociatedTokenAccountInternal();
            if (!instruction) {
                return null;
            }
            return new solana_contrib_1.TransactionEnvelope(this.provider, [instruction]);
        });
    }
    /**
     * Stakes the current wallet's tokens into the pool.
     * @param amount
     * @returns
     */
    stake(amount) {
        return this._performStakeAction(amount, "stakeTokens");
    }
    /**
     * Withdraws the current wallet's tokens from the pool.
     * @param amount
     * @returns
     */
    withdraw(amount) {
        return this._performStakeAction(amount, "withdrawTokens");
    }
    /**
     * Fetches the data associated with the miner.
     * @returns
     */
    fetchData() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return yield this.program.account.miner.fetch(this.minerKey);
        });
    }
    /**
     * Claims an amount of tokens.
     * @returns
     */
    claimV1() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const instructions = [];
            const { address: rewardsTokenAccount, instruction: ataInstruction } = yield (0, token_utils_1.getOrCreateATA)({
                provider: this.provider,
                mint: this.quarry.rewarderData.rewardsTokenMint,
                owner: this.authority,
            });
            if (ataInstruction) {
                instructions.push(ataInstruction);
            }
            const [minter] = yield (0, pda_1.findMinterAddress)(this.quarry.rewarderData.mintWrapper, this.quarry.quarryData.rewarder, this.sdk.mintWrapper.program.programId);
            const ix = this.quarry.program.instruction.claimRewards({
                accounts: {
                    mintWrapper: this.quarry.rewarderData.mintWrapper,
                    minter,
                    rewardsTokenMint: this.quarry.rewarderData.rewardsTokenMint,
                    rewardsTokenAccount,
                    claim: this.userClaimAccounts,
                    mintWrapperProgram: this.sdk.programs.MintWrapper.programId,
                    claimFeeTokenAccount: this.quarry.rewarderData.claimFeeTokenAccount,
                },
            });
            instructions.push(ix);
            return this.sdk.newTx(instructions);
        });
    }
    /**
     * Claims an amount of tokens.
     * @returns
     */
    claim() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const instructions = [];
            const { address: rewardsTokenAccount, instruction: ataInstruction } = yield (0, token_utils_1.getOrCreateATA)({
                provider: this.provider,
                mint: this.quarry.rewarderData.rewardsTokenMint,
                owner: this.authority,
            });
            if (ataInstruction) {
                instructions.push(ataInstruction);
            }
            const [minter] = yield (0, pda_1.findMinterAddress)(this.quarry.rewarderData.mintWrapper, this.quarry.quarryData.rewarder, this.sdk.mintWrapper.program.programId);
            const ix = this.quarry.program.instruction.claimRewardsV2({
                accounts: {
                    mintWrapper: this.quarry.rewarderData.mintWrapper,
                    minter,
                    rewardsTokenMint: this.quarry.rewarderData.rewardsTokenMint,
                    rewardsTokenAccount,
                    claim: this.userClaimAccounts,
                    mintWrapperProgram: this.sdk.programs.MintWrapper.programId,
                    claimFeeTokenAccount: this.quarry.rewarderData.claimFeeTokenAccount,
                },
            });
            instructions.push(ix);
            return this.sdk.newTx(instructions);
        });
    }
}
exports.MinerWrapper = MinerWrapper;
//# sourceMappingURL=miner.js.map