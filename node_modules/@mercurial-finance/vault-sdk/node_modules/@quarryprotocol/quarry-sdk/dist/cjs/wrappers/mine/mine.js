"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MineWrapper = void 0;
const tslib_1 = require("tslib");
const token_utils_1 = require("@saberhq/token-utils");
const web3_js_1 = require("@solana/web3.js");
const constants_1 = require("../../constants");
const pda_1 = require("./pda");
const rewarder_1 = require("./rewarder");
class MineWrapper {
    constructor(sdk) {
        this.sdk = sdk;
    }
    get provider() {
        return this.sdk.provider;
    }
    get program() {
        return this.sdk.programs.Mine;
    }
    /**
     *
     * @deprecated Use {@link createRewarder}.
     * @param param0
     * @returns
     */
    createRewarderV1({ mintWrapper, baseKP = web3_js_1.Keypair.generate(), authority = this.provider.wallet.publicKey, }) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const [rewarderKey, bump] = yield (0, pda_1.findRewarderAddress)(baseKP.publicKey, this.program.programId);
            const mintWrapperDataRaw = yield this.provider.getAccountInfo(mintWrapper);
            if (!mintWrapperDataRaw) {
                throw new Error(`mint wrapper does not exist at ${mintWrapper.toString()}`);
            }
            const mintWrapperData = constants_1.QUARRY_CODERS.MintWrapper.accounts.mintWrapper.parse(mintWrapperDataRaw.accountInfo.data);
            const { address: claimFeeTokenAccount, instruction: createATAInstruction } = yield (0, token_utils_1.getOrCreateATA)({
                provider: this.provider,
                mint: mintWrapperData.tokenMint,
                owner: rewarderKey,
            });
            return {
                key: rewarderKey,
                tx: this.provider.newTX([
                    createATAInstruction,
                    this.program.instruction.newRewarder(bump, {
                        accounts: {
                            base: baseKP.publicKey,
                            initialAuthority: authority,
                            rewarder: rewarderKey,
                            payer: this.provider.wallet.publicKey,
                            systemProgram: web3_js_1.SystemProgram.programId,
                            unusedAccount: web3_js_1.SYSVAR_CLOCK_PUBKEY,
                            mintWrapper,
                            rewardsTokenMint: mintWrapperData.tokenMint,
                            claimFeeTokenAccount,
                        },
                    }),
                ], [baseKP]),
            };
        });
    }
    /**
     * Creates a new Rewarder.
     * @param param0
     * @returns
     */
    createRewarder({ mintWrapper, baseKP = web3_js_1.Keypair.generate(), authority = this.provider.wallet.publicKey, }) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const [rewarderKey] = yield (0, pda_1.findRewarderAddress)(baseKP.publicKey, this.program.programId);
            const mintWrapperDataRaw = yield this.provider.getAccountInfo(mintWrapper);
            if (!mintWrapperDataRaw) {
                throw new Error(`mint wrapper does not exist at ${mintWrapper.toString()}`);
            }
            const mintWrapperData = constants_1.QUARRY_CODERS.MintWrapper.accounts.mintWrapper.parse(mintWrapperDataRaw.accountInfo.data);
            const { address: claimFeeTokenAccount, instruction: createATAInstruction } = yield (0, token_utils_1.getOrCreateATA)({
                provider: this.provider,
                mint: mintWrapperData.tokenMint,
                owner: rewarderKey,
            });
            return {
                key: rewarderKey,
                tx: this.provider.newTX([
                    createATAInstruction,
                    this.program.instruction.newRewarderV2({
                        accounts: {
                            base: baseKP.publicKey,
                            initialAuthority: authority,
                            rewarder: rewarderKey,
                            payer: this.provider.wallet.publicKey,
                            systemProgram: web3_js_1.SystemProgram.programId,
                            mintWrapper,
                            rewardsTokenMint: mintWrapperData.tokenMint,
                            claimFeeTokenAccount,
                        },
                    }),
                ], [baseKP]),
            };
        });
    }
    /**
     * Loads the rewarder wrapper.
     * @param rewarder
     * @returns
     */
    loadRewarderWrapper(rewarder) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const rewarderData = yield this.program.account.rewarder.fetch(rewarder);
            return new rewarder_1.RewarderWrapper(this, rewarder, rewarderData);
        });
    }
    /**
     * Rescue stuck tokens in a miner.
     * @returns
     */
    rescueTokens({ mint, miner, minerTokenAccount, owner = this.provider.wallet.publicKey, }) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const instructions = [];
            const { address: destinationTokenAccount, instruction: ataInstruction } = yield (0, token_utils_1.getOrCreateATA)({
                provider: this.provider,
                mint,
                owner,
            });
            if (ataInstruction) {
                instructions.push(ataInstruction);
            }
            instructions.push(this.program.instruction.rescueTokens({
                accounts: {
                    authority: owner,
                    miner,
                    minerTokenAccount,
                    destinationTokenAccount,
                    tokenProgram: token_utils_1.TOKEN_PROGRAM_ID,
                },
            }));
            return this.sdk.newTx(instructions);
        });
    }
}
exports.MineWrapper = MineWrapper;
//# sourceMappingURL=mine.js.map