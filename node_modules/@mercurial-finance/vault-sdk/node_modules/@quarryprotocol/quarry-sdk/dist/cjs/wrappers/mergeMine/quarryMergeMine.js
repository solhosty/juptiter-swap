"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MergeMine = void 0;
const tslib_1 = require("tslib");
const solana_contrib_1 = require("@saberhq/solana-contrib");
const token_utils_1 = require("@saberhq/token-utils");
const web3_js_1 = require("@solana/web3.js");
const constants_1 = require("../../constants");
const pda_1 = require("../mine/pda");
const mergeMiner_1 = require("./mergeMiner");
const mergePool_1 = require("./mergePool");
const pda_2 = require("./pda");
class MergeMine {
    constructor(sdk) {
        this.sdk = sdk;
    }
    get programs() {
        return this.sdk.programs;
    }
    get program() {
        return this.programs.MergeMine;
    }
    get provider() {
        return this.sdk.provider;
    }
    /**
     * Creates a new pool.
     * @returns
     */
    newPool({ primaryMint, payer = this.provider.wallet.publicKey, }) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const [primaryMintRaw] = yield Promise.all([
                this.provider.getAccountInfo(primaryMint),
            ]);
            if (!primaryMintRaw) {
                throw new Error(`Could not find primary mint: ${primaryMint.toString()}`);
            }
            const parsedMint = (0, token_utils_1.deserializeMint)(primaryMintRaw.accountInfo.data);
            const [pool] = yield (0, pda_2.findPoolAddress)({
                programId: this.program.programId,
                primaryMint,
            });
            const [replicaMint] = yield (0, pda_2.findReplicaMintAddress)({
                programId: this.program.programId,
                primaryMint,
            });
            const newPoolIx = this.program.instruction.newPoolV2({
                accounts: {
                    pool,
                    payer,
                    primaryMint,
                    replicaMint,
                    tokenProgram: token_utils_1.TOKEN_PROGRAM_ID,
                    systemProgram: web3_js_1.SystemProgram.programId,
                    rent: web3_js_1.SYSVAR_RENT_PUBKEY,
                },
            });
            const createPool = new solana_contrib_1.TransactionEnvelope(this.provider, [newPoolIx]);
            return {
                key: pool,
                tx: createPool,
                replicaToken: token_utils_1.Token.fromMint(replicaMint, parsedMint.decimals),
            };
        });
    }
    fetchMergePoolData(key) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return {
                key,
                data: yield this.program.account.mergePool.fetch(key),
            };
        });
    }
    fetchMergeMinerData(key) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return {
                key,
                data: yield this.program.account.mergeMiner.fetch(key),
            };
        });
    }
    findPoolAddress({ primaryMint, }) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const [pool] = yield (0, pda_2.findPoolAddress)({
                programId: this.program.programId,
                primaryMint,
            });
            return pool;
        });
    }
    findMergeMinerAddress({ owner = this.provider.wallet.publicKey, pool, }) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const [mm] = yield (0, pda_2.findMergeMinerAddress)({
                programId: this.program.programId,
                pool,
                owner,
            });
            return mm;
        });
    }
    /**
     * Creates a new MM.
     * @param param0
     * @returns
     */
    newMM({ owner = this.provider.wallet.publicKey, payer = this.provider.wallet.publicKey, pool: { key: poolKey, data: { primaryMint }, }, rewarder, rewardsMint, }) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const [mm] = yield (0, pda_2.findMergeMinerAddress)({
                programId: this.program.programId,
                pool: poolKey,
                owner,
            });
            // mm ATAs
            const { instructions } = yield (0, token_utils_1.getOrCreateATAs)({
                provider: this.provider,
                mints: {
                    rewards: rewardsMint,
                    primary: primaryMint,
                },
                owner: mm,
            });
            const allInstructions = [...instructions];
            const mergeMinerAccountInfo = yield this.sdk.provider.connection.getAccountInfo(mm);
            if (!mergeMinerAccountInfo) {
                allInstructions.push(this.program.instruction.initMergeMinerV2({
                    accounts: {
                        pool: poolKey,
                        owner,
                        mm,
                        payer,
                        systemProgram: web3_js_1.SystemProgram.programId,
                    },
                }));
            }
            const { ixs: initPrimaryIxs } = yield this.getOrCreatePrimary({
                mint: primaryMint,
                pool: poolKey,
                mm,
                payer,
                rewarder,
            });
            allInstructions.push(...initPrimaryIxs);
            return {
                key: mm,
                tx: allInstructions.length
                    ? new solana_contrib_1.TransactionEnvelope(this.provider, allInstructions)
                    : null,
            };
        });
    }
    getOrCreatePrimary({ mint, pool, mm, payer = this.provider.wallet.publicKey, rewarder, }) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const [quarryKey] = yield (0, pda_1.findQuarryAddress)(rewarder, mint);
            const [minerKey] = yield (0, pda_1.findMinerAddress)(quarryKey, mm);
            const ixs = [];
            const minerAccountInfo = yield this.sdk.provider.connection.getAccountInfo(minerKey);
            if (minerAccountInfo) {
                return { miner: minerKey, ixs };
            }
            const minerATA = yield (0, token_utils_1.getOrCreateATA)({
                provider: this.provider,
                mint,
                owner: minerKey,
            });
            if (minerATA.instruction) {
                ixs.push(minerATA.instruction);
            }
            ixs.push(this.program.instruction.initMinerV2({
                accounts: {
                    mineProgram: this.sdk.mine.program.programId,
                    pool,
                    mm,
                    systemProgram: web3_js_1.SystemProgram.programId,
                    payer,
                    tokenProgram: token_utils_1.TOKEN_PROGRAM_ID,
                    rewarder,
                    miner: minerKey,
                    quarry: quarryKey,
                    tokenMint: mint,
                    minerVault: minerATA.address,
                },
            }));
            return {
                miner: minerKey,
                ixs,
            };
        });
    }
    initMiner({ mint, pool, mm, payer = this.provider.wallet.publicKey, rewarder, }) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const [quarryKey] = yield (0, pda_1.findQuarryAddress)(rewarder, mint);
            const [minerKey] = yield (0, pda_1.findMinerAddress)(quarryKey, mm);
            const minerATA = yield (0, token_utils_1.getOrCreateATA)({
                provider: this.provider,
                mint,
                owner: minerKey,
            });
            const initMinerIX = this.program.instruction.initMinerV2({
                accounts: {
                    mineProgram: this.sdk.mine.program.programId,
                    pool,
                    mm,
                    systemProgram: web3_js_1.SystemProgram.programId,
                    payer,
                    tokenProgram: token_utils_1.TOKEN_PROGRAM_ID,
                    rewarder,
                    miner: minerKey,
                    quarry: quarryKey,
                    tokenMint: mint,
                    minerVault: minerATA.address,
                },
            });
            return {
                tx: new solana_contrib_1.TransactionEnvelope(this.provider, [
                    ...(minerATA.instruction ? [minerATA.instruction] : []),
                    initMinerIX,
                ]),
                miner: minerKey,
            };
        });
    }
    /**
     * Loads a mm.
     * @returns
     */
    loadMM({ mmKey }) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const mm = yield this.fetchMergeMinerData(mmKey);
            const pool = yield this.fetchMergePoolData(mm.data.pool);
            return new mergeMiner_1.MergeMiner(this, pool, mm);
        });
    }
    /**
     * Loads a mp.
     * @returns
     */
    loadMP({ mpKey }) {
        return new mergePool_1.MergePool(this, mpKey);
    }
    /**
     * Rescue stuck tokens in a merge miner.
     * @returns
     */
    rescueTokens({ mergePool, mergeMiner, miner, minerTokenAccount, destinationTokenAccount, }) {
        const withdrawTokensIX = this.program.instruction.rescueTokens({
            accounts: {
                mmOwner: this.provider.wallet.publicKey,
                mergePool,
                mm: mergeMiner,
                miner,
                minerTokenAccount,
                destinationTokenAccount,
                tokenProgram: token_utils_1.TOKEN_PROGRAM_ID,
                quarryMineProgram: constants_1.QUARRY_ADDRESSES.Mine,
            },
        });
        return new solana_contrib_1.TransactionEnvelope(this.provider, [withdrawTokensIX]);
    }
}
exports.MergeMine = MergeMine;
//# sourceMappingURL=quarryMergeMine.js.map