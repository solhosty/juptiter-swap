import type { Provider } from "@saberhq/solana-contrib";
import { TransactionEnvelope } from "@saberhq/solana-contrib";
import { Token } from "@saberhq/token-utils";
import type { PublicKey, TransactionInstruction } from "@solana/web3.js";
import type { Programs } from "../../constants";
import type { MergeMinerData, MergePoolData, QuarryMergeMineProgram } from "../../programs";
import type { QuarrySDK } from "../../sdk";
import { MergeMiner } from "./mergeMiner";
import { MergePool } from "./mergePool";
export declare class MergeMine {
    readonly sdk: QuarrySDK;
    constructor(sdk: QuarrySDK);
    get programs(): Programs;
    get program(): QuarryMergeMineProgram;
    get provider(): Provider;
    /**
     * Creates a new pool.
     * @returns
     */
    newPool({ primaryMint, payer, }: {
        /**
         * Primary mint.
         */
        primaryMint: PublicKey;
        payer?: PublicKey;
    }): Promise<{
        key: PublicKey;
        tx: TransactionEnvelope;
        replicaToken: Token;
    }>;
    fetchMergePoolData(key: PublicKey): Promise<{
        key: PublicKey;
        data: MergePoolData;
    }>;
    fetchMergeMinerData(key: PublicKey): Promise<{
        key: PublicKey;
        data: MergeMinerData;
    }>;
    findPoolAddress({ primaryMint, }: {
        primaryMint: PublicKey;
    }): Promise<PublicKey>;
    findMergeMinerAddress({ owner, pool, }: {
        owner?: PublicKey;
        pool: PublicKey;
    }): Promise<PublicKey>;
    /**
     * Creates a new MM.
     * @param param0
     * @returns
     */
    newMM({ owner, payer, pool: { key: poolKey, data: { primaryMint }, }, rewarder, rewardsMint, }: {
        owner?: PublicKey;
        payer?: PublicKey;
        pool: {
            key: PublicKey;
            data: Pick<MergePoolData, "primaryMint">;
        };
        /**
         * Rewarder to deposit into.
         */
        rewarder: PublicKey;
        /**
         * Mint received as rewards from the initial rewarder.
         */
        rewardsMint: PublicKey;
    }): Promise<{
        key: PublicKey;
        tx: TransactionEnvelope | null;
    }>;
    getOrCreatePrimary({ mint, pool, mm, payer, rewarder, }: {
        mint: PublicKey;
        pool: PublicKey;
        mm: PublicKey;
        payer?: PublicKey;
        rewarder: PublicKey;
    }): Promise<{
        miner: PublicKey;
        ixs: TransactionInstruction[];
    }>;
    initMiner({ mint, pool, mm, payer, rewarder, }: {
        mint: PublicKey;
        pool: PublicKey;
        mm: PublicKey;
        payer?: PublicKey;
        rewarder: PublicKey;
    }): Promise<{
        tx: TransactionEnvelope;
        miner: PublicKey;
    }>;
    /**
     * Loads a mm.
     * @returns
     */
    loadMM({ mmKey }: {
        mmKey: PublicKey;
    }): Promise<MergeMiner>;
    /**
     * Loads a mp.
     * @returns
     */
    loadMP({ mpKey }: {
        mpKey: PublicKey;
    }): MergePool;
    /**
     * Rescue stuck tokens in a merge miner.
     * @returns
     */
    rescueTokens({ mergePool, mergeMiner, miner, minerTokenAccount, destinationTokenAccount, }: {
        mergePool: PublicKey;
        mergeMiner: PublicKey;
        miner: PublicKey;
        minerTokenAccount: PublicKey;
        destinationTokenAccount: PublicKey;
    }): TransactionEnvelope;
}
//# sourceMappingURL=quarryMergeMine.d.ts.map