import { __awaiter } from "tslib";
import { TransactionEnvelope } from "@saberhq/solana-contrib";
import { deserializeMint, getOrCreateATA, getOrCreateATAs, Token, TOKEN_PROGRAM_ID, } from "@saberhq/token-utils";
import { SystemProgram, SYSVAR_RENT_PUBKEY } from "@solana/web3.js";
import { QUARRY_ADDRESSES } from "../../constants";
import { findMinerAddress, findQuarryAddress } from "../mine/pda";
import { MergeMiner } from "./mergeMiner";
import { MergePool } from "./mergePool";
import { findMergeMinerAddress, findPoolAddress, findReplicaMintAddress, } from "./pda";
export class MergeMine {
    constructor(sdk) {
        this.sdk = sdk;
    }
    get programs() {
        return this.sdk.programs;
    }
    get program() {
        return this.programs.MergeMine;
    }
    get provider() {
        return this.sdk.provider;
    }
    /**
     * Creates a new pool.
     * @returns
     */
    newPool({ primaryMint, payer = this.provider.wallet.publicKey, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const [primaryMintRaw] = yield Promise.all([
                this.provider.getAccountInfo(primaryMint),
            ]);
            if (!primaryMintRaw) {
                throw new Error(`Could not find primary mint: ${primaryMint.toString()}`);
            }
            const parsedMint = deserializeMint(primaryMintRaw.accountInfo.data);
            const [pool] = yield findPoolAddress({
                programId: this.program.programId,
                primaryMint,
            });
            const [replicaMint] = yield findReplicaMintAddress({
                programId: this.program.programId,
                primaryMint,
            });
            const newPoolIx = this.program.instruction.newPoolV2({
                accounts: {
                    pool,
                    payer,
                    primaryMint,
                    replicaMint,
                    tokenProgram: TOKEN_PROGRAM_ID,
                    systemProgram: SystemProgram.programId,
                    rent: SYSVAR_RENT_PUBKEY,
                },
            });
            const createPool = new TransactionEnvelope(this.provider, [newPoolIx]);
            return {
                key: pool,
                tx: createPool,
                replicaToken: Token.fromMint(replicaMint, parsedMint.decimals),
            };
        });
    }
    fetchMergePoolData(key) {
        return __awaiter(this, void 0, void 0, function* () {
            return {
                key,
                data: yield this.program.account.mergePool.fetch(key),
            };
        });
    }
    fetchMergeMinerData(key) {
        return __awaiter(this, void 0, void 0, function* () {
            return {
                key,
                data: yield this.program.account.mergeMiner.fetch(key),
            };
        });
    }
    findPoolAddress({ primaryMint, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const [pool] = yield findPoolAddress({
                programId: this.program.programId,
                primaryMint,
            });
            return pool;
        });
    }
    findMergeMinerAddress({ owner = this.provider.wallet.publicKey, pool, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const [mm] = yield findMergeMinerAddress({
                programId: this.program.programId,
                pool,
                owner,
            });
            return mm;
        });
    }
    /**
     * Creates a new MM.
     * @param param0
     * @returns
     */
    newMM({ owner = this.provider.wallet.publicKey, payer = this.provider.wallet.publicKey, pool: { key: poolKey, data: { primaryMint }, }, rewarder, rewardsMint, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const [mm] = yield findMergeMinerAddress({
                programId: this.program.programId,
                pool: poolKey,
                owner,
            });
            // mm ATAs
            const { instructions } = yield getOrCreateATAs({
                provider: this.provider,
                mints: {
                    rewards: rewardsMint,
                    primary: primaryMint,
                },
                owner: mm,
            });
            const allInstructions = [...instructions];
            const mergeMinerAccountInfo = yield this.sdk.provider.connection.getAccountInfo(mm);
            if (!mergeMinerAccountInfo) {
                allInstructions.push(this.program.instruction.initMergeMinerV2({
                    accounts: {
                        pool: poolKey,
                        owner,
                        mm,
                        payer,
                        systemProgram: SystemProgram.programId,
                    },
                }));
            }
            const { ixs: initPrimaryIxs } = yield this.getOrCreatePrimary({
                mint: primaryMint,
                pool: poolKey,
                mm,
                payer,
                rewarder,
            });
            allInstructions.push(...initPrimaryIxs);
            return {
                key: mm,
                tx: allInstructions.length
                    ? new TransactionEnvelope(this.provider, allInstructions)
                    : null,
            };
        });
    }
    getOrCreatePrimary({ mint, pool, mm, payer = this.provider.wallet.publicKey, rewarder, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const [quarryKey] = yield findQuarryAddress(rewarder, mint);
            const [minerKey] = yield findMinerAddress(quarryKey, mm);
            const ixs = [];
            const minerAccountInfo = yield this.sdk.provider.connection.getAccountInfo(minerKey);
            if (minerAccountInfo) {
                return { miner: minerKey, ixs };
            }
            const minerATA = yield getOrCreateATA({
                provider: this.provider,
                mint,
                owner: minerKey,
            });
            if (minerATA.instruction) {
                ixs.push(minerATA.instruction);
            }
            ixs.push(this.program.instruction.initMinerV2({
                accounts: {
                    mineProgram: this.sdk.mine.program.programId,
                    pool,
                    mm,
                    systemProgram: SystemProgram.programId,
                    payer,
                    tokenProgram: TOKEN_PROGRAM_ID,
                    rewarder,
                    miner: minerKey,
                    quarry: quarryKey,
                    tokenMint: mint,
                    minerVault: minerATA.address,
                },
            }));
            return {
                miner: minerKey,
                ixs,
            };
        });
    }
    initMiner({ mint, pool, mm, payer = this.provider.wallet.publicKey, rewarder, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const [quarryKey] = yield findQuarryAddress(rewarder, mint);
            const [minerKey] = yield findMinerAddress(quarryKey, mm);
            const minerATA = yield getOrCreateATA({
                provider: this.provider,
                mint,
                owner: minerKey,
            });
            const initMinerIX = this.program.instruction.initMinerV2({
                accounts: {
                    mineProgram: this.sdk.mine.program.programId,
                    pool,
                    mm,
                    systemProgram: SystemProgram.programId,
                    payer,
                    tokenProgram: TOKEN_PROGRAM_ID,
                    rewarder,
                    miner: minerKey,
                    quarry: quarryKey,
                    tokenMint: mint,
                    minerVault: minerATA.address,
                },
            });
            return {
                tx: new TransactionEnvelope(this.provider, [
                    ...(minerATA.instruction ? [minerATA.instruction] : []),
                    initMinerIX,
                ]),
                miner: minerKey,
            };
        });
    }
    /**
     * Loads a mm.
     * @returns
     */
    loadMM({ mmKey }) {
        return __awaiter(this, void 0, void 0, function* () {
            const mm = yield this.fetchMergeMinerData(mmKey);
            const pool = yield this.fetchMergePoolData(mm.data.pool);
            return new MergeMiner(this, pool, mm);
        });
    }
    /**
     * Loads a mp.
     * @returns
     */
    loadMP({ mpKey }) {
        return new MergePool(this, mpKey);
    }
    /**
     * Rescue stuck tokens in a merge miner.
     * @returns
     */
    rescueTokens({ mergePool, mergeMiner, miner, minerTokenAccount, destinationTokenAccount, }) {
        const withdrawTokensIX = this.program.instruction.rescueTokens({
            accounts: {
                mmOwner: this.provider.wallet.publicKey,
                mergePool,
                mm: mergeMiner,
                miner,
                minerTokenAccount,
                destinationTokenAccount,
                tokenProgram: TOKEN_PROGRAM_ID,
                quarryMineProgram: QUARRY_ADDRESSES.Mine,
            },
        });
        return new TransactionEnvelope(this.provider, [withdrawTokensIX]);
    }
}
//# sourceMappingURL=quarryMergeMine.js.map