import { __awaiter } from "tslib";
import { TransactionEnvelope } from "@saberhq/solana-contrib";
import { getATAAddress, getOrCreateATA, Token, u64, } from "@saberhq/token-utils";
import { QuarrySDK } from "../../sdk";
import { MinerWrapper } from "./miner";
import { Payroll } from "./payroll";
import { findMinerAddress } from "./pda";
export class QuarryWrapper {
    constructor(sdk, 
    /**
     * The token being staked.
     */
    token, 
    /**
     * The data of the rewarder.
     */
    rewarderData, 
    /**
     * The data of the quarry.
     */
    quarryData, 
    /**
     * The key of the quarry.
     */
    key) {
        this.sdk = sdk;
        this.token = token;
        this.rewarderData = rewarderData;
        this.quarryData = quarryData;
        this.key = key;
    }
    static fromData(provider, rewarder, quarry) {
        return new QuarryWrapper(QuarrySDK.load({ provider }), Token.fromMint(quarry.account.tokenMintKey, quarry.account.tokenMintDecimals), rewarder.account, quarry.account, quarry.publicKey);
    }
    /**
     * The program.
     */
    get program() {
        return this.sdk.programs.Mine;
    }
    /**
     * The provider.
     */
    get provider() {
        return this.sdk.provider;
    }
    /**
     * Loads a quarry
     * @returns
     */
    static load({ sdk, token, key, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const program = sdk.programs.Mine;
            const quarryData = yield program.account.quarry.fetch(key);
            const rewarderData = yield program.account.rewarder.fetch(quarryData.rewarder);
            return new QuarryWrapper(sdk, token, rewarderData, quarryData, key);
        });
    }
    /**
     * Get the computed rewards rate of the quarry.
     *
     * This is used for tests, so you probably don't want this.
     * You want quarryData.annualRewardsRate.
     *
     * @returns annualRewardsRate
     */
    computeAnnualRewardsRate() {
        const rewarder = this.rewarderData;
        const totalRewardsShares = rewarder.totalRewardsShares;
        if (totalRewardsShares.isZero()) {
            return new u64(0);
        }
        const numerator = rewarder.annualRewardsRate.mul(this.quarryData.rewardsShare);
        return numerator.div(totalRewardsShares);
    }
    /**
     * Get the public key of the miner assocaited with the authority account
     * @param authority who owns the miner
     * @returns miner public key
     */
    getMinerAddress(authority) {
        return __awaiter(this, void 0, void 0, function* () {
            const [key] = yield findMinerAddress(this.key, authority, this.program.programId);
            return key;
        });
    }
    /**
     * Get the miner data associated with the authority account
     * @param authority
     * @returns
     */
    getMiner(authority) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.program.account.miner.fetch(yield this.getMinerAddress(authority));
            }
            catch (e) {
                return null;
            }
        });
    }
    /**
     * Get the miner associated with the authority account
     * @param authority
     * @returns
     */
    getMinerActions(authority = this.provider.wallet.publicKey) {
        return __awaiter(this, void 0, void 0, function* () {
            const miner = yield this.getMinerAddress(authority);
            const stakedTokenATA = yield getATAAddress({
                mint: this.quarryData.tokenMintKey,
                owner: authority,
            });
            const tokenVaultKey = yield getATAAddress({
                mint: this.quarryData.tokenMintKey,
                owner: miner,
            });
            return this.createMinerWrapper(authority, miner, tokenVaultKey, stakedTokenATA);
        });
    }
    /**
     * Creates a miner wrapper
     * @param authority
     * @param minerKey
     * @param tokenVaultKey
     * @param stakedTokenATA
     * @returns
     */
    createMinerWrapper(authority, minerKey, tokenVaultKey, stakedTokenATA) {
        return new MinerWrapper(this, authority, minerKey, tokenVaultKey, stakedTokenATA);
    }
    /**
     * Sets the rewards share of this mine.
     */
    setRewardsShare(share) {
        return new TransactionEnvelope(this.provider, [
            this.program.instruction.setRewardsShare(share, {
                accounts: {
                    auth: {
                        authority: this.provider.wallet.publicKey,
                        rewarder: this.quarryData.rewarder,
                    },
                    quarry: this.key,
                },
            }),
        ]);
    }
    /**
     * Sets the famine timestampe for this mine.
     */
    setFamine(famineTs) {
        return new TransactionEnvelope(this.provider, [
            this.program.instruction.setFamine(famineTs, {
                accounts: {
                    auth: {
                        authority: this.provider.wallet.publicKey,
                        rewarder: this.quarryData.rewarder,
                    },
                    quarry: this.key,
                },
            }),
        ]);
    }
    /**
     * Creates the miner of the provided wallet.
     */
    createMiner({ authority = this.provider.wallet.publicKey, } = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const [miner] = yield findMinerAddress(this.key, authority, this.program.programId);
            const { address: minerVault, instruction: createATATX } = yield getOrCreateATA({
                provider: this.provider,
                mint: this.quarryData.tokenMintKey,
                owner: miner,
            });
            const stakedTokenATA = yield getATAAddress({
                mint: this.quarryData.tokenMintKey,
                owner: authority,
            });
            const wrapper = this.createMinerWrapper(authority, miner, minerVault, stakedTokenATA);
            const result = wrapper.initialize();
            if (createATATX) {
                result.tx.instructions.unshift(createATATX);
            }
            return result;
        });
    }
    /**
     * Payroll helper
     */
    get payroll() {
        const data = this.quarryData;
        return new Payroll(data.famineTs, data.lastUpdateTs, data.annualRewardsRate, data.rewardsPerTokenStored, data.totalTokensDeposited);
    }
}
//# sourceMappingURL=quarry.js.map