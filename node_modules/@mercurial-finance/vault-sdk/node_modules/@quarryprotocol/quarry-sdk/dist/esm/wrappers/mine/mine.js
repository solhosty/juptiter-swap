import { __awaiter } from "tslib";
import { getOrCreateATA, TOKEN_PROGRAM_ID } from "@saberhq/token-utils";
import { Keypair, SystemProgram, SYSVAR_CLOCK_PUBKEY } from "@solana/web3.js";
import { QUARRY_CODERS } from "../../constants";
import { findRewarderAddress } from "./pda";
import { RewarderWrapper } from "./rewarder";
export class MineWrapper {
    constructor(sdk) {
        this.sdk = sdk;
    }
    get provider() {
        return this.sdk.provider;
    }
    get program() {
        return this.sdk.programs.Mine;
    }
    /**
     *
     * @deprecated Use {@link createRewarder}.
     * @param param0
     * @returns
     */
    createRewarderV1({ mintWrapper, baseKP = Keypair.generate(), authority = this.provider.wallet.publicKey, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const [rewarderKey, bump] = yield findRewarderAddress(baseKP.publicKey, this.program.programId);
            const mintWrapperDataRaw = yield this.provider.getAccountInfo(mintWrapper);
            if (!mintWrapperDataRaw) {
                throw new Error(`mint wrapper does not exist at ${mintWrapper.toString()}`);
            }
            const mintWrapperData = QUARRY_CODERS.MintWrapper.accounts.mintWrapper.parse(mintWrapperDataRaw.accountInfo.data);
            const { address: claimFeeTokenAccount, instruction: createATAInstruction } = yield getOrCreateATA({
                provider: this.provider,
                mint: mintWrapperData.tokenMint,
                owner: rewarderKey,
            });
            return {
                key: rewarderKey,
                tx: this.provider.newTX([
                    createATAInstruction,
                    this.program.instruction.newRewarder(bump, {
                        accounts: {
                            base: baseKP.publicKey,
                            initialAuthority: authority,
                            rewarder: rewarderKey,
                            payer: this.provider.wallet.publicKey,
                            systemProgram: SystemProgram.programId,
                            unusedAccount: SYSVAR_CLOCK_PUBKEY,
                            mintWrapper,
                            rewardsTokenMint: mintWrapperData.tokenMint,
                            claimFeeTokenAccount,
                        },
                    }),
                ], [baseKP]),
            };
        });
    }
    /**
     * Creates a new Rewarder.
     * @param param0
     * @returns
     */
    createRewarder({ mintWrapper, baseKP = Keypair.generate(), authority = this.provider.wallet.publicKey, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const [rewarderKey] = yield findRewarderAddress(baseKP.publicKey, this.program.programId);
            const mintWrapperDataRaw = yield this.provider.getAccountInfo(mintWrapper);
            if (!mintWrapperDataRaw) {
                throw new Error(`mint wrapper does not exist at ${mintWrapper.toString()}`);
            }
            const mintWrapperData = QUARRY_CODERS.MintWrapper.accounts.mintWrapper.parse(mintWrapperDataRaw.accountInfo.data);
            const { address: claimFeeTokenAccount, instruction: createATAInstruction } = yield getOrCreateATA({
                provider: this.provider,
                mint: mintWrapperData.tokenMint,
                owner: rewarderKey,
            });
            return {
                key: rewarderKey,
                tx: this.provider.newTX([
                    createATAInstruction,
                    this.program.instruction.newRewarderV2({
                        accounts: {
                            base: baseKP.publicKey,
                            initialAuthority: authority,
                            rewarder: rewarderKey,
                            payer: this.provider.wallet.publicKey,
                            systemProgram: SystemProgram.programId,
                            mintWrapper,
                            rewardsTokenMint: mintWrapperData.tokenMint,
                            claimFeeTokenAccount,
                        },
                    }),
                ], [baseKP]),
            };
        });
    }
    /**
     * Loads the rewarder wrapper.
     * @param rewarder
     * @returns
     */
    loadRewarderWrapper(rewarder) {
        return __awaiter(this, void 0, void 0, function* () {
            const rewarderData = yield this.program.account.rewarder.fetch(rewarder);
            return new RewarderWrapper(this, rewarder, rewarderData);
        });
    }
    /**
     * Rescue stuck tokens in a miner.
     * @returns
     */
    rescueTokens({ mint, miner, minerTokenAccount, owner = this.provider.wallet.publicKey, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const instructions = [];
            const { address: destinationTokenAccount, instruction: ataInstruction } = yield getOrCreateATA({
                provider: this.provider,
                mint,
                owner,
            });
            if (ataInstruction) {
                instructions.push(ataInstruction);
            }
            instructions.push(this.program.instruction.rescueTokens({
                accounts: {
                    authority: owner,
                    miner,
                    minerTokenAccount,
                    destinationTokenAccount,
                    tokenProgram: TOKEN_PROGRAM_ID,
                },
            }));
            return this.sdk.newTx(instructions);
        });
    }
}
//# sourceMappingURL=mine.js.map