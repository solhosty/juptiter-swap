import { __awaiter } from "tslib";
import { TransactionEnvelope } from "@saberhq/solana-contrib";
import { getATAAddress, getOrCreateATA, getOrCreateATAs, SPLToken, TOKEN_PROGRAM_ID, } from "@saberhq/token-utils";
import { SystemProgram } from "@solana/web3.js";
import { QUARRY_ADDRESSES } from "../..";
import { findMinerAddress, findMinterAddress, findQuarryAddress } from "..";
export class MergeMiner {
    constructor(mergeMine, pool, mm) {
        this.mergeMine = mergeMine;
        this.pool = pool;
        this.mm = mm;
    }
    get provider() {
        return this.mergeMine.provider;
    }
    get program() {
        return this.mergeMine.programs.MergeMine;
    }
    get primaryMint() {
        return this.pool.data.primaryMint;
    }
    get replicaMint() {
        return this.pool.data.replicaMint;
    }
    /**
     * Deposit primary tokens into the merge miner.
     * @param amount
     * @returns
     */
    deposit({ amount, rewarder, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const owner = this.provider.wallet.publicKey;
            const { address: ata, instruction } = yield getOrCreateATA({
                provider: this.provider,
                mint: this.primaryMint,
                owner,
            });
            if (instruction) {
                throw new Error("User has no tokens to deposit");
            }
            const mmPrimaryTokenAccount = yield getATAAddress({
                mint: this.primaryMint,
                owner: this.mm.key,
            });
            return new TransactionEnvelope(this.provider, [
                SPLToken.createTransferInstruction(TOKEN_PROGRAM_ID, ata, mmPrimaryTokenAccount, owner, [], amount.toU64()),
            ]).combine(yield this.stakePrimaryMiner(rewarder));
        });
    }
    /**
     * Deposits tokens into the primary quarry.
     * (Not recommended-- you probably want {@link MergeMiner#deposit}.)
     * @returns
     */
    stakePrimaryMiner(rewarder) {
        return __awaiter(this, void 0, void 0, function* () {
            const stake = yield this.getPrimaryStakeAccounts(rewarder);
            const mmPrimaryTokenAccount = yield getATAAddress({
                mint: this.primaryMint,
                owner: this.mm.key,
            });
            return new TransactionEnvelope(this.provider, [
                this.program.instruction.stakePrimaryMiner({
                    accounts: {
                        mmOwner: this.provider.wallet.publicKey,
                        mmPrimaryTokenAccount,
                        stake,
                    },
                }),
            ]);
        });
    }
    /**
     * Stakes replica tokens into a miner.
     * @returns
     */
    stakeReplicaMiner(rewarder) {
        return __awaiter(this, void 0, void 0, function* () {
            const stake = yield this.getReplicaStakeAccounts(rewarder);
            const [quarry] = yield findQuarryAddress(rewarder, this.replicaMint);
            const [miner] = yield findMinerAddress(quarry, this.mm.key);
            const mmReplicaMintTokenAccount = yield getOrCreateATA({
                provider: this.provider,
                mint: this.replicaMint,
                owner: this.mm.key,
            });
            const txEnv = new TransactionEnvelope(this.provider, [
                this.program.instruction.stakeReplicaMiner({
                    accounts: {
                        mmOwner: this.provider.wallet.publicKey,
                        replicaMint: this.replicaMint,
                        replicaMintTokenAccount: mmReplicaMintTokenAccount.address,
                        stake,
                    },
                }),
            ]);
            if (mmReplicaMintTokenAccount.instruction) {
                txEnv.instructions.unshift(mmReplicaMintTokenAccount.instruction);
            }
            // initialize the miner if it does not exist
            if (!(yield this.provider.getAccountInfo(miner))) {
                const minerReplicaMintTokenAccount = yield getOrCreateATA({
                    provider: this.provider,
                    mint: this.replicaMint,
                    owner: miner,
                });
                txEnv.instructions.unshift(this.program.instruction.initMinerV2({
                    accounts: {
                        pool: this.pool.key,
                        mm: this.mm.key,
                        miner,
                        quarry,
                        rewarder,
                        tokenMint: this.replicaMint,
                        minerVault: minerReplicaMintTokenAccount.address,
                        payer: this.provider.wallet.publicKey,
                        mineProgram: QUARRY_ADDRESSES.Mine,
                        systemProgram: SystemProgram.programId,
                        tokenProgram: TOKEN_PROGRAM_ID,
                    },
                }));
                if (minerReplicaMintTokenAccount.instruction) {
                    txEnv.instructions.unshift(minerReplicaMintTokenAccount.instruction);
                }
            }
            else {
                console.log("HERE");
            }
            return txEnv;
        });
    }
    /**
     * Withdraw staked tokens from a merge miner.
     * @param amount
     * @returns
     */
    withdraw({ amount, rewarder, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const withdrawPrimary = yield this.unstakePrimaryMiner(rewarder, amount);
            const withdrawPrimaryFromMM = yield this.withdrawTokens(amount.token.mintAccount);
            return TransactionEnvelope.combineAll(withdrawPrimary, withdrawPrimaryFromMM);
        });
    }
    /**
     * Unstakes all replica tokens from a quarry.
     * You must call this function for each replica miner before unstaking the primary.
     * @returns
     */
    unstakeAllReplica(rewarder) {
        return __awaiter(this, void 0, void 0, function* () {
            const stake = yield this.getReplicaStakeAccounts(rewarder);
            const replicaMintTokenAccount = yield getATAAddress({
                mint: this.replicaMint,
                owner: this.mm.key,
            });
            return new TransactionEnvelope(this.provider, [
                this.program.instruction.unstakeAllReplicaMiner({
                    accounts: {
                        mmOwner: this.provider.wallet.publicKey,
                        replicaMint: this.replicaMint,
                        replicaMintTokenAccount,
                        stake,
                    },
                }),
            ]);
        });
    }
    /**
     * Withdraws primary tokens from the quarry.
     * (Not recommended-- you probably want {@link MergeMiner#withdraw}.)
     * @returns
     */
    unstakePrimaryMiner(rewarder, amount) {
        return __awaiter(this, void 0, void 0, function* () {
            const stake = yield this.getPrimaryStakeAccounts(rewarder);
            const mmPrimaryTokenAccount = yield getATAAddress({
                mint: this.primaryMint,
                owner: this.mm.key,
            });
            return new TransactionEnvelope(this.provider, [
                this.program.instruction.unstakePrimaryMiner(amount.toU64(), {
                    accounts: {
                        mmOwner: this.provider.wallet.publicKey,
                        mmPrimaryTokenAccount,
                        stake,
                    },
                }),
            ]);
        });
    }
    /**
     * Withdraws unstaked primary tokens from the merge miner.
     * (Not recommended-- you probably want {@link MergeMiner#withdraw}.)
     * @returns
     */
    withdrawPrimaryFromMM() {
        return __awaiter(this, void 0, void 0, function* () {
            const owner = this.provider.wallet.publicKey;
            const mmPrimaryAccount = yield getATAAddress({
                mint: this.primaryMint,
                owner: this.mm.key,
            });
            const ownerPrimaryATA = yield getOrCreateATA({
                provider: this.provider,
                mint: this.primaryMint,
                owner,
            });
            const withdrawPrimaryFromMMIx = this.program.instruction.withdrawTokens({
                accounts: {
                    owner,
                    pool: this.pool.key,
                    mm: this.mm.key,
                    mmTokenAccount: mmPrimaryAccount,
                    withdrawMint: this.primaryMint,
                    tokenDestination: ownerPrimaryATA.address,
                    tokenProgram: TOKEN_PROGRAM_ID,
                },
            });
            return new TransactionEnvelope(this.provider, [
                ...(ownerPrimaryATA.instruction ? [ownerPrimaryATA.instruction] : []),
                withdrawPrimaryFromMMIx,
            ]);
        });
    }
    /**
     * Withdraws a specific mint from the merge miner.
     * @param withdrawMint
     * @returns
     */
    withdrawTokens(withdrawMint) {
        return __awaiter(this, void 0, void 0, function* () {
            const owner = this.provider.wallet.publicKey;
            const mmPrimaryAccount = yield getATAAddress({
                mint: withdrawMint,
                owner: this.mm.key,
            });
            const ownerPrimaryATA = yield getATAAddress({
                mint: withdrawMint,
                owner,
            });
            const withdrawTokensIX = this.program.instruction.withdrawTokens({
                accounts: {
                    owner,
                    pool: this.pool.key,
                    mm: this.mm.key,
                    mmTokenAccount: mmPrimaryAccount,
                    tokenDestination: ownerPrimaryATA,
                    tokenProgram: TOKEN_PROGRAM_ID,
                    withdrawMint,
                },
            });
            return new TransactionEnvelope(this.provider, [withdrawTokensIX]);
        });
    }
    /**
     * Claims rewards for a primary account.
     * @param rewarder
     * @returns
     */
    claimPrimaryRewards(rewarder) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.claimRewardsCommon(this.primaryMint, yield this.getPrimaryStakeAccounts(rewarder));
        });
    }
    /**
     * Claims rewards for a replica account.
     * @returns
     */
    claimReplicaRewards(rewarder) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.claimRewardsCommon(this.replicaMint, yield this.getReplicaStakeAccounts(rewarder));
        });
    }
    /**
     * Claims internal mining rewards.
     * @param amount
     * @returns
     */
    claimRewardsCommon(quarryMint, stake, mmOwner = this.provider.wallet.publicKey) {
        return __awaiter(this, void 0, void 0, function* () {
            const rewarderKey = stake.rewarder;
            const rewarder = yield this.mergeMine.sdk.programs.Mine.account.rewarder.fetch(rewarderKey);
            const [minter] = yield findMinterAddress(rewarder.mintWrapper, rewarderKey, this.mergeMine.sdk.programs.MintWrapper.programId);
            const mm = this.mm.key;
            const withdrawMint = rewarder.rewardsTokenMint;
            const mmATAs = yield getOrCreateATAs({
                provider: this.provider,
                mints: {
                    quarry: quarryMint,
                    rewards: withdrawMint,
                },
                owner: mm,
            });
            const ownerATAs = yield getOrCreateATAs({
                provider: this.provider,
                mints: {
                    rewards: withdrawMint,
                },
                owner: mmOwner,
            });
            const feeATA = yield getOrCreateATA({
                provider: this.provider,
                mint: withdrawMint,
                owner: this.pool.key,
            });
            return new TransactionEnvelope(this.provider, [
                ...mmATAs.instructions,
                ...ownerATAs.instructions,
                ...(feeATA.instruction ? [feeATA.instruction] : []),
                this.program.instruction.claimRewards({
                    accounts: {
                        mintWrapper: rewarder.mintWrapper,
                        mintWrapperProgram: this.mergeMine.sdk.programs.MintWrapper.programId,
                        minter,
                        rewardsTokenMint: withdrawMint,
                        rewardsTokenAccount: mmATAs.accounts.rewards,
                        claimFeeTokenAccount: rewarder.claimFeeTokenAccount,
                        stakeTokenAccount: mmATAs.accounts.quarry,
                        stake,
                    },
                }),
            ]).combine(yield this.withdrawTokens(withdrawMint));
        });
    }
    getReplicaStakeAccounts(rewarder) {
        return __awaiter(this, void 0, void 0, function* () {
            const [quarry] = yield findQuarryAddress(rewarder, this.replicaMint);
            const [miner] = yield findMinerAddress(quarry, this.mm.key);
            const minerVault = yield getATAAddress({
                mint: this.replicaMint,
                owner: miner,
            });
            return Object.assign(Object.assign({}, this.commonStakeAccounts), { rewarder,
                quarry,
                miner,
                minerVault });
        });
    }
    getPrimaryStakeAccounts(rewarder) {
        return __awaiter(this, void 0, void 0, function* () {
            const [quarry] = yield findQuarryAddress(rewarder, this.primaryMint);
            const [miner] = yield findMinerAddress(quarry, this.mm.key);
            const minerVault = yield getATAAddress({
                mint: this.primaryMint,
                owner: miner,
            });
            return Object.assign(Object.assign({}, this.commonStakeAccounts), { rewarder,
                quarry,
                miner,
                minerVault });
        });
    }
    get commonStakeAccounts() {
        return {
            pool: this.mm.data.pool,
            mm: this.mm.key,
            tokenProgram: TOKEN_PROGRAM_ID,
            mineProgram: this.mergeMine.sdk.mine.program.programId,
        };
    }
}
//# sourceMappingURL=mergeMiner.js.map