import { __awaiter } from "tslib";
import { TransactionEnvelope } from "@saberhq/solana-contrib";
import { getATAAddress, getOrCreateATA, getOrCreateATAs, SPLToken, TOKEN_PROGRAM_ID, } from "@saberhq/token-utils";
import { SystemProgram } from "@solana/web3.js";
import { QUARRY_ADDRESSES } from "../../constants";
import { findMinterAddress } from "..";
import { findMinerAddress, findQuarryAddress } from "../mine/pda";
import { findMergeMinerAddress } from "./pda";
export class MergePool {
    constructor(mergeMine, key) {
        this.mergeMine = mergeMine;
        this.key = key;
        this._data = null;
    }
    reloadData() {
        return __awaiter(this, void 0, void 0, function* () {
            this._data = yield this.mergeMine.program.account.mergePool.fetch(this.key);
            return this._data;
        });
    }
    data() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._data) {
                return this._data;
            }
            return yield this.reloadData();
        });
    }
    get provider() {
        return this.mergeMine.provider;
    }
    get program() {
        return this.mergeMine.programs.MergeMine;
    }
    /**
     * Deposit primary tokens into the merge miner.
     * @param amount
     * @returns
     */
    deposit({ amount, rewarder, mmOwner = this.provider.wallet.publicKey, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const poolData = yield this.data();
            const { address: ata, instruction } = yield getOrCreateATA({
                provider: this.provider,
                mint: poolData.primaryMint,
                owner: mmOwner,
            });
            if (instruction) {
                throw new Error("User has no tokens to deposit");
            }
            const [mmKey] = yield findMergeMinerAddress({
                pool: this.key,
                owner: mmOwner,
            });
            const mmAccount = yield this.provider.getAccountInfo(mmKey);
            const { address: mmPrimaryTokenAccount, instruction: mmATAIx } = yield getOrCreateATA({
                provider: this.provider,
                mint: poolData.primaryMint,
                owner: mmKey,
            });
            const allInstructions = [];
            // Initialize mergeMiner if it does not exist
            if (!mmAccount) {
                allInstructions.push(this.program.instruction.initMergeMinerV2({
                    accounts: {
                        pool: this.key,
                        owner: mmOwner,
                        mm: mmKey,
                        payer: this.provider.wallet.publicKey,
                        systemProgram: SystemProgram.programId,
                    },
                }));
                if (mmATAIx) {
                    allInstructions.push(mmATAIx);
                }
                const { ixs: initPrimaryIxs } = yield this.mergeMine.getOrCreatePrimary({
                    mint: poolData.primaryMint,
                    pool: this.key,
                    mm: mmKey,
                    payer: this.provider.wallet.publicKey,
                    rewarder,
                });
                allInstructions.push(...initPrimaryIxs);
            }
            allInstructions.push(SPLToken.createTransferInstruction(TOKEN_PROGRAM_ID, ata, mmPrimaryTokenAccount, mmOwner, [], amount.toU64()));
            return new TransactionEnvelope(this.provider, allInstructions).combine(yield this.stakePrimaryMiner(rewarder, mmKey));
        });
    }
    /**
     * Deposits tokens into the primary quarry.
     * (Not recommended-- you probably want {@link MergeMiner#deposit}.)
     * @returns
     */
    stakePrimaryMiner(rewarder, mergeMiner) {
        return __awaiter(this, void 0, void 0, function* () {
            const { provider } = this.mergeMine;
            const data = yield this.data();
            const stake = yield this.getPrimaryStakeAccounts(rewarder, mergeMiner);
            const mmPrimaryTokenAccount = yield getATAAddress({
                mint: data.primaryMint,
                owner: mergeMiner,
            });
            return new TransactionEnvelope(provider, [
                this.mergeMine.program.instruction.stakePrimaryMiner({
                    accounts: {
                        mmOwner: provider.wallet.publicKey,
                        mmPrimaryTokenAccount,
                        stake,
                    },
                }),
            ]);
        });
    }
    /**
     * Stakes replica tokens into a miner.
     * @returns
     */
    stakeReplicaMiner(rewarder, mergeMiner) {
        return __awaiter(this, void 0, void 0, function* () {
            const poolData = yield this.data();
            const stake = yield this.getReplicaStakeAccounts(rewarder, mergeMiner);
            const [quarry] = yield findQuarryAddress(rewarder, poolData.replicaMint);
            const [miner] = yield findMinerAddress(quarry, mergeMiner);
            const mmReplicaMintTokenAccount = yield getOrCreateATA({
                provider: this.provider,
                mint: poolData.replicaMint,
                owner: mergeMiner,
            });
            const txEnv = new TransactionEnvelope(this.provider, [
                this.program.instruction.stakeReplicaMiner({
                    accounts: {
                        mmOwner: this.provider.wallet.publicKey,
                        replicaMint: poolData.replicaMint,
                        replicaMintTokenAccount: mmReplicaMintTokenAccount.address,
                        stake,
                    },
                }),
            ]);
            if (mmReplicaMintTokenAccount.instruction) {
                txEnv.instructions.unshift(mmReplicaMintTokenAccount.instruction);
            }
            // initialize the miner if it does not exist
            if (!(yield this.provider.getAccountInfo(miner))) {
                const minerReplicaMintTokenAccount = yield getOrCreateATA({
                    provider: this.provider,
                    mint: poolData.replicaMint,
                    owner: miner,
                });
                txEnv.instructions.unshift(this.program.instruction.initMinerV2({
                    accounts: {
                        pool: this.key,
                        mm: mergeMiner,
                        miner,
                        quarry,
                        rewarder,
                        tokenMint: poolData.replicaMint,
                        minerVault: minerReplicaMintTokenAccount.address,
                        payer: this.provider.wallet.publicKey,
                        mineProgram: QUARRY_ADDRESSES.Mine,
                        systemProgram: SystemProgram.programId,
                        tokenProgram: TOKEN_PROGRAM_ID,
                    },
                }));
                if (minerReplicaMintTokenAccount.instruction) {
                    txEnv.instructions.unshift(minerReplicaMintTokenAccount.instruction);
                }
            }
            else {
                console.error("HERE");
            }
            return txEnv;
        });
    }
    /**
     * Withdraw staked tokens from a merge miner.
     * @param amount
     * @returns
     */
    withdraw({ amount, rewarder, mergeMiner, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const withdrawPrimary = yield this.unstakePrimaryMiner(rewarder, mergeMiner, amount);
            const withdrawPrimaryFromMM = yield this.withdrawTokens(amount.token.mintAccount, mergeMiner);
            return TransactionEnvelope.combineAll(withdrawPrimary, withdrawPrimaryFromMM);
        });
    }
    /**
     * Unstakes all replica tokens from a quarry.
     * You must call this function for each replica miner before unstaking the primary.
     * @returns
     */
    unstakeAllReplica(rewarder, mergeMiner) {
        return __awaiter(this, void 0, void 0, function* () {
            const poolData = yield this.data();
            const stake = yield this.getReplicaStakeAccounts(rewarder, mergeMiner);
            const replicaMintTokenAccount = yield getATAAddress({
                mint: poolData.replicaMint,
                owner: mergeMiner,
            });
            return new TransactionEnvelope(this.provider, [
                this.program.instruction.unstakeAllReplicaMiner({
                    accounts: {
                        mmOwner: this.provider.wallet.publicKey,
                        replicaMint: poolData.replicaMint,
                        replicaMintTokenAccount,
                        stake,
                    },
                }),
            ]);
        });
    }
    /**
     * Withdraws primary tokens from the quarry.
     * (Not recommended-- you probably want {@link MergeMiner#withdraw}.)
     * @returns
     */
    unstakePrimaryMiner(rewarder, mergeMiner, amount) {
        return __awaiter(this, void 0, void 0, function* () {
            const poolData = yield this.data();
            const stake = yield this.getPrimaryStakeAccounts(rewarder, mergeMiner);
            const mmPrimaryTokenAccount = yield getATAAddress({
                mint: poolData.primaryMint,
                owner: mergeMiner,
            });
            return new TransactionEnvelope(this.provider, [
                this.program.instruction.unstakePrimaryMiner(amount.toU64(), {
                    accounts: {
                        mmOwner: this.provider.wallet.publicKey,
                        mmPrimaryTokenAccount,
                        stake,
                    },
                }),
            ]);
        });
    }
    /**
     * Withdraws a specific mint from the merge miner.
     * @param withdrawMint
     * @returns
     */
    withdrawTokens(withdrawMint, mergeMiner) {
        return __awaiter(this, void 0, void 0, function* () {
            const owner = this.provider.wallet.publicKey;
            const mmPrimaryAccount = yield getATAAddress({
                mint: withdrawMint,
                owner: mergeMiner,
            });
            const ownerPrimaryATA = yield getATAAddress({
                mint: withdrawMint,
                owner,
            });
            const withdrawTokensIX = this.program.instruction.withdrawTokens({
                accounts: {
                    owner,
                    pool: this.key,
                    mm: mergeMiner,
                    mmTokenAccount: mmPrimaryAccount,
                    tokenDestination: ownerPrimaryATA,
                    tokenProgram: TOKEN_PROGRAM_ID,
                    withdrawMint,
                },
            });
            return new TransactionEnvelope(this.provider, [withdrawTokensIX]);
        });
    }
    /**
     * Claims rewards for a primary account.
     * @param rewarder
     * @returns
     */
    claimPrimaryRewards(rewarder, mergeMiner) {
        return __awaiter(this, void 0, void 0, function* () {
            const poolData = yield this.data();
            return yield this.claimRewardsCommon(poolData.primaryMint, yield this.getPrimaryStakeAccounts(rewarder, mergeMiner));
        });
    }
    /**
     * Claims rewards for a replica account.
     * @returns
     */
    claimReplicaRewards(rewarder, mergeMiner) {
        return __awaiter(this, void 0, void 0, function* () {
            const poolData = yield this.data();
            return yield this.claimRewardsCommon(poolData.replicaMint, yield this.getReplicaStakeAccounts(rewarder, mergeMiner));
        });
    }
    /**
     * Claims internal mining rewards.
     * @param amount
     * @returns
     */
    claimRewardsCommon(quarryMint, stake, mmOwner = this.provider.wallet.publicKey) {
        return __awaiter(this, void 0, void 0, function* () {
            const rewarder = yield this.mergeMine.sdk.programs.Mine.account.rewarder.fetch(stake.rewarder);
            const [minter] = yield findMinterAddress(rewarder.mintWrapper, stake.rewarder, this.mergeMine.sdk.programs.MintWrapper.programId);
            const withdrawMint = rewarder.rewardsTokenMint;
            const mmATAs = yield getOrCreateATAs({
                provider: this.provider,
                mints: {
                    quarry: quarryMint,
                    rewards: withdrawMint,
                },
                owner: stake.mm,
            });
            const ownerATAs = yield getOrCreateATAs({
                provider: this.provider,
                mints: {
                    rewards: withdrawMint,
                },
                owner: mmOwner,
            });
            const feeATA = yield getOrCreateATA({
                provider: this.provider,
                mint: withdrawMint,
                owner: this.key,
            });
            return new TransactionEnvelope(this.provider, [
                ...mmATAs.instructions,
                ...ownerATAs.instructions,
                ...(feeATA.instruction ? [feeATA.instruction] : []),
                this.program.instruction.claimRewards({
                    accounts: {
                        mintWrapper: rewarder.mintWrapper,
                        mintWrapperProgram: this.mergeMine.sdk.programs.MintWrapper.programId,
                        minter,
                        rewardsTokenMint: withdrawMint,
                        rewardsTokenAccount: mmATAs.accounts.rewards,
                        claimFeeTokenAccount: rewarder.claimFeeTokenAccount,
                        stakeTokenAccount: mmATAs.accounts.quarry,
                        stake,
                    },
                }),
            ]).combine(yield this.withdrawTokens(withdrawMint, stake.mm));
        });
    }
    getReplicaStakeAccounts(rewarder, mergeMiner) {
        return __awaiter(this, void 0, void 0, function* () {
            const poolData = yield this.data();
            const [quarry] = yield findQuarryAddress(rewarder, poolData.replicaMint);
            const [miner] = yield findMinerAddress(quarry, mergeMiner);
            const minerVault = yield getATAAddress({
                mint: poolData.replicaMint,
                owner: miner,
            });
            return Object.assign({ mm: mergeMiner, rewarder,
                quarry,
                miner,
                minerVault }, this.commonAccounts);
        });
    }
    getPrimaryStakeAccounts(rewarder, mergeMiner) {
        return __awaiter(this, void 0, void 0, function* () {
            const poolData = yield this.data();
            const [quarry] = yield findQuarryAddress(rewarder, poolData.primaryMint);
            const [miner] = yield findMinerAddress(quarry, mergeMiner);
            const minerVault = yield getATAAddress({
                mint: poolData.primaryMint,
                owner: miner,
            });
            return Object.assign({ mm: mergeMiner, rewarder,
                quarry,
                miner,
                minerVault }, this.commonAccounts);
        });
    }
    get commonAccounts() {
        return {
            pool: this.key,
            tokenProgram: TOKEN_PROGRAM_ID,
            mineProgram: this.mergeMine.programs.Mine.programId,
        };
    }
}
//# sourceMappingURL=mergePool.js.map