{"version":3,"file":"coder.js","sourceRoot":"","sources":["../../../src/utils/coder.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Accounts, Idl } from \"@project-serum/anchor\";\nimport { BorshCoder, EventParser, utils } from \"@project-serum/anchor\";\nimport { default as InstructionNamespaceFactory } from \"@project-serum/anchor/dist/cjs/program/namespace/instruction.js\";\nimport type { InstructionDisplay } from \"@project-serum/anchor/dist/esm/coder/borsh/instruction.js\";\nimport type {\n  IdlAccountItem,\n  IdlTypeDef,\n} from \"@project-serum/anchor/dist/esm/idl.js\";\nimport type { Provider as SaberProvider } from \"@saberhq/solana-contrib\";\nimport type { GetProgramAccountsFilter, PublicKey } from \"@solana/web3.js\";\nimport { TransactionInstruction } from \"@solana/web3.js\";\nimport mapValues from \"lodash.mapvalues\";\n\nimport type { ErrorMap } from \"../errors.js\";\nimport { generateErrorMap } from \"../errors.js\";\nimport type { AccountParsers } from \"../generateAccountParsers.js\";\nimport { generateAccountParsersFromCoder } from \"../generateAccountParsers.js\";\nimport type { AnchorAccount, AnchorAccountMap } from \"./accounts.js\";\nimport { generateAnchorAccounts } from \"./accounts.js\";\nimport { newProgram } from \"./programs.js\";\n\n/**\n * Formatted instruction with its name.\n */\nexport type InstructionParsed = InstructionDisplay & {\n  name: string;\n};\n\ntype CoderAnchorTypes = {\n  AccountMap: Record<string, object>;\n  Events: Record<string, unknown>;\n  IDL: Idl;\n  Instructions: Record<\n    string,\n    {\n      accounts: IdlAccountItem[];\n      args: unknown[];\n      namedArgs: Record<string, unknown>;\n    }\n  >;\n  Program: unknown;\n};\n\ntype IDLAccountName<IDL extends Idl> = NonNullable<\n  IDL[\"accounts\"]\n>[number][\"name\"];\n\ntype AccountTypeDefMap<IDL extends Idl> = {\n  [K in IDLAccountName<IDL>]: IdlTypeDef;\n};\n\n/**\n * Coder wrapper.\n *\n * Allows interacting with a program without a provider.\n */\nexport class SuperCoder<T extends CoderAnchorTypes> {\n  /**\n   * Underlying Coder.\n   */\n  readonly coder: BorshCoder;\n  /**\n   * Parses events.\n   */\n  readonly eventParser: EventParser;\n  /**\n   * All accounts.\n   */\n  readonly accounts: AnchorAccountMap<T[\"AccountMap\"]>;\n  /**\n   * Parses accounts.\n   * @deprecated use {@link SuperCoder#accounts}\n   */\n  readonly accountParsers: AccountParsers<T[\"AccountMap\"]>;\n  /**\n   * All account {@link IdlTypeDef}s.\n   * @deprecated use {@link SuperCoder#accounts}\n   */\n  readonly accountTypeDefs: {\n    [K in IDLAccountName<T[\"IDL\"]>]: IdlTypeDef;\n  };\n  /**\n   * Mapping of error name to error details.\n   */\n  readonly errorMap: ErrorMap<T[\"IDL\"]>;\n  /**\n   * Mapping of hex discriminator to the account name.\n   */\n  readonly discriminators: {\n    [hexDiscriminator: string]: string;\n  };\n  /**\n   * Mapping of hex discriminator to the account name.\n   * @deprecated use {@link SuperCoder#accounts}\n   */\n  readonly discriminatorsByAccount: {\n    [K in NonNullable<T[\"IDL\"][\"accounts\"]>[number][\"name\"]]: Buffer;\n  };\n\n  /**\n   * Constructor.\n   * @param address\n   * @param idl\n   */\n  constructor(\n    /**\n     * Program address.\n     */\n    readonly address: PublicKey,\n    /**\n     * Program IDL.\n     */\n    readonly idl: T[\"IDL\"]\n  ) {\n    this.coder = new BorshCoder<IDLAccountName<T[\"IDL\"]>>(idl);\n    this.eventParser = new EventParser(address, this.coder);\n    this.accounts = generateAnchorAccounts(\n      address,\n      idl.accounts ?? [],\n      this.coder.accounts\n    );\n\n    this.errorMap = generateErrorMap<T[\"IDL\"]>(idl);\n\n    const accountsList = Object.values(\n      this.accounts\n    ) as AnchorAccount<unknown>[];\n    const accountTypeDefs: Partial<AccountTypeDefMap<T[\"IDL\"]>> = {};\n    accountsList.forEach((account) => {\n      accountTypeDefs[account.name as IDLAccountName<T[\"IDL\"]>] = account.idl;\n    });\n\n    this.accountParsers = generateAccountParsersFromCoder(\n      idl.accounts?.map((acc) => acc.name),\n      this.coder.accounts\n    );\n    this.accountTypeDefs = accountTypeDefs as AccountTypeDefMap<T[\"IDL\"]>;\n    this.discriminators = accountsList.reduce(\n      (acc, el) => ({ ...acc, [el.discriminator.toString(\"hex\")]: el.name }),\n      {}\n    );\n    this.discriminatorsByAccount = accountsList.reduce(\n      (acc, el) => ({ ...acc, [el.name]: el.discriminator }),\n      {} as { [K in NonNullable<T[\"IDL\"][\"accounts\"]>[number][\"name\"]]: Buffer }\n    );\n  }\n\n  /**\n   * Creates a {@link GetProgramAccountsFilter} for the given account.\n   */\n  makeGPAFilter(\n    account: NonNullable<T[\"IDL\"][\"accounts\"]>[number][\"name\"],\n    ...filters: GetProgramAccountsFilter[]\n  ): GetProgramAccountsFilter[] {\n    return [\n      {\n        memcmp: {\n          offset: 0,\n          bytes: utils.bytes.bs58.encode(this.discriminatorsByAccount[account]),\n        },\n      },\n      ...filters,\n    ];\n  }\n\n  /**\n   * Parses events in the program log.\n   * @param logs\n   * @returns\n   */\n  parseProgramLogEvents<\n    E extends T[\"Events\"][keyof T[\"Events\"]] = T[\"Events\"][keyof T[\"Events\"]]\n  >(logs?: string[]): readonly E[] {\n    if (!logs) {\n      return [];\n    }\n    const events: E[] = [];\n    const parsedLogsIter = this.eventParser.parseLogs(logs ?? []);\n    let parsedEvent = parsedLogsIter.next();\n    while (!parsedEvent.done) {\n      events.push(parsedEvent.value as unknown as E);\n      parsedEvent = parsedLogsIter.next();\n    }\n    return events;\n  }\n\n  /**\n   * Encodes a {@link TransactionInstruction}.\n   * @returns\n   */\n  encodeIX<\n    K extends keyof T[\"Instructions\"] & string = keyof T[\"Instructions\"] &\n      string,\n    I extends T[\"Instructions\"][K] = T[\"Instructions\"][K]\n  >(\n    name: K,\n    args: I[\"namedArgs\"],\n    accounts: Accounts<I[\"accounts\"][number]>\n  ): TransactionInstruction {\n    const idlIx = this.idl.instructions.find((ix) => ix.name === name);\n    if (!idlIx) {\n      throw new Error(`could not find ix: ${name}`);\n    }\n    const encoded = this.coder.instruction.encode(name, args);\n    const keys = InstructionNamespaceFactory.accountsArray(\n      accounts,\n      idlIx.accounts,\n      name\n    );\n    return new TransactionInstruction({\n      programId: this.address,\n      keys,\n      data: encoded,\n    });\n  }\n\n  /**\n   * Parses a {@link TransactionInstruction}.\n   * @returns\n   */\n  parseInstruction(txInstruction: TransactionInstruction): InstructionParsed {\n    const decoded = this.coder.instruction.decode(txInstruction.data);\n    if (!decoded) {\n      throw new Error(\"could not decode ix data\");\n    }\n    const fmt = this.coder.instruction.format(decoded, txInstruction.keys);\n    if (!fmt) {\n      throw new Error(\"invalid instruction\");\n    }\n    return { ...fmt, name: decoded.name };\n  }\n\n  /**\n   * Gets a {@link Program} from a provider.\n   * @param provider\n   * @returns\n   */\n  getProgram(provider: SaberProvider): T[\"Program\"] {\n    return newProgram(this.idl, this.address, provider);\n  }\n}\n\n/**\n * Builds a map of coders from their IDLs and addresses.\n *\n * @param provider\n * @param programs\n * @returns\n */\nexport const buildCoderMap = <\n  P extends {\n    [K in keyof P]: CoderAnchorTypes;\n  }\n>(\n  idls: {\n    [K in keyof P]: Idl;\n  },\n  addresses: {\n    [K in keyof P]: PublicKey;\n  }\n): {\n  [K in keyof P]: SuperCoder<P[K]>;\n} => {\n  return mapValues(\n    idls,\n    <K extends keyof P>(idl: P[K][\"IDL\"], k: K) =>\n      new SuperCoder<P[K]>(addresses[k], idl)\n  ) as unknown as {\n    [K in keyof P]: SuperCoder<P[K]>;\n  };\n};\n"]}