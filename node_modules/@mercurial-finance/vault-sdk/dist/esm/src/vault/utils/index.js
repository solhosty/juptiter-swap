var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { ASSOCIATED_TOKEN_PROGRAM_ID, Token, TOKEN_PROGRAM_ID } from '@solana/spl-token';
import { PublicKey, SystemProgram, SYSVAR_CLOCK_PUBKEY, TransactionInstruction, } from '@solana/web3.js';
import { AccountLayout, u64 } from '@solana/spl-token';
import { BN } from '@project-serum/anchor';
import { SEEDS, SOL_MINT, VAULT_BASE_KEY } from '../constants';
export const getAssociatedTokenAccount = (tokenMint, owner, allowOwnerOffCurve = false) => __awaiter(void 0, void 0, void 0, function* () {
    return yield Token.getAssociatedTokenAddress(ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID, tokenMint, owner, allowOwnerOffCurve);
});
export const deserializeAccount = (data) => {
    if (data == undefined || data.length == 0) {
        return undefined;
    }
    const accountInfo = AccountLayout.decode(data);
    accountInfo.mint = new PublicKey(accountInfo.mint);
    accountInfo.owner = new PublicKey(accountInfo.owner);
    accountInfo.amount = u64.fromBuffer(accountInfo.amount);
    if (accountInfo.delegateOption === 0) {
        accountInfo.delegate = null;
        accountInfo.delegatedAmount = new u64(0);
    }
    else {
        accountInfo.delegate = new PublicKey(accountInfo.delegate);
        accountInfo.delegatedAmount = u64.fromBuffer(accountInfo.delegatedAmount);
    }
    accountInfo.isInitialized = accountInfo.state !== 0;
    accountInfo.isFrozen = accountInfo.state === 2;
    if (accountInfo.isNativeOption === 1) {
        accountInfo.rentExemptReserve = u64.fromBuffer(accountInfo.isNative);
        accountInfo.isNative = true;
    }
    else {
        accountInfo.rentExemptReserve = null;
        accountInfo.isNative = false;
    }
    if (accountInfo.closeAuthorityOption === 0) {
        accountInfo.closeAuthority = null;
    }
    else {
        accountInfo.closeAuthority = new PublicKey(accountInfo.closeAuthority);
    }
    return accountInfo;
};
export const getOrCreateATAInstruction = (tokenMint, owner, connection, opt) => __awaiter(void 0, void 0, void 0, function* () {
    let toAccount;
    try {
        toAccount = yield Token.getAssociatedTokenAddress(ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID, tokenMint, owner, true);
        const account = yield connection.getAccountInfo(toAccount);
        if (!account) {
            const ix = Token.createAssociatedTokenAccountInstruction(ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID, tokenMint, toAccount, owner, (opt === null || opt === void 0 ? void 0 : opt.payer) || owner);
            return [toAccount, ix];
        }
        return [toAccount, undefined];
    }
    catch (e) {
        /* handle error */
        console.error('Error::getOrCreateATAInstruction', e);
        throw e;
    }
});
export const getVaultPdas = (tokenMint, programId, seedBaseKey) => {
    const [vault, _vaultBump] = PublicKey.findProgramAddressSync([Buffer.from(SEEDS.VAULT_PREFIX), tokenMint.toBuffer(), (seedBaseKey !== null && seedBaseKey !== void 0 ? seedBaseKey : VAULT_BASE_KEY).toBuffer()], programId);
    const tokenVault = PublicKey.findProgramAddressSync([Buffer.from(SEEDS.TOKEN_VAULT_PREFIX), vault.toBuffer()], programId);
    const lpMint = PublicKey.findProgramAddressSync([Buffer.from(SEEDS.LP_MINT_PREFIX), vault.toBuffer()], programId);
    return {
        vaultPda: vault,
        tokenVaultPda: tokenVault[0],
        lpMintPda: lpMint[0],
    };
};
export const wrapSOLInstruction = (from, to, amount) => {
    return [
        SystemProgram.transfer({
            fromPubkey: from,
            toPubkey: to,
            lamports: amount.toNumber(),
        }),
        new TransactionInstruction({
            keys: [
                {
                    pubkey: to,
                    isSigner: false,
                    isWritable: true,
                },
            ],
            data: Buffer.from(new Uint8Array([17])),
            programId: TOKEN_PROGRAM_ID,
        }),
    ];
};
export const unwrapSOLInstruction = (walletPublicKey) => __awaiter(void 0, void 0, void 0, function* () {
    const wSolATAAccount = yield Token.getAssociatedTokenAddress(ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID, SOL_MINT, walletPublicKey, true);
    if (wSolATAAccount) {
        const closedWrappedSolInstruction = Token.createCloseAccountInstruction(TOKEN_PROGRAM_ID, wSolATAAccount, walletPublicKey, walletPublicKey, []);
        return closedWrappedSolInstruction;
    }
    return null;
});
export const getOnchainTime = (connection) => __awaiter(void 0, void 0, void 0, function* () {
    const parsedClock = yield connection.getParsedAccountInfo(SYSVAR_CLOCK_PUBKEY);
    const parsedClockAccount = parsedClock.value.data.parsed;
    const currentTime = parsedClockAccount.info.unixTimestamp;
    return currentTime;
});
export const getLpSupply = (connection, tokenMint) => __awaiter(void 0, void 0, void 0, function* () {
    const context = yield connection.getTokenSupply(tokenMint);
    return new BN(context.value.amount);
});
//# sourceMappingURL=index.js.map