var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { AnchorProvider, Program, BN } from '@project-serum/anchor';
import { PublicKey, Transaction, SYSVAR_RENT_PUBKEY, SystemProgram, } from '@solana/web3.js';
import { MintLayout, TOKEN_PROGRAM_ID, u64 } from '@solana/spl-token';
import { deserializeAccount, getAssociatedTokenAccount, getLpSupply, getOnchainTime, getOrCreateATAInstruction, getVaultPdas, unwrapSOLInstruction, wrapSOLInstruction, } from './utils';
import { AFFILIATE_PROGRAM_ID, PROGRAM_ID, SOL_MINT, VAULT_STRATEGY_ADDRESS } from './constants';
import { getStrategyHandler, getStrategyType } from './strategy';
import { IDL } from './idl';
import { IDL as AffiliateIDL } from './affiliate-idl';
import { calculateWithdrawableAmount } from './helper';
const getAllVaultState = (tokenInfos, program, seedBaseKey) => __awaiter(void 0, void 0, void 0, function* () {
    const vaultAccountPdas = tokenInfos.map((tokenInfo) => getVaultPdas(new PublicKey(tokenInfo.address), new PublicKey(program.programId), seedBaseKey));
    const vaultPdas = vaultAccountPdas.map(({ vaultPda }) => vaultPda);
    const vaultsState = (yield program.account.vault.fetchMultiple(vaultPdas));
    if (vaultsState.length !== tokenInfos.length) {
        throw new Error('Some of the vault state cannot be fetched');
    }
    const vaultLpMints = vaultsState.map((vaultState) => vaultState.lpMint);
    const vaultLpAccounts = yield program.provider.connection.getMultipleAccountsInfo(vaultLpMints);
    return vaultsState.map((vaultState, index) => {
        const vaultAccountPda = vaultAccountPdas[index];
        if (!vaultAccountPda)
            throw new Error('Missing vault account pda');
        const vaultLpAccount = vaultLpAccounts[index];
        if (!vaultLpAccount)
            throw new Error('Missing vault lp account');
        const lpSupply = new BN(u64.fromBuffer(MintLayout.decode(vaultLpAccount.data).supply));
        return Object.assign(Object.assign({}, vaultAccountPda), { vaultState, lpSupply });
    });
});
const getVaultState = (vaultParams, program, seedBaseKey) => __awaiter(void 0, void 0, void 0, function* () {
    const { vaultPda, tokenVaultPda } = getVaultPdas(new PublicKey(vaultParams.address), new PublicKey(program.programId), seedBaseKey);
    const vaultState = (yield program.account.vault.fetchNullable(vaultPda));
    if (!vaultState) {
        throw 'Cannot get vault state';
    }
    const lpSupply = yield getLpSupply(program.provider.connection, vaultState.lpMint);
    return { vaultPda, tokenVaultPda, vaultState, lpSupply };
});
const getVaultLiquidity = (connection, tokenVaultPda) => __awaiter(void 0, void 0, void 0, function* () {
    const vaultLiquidityResponse = yield connection.getAccountInfo(tokenVaultPda);
    if (!vaultLiquidityResponse)
        return null;
    const vaultLiquiditySerialize = deserializeAccount(vaultLiquidityResponse.data);
    return (vaultLiquiditySerialize === null || vaultLiquiditySerialize === void 0 ? void 0 : vaultLiquiditySerialize.amount.toString()) || null;
});
export default class VaultImpl {
    constructor(program, vaultDetails, opt) {
        var _a;
        this.cluster = 'mainnet-beta';
        this.connection = program.provider.connection;
        this.cluster = (_a = opt === null || opt === void 0 ? void 0 : opt.cluster) !== null && _a !== void 0 ? _a : 'mainnet-beta';
        this.tokenInfo = vaultDetails.tokenInfo;
        this.program = program;
        this.affiliateProgram = opt === null || opt === void 0 ? void 0 : opt.affiliateProgram;
        this.affiliateId = opt === null || opt === void 0 ? void 0 : opt.affiliateId;
        this.allowOwnerOffCurve = opt === null || opt === void 0 ? void 0 : opt.allowOwnerOffCurve;
        this.vaultPda = vaultDetails.vaultPda;
        this.tokenVaultPda = vaultDetails.tokenVaultPda;
        this.vaultState = vaultDetails.vaultState;
        this.lpSupply = vaultDetails.lpSupply;
    }
    static createPermissionlessVaultInstruction(connection, payer, tokenInfo, opt) {
        return __awaiter(this, void 0, void 0, function* () {
            const provider = new AnchorProvider(connection, {}, AnchorProvider.defaultOptions());
            const program = new Program(IDL, (opt === null || opt === void 0 ? void 0 : opt.programId) || PROGRAM_ID, provider);
            const tokenMint = new PublicKey(tokenInfo.address);
            const { vaultPda: vault, tokenVaultPda: tokenVault, lpMintPda: lpMint, } = getVaultPdas(tokenMint, program.programId);
            return program.methods
                .initialize()
                .accounts({
                vault,
                payer,
                tokenVault,
                tokenMint,
                lpMint,
                systemProgram: SystemProgram.programId,
                rent: SYSVAR_RENT_PUBKEY,
                tokenProgram: TOKEN_PROGRAM_ID,
            })
                .instruction();
        });
    }
    static fetchMultipleUserBalance(connection, lpMintList, owner) {
        return __awaiter(this, void 0, void 0, function* () {
            const ataAccounts = yield Promise.all(lpMintList.map((lpMint) => getAssociatedTokenAccount(lpMint, owner)));
            const accountsInfo = yield connection.getMultipleAccountsInfo(ataAccounts);
            return accountsInfo.map((accountInfo) => {
                if (!accountInfo)
                    return new BN(0);
                const accountBalance = deserializeAccount(accountInfo.data);
                if (!accountBalance)
                    throw new Error('Failed to parse user account for LP token.');
                return new BN(accountBalance.amount);
            });
        });
    }
    static createMultiple(connection, tokenInfos, opt) {
        return __awaiter(this, void 0, void 0, function* () {
            const provider = new AnchorProvider(connection, {}, AnchorProvider.defaultOptions());
            const program = new Program(IDL, (opt === null || opt === void 0 ? void 0 : opt.programId) || PROGRAM_ID, provider);
            const vaultsStateInfo = yield getAllVaultState(tokenInfos, program);
            return vaultsStateInfo.map(({ vaultPda, tokenVaultPda, vaultState, lpSupply }, index) => {
                const tokenInfo = tokenInfos[index];
                return new VaultImpl(program, { tokenInfo, vaultPda, tokenVaultPda, vaultState, lpSupply }, Object.assign(Object.assign({}, opt), { affiliateId: opt === null || opt === void 0 ? void 0 : opt.affiliateId, affiliateProgram: (opt === null || opt === void 0 ? void 0 : opt.affiliateId)
                        ? new Program(AffiliateIDL, (opt === null || opt === void 0 ? void 0 : opt.affiliateProgramId) || AFFILIATE_PROGRAM_ID, provider)
                        : undefined }));
            });
        });
    }
    static create(connection, tokenInfo, opt) {
        return __awaiter(this, void 0, void 0, function* () {
            const provider = new AnchorProvider(connection, {}, AnchorProvider.defaultOptions());
            const program = new Program(IDL, (opt === null || opt === void 0 ? void 0 : opt.programId) || PROGRAM_ID, provider);
            const { vaultPda, tokenVaultPda, vaultState, lpSupply } = yield getVaultState(tokenInfo, program);
            return new VaultImpl(program, { tokenInfo, vaultPda, tokenVaultPda, vaultState, lpSupply }, Object.assign(Object.assign({}, opt), { affiliateId: opt === null || opt === void 0 ? void 0 : opt.affiliateId, affiliateProgram: (opt === null || opt === void 0 ? void 0 : opt.affiliateId)
                    ? new Program(AffiliateIDL, (opt === null || opt === void 0 ? void 0 : opt.affiliateProgramId) || AFFILIATE_PROGRAM_ID, provider)
                    : undefined }));
        });
    }
    getUserBalance(owner) {
        return __awaiter(this, void 0, void 0, function* () {
            const isAffiliated = this.affiliateId && this.affiliateProgram;
            const address = yield (() => __awaiter(this, void 0, void 0, function* () {
                // User deposit directly
                if (!isAffiliated) {
                    return yield getAssociatedTokenAccount(this.vaultState.lpMint, owner, this.allowOwnerOffCurve);
                }
                // Get user affiliated address with the partner
                const { userLpToken } = yield this.createAffiliateATAPreInstructions(owner);
                return userLpToken;
            }))();
            const accountInfo = yield this.connection.getAccountInfo(address);
            if (!accountInfo) {
                return new BN(0);
            }
            const result = deserializeAccount(accountInfo.data);
            if (result == undefined) {
                throw new Error('Failed to parse user account for LP token.');
            }
            return new BN(result.amount);
        });
    }
    /** To refetch the latest lpSupply */
    /** Use vaultImpl.lpSupply to use cached result */
    getVaultSupply() {
        return __awaiter(this, void 0, void 0, function* () {
            const lpSupply = yield getLpSupply(this.connection, this.vaultState.lpMint);
            this.lpSupply = lpSupply;
            return lpSupply;
        });
    }
    getWithdrawableAmount() {
        return __awaiter(this, void 0, void 0, function* () {
            const currentTime = yield getOnchainTime(this.connection);
            return calculateWithdrawableAmount(currentTime, this.vaultState);
        });
    }
    refreshVaultState() {
        return __awaiter(this, void 0, void 0, function* () {
            const { vaultState, lpSupply } = yield getVaultState(this.tokenInfo, this.program);
            this.vaultState = vaultState;
            this.lpSupply = lpSupply;
        });
    }
    createATAPreInstructions(owner) {
        return __awaiter(this, void 0, void 0, function* () {
            let preInstructions = [];
            const [userToken, createUserTokenIx] = yield getOrCreateATAInstruction(new PublicKey(this.tokenInfo.address), owner, this.connection);
            const [userLpToken, createUserLpTokenIx] = yield getOrCreateATAInstruction(this.vaultState.lpMint, owner, this.connection);
            if (createUserTokenIx) {
                preInstructions.push(createUserTokenIx);
            }
            if (createUserLpTokenIx) {
                preInstructions.push(createUserLpTokenIx);
            }
            return {
                preInstructions,
                userToken,
                userLpToken,
            };
        });
    }
    createAffiliateATAPreInstructions(owner) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.affiliateId || !this.affiliateProgram)
                throw new Error('Affiliate ID or program not found');
            const partner = this.affiliateId;
            const partnerToken = yield getAssociatedTokenAccount(new PublicKey(this.tokenInfo.address), partner);
            const [partnerAddress, _nonce] = yield PublicKey.findProgramAddress([this.vaultPda.toBuffer(), partnerToken.toBuffer()], this.affiliateProgram.programId);
            const [userAddress, _nonceUser] = yield PublicKey.findProgramAddress([partnerAddress.toBuffer(), owner.toBuffer()], this.affiliateProgram.programId);
            let preInstructions = [];
            const [userToken, createUserTokenIx] = yield getOrCreateATAInstruction(new PublicKey(this.tokenInfo.address), owner, this.connection);
            const [userLpToken, createUserLpTokenIx] = yield getOrCreateATAInstruction(this.vaultState.lpMint, userAddress, this.connection, {
                payer: owner,
            });
            if (createUserTokenIx) {
                preInstructions.push(createUserTokenIx);
            }
            if (createUserLpTokenIx) {
                preInstructions.push(createUserLpTokenIx);
            }
            return {
                preInstructions,
                partner,
                partnerAddress,
                userAddress,
                userToken,
                userLpToken,
            };
        });
    }
    deposit(owner, baseTokenAmount) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            // Refresh vault state
            yield this.refreshVaultState();
            let preInstructions = [];
            let partnerAddress;
            let userAddress;
            let userToken;
            let userLpToken;
            // Withdraw with Affiliate
            if (this.affiliateId && this.affiliateProgram) {
                const { preInstructions: preInstructionsATA, partnerAddress: partnerAddressATA, userAddress: userAddressATA, userToken: userTokenATA, userLpToken: userLpTokenATA, } = yield this.createAffiliateATAPreInstructions(owner);
                preInstructions = preInstructionsATA;
                userToken = userTokenATA;
                userLpToken = userLpTokenATA;
                partnerAddress = partnerAddressATA;
                userAddress = userAddressATA;
            }
            else {
                // Without affiliate
                const { preInstructions: preInstructionsATA, userToken: userTokenATA, userLpToken: userLpTokenATA, } = yield this.createATAPreInstructions(owner);
                preInstructions = preInstructionsATA;
                userToken = userTokenATA;
                userLpToken = userLpTokenATA;
            }
            // If it's SOL vault, wrap desired amount of SOL
            if (this.tokenInfo.address === SOL_MINT.toString()) {
                preInstructions = preInstructions.concat(wrapSOLInstruction(owner, userToken, baseTokenAmount));
            }
            let depositTx;
            if (partnerAddress && userAddress && this.affiliateId && this.affiliateProgram) {
                const userPda = yield this.connection.getParsedAccountInfo(userAddress);
                if (!userPda || !((_a = userPda.value) === null || _a === void 0 ? void 0 : _a.data)) {
                    // Init first time user
                    preInstructions.push(yield this.affiliateProgram.methods
                        .initUser()
                        .accounts({
                        user: userAddress,
                        partner: partnerAddress,
                        owner,
                        systemProgram: SystemProgram.programId,
                        rent: SYSVAR_RENT_PUBKEY,
                    })
                        .instruction());
                }
                depositTx = yield this.affiliateProgram.methods
                    .deposit(new BN(baseTokenAmount.toString()), new BN(0)) // Vault does not have slippage, second parameter is ignored.
                    .accounts({
                    partner: partnerAddress,
                    user: userAddress,
                    vaultProgram: this.program.programId,
                    vault: this.vaultPda,
                    tokenVault: this.tokenVaultPda,
                    vaultLpMint: this.vaultState.lpMint,
                    userToken,
                    userLp: userLpToken,
                    owner,
                    tokenProgram: TOKEN_PROGRAM_ID,
                })
                    .preInstructions(preInstructions)
                    .transaction();
            }
            else {
                depositTx = yield this.program.methods
                    .deposit(new BN(baseTokenAmount.toString()), new BN(0)) // Vault does not have slippage, second parameter is ignored.
                    .accounts({
                    vault: this.vaultPda,
                    tokenVault: this.tokenVaultPda,
                    lpMint: this.vaultState.lpMint,
                    userToken,
                    userLp: userLpToken,
                    user: owner,
                    tokenProgram: TOKEN_PROGRAM_ID,
                })
                    .preInstructions(preInstructions)
                    .transaction();
            }
            return new Transaction(Object.assign({ feePayer: owner }, (yield this.connection.getLatestBlockhash()))).add(depositTx);
        });
    }
    getStrategiesState() {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.program.account.strategy.fetchMultiple(this.vaultState.strategies.filter((address) => address.toString() !== VAULT_STRATEGY_ADDRESS))).filter(Boolean);
        });
    }
    getStrategyWithHighestLiquidity(strategy) {
        return __awaiter(this, void 0, void 0, function* () {
            // Reserved for testing
            if (strategy) {
                const strategyState = (yield this.program.account.strategy.fetchNullable(strategy));
                return { publicKey: strategy, strategyState };
            }
            const vaultStrategiesStatePromise = this.vaultState.strategies
                .filter((address) => address.toString() !== VAULT_STRATEGY_ADDRESS)
                .map((strat) => __awaiter(this, void 0, void 0, function* () {
                const strategyState = (yield this.program.account.strategy.fetch(strat));
                return { publicKey: strat, strategyState };
            }));
            const vaultStrategiesState = yield Promise.allSettled(vaultStrategiesStatePromise);
            const settledVaultStrategiesState = vaultStrategiesState
                .map((item) => (item.status === 'fulfilled' ? item.value : undefined))
                .filter(Boolean);
            const highestLiquidity = settledVaultStrategiesState.sort((a, b) => b.strategyState.currentLiquidity.sub(a.strategyState.currentLiquidity).toNumber())[0];
            return highestLiquidity;
        });
    }
    withdraw(owner, baseTokenAmount, opt) {
        return __awaiter(this, void 0, void 0, function* () {
            // Refresh vault state
            yield this.refreshVaultState();
            const lpSupply = yield this.getVaultSupply();
            let preInstructions = [];
            let userToken;
            let userLpToken;
            let withdrawOpt;
            // Withdraw with Affiliate
            if (this.affiliateId && this.affiliateProgram) {
                const { preInstructions: preInstructionsATA, partnerAddress, userAddress, userToken: userTokenATA, userLpToken: userLpTokenATA, } = yield this.createAffiliateATAPreInstructions(owner);
                preInstructions = preInstructionsATA;
                userToken = userTokenATA;
                userLpToken = userLpTokenATA;
                withdrawOpt =
                    this.affiliateId && this.affiliateProgram
                        ? {
                            affiliate: {
                                affiliateId: this.affiliateId,
                                affiliateProgram: this.affiliateProgram,
                                partner: partnerAddress,
                                user: userAddress,
                            },
                        }
                        : undefined;
            }
            else {
                // Without affiliate
                const { preInstructions: preInstructionsATA, userToken: userTokenATA, userLpToken: userLpTokenATA, } = yield this.createATAPreInstructions(owner);
                preInstructions = preInstructionsATA;
                userToken = userTokenATA;
                userLpToken = userLpTokenATA;
            }
            const unlockedAmount = yield this.getWithdrawableAmount();
            const amountToWithdraw = baseTokenAmount.mul(unlockedAmount).div(lpSupply);
            const vaultLiquidity = new BN((yield getVaultLiquidity(this.connection, this.tokenVaultPda)) || 0);
            if (amountToWithdraw.lt(vaultLiquidity) // If withdraw amount lesser than vault reserve
            ) {
                return this.withdrawFromVaultReserve(owner, baseTokenAmount, userToken, userLpToken, preInstructions, withdrawOpt);
            }
            // Get strategy with highest liquidity
            // opt.strategy reserved for testing
            const selectedStrategy = yield this.getStrategyWithHighestLiquidity(opt === null || opt === void 0 ? void 0 : opt.strategy);
            const currentLiquidity = new BN(selectedStrategy.strategyState.currentLiquidity);
            const availableAmount = currentLiquidity.add(vaultLiquidity);
            if (amountToWithdraw.gt(availableAmount)) {
                throw new Error('Selected strategy does not have enough liquidity.');
            }
            const strategyType = getStrategyType(selectedStrategy.strategyState.strategyType);
            const strategyHandler = getStrategyHandler(strategyType, this.cluster, this.program);
            if (!strategyType || !strategyHandler) {
                throw new Error('Cannot find strategy handler');
            }
            // Unwrap SOL
            const postInstruction = [];
            if (this.tokenInfo.address === SOL_MINT.toString()) {
                const closeWrappedSOLIx = yield unwrapSOLInstruction(owner);
                if (closeWrappedSOLIx) {
                    postInstruction.push(closeWrappedSOLIx);
                }
            }
            const withdrawFromStrategyTx = yield strategyHandler.withdraw(owner, this.program, {
                pubkey: selectedStrategy.publicKey,
                state: selectedStrategy.strategyState,
            }, this.vaultPda, this.tokenVaultPda, this.vaultState, userToken, userLpToken, baseTokenAmount, preInstructions, postInstruction, withdrawOpt);
            const tx = new Transaction(Object.assign({ feePayer: owner }, (yield this.connection.getLatestBlockhash()))).add(withdrawFromStrategyTx);
            return tx;
        });
    }
    // Reserved code to withdraw from Vault Reserves directly.
    // The only situation this piece of code will be required, is when a single Vault have no other strategy, and only have its own reserve.
    withdrawFromVaultReserve(owner, baseTokenAmount, userToken, userLpToken, preInstructions, withdrawOpt) {
        return __awaiter(this, void 0, void 0, function* () {
            // Unwrap SOL
            const postInstruction = [];
            if (this.tokenInfo.address === SOL_MINT.toString()) {
                const closeWrappedSOLIx = yield unwrapSOLInstruction(owner);
                if (closeWrappedSOLIx) {
                    postInstruction.push(closeWrappedSOLIx);
                }
            }
            let withdrawTx;
            if (withdrawOpt === null || withdrawOpt === void 0 ? void 0 : withdrawOpt.affiliate) {
                withdrawTx = yield withdrawOpt.affiliate.affiliateProgram.methods
                    .withdraw(baseTokenAmount, new BN(0))
                    .accounts({
                    vault: this.vaultPda,
                    tokenVault: this.tokenVaultPda,
                    vaultLpMint: this.vaultState.lpMint,
                    partner: withdrawOpt.affiliate.partner,
                    owner,
                    userToken,
                    vaultProgram: this.program.programId,
                    userLp: userLpToken,
                    user: withdrawOpt.affiliate.user,
                    tokenProgram: TOKEN_PROGRAM_ID,
                })
                    .preInstructions(preInstructions)
                    .postInstructions(postInstruction)
                    .transaction();
            }
            else {
                withdrawTx = yield this.program.methods
                    .withdraw(baseTokenAmount, new BN(0)) // Vault does not have slippage, second parameter is ignored.
                    .accounts({
                    vault: this.vaultPda,
                    tokenVault: this.tokenVaultPda,
                    lpMint: this.vaultState.lpMint,
                    userToken,
                    userLp: userLpToken,
                    user: owner,
                    tokenProgram: TOKEN_PROGRAM_ID,
                })
                    .preInstructions(preInstructions)
                    .postInstructions(postInstruction)
                    .transaction();
            }
            return new Transaction(Object.assign({ feePayer: owner }, (yield this.connection.getLatestBlockhash()))).add(withdrawTx);
        });
    }
    getAffiliateInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.affiliateId || !this.affiliateProgram)
                throw new Error('No affiliateId or affiliate program found');
            const partner = this.affiliateId;
            const partnerToken = yield getAssociatedTokenAccount(new PublicKey(this.tokenInfo.address), partner);
            const [partnerAddress, _nonce] = yield PublicKey.findProgramAddress([this.vaultPda.toBuffer(), partnerToken.toBuffer()], this.affiliateProgram.programId);
            const partnerDetails = (yield this.affiliateProgram.account.partner.fetchNullable(partnerAddress));
            return partnerDetails;
        });
    }
}
//# sourceMappingURL=index.js.map