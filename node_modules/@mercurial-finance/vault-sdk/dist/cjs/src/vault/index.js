"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const anchor_1 = require("@project-serum/anchor");
const web3_js_1 = require("@solana/web3.js");
const spl_token_1 = require("@solana/spl-token");
const utils_1 = require("./utils");
const constants_1 = require("./constants");
const strategy_1 = require("./strategy");
const idl_1 = require("./idl");
const affiliate_idl_1 = require("./affiliate-idl");
const helper_1 = require("./helper");
const getAllVaultState = (tokenInfos, program, seedBaseKey) => __awaiter(void 0, void 0, void 0, function* () {
    const vaultAccountPdas = tokenInfos.map((tokenInfo) => (0, utils_1.getVaultPdas)(new web3_js_1.PublicKey(tokenInfo.address), new web3_js_1.PublicKey(program.programId), seedBaseKey));
    const vaultPdas = vaultAccountPdas.map(({ vaultPda }) => vaultPda);
    const vaultsState = (yield program.account.vault.fetchMultiple(vaultPdas));
    if (vaultsState.length !== tokenInfos.length) {
        throw new Error('Some of the vault state cannot be fetched');
    }
    const vaultLpMints = vaultsState.map((vaultState) => vaultState.lpMint);
    const vaultLpAccounts = yield program.provider.connection.getMultipleAccountsInfo(vaultLpMints);
    return vaultsState.map((vaultState, index) => {
        const vaultAccountPda = vaultAccountPdas[index];
        if (!vaultAccountPda)
            throw new Error('Missing vault account pda');
        const vaultLpAccount = vaultLpAccounts[index];
        if (!vaultLpAccount)
            throw new Error('Missing vault lp account');
        const lpSupply = new anchor_1.BN(spl_token_1.u64.fromBuffer(spl_token_1.MintLayout.decode(vaultLpAccount.data).supply));
        return Object.assign(Object.assign({}, vaultAccountPda), { vaultState, lpSupply });
    });
});
const getVaultState = (vaultParams, program, seedBaseKey) => __awaiter(void 0, void 0, void 0, function* () {
    const { vaultPda, tokenVaultPda } = (0, utils_1.getVaultPdas)(new web3_js_1.PublicKey(vaultParams.address), new web3_js_1.PublicKey(program.programId), seedBaseKey);
    const vaultState = (yield program.account.vault.fetchNullable(vaultPda));
    if (!vaultState) {
        throw 'Cannot get vault state';
    }
    const lpSupply = yield (0, utils_1.getLpSupply)(program.provider.connection, vaultState.lpMint);
    return { vaultPda, tokenVaultPda, vaultState, lpSupply };
});
const getVaultLiquidity = (connection, tokenVaultPda) => __awaiter(void 0, void 0, void 0, function* () {
    const vaultLiquidityResponse = yield connection.getAccountInfo(tokenVaultPda);
    if (!vaultLiquidityResponse)
        return null;
    const vaultLiquiditySerialize = (0, utils_1.deserializeAccount)(vaultLiquidityResponse.data);
    return (vaultLiquiditySerialize === null || vaultLiquiditySerialize === void 0 ? void 0 : vaultLiquiditySerialize.amount.toString()) || null;
});
class VaultImpl {
    constructor(program, vaultDetails, opt) {
        var _a;
        this.cluster = 'mainnet-beta';
        this.connection = program.provider.connection;
        this.cluster = (_a = opt === null || opt === void 0 ? void 0 : opt.cluster) !== null && _a !== void 0 ? _a : 'mainnet-beta';
        this.tokenInfo = vaultDetails.tokenInfo;
        this.program = program;
        this.affiliateProgram = opt === null || opt === void 0 ? void 0 : opt.affiliateProgram;
        this.affiliateId = opt === null || opt === void 0 ? void 0 : opt.affiliateId;
        this.allowOwnerOffCurve = opt === null || opt === void 0 ? void 0 : opt.allowOwnerOffCurve;
        this.vaultPda = vaultDetails.vaultPda;
        this.tokenVaultPda = vaultDetails.tokenVaultPda;
        this.vaultState = vaultDetails.vaultState;
        this.lpSupply = vaultDetails.lpSupply;
    }
    static createPermissionlessVaultInstruction(connection, payer, tokenInfo, opt) {
        return __awaiter(this, void 0, void 0, function* () {
            const provider = new anchor_1.AnchorProvider(connection, {}, anchor_1.AnchorProvider.defaultOptions());
            const program = new anchor_1.Program(idl_1.IDL, (opt === null || opt === void 0 ? void 0 : opt.programId) || constants_1.PROGRAM_ID, provider);
            const tokenMint = new web3_js_1.PublicKey(tokenInfo.address);
            const { vaultPda: vault, tokenVaultPda: tokenVault, lpMintPda: lpMint, } = (0, utils_1.getVaultPdas)(tokenMint, program.programId);
            return program.methods
                .initialize()
                .accounts({
                vault,
                payer,
                tokenVault,
                tokenMint,
                lpMint,
                systemProgram: web3_js_1.SystemProgram.programId,
                rent: web3_js_1.SYSVAR_RENT_PUBKEY,
                tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
            })
                .instruction();
        });
    }
    static fetchMultipleUserBalance(connection, lpMintList, owner) {
        return __awaiter(this, void 0, void 0, function* () {
            const ataAccounts = yield Promise.all(lpMintList.map((lpMint) => (0, utils_1.getAssociatedTokenAccount)(lpMint, owner)));
            const accountsInfo = yield connection.getMultipleAccountsInfo(ataAccounts);
            return accountsInfo.map((accountInfo) => {
                if (!accountInfo)
                    return new anchor_1.BN(0);
                const accountBalance = (0, utils_1.deserializeAccount)(accountInfo.data);
                if (!accountBalance)
                    throw new Error('Failed to parse user account for LP token.');
                return new anchor_1.BN(accountBalance.amount);
            });
        });
    }
    static createMultiple(connection, tokenInfos, opt) {
        return __awaiter(this, void 0, void 0, function* () {
            const provider = new anchor_1.AnchorProvider(connection, {}, anchor_1.AnchorProvider.defaultOptions());
            const program = new anchor_1.Program(idl_1.IDL, (opt === null || opt === void 0 ? void 0 : opt.programId) || constants_1.PROGRAM_ID, provider);
            const vaultsStateInfo = yield getAllVaultState(tokenInfos, program);
            return vaultsStateInfo.map(({ vaultPda, tokenVaultPda, vaultState, lpSupply }, index) => {
                const tokenInfo = tokenInfos[index];
                return new VaultImpl(program, { tokenInfo, vaultPda, tokenVaultPda, vaultState, lpSupply }, Object.assign(Object.assign({}, opt), { affiliateId: opt === null || opt === void 0 ? void 0 : opt.affiliateId, affiliateProgram: (opt === null || opt === void 0 ? void 0 : opt.affiliateId)
                        ? new anchor_1.Program(affiliate_idl_1.IDL, (opt === null || opt === void 0 ? void 0 : opt.affiliateProgramId) || constants_1.AFFILIATE_PROGRAM_ID, provider)
                        : undefined }));
            });
        });
    }
    static create(connection, tokenInfo, opt) {
        return __awaiter(this, void 0, void 0, function* () {
            const provider = new anchor_1.AnchorProvider(connection, {}, anchor_1.AnchorProvider.defaultOptions());
            const program = new anchor_1.Program(idl_1.IDL, (opt === null || opt === void 0 ? void 0 : opt.programId) || constants_1.PROGRAM_ID, provider);
            const { vaultPda, tokenVaultPda, vaultState, lpSupply } = yield getVaultState(tokenInfo, program);
            return new VaultImpl(program, { tokenInfo, vaultPda, tokenVaultPda, vaultState, lpSupply }, Object.assign(Object.assign({}, opt), { affiliateId: opt === null || opt === void 0 ? void 0 : opt.affiliateId, affiliateProgram: (opt === null || opt === void 0 ? void 0 : opt.affiliateId)
                    ? new anchor_1.Program(affiliate_idl_1.IDL, (opt === null || opt === void 0 ? void 0 : opt.affiliateProgramId) || constants_1.AFFILIATE_PROGRAM_ID, provider)
                    : undefined }));
        });
    }
    getUserBalance(owner) {
        return __awaiter(this, void 0, void 0, function* () {
            const isAffiliated = this.affiliateId && this.affiliateProgram;
            const address = yield (() => __awaiter(this, void 0, void 0, function* () {
                // User deposit directly
                if (!isAffiliated) {
                    return yield (0, utils_1.getAssociatedTokenAccount)(this.vaultState.lpMint, owner, this.allowOwnerOffCurve);
                }
                // Get user affiliated address with the partner
                const { userLpToken } = yield this.createAffiliateATAPreInstructions(owner);
                return userLpToken;
            }))();
            const accountInfo = yield this.connection.getAccountInfo(address);
            if (!accountInfo) {
                return new anchor_1.BN(0);
            }
            const result = (0, utils_1.deserializeAccount)(accountInfo.data);
            if (result == undefined) {
                throw new Error('Failed to parse user account for LP token.');
            }
            return new anchor_1.BN(result.amount);
        });
    }
    /** To refetch the latest lpSupply */
    /** Use vaultImpl.lpSupply to use cached result */
    getVaultSupply() {
        return __awaiter(this, void 0, void 0, function* () {
            const lpSupply = yield (0, utils_1.getLpSupply)(this.connection, this.vaultState.lpMint);
            this.lpSupply = lpSupply;
            return lpSupply;
        });
    }
    getWithdrawableAmount() {
        return __awaiter(this, void 0, void 0, function* () {
            const currentTime = yield (0, utils_1.getOnchainTime)(this.connection);
            return (0, helper_1.calculateWithdrawableAmount)(currentTime, this.vaultState);
        });
    }
    refreshVaultState() {
        return __awaiter(this, void 0, void 0, function* () {
            const { vaultState, lpSupply } = yield getVaultState(this.tokenInfo, this.program);
            this.vaultState = vaultState;
            this.lpSupply = lpSupply;
        });
    }
    createATAPreInstructions(owner) {
        return __awaiter(this, void 0, void 0, function* () {
            let preInstructions = [];
            const [userToken, createUserTokenIx] = yield (0, utils_1.getOrCreateATAInstruction)(new web3_js_1.PublicKey(this.tokenInfo.address), owner, this.connection);
            const [userLpToken, createUserLpTokenIx] = yield (0, utils_1.getOrCreateATAInstruction)(this.vaultState.lpMint, owner, this.connection);
            if (createUserTokenIx) {
                preInstructions.push(createUserTokenIx);
            }
            if (createUserLpTokenIx) {
                preInstructions.push(createUserLpTokenIx);
            }
            return {
                preInstructions,
                userToken,
                userLpToken,
            };
        });
    }
    createAffiliateATAPreInstructions(owner) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.affiliateId || !this.affiliateProgram)
                throw new Error('Affiliate ID or program not found');
            const partner = this.affiliateId;
            const partnerToken = yield (0, utils_1.getAssociatedTokenAccount)(new web3_js_1.PublicKey(this.tokenInfo.address), partner);
            const [partnerAddress, _nonce] = yield web3_js_1.PublicKey.findProgramAddress([this.vaultPda.toBuffer(), partnerToken.toBuffer()], this.affiliateProgram.programId);
            const [userAddress, _nonceUser] = yield web3_js_1.PublicKey.findProgramAddress([partnerAddress.toBuffer(), owner.toBuffer()], this.affiliateProgram.programId);
            let preInstructions = [];
            const [userToken, createUserTokenIx] = yield (0, utils_1.getOrCreateATAInstruction)(new web3_js_1.PublicKey(this.tokenInfo.address), owner, this.connection);
            const [userLpToken, createUserLpTokenIx] = yield (0, utils_1.getOrCreateATAInstruction)(this.vaultState.lpMint, userAddress, this.connection, {
                payer: owner,
            });
            if (createUserTokenIx) {
                preInstructions.push(createUserTokenIx);
            }
            if (createUserLpTokenIx) {
                preInstructions.push(createUserLpTokenIx);
            }
            return {
                preInstructions,
                partner,
                partnerAddress,
                userAddress,
                userToken,
                userLpToken,
            };
        });
    }
    deposit(owner, baseTokenAmount) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            // Refresh vault state
            yield this.refreshVaultState();
            let preInstructions = [];
            let partnerAddress;
            let userAddress;
            let userToken;
            let userLpToken;
            // Withdraw with Affiliate
            if (this.affiliateId && this.affiliateProgram) {
                const { preInstructions: preInstructionsATA, partnerAddress: partnerAddressATA, userAddress: userAddressATA, userToken: userTokenATA, userLpToken: userLpTokenATA, } = yield this.createAffiliateATAPreInstructions(owner);
                preInstructions = preInstructionsATA;
                userToken = userTokenATA;
                userLpToken = userLpTokenATA;
                partnerAddress = partnerAddressATA;
                userAddress = userAddressATA;
            }
            else {
                // Without affiliate
                const { preInstructions: preInstructionsATA, userToken: userTokenATA, userLpToken: userLpTokenATA, } = yield this.createATAPreInstructions(owner);
                preInstructions = preInstructionsATA;
                userToken = userTokenATA;
                userLpToken = userLpTokenATA;
            }
            // If it's SOL vault, wrap desired amount of SOL
            if (this.tokenInfo.address === constants_1.SOL_MINT.toString()) {
                preInstructions = preInstructions.concat((0, utils_1.wrapSOLInstruction)(owner, userToken, baseTokenAmount));
            }
            let depositTx;
            if (partnerAddress && userAddress && this.affiliateId && this.affiliateProgram) {
                const userPda = yield this.connection.getParsedAccountInfo(userAddress);
                if (!userPda || !((_a = userPda.value) === null || _a === void 0 ? void 0 : _a.data)) {
                    // Init first time user
                    preInstructions.push(yield this.affiliateProgram.methods
                        .initUser()
                        .accounts({
                        user: userAddress,
                        partner: partnerAddress,
                        owner,
                        systemProgram: web3_js_1.SystemProgram.programId,
                        rent: web3_js_1.SYSVAR_RENT_PUBKEY,
                    })
                        .instruction());
                }
                depositTx = yield this.affiliateProgram.methods
                    .deposit(new anchor_1.BN(baseTokenAmount.toString()), new anchor_1.BN(0)) // Vault does not have slippage, second parameter is ignored.
                    .accounts({
                    partner: partnerAddress,
                    user: userAddress,
                    vaultProgram: this.program.programId,
                    vault: this.vaultPda,
                    tokenVault: this.tokenVaultPda,
                    vaultLpMint: this.vaultState.lpMint,
                    userToken,
                    userLp: userLpToken,
                    owner,
                    tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
                })
                    .preInstructions(preInstructions)
                    .transaction();
            }
            else {
                depositTx = yield this.program.methods
                    .deposit(new anchor_1.BN(baseTokenAmount.toString()), new anchor_1.BN(0)) // Vault does not have slippage, second parameter is ignored.
                    .accounts({
                    vault: this.vaultPda,
                    tokenVault: this.tokenVaultPda,
                    lpMint: this.vaultState.lpMint,
                    userToken,
                    userLp: userLpToken,
                    user: owner,
                    tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
                })
                    .preInstructions(preInstructions)
                    .transaction();
            }
            return new web3_js_1.Transaction(Object.assign({ feePayer: owner }, (yield this.connection.getLatestBlockhash()))).add(depositTx);
        });
    }
    getStrategiesState() {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.program.account.strategy.fetchMultiple(this.vaultState.strategies.filter((address) => address.toString() !== constants_1.VAULT_STRATEGY_ADDRESS))).filter(Boolean);
        });
    }
    getStrategyWithHighestLiquidity(strategy) {
        return __awaiter(this, void 0, void 0, function* () {
            // Reserved for testing
            if (strategy) {
                const strategyState = (yield this.program.account.strategy.fetchNullable(strategy));
                return { publicKey: strategy, strategyState };
            }
            const vaultStrategiesStatePromise = this.vaultState.strategies
                .filter((address) => address.toString() !== constants_1.VAULT_STRATEGY_ADDRESS)
                .map((strat) => __awaiter(this, void 0, void 0, function* () {
                const strategyState = (yield this.program.account.strategy.fetch(strat));
                return { publicKey: strat, strategyState };
            }));
            const vaultStrategiesState = yield Promise.allSettled(vaultStrategiesStatePromise);
            const settledVaultStrategiesState = vaultStrategiesState
                .map((item) => (item.status === 'fulfilled' ? item.value : undefined))
                .filter(Boolean);
            const highestLiquidity = settledVaultStrategiesState.sort((a, b) => b.strategyState.currentLiquidity.sub(a.strategyState.currentLiquidity).toNumber())[0];
            return highestLiquidity;
        });
    }
    withdraw(owner, baseTokenAmount, opt) {
        return __awaiter(this, void 0, void 0, function* () {
            // Refresh vault state
            yield this.refreshVaultState();
            const lpSupply = yield this.getVaultSupply();
            let preInstructions = [];
            let userToken;
            let userLpToken;
            let withdrawOpt;
            // Withdraw with Affiliate
            if (this.affiliateId && this.affiliateProgram) {
                const { preInstructions: preInstructionsATA, partnerAddress, userAddress, userToken: userTokenATA, userLpToken: userLpTokenATA, } = yield this.createAffiliateATAPreInstructions(owner);
                preInstructions = preInstructionsATA;
                userToken = userTokenATA;
                userLpToken = userLpTokenATA;
                withdrawOpt =
                    this.affiliateId && this.affiliateProgram
                        ? {
                            affiliate: {
                                affiliateId: this.affiliateId,
                                affiliateProgram: this.affiliateProgram,
                                partner: partnerAddress,
                                user: userAddress,
                            },
                        }
                        : undefined;
            }
            else {
                // Without affiliate
                const { preInstructions: preInstructionsATA, userToken: userTokenATA, userLpToken: userLpTokenATA, } = yield this.createATAPreInstructions(owner);
                preInstructions = preInstructionsATA;
                userToken = userTokenATA;
                userLpToken = userLpTokenATA;
            }
            const unlockedAmount = yield this.getWithdrawableAmount();
            const amountToWithdraw = baseTokenAmount.mul(unlockedAmount).div(lpSupply);
            const vaultLiquidity = new anchor_1.BN((yield getVaultLiquidity(this.connection, this.tokenVaultPda)) || 0);
            if (amountToWithdraw.lt(vaultLiquidity) // If withdraw amount lesser than vault reserve
            ) {
                return this.withdrawFromVaultReserve(owner, baseTokenAmount, userToken, userLpToken, preInstructions, withdrawOpt);
            }
            // Get strategy with highest liquidity
            // opt.strategy reserved for testing
            const selectedStrategy = yield this.getStrategyWithHighestLiquidity(opt === null || opt === void 0 ? void 0 : opt.strategy);
            const currentLiquidity = new anchor_1.BN(selectedStrategy.strategyState.currentLiquidity);
            const availableAmount = currentLiquidity.add(vaultLiquidity);
            if (amountToWithdraw.gt(availableAmount)) {
                throw new Error('Selected strategy does not have enough liquidity.');
            }
            const strategyType = (0, strategy_1.getStrategyType)(selectedStrategy.strategyState.strategyType);
            const strategyHandler = (0, strategy_1.getStrategyHandler)(strategyType, this.cluster, this.program);
            if (!strategyType || !strategyHandler) {
                throw new Error('Cannot find strategy handler');
            }
            // Unwrap SOL
            const postInstruction = [];
            if (this.tokenInfo.address === constants_1.SOL_MINT.toString()) {
                const closeWrappedSOLIx = yield (0, utils_1.unwrapSOLInstruction)(owner);
                if (closeWrappedSOLIx) {
                    postInstruction.push(closeWrappedSOLIx);
                }
            }
            const withdrawFromStrategyTx = yield strategyHandler.withdraw(owner, this.program, {
                pubkey: selectedStrategy.publicKey,
                state: selectedStrategy.strategyState,
            }, this.vaultPda, this.tokenVaultPda, this.vaultState, userToken, userLpToken, baseTokenAmount, preInstructions, postInstruction, withdrawOpt);
            const tx = new web3_js_1.Transaction(Object.assign({ feePayer: owner }, (yield this.connection.getLatestBlockhash()))).add(withdrawFromStrategyTx);
            return tx;
        });
    }
    // Reserved code to withdraw from Vault Reserves directly.
    // The only situation this piece of code will be required, is when a single Vault have no other strategy, and only have its own reserve.
    withdrawFromVaultReserve(owner, baseTokenAmount, userToken, userLpToken, preInstructions, withdrawOpt) {
        return __awaiter(this, void 0, void 0, function* () {
            // Unwrap SOL
            const postInstruction = [];
            if (this.tokenInfo.address === constants_1.SOL_MINT.toString()) {
                const closeWrappedSOLIx = yield (0, utils_1.unwrapSOLInstruction)(owner);
                if (closeWrappedSOLIx) {
                    postInstruction.push(closeWrappedSOLIx);
                }
            }
            let withdrawTx;
            if (withdrawOpt === null || withdrawOpt === void 0 ? void 0 : withdrawOpt.affiliate) {
                withdrawTx = yield withdrawOpt.affiliate.affiliateProgram.methods
                    .withdraw(baseTokenAmount, new anchor_1.BN(0))
                    .accounts({
                    vault: this.vaultPda,
                    tokenVault: this.tokenVaultPda,
                    vaultLpMint: this.vaultState.lpMint,
                    partner: withdrawOpt.affiliate.partner,
                    owner,
                    userToken,
                    vaultProgram: this.program.programId,
                    userLp: userLpToken,
                    user: withdrawOpt.affiliate.user,
                    tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
                })
                    .preInstructions(preInstructions)
                    .postInstructions(postInstruction)
                    .transaction();
            }
            else {
                withdrawTx = yield this.program.methods
                    .withdraw(baseTokenAmount, new anchor_1.BN(0)) // Vault does not have slippage, second parameter is ignored.
                    .accounts({
                    vault: this.vaultPda,
                    tokenVault: this.tokenVaultPda,
                    lpMint: this.vaultState.lpMint,
                    userToken,
                    userLp: userLpToken,
                    user: owner,
                    tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
                })
                    .preInstructions(preInstructions)
                    .postInstructions(postInstruction)
                    .transaction();
            }
            return new web3_js_1.Transaction(Object.assign({ feePayer: owner }, (yield this.connection.getLatestBlockhash()))).add(withdrawTx);
        });
    }
    getAffiliateInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.affiliateId || !this.affiliateProgram)
                throw new Error('No affiliateId or affiliate program found');
            const partner = this.affiliateId;
            const partnerToken = yield (0, utils_1.getAssociatedTokenAccount)(new web3_js_1.PublicKey(this.tokenInfo.address), partner);
            const [partnerAddress, _nonce] = yield web3_js_1.PublicKey.findProgramAddress([this.vaultPda.toBuffer(), partnerToken.toBuffer()], this.affiliateProgram.programId);
            const partnerDetails = (yield this.affiliateProgram.account.partner.fetchNullable(partnerAddress));
            return partnerDetails;
        });
    }
}
exports.default = VaultImpl;
//# sourceMappingURL=index.js.map