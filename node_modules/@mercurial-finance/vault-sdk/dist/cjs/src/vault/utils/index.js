"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getLpSupply = exports.getOnchainTime = exports.unwrapSOLInstruction = exports.wrapSOLInstruction = exports.getVaultPdas = exports.getOrCreateATAInstruction = exports.deserializeAccount = exports.getAssociatedTokenAccount = void 0;
const spl_token_1 = require("@solana/spl-token");
const web3_js_1 = require("@solana/web3.js");
const spl_token_2 = require("@solana/spl-token");
const anchor_1 = require("@project-serum/anchor");
const constants_1 = require("../constants");
const getAssociatedTokenAccount = (tokenMint, owner, allowOwnerOffCurve = false) => __awaiter(void 0, void 0, void 0, function* () {
    return yield spl_token_1.Token.getAssociatedTokenAddress(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, tokenMint, owner, allowOwnerOffCurve);
});
exports.getAssociatedTokenAccount = getAssociatedTokenAccount;
const deserializeAccount = (data) => {
    if (data == undefined || data.length == 0) {
        return undefined;
    }
    const accountInfo = spl_token_2.AccountLayout.decode(data);
    accountInfo.mint = new web3_js_1.PublicKey(accountInfo.mint);
    accountInfo.owner = new web3_js_1.PublicKey(accountInfo.owner);
    accountInfo.amount = spl_token_2.u64.fromBuffer(accountInfo.amount);
    if (accountInfo.delegateOption === 0) {
        accountInfo.delegate = null;
        accountInfo.delegatedAmount = new spl_token_2.u64(0);
    }
    else {
        accountInfo.delegate = new web3_js_1.PublicKey(accountInfo.delegate);
        accountInfo.delegatedAmount = spl_token_2.u64.fromBuffer(accountInfo.delegatedAmount);
    }
    accountInfo.isInitialized = accountInfo.state !== 0;
    accountInfo.isFrozen = accountInfo.state === 2;
    if (accountInfo.isNativeOption === 1) {
        accountInfo.rentExemptReserve = spl_token_2.u64.fromBuffer(accountInfo.isNative);
        accountInfo.isNative = true;
    }
    else {
        accountInfo.rentExemptReserve = null;
        accountInfo.isNative = false;
    }
    if (accountInfo.closeAuthorityOption === 0) {
        accountInfo.closeAuthority = null;
    }
    else {
        accountInfo.closeAuthority = new web3_js_1.PublicKey(accountInfo.closeAuthority);
    }
    return accountInfo;
};
exports.deserializeAccount = deserializeAccount;
const getOrCreateATAInstruction = (tokenMint, owner, connection, opt) => __awaiter(void 0, void 0, void 0, function* () {
    let toAccount;
    try {
        toAccount = yield spl_token_1.Token.getAssociatedTokenAddress(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, tokenMint, owner, true);
        const account = yield connection.getAccountInfo(toAccount);
        if (!account) {
            const ix = spl_token_1.Token.createAssociatedTokenAccountInstruction(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, tokenMint, toAccount, owner, (opt === null || opt === void 0 ? void 0 : opt.payer) || owner);
            return [toAccount, ix];
        }
        return [toAccount, undefined];
    }
    catch (e) {
        /* handle error */
        console.error('Error::getOrCreateATAInstruction', e);
        throw e;
    }
});
exports.getOrCreateATAInstruction = getOrCreateATAInstruction;
const getVaultPdas = (tokenMint, programId, seedBaseKey) => {
    const [vault, _vaultBump] = web3_js_1.PublicKey.findProgramAddressSync([Buffer.from(constants_1.SEEDS.VAULT_PREFIX), tokenMint.toBuffer(), (seedBaseKey !== null && seedBaseKey !== void 0 ? seedBaseKey : constants_1.VAULT_BASE_KEY).toBuffer()], programId);
    const tokenVault = web3_js_1.PublicKey.findProgramAddressSync([Buffer.from(constants_1.SEEDS.TOKEN_VAULT_PREFIX), vault.toBuffer()], programId);
    const lpMint = web3_js_1.PublicKey.findProgramAddressSync([Buffer.from(constants_1.SEEDS.LP_MINT_PREFIX), vault.toBuffer()], programId);
    return {
        vaultPda: vault,
        tokenVaultPda: tokenVault[0],
        lpMintPda: lpMint[0],
    };
};
exports.getVaultPdas = getVaultPdas;
const wrapSOLInstruction = (from, to, amount) => {
    return [
        web3_js_1.SystemProgram.transfer({
            fromPubkey: from,
            toPubkey: to,
            lamports: amount.toNumber(),
        }),
        new web3_js_1.TransactionInstruction({
            keys: [
                {
                    pubkey: to,
                    isSigner: false,
                    isWritable: true,
                },
            ],
            data: Buffer.from(new Uint8Array([17])),
            programId: spl_token_1.TOKEN_PROGRAM_ID,
        }),
    ];
};
exports.wrapSOLInstruction = wrapSOLInstruction;
const unwrapSOLInstruction = (walletPublicKey) => __awaiter(void 0, void 0, void 0, function* () {
    const wSolATAAccount = yield spl_token_1.Token.getAssociatedTokenAddress(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, constants_1.SOL_MINT, walletPublicKey, true);
    if (wSolATAAccount) {
        const closedWrappedSolInstruction = spl_token_1.Token.createCloseAccountInstruction(spl_token_1.TOKEN_PROGRAM_ID, wSolATAAccount, walletPublicKey, walletPublicKey, []);
        return closedWrappedSolInstruction;
    }
    return null;
});
exports.unwrapSOLInstruction = unwrapSOLInstruction;
const getOnchainTime = (connection) => __awaiter(void 0, void 0, void 0, function* () {
    const parsedClock = yield connection.getParsedAccountInfo(web3_js_1.SYSVAR_CLOCK_PUBKEY);
    const parsedClockAccount = parsedClock.value.data.parsed;
    const currentTime = parsedClockAccount.info.unixTimestamp;
    return currentTime;
});
exports.getOnchainTime = getOnchainTime;
const getLpSupply = (connection, tokenMint) => __awaiter(void 0, void 0, void 0, function* () {
    const context = yield connection.getTokenSupply(tokenMint);
    return new anchor_1.BN(context.value.amount);
});
exports.getLpSupply = getLpSupply;
//# sourceMappingURL=index.js.map