import { Decimal } from 'decimal.js';
import { PublicKey, AccountMeta } from '@solana/web3.js';

declare const CMD_REFRESH_USER = 10;
declare const CMD_ADD_USER_AND_DEPOSIT = 16;
declare const CMD_DEPOSIT = 17;
declare const CMD_WITHDRAW = 18;
declare const CMD_BORROW = 19;
declare const CMD_REPAY = 20;
declare const CMD_EXTERN_LIQUIDATE = 21;
declare const CMD_UPDATE_USER_CONFIG = 23;
declare const CMD_MARGIN_SWAP = 24;
declare const CMD_UPDATE_USER_ASSET_CONFIG = 25;
declare const CMD_WITHDRAW_AND_REMOVE_USER = 26;
declare const CMD_LP_CREATE = 29;
declare const CMD_LP_REDEEM = 30;
declare const CMD_LP_OP_CHECK = 33;
declare const CMD_LP_OP_ENDCHECK = 34;
declare const CMD_LP_STAKE = 35;
declare const CMD_LP_UNSTAKE = 36;
declare const CMD_CLAIM_APT_LM_REWARD = 41;
declare const CMD_MAKE_LM_REWARD_AVAILABLE = 42;
declare const CMD_LP_STAKE_SECOND = 129;
declare const CMD_LP_UNSTAKE_SECOND = 130;
declare const SWAP_FAKE = 0;
declare const SWAP_SERUM = 1;
declare const SWAP_RAYDIUM = 2;
declare const SWAP_SABER = 3;
declare const SWAP_MERCURIAL = 4;
declare const SWAP_ORCA = 5;
declare const INVALID_PAGE = 65535;
declare const AMOUNT_MULTIPLIER = 16777216;
declare const MAX_ASSIST_ACTIONS = 6;
declare const ASSIST_MODE_STABLE_ONLY = 2;

declare const FAKE_KEY: PublicKey;
declare const SAFE_LIMIT: Decimal;
declare const FORCE_ASSIST_LIMIT: Decimal;
declare const LIQUIDATION_LIMIT: Decimal;
declare const MINTS: {
    [key in TokenID]: PublicKey;
};
declare const DECIMAL_MULT: {
    [key in TokenID]: number;
};
declare class InterestRate {
    baseRate: number;
    kink: number;
    kinkRate: number;
    fullRate: number;
    multiplier: number;
    jumpMultiplier: number;
    constructor(baseRate: number, kink: number, kinkRate: number, fullRate: number);
}
declare const CATEGORY: {
    [key in TokenID]: TokenCategory;
};
declare const LIQUIDATION_DISCOUNT: {
    [key in TokenID]?: number;
};
declare const LP_TO_LR: {
    [key in TokenID]?: [TokenID, TokenID];
};
declare const LP_TO_TARGET_SWAP: {
    [key in TokenID]?: number;
};
declare const LP_TO_DEX: {
    [key in TokenID]?: Dex;
};
declare const LP_TO_NEED_2ND_STAKE: {
    [key in TokenID]?: boolean;
};
declare const SWAP_METAS: {
    3: {
        stake_program: PublicKey;
        deposit_program: PublicKey;
        redeem_program: PublicKey;
    };
    5: {
        depositProgramPubkey: PublicKey;
        farmProgramPubkey: PublicKey;
    };
    2: {
        depositProgramPubkey: PublicKey;
        stakeProgramPubkey: PublicKey;
        stakeProgramV5Pubkey: PublicKey;
    };
};
declare const DUAL_REWARD_CONFIGS: {
    [key in TokenID]?: DualRewardInfo;
};
type SaberLpArgs = {
    swap: PublicKey;
    swapAuthority: PublicKey;
    tokenAVault: PublicKey;
    tokenBVault: PublicKey;
    tokenAfees: PublicKey;
    tokenBfees: PublicKey;
    quarry: PublicKey;
    rewarder: PublicKey;
    mint: PublicKey;
};
declare class SaberLpSwapInfo implements LpSwapKeyInfo {
    swap: PublicKey;
    swapAuthority: PublicKey;
    tokenAVault: PublicKey;
    tokenBVault: PublicKey;
    tokenAfees: PublicKey;
    tokenBfees: PublicKey;
    quarry: PublicKey;
    rewarder: PublicKey;
    mint: PublicKey;
    constructor(args: SaberLpArgs);
    getMinerKey(ownerKey: PublicKey): Promise<[PublicKey, number]>;
    getMinerVault(ownerKey: PublicKey): Promise<PublicKey>;
    getLpDepositKeys(_ownerKey: PublicKey): Promise<{
        pubkey: PublicKey;
        isSigner: boolean;
        isWritable: boolean;
    }[]>;
    getLpWithdrawKeys(): Promise<{
        pubkey: PublicKey;
        isSigner: boolean;
        isWritable: boolean;
    }[]>;
    getLpStakeKeys(ownerKey: PublicKey): Promise<{
        pubkey: PublicKey;
        isSigner: boolean;
        isWritable: boolean;
    }[]>;
    getLRVaults(): [PublicKey, PublicKey];
}
type OrcaLpArgs = {
    lpMintPubkey: PublicKey;
    swapPubkey: PublicKey;
    swapAuthority: PublicKey;
    swapTokenAAccount: PublicKey;
    swapTokenBAccount: PublicKey;
    globalLpVault: PublicKey;
    farmTokenMint: PublicKey;
    globalFarmState: PublicKey;
    globalRewardTokenVault: PublicKey;
    rewardTokenAuthority: PublicKey;
    feeAccount: PublicKey;
    publicRewardTokAcc: PublicKey;
    alphaRewardTokAcc: PublicKey;
    isDoubleDipSupported?: boolean;
    globalLp3Vault?: PublicKey;
    farmTokenLp3Mint?: PublicKey;
    globalDoubleDipFarmState?: PublicKey;
    globalDoubleDipRewardTokenVault?: PublicKey;
    doubleDipRewardTokenAuthority?: PublicKey;
    publicDoubleDipRewardAcc?: PublicKey;
    alphaDoubleDipRewardAcc?: PublicKey;
    doubleDipRewardMint?: PublicKey;
};
declare class OrcaLpSwapInfo implements LpSwapKeyInfo {
    lpMintPubkey: PublicKey;
    swapPubkey: PublicKey;
    swapAuthority: PublicKey;
    swapTokenAAccount: PublicKey;
    swapTokenBAccount: PublicKey;
    globalLpVault: PublicKey;
    farmTokenMint: PublicKey;
    globalFarmState: PublicKey;
    globalRewardTokenVault: PublicKey;
    rewardTokenAuthority: PublicKey;
    feeAccount: PublicKey;
    publicRewardTokAcc: PublicKey;
    alphaRewardTokAcc: PublicKey;
    isDoubleDipSupported: boolean;
    globalLp3Vault?: PublicKey;
    farmTokenLp3Mint?: PublicKey;
    globalDoubleDipFarmState?: PublicKey;
    globalDoubleDipRewardTokenVault?: PublicKey;
    doubleDipRewardTokenAuthority?: PublicKey;
    publicDoubleDipRewardAcc?: PublicKey;
    alphaDoubleDipRewardAcc?: PublicKey;
    doubleDipRewardMint?: PublicKey;
    constructor(args: OrcaLpArgs);
    getPdaKeys(ownerKey: PublicKey): Promise<{
        pdaFarmTokenAccount: any;
        pdaRewardTokenAccount: PublicKey;
        pdaFarmState: PublicKey;
    }>;
    getPdaDoubleDipKeys(ownerKey: PublicKey): Promise<{
        pdaDoubleDipFarmTokenAccount: any;
        pdaDoubleDipRewardTokenAccount: PublicKey;
        pdaDoubleDipFarmState: PublicKey;
    }>;
    getLpDepositKeys(_ownerKey: PublicKey): Promise<{
        pubkey: PublicKey;
        isSigner: boolean;
        isWritable: boolean;
    }[]>;
    getLpWithdrawKeys(_ownerKey: PublicKey): Promise<{
        pubkey: PublicKey;
        isSigner: boolean;
        isWritable: boolean;
    }[]>;
    getLpStakeKeys(ownerKey: PublicKey): Promise<{
        pubkey: any;
        isSigner: boolean;
        isWritable: boolean;
    }[]>;
    getFirstStakeKeys(ownerKey: PublicKey): Promise<{
        pubkey: any;
        isSigner: boolean;
        isWritable: boolean;
    }[]>;
    getSecondStakeKeys(ownerKey: PublicKey): Promise<{
        pubkey: any;
        isSigner: boolean;
        isWritable: boolean;
    }[]>;
    getLRVaults(): [PublicKey, PublicKey];
}
type RaydiumStakeKeys = {
    poolIdPubkey: PublicKey;
    poolAuthorityPubkey: PublicKey;
    poolLPVault: PublicKey;
};
type RaydiumRewardKeys = {
    rewardToken: TokenID;
    userRewardAlphaAccountPubkey: PublicKey;
    userRewardPublicAccountPubkey: PublicKey;
    rewardVault: PublicKey;
};
type RaydiumLpArgs = {
    lpMintPubkey: PublicKey;
    ammIdPubkey: PublicKey;
    ammAuthPubkey: PublicKey;
    ammOpenOrdersPubkey: PublicKey;
    ammTargetOrderPubkey: PublicKey;
    poolCoinTokenPubkey: PublicKey;
    poolPcTokenPubkey: PublicKey;
    poolWithdrawQueue: PublicKey;
    poolTempLpTokenAccount: PublicKey;
    serumProgramId: PublicKey;
    serumMarketPubkey: PublicKey;
    serumCoinVaultAccount: PublicKey;
    serumPcVaultAccount: PublicKey;
    serumVaultSigner: PublicKey;
    rewardAccounts?: RaydiumRewardKeys[];
    stakeKeys: RaydiumStakeKeys | null;
    stakeProgram?: PublicKey;
    serumEventQueueAccount?: PublicKey;
    serumBidsAccount?: PublicKey;
    serumAsksAccount?: PublicKey;
};
declare class RaydiumLpSwapInfo implements LpSwapKeyInfo {
    lpMintPubkey: PublicKey;
    ammIdPubkey: PublicKey;
    ammAuthPubkey: PublicKey;
    ammOpenOrdersPubkey: PublicKey;
    ammTargetOrderPubkey: PublicKey;
    poolCoinTokenPubkey: PublicKey;
    poolPcTokenPubkey: PublicKey;
    poolWithdrawQueue: PublicKey;
    poolTempLpTokenAccount: PublicKey;
    serumProgramId: PublicKey;
    serumMarketPubkey: PublicKey;
    serumCoinVaultAccount: PublicKey;
    serumPcVaultAccount: PublicKey;
    serumVaultSigner: PublicKey;
    rewardAccounts?: RaydiumRewardKeys[];
    stakeKeys: RaydiumStakeKeys | null;
    stakeProgram: PublicKey;
    serumEventQueueAccount?: PublicKey;
    serumBidsAccount?: PublicKey;
    serumAsksAccount?: PublicKey;
    constructor(args: RaydiumLpArgs);
    getLpDepositKeys(_ownerKey: PublicKey): Promise<{
        pubkey: PublicKey;
        isSigner: boolean;
        isWritable: boolean;
    }[]>;
    getLpWithdrawKeys(_ownerKey: PublicKey): Promise<{
        pubkey: PublicKey;
        isSigner: boolean;
        isWritable: boolean;
    }[]>;
    getLpStakeKeys(ownerKey: PublicKey): Promise<{
        pubkey: PublicKey;
        isSigner: boolean;
        isWritable: boolean;
    }[]>;
    getUserRewardAccountsToClaim(ownerKey: PublicKey): Promise<Record<TokenID, PublicKey>>;
    getLRVaults(): [PublicKey, PublicKey];
    getAssociatedLedger(owner: PublicKey): Promise<PublicKey>;
}
declare const SABER_LP_METAS: {
    [key in TokenID]?: SaberLpSwapInfo;
};
declare const ORCA_LP_METAS: {
    [key in TokenID]?: OrcaLpSwapInfo;
};
declare const RAYDIUM_LP_METAS: {
    [key in TokenID]?: RaydiumLpSwapInfo;
};
declare const LP_SWAP_METAS: {
    [key in TokenID]?: LpSwapKeyInfo;
};
declare const SWITCHBOARD_PRICE: {
    [key in TokenID]?: PublicKey;
};
declare const PYTH_PRICE: {
    [key in TokenID]?: PublicKey;
};
declare const COINGECKO_PRICE_ID: {
    [key in TokenID]?: string;
};
declare const ALPHA_CONFIG: AppConfig;
declare const PUBLIC_CONFIG: AppConfig;

declare enum TokenID {
    APT = "APT",
    BTC = "BTC",
    ETH = "ETH",
    USDT = "USDT",
    USDC = "USDC",
    UST = "UST",
    SOL = "SOL",
    SBR = "SBR",
    ORCA = "ORCA",
    RAY = "RAY",
    MERC = "MERC",
    MNDE = "MNDE",
    mSOL = "mSOL",
    USTv2 = "USTv2",
    FTT = "FTT",
    SRM = "SRM",
    stSOL = "stSOL",
    whETH = "whETH",
    wLDO = "wLDO",
    scnSOL = "scnSOL",
    SOCN = "SOCN",
    wLUNA = "wLUNA",
    USDT_USDC_SABER = "USDT_USDC_SABER",
    USTv2_USDC_SABER = "USTv2_USDC_SABER",
    UST_USDC_SABER = "UST_USDC_SABER",
    mSOL_SOL_SABER = "mSOL_SOL_SABER",
    stSOL_SOL_SABER = "stSOL_SOL_SABER",
    SOL_USDC_RAYDIUM = "SOL_USDC_RAYDIUM",
    RAY_USDC_RAYDIUM = "RAY_USDC_RAYDIUM",
    SOL_USDT_RAYDIUM = "SOL_USDT_RAYDIUM",
    mSOL_SOL_RAYDIUM = "mSOL_SOL_RAYDIUM",
    RAY_USDT_RAYDIUM = "RAY_USDT_RAYDIUM",
    RAY_ETH_RAYDIUM = "RAY_ETH_RAYDIUM",
    RAY_SOL_RAYDIUM = "RAY_SOL_RAYDIUM",
    SRM_USDC_RAYDIUM = "SRM_USDC_RAYDIUM",
    USDC_USDT_ORCA = "USDC_USDT_ORCA",
    SOL_USDC_ORCA = "SOL_USDC_ORCA",
    mSOL_SOL_ORCA = "mSOL_SOL_ORCA",
    ORCA_USDC_ORCA = "ORCA_USDC_ORCA",
    ORCA_SOL_ORCA = "ORCA_SOL_ORCA",
    ETH_USDC_ORCA = "ETH_USDC_ORCA",
    SOL_USDT_ORCA = "SOL_USDT_ORCA",
    ETH_SOL_ORCA = "ETH_SOL_ORCA",
    BTC_mSOL_ORCA = "BTC_mSOL_ORCA",
    mSOL_USDC_ORCA = "mSOL_USDC_ORCA",
    APT_USDC_ORCA = "APT_USDC_ORCA",
    stSOL_USTv2_ORCA = "stSOL_USTv2_ORCA",
    ORCA_whETH_ORCA = "ORCA_whETH_ORCA"
}
type PoolId = number;
declare enum TokenCategory {
    Volatile = "volatile",
    Stable = "stable",
    Lp = "lp"
}
declare enum PoolFlag {
    AllowBorrow = 1,
    IsLp = 2,
    IsStable = 4
}
interface LpSwapKeyInfo {
    getLpDepositKeys: (ownerKey: PublicKey) => Promise<AccountMeta[]>;
    getLpWithdrawKeys: (ownerKey: PublicKey) => Promise<AccountMeta[]>;
    getLpStakeKeys: (ownerKey: PublicKey) => Promise<AccountMeta[]>;
    getLRVaults: () => [PublicKey, PublicKey];
}
declare enum Dex {
    Serum = 0,
    Raydium = 1,
    Saber = 2,
    Mercurial = 3,
    Orca = 4
}
declare class PoolConfig {
    tokenId: TokenID;
    poolId: PoolId;
    ltv: number;
    mint: PublicKey;
    liquidationDiscount: number;
    tokenCategory: TokenCategory;
    lpLeftRightTokenId: [TokenID, TokenID] | null;
    lpLeftRightPoolId: [PoolId, PoolId] | null;
    lpDex: Dex | null;
    lpTargetSwap: number | null;
    lpSwapKeyInfo: LpSwapKeyInfo | null;
    lpNeedSndStake: boolean | null;
    interestRate: InterestRate | null;
    reserveRatio: number;
    constructor(tokenId: TokenID, poolId: PoolId, ltv: number, mint: PublicKey, liquidationDiscount: number, tokenCategory: TokenCategory, lpLeftRightTokenId: [TokenID, TokenID] | null, lpLeftRightPoolId: [PoolId, PoolId] | null, lpDex: Dex | null, lpTargetSwap: number | null, lpSwapKeyInfo: LpSwapKeyInfo | null, lpNeedSndStake: boolean | null, interestRate: InterestRate | null, reserveRatio: number);
    isStable(): boolean;
    isLp(): boolean;
    isVolatile(): boolean;
}
declare class AppConfig {
    programPubkey: PublicKey;
    adminPubkey: PublicKey;
    farmerPubkey: PublicKey;
    assistKey: PublicKey;
    refresherKey: PublicKey;
    retroAptVault: PublicKey;
    lmAptVault: PublicKey;
    mints: {
        [key in TokenID]: PublicKey;
    };
    decimalMults: {
        [key in TokenID]: number;
    };
    categories: {
        [key in TokenID]: TokenCategory;
    };
    tokenIdToPoolId: {
        [key in TokenID]?: PoolId | undefined;
    };
    discounts: {
        [key in TokenID]?: number | undefined;
    };
    ltvs: {
        [key in TokenID]?: number | undefined;
    };
    lpToLR: {
        [key in TokenID]?: [TokenID, TokenID] | undefined;
    };
    lpToDex: {
        [key in TokenID]?: Dex | undefined;
    };
    lpToTargetSwap: {
        [key in TokenID]?: number | undefined;
    };
    lpToNeedSndStake: {
        [key in TokenID]?: boolean;
    };
    switchboardPriceKeys: {
        [key in TokenID]?: PublicKey;
    };
    pythPriceKeys: {
        [key in TokenID]?: PublicKey;
    };
    interestRates: {
        [key in TokenID]?: InterestRate;
    };
    fees: {
        [key in TokenID]?: number;
    };
    lpSwapInfo: {
        [key in TokenID]?: LpSwapKeyInfo;
    };
    firebaseConfig: object;
    poolConfigs: {
        [key in TokenID]?: PoolConfig;
    };
    constructor(programPubkey: PublicKey, adminPubkey: PublicKey, farmerPubkey: PublicKey, assistKey: PublicKey, refresherKey: PublicKey, retroAptVault: PublicKey, lmAptVault: PublicKey, mints: {
        [key in TokenID]: PublicKey;
    }, decimalMults: {
        [key in TokenID]: number;
    }, categories: {
        [key in TokenID]: TokenCategory;
    }, tokenIdToPoolId: {
        [key in TokenID]?: PoolId | undefined;
    }, discounts: {
        [key in TokenID]?: number | undefined;
    }, ltvs: {
        [key in TokenID]?: number | undefined;
    }, lpToLR: {
        [key in TokenID]?: [TokenID, TokenID] | undefined;
    }, lpToDex: {
        [key in TokenID]?: Dex | undefined;
    }, lpToTargetSwap: {
        [key in TokenID]?: number | undefined;
    }, lpToNeedSndStake: {
        [key in TokenID]?: boolean;
    }, switchboardPriceKeys: {
        [key in TokenID]?: PublicKey;
    }, pythPriceKeys: {
        [key in TokenID]?: PublicKey;
    }, interestRates: {
        [key in TokenID]?: InterestRate;
    }, fees: {
        [key in TokenID]?: number;
    }, lpSwapInfo: {
        [key in TokenID]?: LpSwapKeyInfo;
    }, firebaseConfig: object);
    mintKeyStrToPoolId(mint_key_str: string): number;
    getPoolIdList(): number[];
    getTokenIdByPoolId(targetPoolId: number): TokenID;
    getLtvByPoolId(poolId: number): number;
    getDecimalMultByPoolId(poolId: number): number;
    getMintByPoolId(poolId: number): PublicKey;
    getPoolConfigList(): PoolConfig[];
    getPoolConfigByPoolId(poolId: number): PoolConfig;
}
interface AssetPool {
    coin_name: string;
    mint_key: PublicKey;
    mint_decimal_mult: Decimal;
    pool_id: number;
    deposit_amount: Decimal;
    deposit_index: Decimal;
    borrow_amount: Decimal;
    borrow_index: Decimal;
    reserve_factor: Decimal;
    fee_amount: Decimal;
    fee_withdrawn_amt: Decimal;
    fee_rate: Decimal;
    last_update_time: Decimal;
    spl_key: PublicKey;
    atoken_mint_key: PublicKey;
    price_key: PublicKey;
    pyth_price_key: PublicKey;
    serum_next_cl_id: Decimal;
    ltv: Decimal;
    safe_factor: Decimal;
    flags: number;
    base_rate: Decimal;
    multiplier1: Decimal;
    multiplier2: Decimal;
    kink: Decimal;
    borrow_rate: Decimal;
    deposit_rate: Decimal;
    reward_multiplier: Decimal;
    reward_deposit_intra: Decimal;
    reward_per_year: Decimal;
    reward_per_year_deposit: Decimal;
    reward_per_year_borrow: Decimal;
    reward_per_year_per_d: Decimal;
    reward_per_year_per_b: Decimal;
    reward_deposit_index: Decimal;
    reward_borrow_index: Decimal;
    deposit_cap: Decimal;
    is_disabled: boolean;
    farm_yield: Decimal;
}
interface AssetPrice {
    price_in_usd: Decimal;
}
interface UserInfo {
    page_id: number;
    num_assets: number;
    user_asset_info: UserAssetInfo[];
    reward: unknown;
    last_vest_cutoff_time: Decimal;
    last_update_time: Decimal;
    assist: Assist;
}
interface JsonUserInfo {
    page_id: number;
    num_assets: number;
    user_asset_info: JsonUserAssetInfo[];
    reward: unknown;
    last_vest_cutoff_time: number;
    last_update_time: number;
    assist: Assist;
}
interface UserAssetInfo {
    pool_id: number;
    use_as_collateral: number;
    deposit_amount: Decimal;
    deposit_interests: Decimal;
    deposit_index: Decimal;
    reward_deposit_amount: Decimal;
    reward_deposit_index: Decimal;
    borrow_amount: Decimal;
    borrow_interests: Decimal;
    borrow_index: Decimal;
    reward_borrow_amount: Decimal;
    reward_borrow_index: Decimal;
}
interface JsonUserAssetInfo {
    pool_id: number;
    use_as_collateral: number;
    deposit_amount: number;
    deposit_interests: number;
    deposit_index: number;
    reward_deposit_amount: number;
    reward_deposit_index: number;
    borrow_amount: number;
    borrow_interests: number;
    borrow_index: number;
    reward_borrow_amount: number;
    reward_borrow_index: number;
}
interface Assist {
    assist_mode: number;
    self_deleverage_factor: number;
    post_deleverage_factor: number;
    sell_sequence: Uint8Array;
    buy_sequence: Uint8Array;
    num_actions: number;
    num_executed: number;
}
interface ApiAssetPool {
    tokenName: string;
    mintKey: PublicKey;
    poolKey: PublicKey;
    allowBorrow: boolean;
    isLp: boolean;
    isStable: boolean;
    depositAmount: Decimal;
    depositValue?: Decimal;
    depositRate: Decimal;
    borrowAmount: Decimal;
    borrowValue?: Decimal;
    borrowRate: Decimal;
    lastPoolUpdate: Date;
    lastPriceUpdate?: Date;
    farmYieldRate: Decimal;
    liquidityMiningReward: ApiAssetPoolRewardInfo;
    dualIncentiveReward?: ApiAssetPoolRewardInfo;
}
interface ApiAssetPoolRewardInfo {
    tokenName: string;
    tokenMint: PublicKey;
    amountPerDay: Decimal;
    amountPerWeek: Decimal;
    amountPerMonth: Decimal;
    amountPerYear: Decimal;
    amountPerYearForDeposit: Decimal;
    amountPerYearForBorrow: Decimal;
    aprForDeposit?: Decimal;
    aprForBorrow?: Decimal;
}
interface ApiBorrowPowerInfo {
    totalDeposit: Decimal;
    totalCollateral: Decimal;
    maxBorrowAllowed: Decimal;
    totalBorrow: Decimal;
    collateralRatio: Decimal;
    safeLimit: Decimal;
    forceAssistLimit: Decimal;
    liquidationLimit: Decimal;
    assistTriggerLimit?: Decimal;
    assistTargetLimit?: Decimal;
}
interface ApiUserAssetInfo {
    tokenId: TokenID;
    useAsCollateral: boolean;
    ltv: Decimal;
    depositAmount: Decimal;
    depositValue?: Decimal;
    borrowAmount: Decimal;
    borrowValue?: Decimal;
}
interface ApiUserInfo {
    userWallet: string;
    userAssetInfo: ApiUserAssetInfo[];
    borrowPowerInfo?: ApiBorrowPowerInfo;
}
interface AptUserRewardInfo {
}
interface DualRewardInfo {
    tokenId: TokenID;
    multiplier: Decimal;
}
interface AdhocSwapInfo {
    targetSwap: number;
    getSwapKeys: (isBuy: boolean) => AccountMeta[];
}
declare enum RPC {
    GenesysGo = "GenesysGo",
    Triton = "Triton",
    Serum = "Serum"
}

declare class Addresses {
    config: AppConfig;
    constructor(config: AppConfig);
    getProgramKey(): PublicKey;
    getAdminKey(): PublicKey;
    mintKeyStrToPoolId(mintKeyStr: string): number;
    getBasePda(): Promise<[PublicKey, number]>;
    getPricePda(): Promise<[PublicKey, number]>;
    getPoolListKey(basePda: PublicKey): Promise<PublicKey>;
    POOL_SUMMARIES_SEED: string;
    getPoolSummariesKey(): Promise<PublicKey>;
    getPriceSummariesKey(basePda: PublicKey): Promise<PublicKey>;
    static USER_STATS_SEED: string;
    getUserPagesStatsKey(): Promise<PublicKey>;
    getUsersPageKey(basePda: PublicKey, page_id: number): Promise<PublicKey>;
    getLmAptVault(): PublicKey;
    getAssetPoolKey(basePda: PublicKey, mintKeyStr: string): Promise<PublicKey>;
    getAssetPriceKey(pricePda: PublicKey, mintKeyStr: string): Promise<PublicKey>;
    getAssetPoolSplKey(basePda: PublicKey, mintKeyStr: string): Promise<PublicKey>;
    getAssetPoolStakeTableKey(mintKeyStr: string): Promise<PublicKey>;
    getUserInfoKey(walletKey: PublicKey): Promise<PublicKey>;
    poolIdToSeedStr(pool_id: number): string;
    poolIdToStakeTableSeedStr(pool_id: number): string;
    mintKeyStrToPoolSeedStr(mintKeyStr: string): string;
    mintKeyStrToStakeTableSeedStr(mintKeyStr: string): string;
    getLpTargetSwap(tokenId: TokenID): number;
    getLpDepositKeys(tokenId: TokenID): Promise<AccountMeta[]>;
    getLpWithdrawKeys(tokenId: TokenID): Promise<AccountMeta[]>;
    getLpStakeKeys(tokenId: TokenID): Promise<AccountMeta[]>;
    getLpFirstStakeKeys(tokenId: TokenID): Promise<AccountMeta[]>;
    getLpSecondStakeKeys(tokenId: TokenID): Promise<AccountMeta[]>;
    getFloatingLpTokenAccount(tokenId: TokenID): Promise<any>;
}

declare function assert(cond: boolean, msg?: string): asserts cond;
declare const getAssociatedTokenPubkey: (ownerPubkey: PublicKey, mintPubkey: PublicKey, allowOwnerOffCurve?: boolean) => Promise<any>;
declare const delay: (ms: number) => Promise<unknown>;

export { ALPHA_CONFIG, AMOUNT_MULTIPLIER, ASSIST_MODE_STABLE_ONLY, Addresses, AdhocSwapInfo, ApiAssetPool, ApiAssetPoolRewardInfo, ApiBorrowPowerInfo, ApiUserAssetInfo, ApiUserInfo, AppConfig, AptUserRewardInfo, AssetPool, AssetPrice, Assist, CATEGORY, CMD_ADD_USER_AND_DEPOSIT, CMD_BORROW, CMD_CLAIM_APT_LM_REWARD, CMD_DEPOSIT, CMD_EXTERN_LIQUIDATE, CMD_LP_CREATE, CMD_LP_OP_CHECK, CMD_LP_OP_ENDCHECK, CMD_LP_REDEEM, CMD_LP_STAKE, CMD_LP_STAKE_SECOND, CMD_LP_UNSTAKE, CMD_LP_UNSTAKE_SECOND, CMD_MAKE_LM_REWARD_AVAILABLE, CMD_MARGIN_SWAP, CMD_REFRESH_USER, CMD_REPAY, CMD_UPDATE_USER_ASSET_CONFIG, CMD_UPDATE_USER_CONFIG, CMD_WITHDRAW, CMD_WITHDRAW_AND_REMOVE_USER, COINGECKO_PRICE_ID, DECIMAL_MULT, DUAL_REWARD_CONFIGS, Dex, DualRewardInfo, FAKE_KEY, FORCE_ASSIST_LIMIT, INVALID_PAGE, InterestRate, JsonUserAssetInfo, JsonUserInfo, LIQUIDATION_DISCOUNT, LIQUIDATION_LIMIT, LP_SWAP_METAS, LP_TO_DEX, LP_TO_LR, LP_TO_NEED_2ND_STAKE, LP_TO_TARGET_SWAP, LpSwapKeyInfo, MAX_ASSIST_ACTIONS, MINTS, ORCA_LP_METAS, OrcaLpSwapInfo, PUBLIC_CONFIG, PYTH_PRICE, PoolConfig, PoolFlag, PoolId, RAYDIUM_LP_METAS, RPC, RaydiumLpSwapInfo, SABER_LP_METAS, SAFE_LIMIT, SWAP_FAKE, SWAP_MERCURIAL, SWAP_METAS, SWAP_ORCA, SWAP_RAYDIUM, SWAP_SABER, SWAP_SERUM, SWITCHBOARD_PRICE, SaberLpSwapInfo, TokenCategory, TokenID, UserAssetInfo, UserInfo, assert, delay, getAssociatedTokenPubkey };
